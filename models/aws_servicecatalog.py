from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_servicecatalog.CloudFormationTemplate
class CloudFormationTemplateDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_asset', 'from_product_stack', 'from_url']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CloudFormationTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_asset', 'from_product_stack', 'from_url']
    ...


    from_asset: typing.Optional[models.aws_servicecatalog.CloudFormationTemplateDefFromAssetParams] = pydantic.Field(None, description='Loads the provisioning artifacts template from a local disk path.')
    from_product_stack: typing.Optional[models.aws_servicecatalog.CloudFormationTemplateDefFromProductStackParams] = pydantic.Field(None, description='Creates a product with the resources defined in the given product stack.')
    from_url: typing.Optional[models.aws_servicecatalog.CloudFormationTemplateDefFromUrlParams] = pydantic.Field(None, description='Template from URL.')
    resource_config: typing.Optional[models.aws_servicecatalog.CloudFormationTemplateDefConfig] = pydantic.Field(None)


class CloudFormationTemplateDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_servicecatalog.CloudFormationTemplateDefBindParams]] = pydantic.Field(None, description='Called when the product is initialized to allow this object to bind to the stack, add resources and have fun.')

class CloudFormationTemplateDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description="The binding scope. Don't be smart about trying to down-cast or assume it's initialized. You may just use it as a construct scope.")
    ...

class CloudFormationTemplateDefFromAssetParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='A file containing the provisioning artifacts.\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[models.AnyResource]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    ...

class CloudFormationTemplateDefFromProductStackParams(pydantic.BaseModel):
    product_stack: models.aws_servicecatalog.ProductStackDef = pydantic.Field(..., description='-')
    ...

class CloudFormationTemplateDefFromUrlParams(pydantic.BaseModel):
    url: str = pydantic.Field(..., description='The url that points to the provisioning artifacts template.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.Product
class ProductDef(BaseClass):
    account: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to\n')
    environment_from_arn: typing.Optional[str] = pydantic.Field(None, description='ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.\n')
    physical_name: typing.Optional[str] = pydantic.Field(None, description='The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to')
    _init_params: typing.ClassVar[list[str]] = ['account', 'environment_from_arn', 'physical_name', 'region']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'associate_tag_options']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_product_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.Product'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_product_arn']
    ...


    from_product_arn: typing.Optional[models.aws_servicecatalog.ProductDefFromProductArnParams] = pydantic.Field(None, description='Creates a Product construct that represents an external product.')
    resource_config: typing.Optional[models.aws_servicecatalog.ProductDefConfig] = pydantic.Field(None)


class ProductDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    associate_tag_options: typing.Optional[list[models.aws_servicecatalog.ProductDefAssociateTagOptionsParams]] = pydantic.Field(None, description='Associate Tag Options.\nA TagOption is a key-value pair managed in AWS Service Catalog.\nIt is not an AWS tag, but serves as a template for creating an AWS tag based on the TagOption.')

class ProductDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ProductDefAssociateTagOptionsParams(pydantic.BaseModel):
    tag_options: models.aws_servicecatalog.TagOptionsDef = pydantic.Field(..., description='-')
    ...

class ProductDefFromProductArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    product_arn: str = pydantic.Field(..., description='Product Arn.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CloudFormationProduct
class CloudFormationProductDef(BaseConstruct):
    owner: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The owner of the product.\n')
    product_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the product.\n')
    product_versions: typing.Union[typing.Sequence[typing.Union[models.aws_servicecatalog.CloudFormationProductVersionDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration of the product version.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the product. Default: - No description provided\n')
    distributor: typing.Optional[str] = pydantic.Field(None, description='The distributor of the product. Default: - No distributor provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Controls language for logging and errors. Default: - English\n')
    replace_product_version_ids: typing.Optional[bool] = pydantic.Field(None, description='Whether to give provisioning artifacts a new unique identifier when the product attributes or provisioning artifacts is updated. Default: false\n')
    support_description: typing.Optional[str] = pydantic.Field(None, description='The support information about the product. Default: - No support description provided\n')
    support_email: typing.Optional[str] = pydantic.Field(None, description='The contact email for product support. Default: - No support email provided\n')
    support_url: typing.Optional[str] = pydantic.Field(None, description='The contact URL for product support. Default: - No support URL provided\n')
    tag_options: typing.Optional[models.aws_servicecatalog.TagOptionsDef] = pydantic.Field(None, description='TagOptions associated directly to a product. Default: - No tagOptions provided')
    _init_params: typing.ClassVar[list[str]] = ['owner', 'product_name', 'product_versions', 'description', 'distributor', 'message_language', 'replace_product_version_ids', 'support_description', 'support_email', 'support_url', 'tag_options']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'associate_tag_options']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_product_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CloudFormationProduct'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_product_arn']
    ...


    from_product_arn: typing.Optional[models.aws_servicecatalog.CloudFormationProductDefFromProductArnParams] = pydantic.Field(None, description='Creates a Product construct that represents an external product.')
    resource_config: typing.Optional[models.aws_servicecatalog.CloudFormationProductDefConfig] = pydantic.Field(None)


class CloudFormationProductDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    associate_tag_options: typing.Optional[list[models.aws_servicecatalog.CloudFormationProductDefAssociateTagOptionsParams]] = pydantic.Field(None, description='Associate Tag Options.\nA TagOption is a key-value pair managed in AWS Service Catalog.\nIt is not an AWS tag, but serves as a template for creating an AWS tag based on the TagOption.')

class CloudFormationProductDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class CloudFormationProductDefAssociateTagOptionsParams(pydantic.BaseModel):
    tag_options: models.aws_servicecatalog.TagOptionsDef = pydantic.Field(..., description='-')
    ...

class CloudFormationProductDefFromProductArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    product_arn: str = pydantic.Field(..., description='Product Arn.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.Portfolio
class PortfolioDef(BaseConstruct):
    display_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the portfolio.\n')
    provider_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The provider name.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Description for portfolio. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The message language. Controls language for status logging and errors. Default: - English\n')
    tag_options: typing.Optional[models.aws_servicecatalog.TagOptionsDef] = pydantic.Field(None, description='TagOptions associated directly to a portfolio. Default: - No tagOptions provided')
    _init_params: typing.ClassVar[list[str]] = ['display_name', 'provider_name', 'description', 'message_language', 'tag_options']
    _method_names: typing.ClassVar[list[str]] = ['add_product', 'apply_removal_policy', 'associate_tag_options', 'constrain_cloud_formation_parameters', 'constrain_tag_updates', 'deploy_with_stack_sets', 'give_access_to_group', 'give_access_to_role', 'give_access_to_user', 'notify_on_stack_events', 'set_launch_role', 'set_local_launch_role', 'set_local_launch_role_name', 'share_with_account']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_portfolio_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.Portfolio'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_portfolio_arn']
    ...


    from_portfolio_arn: typing.Optional[models.aws_servicecatalog.PortfolioDefFromPortfolioArnParams] = pydantic.Field(None, description='Creates a Portfolio construct that represents an external portfolio.')
    resource_config: typing.Optional[models.aws_servicecatalog.PortfolioDefConfig] = pydantic.Field(None)


class PortfolioDefConfig(pydantic.BaseModel):
    add_product: typing.Optional[list[models.aws_servicecatalog.PortfolioDefAddProductParams]] = pydantic.Field(None, description='Associate portfolio with the given product.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    associate_tag_options: typing.Optional[list[models.aws_servicecatalog.PortfolioDefAssociateTagOptionsParams]] = pydantic.Field(None, description='Associate Tag Options.\nA TagOption is a key-value pair managed in AWS Service Catalog.\nIt is not an AWS tag, but serves as a template for creating an AWS tag based on the TagOption.')
    constrain_cloud_formation_parameters: typing.Optional[list[models.aws_servicecatalog.PortfolioDefConstrainCloudFormationParametersParams]] = pydantic.Field(None, description='Set provisioning rules for the product.')
    constrain_tag_updates: typing.Optional[list[models.aws_servicecatalog.PortfolioDefConstrainTagUpdatesParams]] = pydantic.Field(None, description='Add a Resource Update Constraint.')
    deploy_with_stack_sets: typing.Optional[list[models.aws_servicecatalog.PortfolioDefDeployWithStackSetsParams]] = pydantic.Field(None, description='Configure deployment options using AWS Cloudformation StackSets.')
    give_access_to_group: typing.Optional[list[models.aws_servicecatalog.PortfolioDefGiveAccessToGroupParams]] = pydantic.Field(None, description='Associate portfolio with an IAM Group.')
    give_access_to_role: typing.Optional[list[models.aws_servicecatalog.PortfolioDefGiveAccessToRoleParams]] = pydantic.Field(None, description='Associate portfolio with an IAM Role.')
    give_access_to_user: typing.Optional[list[models.aws_servicecatalog.PortfolioDefGiveAccessToUserParams]] = pydantic.Field(None, description='Associate portfolio with an IAM User.')
    notify_on_stack_events: typing.Optional[list[models.aws_servicecatalog.PortfolioDefNotifyOnStackEventsParams]] = pydantic.Field(None, description='Add notifications for supplied topics on the provisioned product.')
    set_launch_role: typing.Optional[list[models.aws_servicecatalog.PortfolioDefSetLaunchRoleParams]] = pydantic.Field(None, description='Force users to assume a certain role when launching a product.\nThis sets the launch role using the role arn which is tied to the account this role exists in.\nThis is useful if you will be provisioning products from the account where this role exists.\nIf you intend to share the portfolio across accounts, use a local launch role.')
    set_local_launch_role: typing.Optional[list[models.aws_servicecatalog.PortfolioDefSetLocalLaunchRoleParams]] = pydantic.Field(None, description='Force users to assume a certain role when launching a product.\nThe role name will be referenced by in the local account and must be set explicitly.\nThis is useful when sharing the portfolio with multiple accounts.')
    set_local_launch_role_name: typing.Optional[list[models.aws_servicecatalog.PortfolioDefSetLocalLaunchRoleNameParams]] = pydantic.Field(None, description='Force users to assume a certain role when launching a product.\nThe role will be referenced by name in the local account instead of a static role arn.\nA role with this name will automatically be created and assumable by Service Catalog in this account.\nThis is useful when sharing the portfolio with multiple accounts.')
    share_with_account: typing.Optional[list[models.aws_servicecatalog.PortfolioDefShareWithAccountParams]] = pydantic.Field(None, description='Initiate a portfolio share with another account.')

class PortfolioDefAddProductParams(pydantic.BaseModel):
    product: typing.Union[models.aws_servicecatalog.ProductDef, models.aws_servicecatalog.CloudFormationProductDef] = pydantic.Field(..., description='-')
    ...

class PortfolioDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PortfolioDefAssociateTagOptionsParams(pydantic.BaseModel):
    tag_options: models.aws_servicecatalog.TagOptionsDef = pydantic.Field(..., description='-')
    ...

class PortfolioDefConstrainCloudFormationParametersParams(pydantic.BaseModel):
    product: typing.Union[models.aws_servicecatalog.ProductDef, models.aws_servicecatalog.CloudFormationProductDef] = pydantic.Field(..., description='-\n')
    rule: typing.Union[models.aws_servicecatalog.TemplateRuleDef, dict[str, typing.Any]] = pydantic.Field(..., description='The rule with condition and assertions to apply to template.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English')
    ...

class PortfolioDefConstrainTagUpdatesParams(pydantic.BaseModel):
    product: typing.Union[models.aws_servicecatalog.ProductDef, models.aws_servicecatalog.CloudFormationProductDef] = pydantic.Field(..., description='-\n')
    allow: typing.Optional[bool] = pydantic.Field(None, description='Toggle for if users should be allowed to change/update tags on provisioned products. Default: true\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English')
    ...

class PortfolioDefDeployWithStackSetsParams(pydantic.BaseModel):
    product: typing.Union[models.aws_servicecatalog.ProductDef, models.aws_servicecatalog.CloudFormationProductDef] = pydantic.Field(..., description='-\n')
    accounts: typing.Sequence[str] = pydantic.Field(..., description='List of accounts to deploy stacks to.\n')
    admin_role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='IAM role used to administer the StackSets configuration.\n')
    execution_role_name: str = pydantic.Field(..., description='IAM role used to provision the products in the Stacks.\n')
    regions: typing.Sequence[str] = pydantic.Field(..., description='List of regions to deploy stacks to.\n')
    allow_stack_set_instance_operations: typing.Optional[bool] = pydantic.Field(None, description='Wether to allow end users to create, update, and delete stacks. Default: false\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English')
    ...

class PortfolioDefFromPortfolioArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    portfolio_arn: str = pydantic.Field(..., description='the Amazon Resource Name of the existing portfolio.')
    ...

class PortfolioDefGiveAccessToGroupParams(pydantic.BaseModel):
    group: typing.Union[models.aws_iam.GroupDef] = pydantic.Field(..., description='-')
    ...

class PortfolioDefGiveAccessToRoleParams(pydantic.BaseModel):
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='-')
    ...

class PortfolioDefGiveAccessToUserParams(pydantic.BaseModel):
    user: typing.Union[models.aws_iam.UserDef] = pydantic.Field(..., description='-')
    ...

class PortfolioDefNotifyOnStackEventsParams(pydantic.BaseModel):
    product: typing.Union[models.aws_servicecatalog.ProductDef, models.aws_servicecatalog.CloudFormationProductDef] = pydantic.Field(..., description='-\n')
    topic: typing.Union[models.aws_sns.TopicBaseDef, models.aws_sns.TopicDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English')
    ...

class PortfolioDefSetLaunchRoleParams(pydantic.BaseModel):
    product: typing.Union[models.aws_servicecatalog.ProductDef, models.aws_servicecatalog.CloudFormationProductDef] = pydantic.Field(..., description='-\n')
    launch_role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English')
    ...

class PortfolioDefSetLocalLaunchRoleParams(pydantic.BaseModel):
    product: typing.Union[models.aws_servicecatalog.ProductDef, models.aws_servicecatalog.CloudFormationProductDef] = pydantic.Field(..., description='-\n')
    launch_role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English')
    ...

class PortfolioDefSetLocalLaunchRoleNameParams(pydantic.BaseModel):
    product: typing.Union[models.aws_servicecatalog.ProductDef, models.aws_servicecatalog.CloudFormationProductDef] = pydantic.Field(..., description='-\n')
    launch_role_name: str = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English')
    return_config: typing.Optional[list[models._interface_methods.AwsIamIRoleDefConfig]] = pydantic.Field(None)
    ...

class PortfolioDefShareWithAccountParams(pydantic.BaseModel):
    account_id: str = pydantic.Field(..., description='-\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The message language of the share. Controls status and error message language for share. Default: - English\n')
    share_tag_options: typing.Optional[bool] = pydantic.Field(None, description='Whether to share tagOptions as a part of the portfolio share. Default: - share not specified')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.ProductStack
class ProductStackDef(BaseConstruct):
    asset_bucket: typing.Optional[typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef]] = pydantic.Field(None, description='A Bucket can be passed to store assets, enabling ProductStack Asset support. Default: - No Bucket provided and Assets will not be supported.\n')
    memory_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of memory (in MiB) to allocate to the AWS Lambda function which replicates the files from the CDK bucket to the destination bucket. If you are deploying large files, you will need to increase this number accordingly. Default: 128\n')
    server_side_encryption: typing.Optional[aws_cdk.aws_s3_deployment.ServerSideEncryption] = pydantic.Field(None, description='A ServerSideEncryption can be enabled to encrypt assets that are put into assetBucket. Default: - No encryption is used\n')
    server_side_encryption_aws_kms_key_id: typing.Optional[str] = pydantic.Field(None, description='For AWS_KMS ServerSideEncryption a KMS KeyId must be provided which will be used to encrypt assets. Default: - No KMS KeyId and SSE_KMS encryption cannot be used')
    _init_params: typing.ClassVar[list[str]] = ['asset_bucket', 'memory_limit', 'server_side_encryption', 'server_side_encryption_aws_kms_key_id']
    _method_names: typing.ClassVar[list[str]] = ['add_dependency', 'add_metadata', 'add_transform', 'export_string_list_value', 'export_value', 'format_arn', 'get_logical_id', 'regional_fact', 'rename_logical_id', 'report_missing_context_key', 'resolve', 'split_arn']
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.ProductStack'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.ProductStackDefConfig] = pydantic.Field(None)


class ProductStackDefConfig(pydantic.BaseModel):
    add_dependency: typing.Optional[list[models.aws_servicecatalog.ProductStackDefAddDependencyParams]] = pydantic.Field(None, description='Add a dependency between this stack and another stack.\nThis can be used to define dependencies between any two stacks within an\napp, and also supports nested stacks.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.ProductStackDefAddMetadataParams]] = pydantic.Field(None, description='Adds an arbitary key-value pair, with information you want to record about the stack.\nThese get translated to the Metadata section of the generated template.')
    add_transform: typing.Optional[list[models.aws_servicecatalog.ProductStackDefAddTransformParams]] = pydantic.Field(None, description='Add a Transform to this stack. A Transform is a macro that AWS CloudFormation uses to process your template.\nDuplicate values are removed when stack is synthesized.')
    export_string_list_value: typing.Optional[list[models.aws_servicecatalog.ProductStackDefExportStringListValueParams]] = pydantic.Field(None, description="Create a CloudFormation Export for a string list value.\nReturns a string list representing the corresponding ``Fn.importValue()``\nexpression for this Export. The export expression is automatically wrapped with an\n``Fn::Join`` and the import value with an ``Fn::Split``, since CloudFormation can only\nexport strings. You can control the name for the export by passing the ``name`` option.\n\nIf you don't supply a value for ``name``, the value you're exporting must be\na Resource attribute (for example: ``bucket.bucketName``) and it will be\ngiven the same name as the automatic cross-stack reference that would be created\nif you used the attribute in another Stack.\n\nOne of the uses for this method is to *remove* the relationship between\ntwo Stacks established by automatic cross-stack references. It will\ntemporarily ensure that the CloudFormation Export still exists while you\nremove the reference from the consuming stack. After that, you can remove\nthe resource and the manual export.\n\nSee ``exportValue`` for an example of this process.")
    export_value: typing.Optional[list[models.aws_servicecatalog.ProductStackDefExportValueParams]] = pydantic.Field(None, description="Create a CloudFormation Export for a string value.\nReturns a string representing the corresponding ``Fn.importValue()``\nexpression for this Export. You can control the name for the export by\npassing the ``name`` option.\n\nIf you don't supply a value for ``name``, the value you're exporting must be\na Resource attribute (for example: ``bucket.bucketName``) and it will be\ngiven the same name as the automatic cross-stack reference that would be created\nif you used the attribute in another Stack.\n\nOne of the uses for this method is to *remove* the relationship between\ntwo Stacks established by automatic cross-stack references. It will\ntemporarily ensure that the CloudFormation Export still exists while you\nremove the reference from the consuming stack. After that, you can remove\nthe resource and the manual export.\n\n\nExample\n\nHere is how the process works. Let's say there are two stacks,\n``producerStack`` and ``consumerStack``, and ``producerStack`` has a bucket\ncalled ``bucket``, which is referenced by ``consumerStack`` (perhaps because\nan AWS Lambda Function writes into it, or something like that).\n\nIt is not safe to remove ``producerStack.bucket`` because as the bucket is being\ndeleted, ``consumerStack`` might still be using it.\n\nInstead, the process takes two deployments:\n\n\nDeployment 1: break the relationship\n\n- Make sure ``consumerStack`` no longer references ``bucket.bucketName`` (maybe the consumer\n  stack now uses its own bucket, or it writes to an AWS DynamoDB table, or maybe you just\n  remove the Lambda Function altogether).\n- In the ``ProducerStack`` class, call ``this.exportValue(this.bucket.bucketName)``. This\n  will make sure the CloudFormation Export continues to exist while the relationship\n  between the two stacks is being broken.\n- Deploy (this will effectively only change the ``consumerStack``, but it's safe to deploy both).\n\n\n\nDeployment 2: remove the bucket resource\n\n- You are now free to remove the ``bucket`` resource from ``producerStack``.\n- Don't forget to remove the ``exportValue()`` call as well.\n- Deploy again (this time only the ``producerStack`` will be changed -- the bucket will be deleted).")
    format_arn: typing.Optional[list[models.aws_servicecatalog.ProductStackDefFormatArnParams]] = pydantic.Field(None, description="Creates an ARN from components.\nIf ``partition``, ``region`` or ``account`` are not specified, the stack's\npartition, region and account will be used.\n\nIf any component is the empty string, an empty string will be inserted\ninto the generated ARN at the location that component corresponds to.\n\nThe ARN will be formatted as follows:\n\narn:{partition}:{service}:{region}:{account}:{resource}{sep}{resource-name}\n\nThe required ARN pieces that are omitted will be taken from the stack that\nthe 'scope' is attached to. If all ARN pieces are supplied, the supplied scope\ncan be 'undefined'.")
    get_logical_id: typing.Optional[list[models.aws_servicecatalog.ProductStackDefGetLogicalIdParams]] = pydantic.Field(None, description='Allocates a stack-unique CloudFormation-compatible logical identity for a specific resource.\nThis method is called when a ``CfnElement`` is created and used to render the\ninitial logical identity of resources. Logical ID renames are applied at\nthis stage.\n\nThis method uses the protected method ``allocateLogicalId`` to render the\nlogical ID for an element. To modify the naming scheme, extend the ``Stack``\nclass and override this method.')
    of: typing.Optional[list[models.aws_servicecatalog.ProductStackDefOfParams]] = pydantic.Field(None, description='Looks up the first stack scope in which ``construct`` is defined.\nFails if there is no stack up the tree.')
    regional_fact: typing.Optional[list[models.aws_servicecatalog.ProductStackDefRegionalFactParams]] = pydantic.Field(None, description='Look up a fact value for the given fact for the region of this stack.\nWill return a definite value only if the region of the current stack is resolved.\nIf not, a lookup map will be added to the stack and the lookup will be done at\nCDK deployment time.\n\nWhat regions will be included in the lookup map is controlled by the\n``@aws-cdk/core:target-partitions`` context value: it must be set to a list\nof partitions, and only regions from the given partitions will be included.\nIf no such context key is set, all regions will be included.\n\nThis function is intended to be used by construct library authors. Application\nbuilders can rely on the abstractions offered by construct libraries and do\nnot have to worry about regional facts.\n\nIf ``defaultValue`` is not given, it is an error if the fact is unknown for\nthe given region.')
    rename_logical_id: typing.Optional[list[models.aws_servicecatalog.ProductStackDefRenameLogicalIdParams]] = pydantic.Field(None, description='Rename a generated logical identities.\nTo modify the naming scheme strategy, extend the ``Stack`` class and\noverride the ``allocateLogicalId`` method.')
    report_missing_context_key: typing.Optional[list[models.aws_servicecatalog.ProductStackDefReportMissingContextKeyParams]] = pydantic.Field(None, description='Indicate that a context key was expected.\nContains instructions which will be emitted into the cloud assembly on how\nthe key should be supplied.')
    resolve: typing.Optional[list[models.aws_servicecatalog.ProductStackDefResolveParams]] = pydantic.Field(None, description='Resolve a tokenized value in the context of the current stack.')
    split_arn: typing.Optional[list[models.aws_servicecatalog.ProductStackDefSplitArnParams]] = pydantic.Field(None, description="Splits the provided ARN into its components.\nWorks both if 'arn' is a string like 'arn:aws:s3:::bucket',\nand a Token representing a dynamic CloudFormation expression\n(in which case the returned components will also be dynamic CloudFormation expressions,\nencoded as Tokens).")
    synthesizer_config: typing.Optional[models._interface_methods.CoreIStackSynthesizerDefConfig] = pydantic.Field(None)

class ProductStackDefAddDependencyParams(pydantic.BaseModel):
    target: models.StackDef = pydantic.Field(..., description='-\n')
    reason: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ProductStackDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n')
    ...

class ProductStackDefAddTransformParams(pydantic.BaseModel):
    transform: str = pydantic.Field(..., description='The transform to add.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-section-structure.html\n\nExample::\n\n    # stack: Stack\n\n\n    stack.add_transform("AWS::Serverless-2016-10-31")\n')
    ...

class ProductStackDefExportStringListValueParams(pydantic.BaseModel):
    exported_value: typing.Any = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the outputs. Default: - No description\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the export to create. Default: - A name is automatically chosen')
    ...

class ProductStackDefExportValueParams(pydantic.BaseModel):
    exported_value: typing.Any = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the outputs. Default: - No description\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the export to create. Default: - A name is automatically chosen')
    ...

class ProductStackDefFormatArnParams(pydantic.BaseModel):
    resource: str = pydantic.Field(..., description='Resource type (e.g. "table", "autoScalingGroup", "certificate"). For some resource types, e.g. S3 buckets, this field defines the bucket name.\n')
    service: str = pydantic.Field(..., description="The service namespace that identifies the AWS product (for example, 's3', 'iam', 'codepipeline').\n")
    account: typing.Optional[str] = pydantic.Field(None, description="The ID of the AWS account that owns the resource, without the hyphens. For example, 123456789012. Note that the ARNs for some resources don't require an account number, so this component might be omitted. Default: The account the stack is deployed to.\n")
    arn_format: typing.Optional[aws_cdk.ArnFormat] = pydantic.Field(None, description='The specific ARN format to use for this ARN value. Default: - uses value of ``sep`` as the separator for formatting, ``ArnFormat.SLASH_RESOURCE_NAME`` if that property was also not provided\n')
    partition: typing.Optional[str] = pydantic.Field(None, description='The partition that the resource is in. For standard AWS regions, the partition is aws. If you have resources in other partitions, the partition is aws-partitionname. For example, the partition for resources in the China (Beijing) region is aws-cn. Default: The AWS partition the stack is deployed to.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the resource resides in. Note that the ARNs for some resources do not require a region, so this component might be omitted. Default: The region the stack is deployed to.\n')
    resource_name: typing.Optional[str] = pydantic.Field(None, description='Resource name or path within the resource (i.e. S3 bucket object key) or a wildcard such as ``"*"``. This is service-dependent.')
    ...

class ProductStackDefGetLogicalIdParams(pydantic.BaseModel):
    element: models.CfnElementDef = pydantic.Field(..., description='The CloudFormation element for which a logical identity is needed.')
    ...

class ProductStackDefOfParams(pydantic.BaseModel):
    construct_: models.AnyResource = pydantic.Field(..., description='The construct to start the search from.', alias='construct')
    return_config: typing.Optional[list[models.core.StackDefConfig]] = pydantic.Field(None)
    ...

class ProductStackDefRegionalFactParams(pydantic.BaseModel):
    fact_name: str = pydantic.Field(..., description='-\n')
    default_value: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ProductStackDefRenameLogicalIdParams(pydantic.BaseModel):
    old_id: str = pydantic.Field(..., description='-\n')
    new_id: str = pydantic.Field(..., description='-')
    ...

class ProductStackDefReportMissingContextKeyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='The missing context key.\n')
    props: typing.Union[models.cloud_assembly_schema.AmiContextQueryDef, dict[str, typing.Any], models.cloud_assembly_schema.AvailabilityZonesContextQueryDef, models.cloud_assembly_schema.HostedZoneContextQueryDef, models.cloud_assembly_schema.SSMParameterContextQueryDef, models.cloud_assembly_schema.VpcContextQueryDef, models.cloud_assembly_schema.EndpointServiceAvailabilityZonesContextQueryDef, models.cloud_assembly_schema.LoadBalancerContextQueryDef, models.cloud_assembly_schema.LoadBalancerListenerContextQueryDef, models.cloud_assembly_schema.SecurityGroupContextQueryDef, models.cloud_assembly_schema.KeyContextQueryDef, models.cloud_assembly_schema.PluginContextQueryDef] = pydantic.Field(..., description='A set of provider-specific options.\n')
    provider: aws_cdk.cloud_assembly_schema.ContextProvider = pydantic.Field(..., description='The provider from which we expect this context key to be obtained.')
    ...

class ProductStackDefResolveParams(pydantic.BaseModel):
    obj: typing.Any = pydantic.Field(..., description='-')
    ...

class ProductStackDefSplitArnParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='the ARN to split into its components.\n')
    arn_format: aws_cdk.ArnFormat = pydantic.Field(..., description="the expected format of 'arn' - depends on what format the service 'arn' represents uses.")
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.ProductStackHistory
class ProductStackHistoryDef(BaseConstruct):
    current_version_locked: typing.Union[bool, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='If this is set to true, the ProductStack will not be overwritten if a snapshot is found for the currentVersionName.\n')
    current_version_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The current version name of the ProductStack.\n')
    product_stack: typing.Union[models.aws_servicecatalog.ProductStackDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ProductStack whose history will be retained as a snapshot.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the product version. Default: - No description provided\n')
    directory: typing.Optional[str] = pydantic.Field(None, description="The directory where template snapshots will be stored. Default: 'product-stack-snapshots'\n")
    validate_template: typing.Optional[bool] = pydantic.Field(None, description='Whether the specified product template will be validated by CloudFormation. If turned off, an invalid template configuration can be stored. Default: true')
    _init_params: typing.ClassVar[list[str]] = ['current_version_locked', 'current_version_name', 'product_stack', 'description', 'directory', 'validate_template']
    _method_names: typing.ClassVar[list[str]] = ['current_version', 'version_from_snapshot']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.ProductStackHistory'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.ProductStackHistoryDefConfig] = pydantic.Field(None)


class ProductStackHistoryDefConfig(pydantic.BaseModel):
    current_version: typing.Optional[list[models.aws_servicecatalog.ProductStackHistoryDefCurrentVersionParams]] = pydantic.Field(None, description='Retains product stack template as a snapshot when deployed and retrieves a CloudFormationProductVersion for the current product version.')
    version_from_snapshot: typing.Optional[list[models.aws_servicecatalog.ProductStackHistoryDefVersionFromSnapshotParams]] = pydantic.Field(None, description='Retrieves a CloudFormationProductVersion from a previously deployed productVersionName.')

class ProductStackHistoryDefCurrentVersionParams(pydantic.BaseModel):
    ...

class ProductStackHistoryDefVersionFromSnapshotParams(pydantic.BaseModel):
    product_version_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.TagOptions
class TagOptionsDef(BaseConstruct):
    allowed_values_for_tags: typing.Union[typing.Mapping[str, typing.Sequence[str]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The values that are allowed to be set for specific tags. The keys of the map represent the tag keys, and the values of the map are a list of allowed values for that particular tag key.')
    _init_params: typing.ClassVar[list[str]] = ['allowed_values_for_tags']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.TagOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.TagOptionsDefConfig] = pydantic.Field(None)


class TagOptionsDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class TagOptionsDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProduct.CodeStarParametersProperty
class CfnCloudFormationProduct_CodeStarParametersPropertyDef(BaseStruct):
    artifact_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The absolute path wehre the artifact resides within the repo and branch, formatted as "folder/file.json.".\n')
    branch: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The specific branch where the artifact resides.\n')
    connection_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The CodeStar ARN, which is the connection between AWS Service Catalog and the external repository.\n')
    repository: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The specific repository where the product’s artifact-to-be-synced resides, formatted as "Account/Repo.".\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicecatalog-cloudformationproduct-codestarparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    code_star_parameters_property = servicecatalog.CfnCloudFormationProduct.CodeStarParametersProperty(\n        artifact_path="artifactPath",\n        branch="branch",\n        connection_arn="connectionArn",\n        repository="repository"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['artifact_path', 'branch', 'connection_arn', 'repository']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProduct.CodeStarParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProduct.ConnectionParametersProperty
class CfnCloudFormationProduct_ConnectionParametersPropertyDef(BaseStruct):
    code_star: typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProduct_CodeStarParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Provides ``ConnectionType`` details.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicecatalog-cloudformationproduct-connectionparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    connection_parameters_property = servicecatalog.CfnCloudFormationProduct.ConnectionParametersProperty(\n        code_star=servicecatalog.CfnCloudFormationProduct.CodeStarParametersProperty(\n            artifact_path="artifactPath",\n            branch="branch",\n            connection_arn="connectionArn",\n            repository="repository"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['code_star']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProduct.ConnectionParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProduct.ProvisioningArtifactPropertiesProperty
class CfnCloudFormationProduct_ProvisioningArtifactPropertiesPropertyDef(BaseStruct):
    info: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specify the template source with one of the following options, but not both. Keys accepted: [ ``LoadTemplateFromURL`` , ``ImportFromPhysicalId`` ] The URL of the AWS CloudFormation template in Amazon S3 in JSON format. Specify the URL in JSON format as follows: ``"LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."`` ``ImportFromPhysicalId`` : The physical id of the resource that contains the template. Currently only supports AWS CloudFormation stack arn. Specify the physical id in JSON format as follows: ``ImportFromPhysicalId: “arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]``\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the provisioning artifact, including how it differs from the previous provisioning artifact.\n')
    disable_template_validation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If set to true, AWS Service Catalog stops validating the specified provisioning artifact even if it is invalid.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of provisioning artifact. - ``CLOUD_FORMATION_TEMPLATE`` - AWS CloudFormation template - ``TERRAFORM_OPEN_SOURCE`` - Terraform Open Source configuration file - ``TERRAFORM_CLOUD`` - Terraform Cloud configuration file - ``EXTERNAL`` - External configuration file\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicecatalog-cloudformationproduct-provisioningartifactproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    # info: Any\n\n    provisioning_artifact_properties_property = servicecatalog.CfnCloudFormationProduct.ProvisioningArtifactPropertiesProperty(\n        info=info,\n\n        # the properties below are optional\n        description="description",\n        disable_template_validation=False,\n        name="name",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['info', 'description', 'disable_template_validation', 'name', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProduct.ProvisioningArtifactPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProduct.SourceConnectionProperty
class CfnCloudFormationProduct_SourceConnectionPropertyDef(BaseStruct):
    connection_parameters: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProduct_ConnectionParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The connection details based on the connection ``Type`` .\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The only supported ``SourceConnection`` type is Codestar.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicecatalog-cloudformationproduct-sourceconnection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    source_connection_property = servicecatalog.CfnCloudFormationProduct.SourceConnectionProperty(\n        connection_parameters=servicecatalog.CfnCloudFormationProduct.ConnectionParametersProperty(\n            code_star=servicecatalog.CfnCloudFormationProduct.CodeStarParametersProperty(\n                artifact_path="artifactPath",\n                branch="branch",\n                connection_arn="connectionArn",\n                repository="repository"\n            )\n        ),\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_parameters', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProduct.SourceConnectionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProvisionedProduct.ProvisioningParameterProperty
class CfnCloudFormationProvisionedProduct_ProvisioningParameterPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parameter key.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parameter value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicecatalog-cloudformationprovisionedproduct-provisioningparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    provisioning_parameter_property = servicecatalog.CfnCloudFormationProvisionedProduct.ProvisioningParameterProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProvisionedProduct.ProvisioningParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProvisionedProduct.ProvisioningPreferencesProperty
class CfnCloudFormationProvisionedProduct_ProvisioningPreferencesPropertyDef(BaseStruct):
    stack_set_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='One or more AWS accounts where the provisioned product will be available. Applicable only to a ``CFN_STACKSET`` provisioned product type. The specified accounts should be within the list of accounts from the ``STACKSET`` constraint. To get the list of accounts in the ``STACKSET`` constraint, use the ``DescribeProvisioningParameters`` operation. If no values are specified, the default value is all acounts from the ``STACKSET`` constraint.\n')
    stack_set_failure_tolerance_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of accounts, per Region, for which this operation can fail before AWS Service Catalog stops the operation in that Region. If the operation is stopped in a Region, AWS Service Catalog doesn't attempt the operation in any subsequent Regions. Applicable only to a ``CFN_STACKSET`` provisioned product type. Conditional: You must specify either ``StackSetFailureToleranceCount`` or ``StackSetFailureTolerancePercentage`` , but not both. The default value is ``0`` if no value is specified.\n")
    stack_set_failure_tolerance_percentage: typing.Union[int, float, None] = pydantic.Field(None, description="The percentage of accounts, per Region, for which this stack operation can fail before AWS Service Catalog stops the operation in that Region. If the operation is stopped in a Region, AWS Service Catalog doesn't attempt the operation in any subsequent Regions. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. Applicable only to a ``CFN_STACKSET`` provisioned product type. Conditional: You must specify either ``StackSetFailureToleranceCount`` or ``StackSetFailureTolerancePercentage`` , but not both.\n")
    stack_set_max_concurrency_count: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of ``StackSetFailureToleranceCount`` . ``StackSetMaxConcurrentCount`` is at most one more than the ``StackSetFailureToleranceCount`` . Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a ``CFN_STACKSET`` provisioned product type. Conditional: You must specify either ``StackSetMaxConcurrentCount`` or ``StackSetMaxConcurrentPercentage`` , but not both.\n')
    stack_set_max_concurrency_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as ``1`` instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a ``CFN_STACKSET`` provisioned product type. Conditional: You must specify either ``StackSetMaxConcurrentCount`` or ``StackSetMaxConcurrentPercentage`` , but not both.\n')
    stack_set_operation_type: typing.Optional[str] = pydantic.Field(None, description='Determines what action AWS Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is ``UPDATE`` if nothing is specified. Applicable only to a ``CFN_STACKSET`` provisioned product type. - **CREATE** - Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and Regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored. - **UPDATE** - Updates the stack set represented by the provisioned product and also its stack instances. - **DELETE** - Deletes a stack instance in the stack set represented by the provisioned product.\n')
    stack_set_regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='One or more AWS Regions where the provisioned product will be available. Applicable only to a ``CFN_STACKSET`` provisioned product type. The specified Regions should be within the list of Regions from the ``STACKSET`` constraint. To get the list of Regions in the ``STACKSET`` constraint, use the ``DescribeProvisioningParameters`` operation. If no values are specified, the default value is all Regions from the ``STACKSET`` constraint.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicecatalog-cloudformationprovisionedproduct-provisioningpreferences.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    provisioning_preferences_property = servicecatalog.CfnCloudFormationProvisionedProduct.ProvisioningPreferencesProperty(\n        stack_set_accounts=["stackSetAccounts"],\n        stack_set_failure_tolerance_count=123,\n        stack_set_failure_tolerance_percentage=123,\n        stack_set_max_concurrency_count=123,\n        stack_set_max_concurrency_percentage=123,\n        stack_set_operation_type="stackSetOperationType",\n        stack_set_regions=["stackSetRegions"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['stack_set_accounts', 'stack_set_failure_tolerance_count', 'stack_set_failure_tolerance_percentage', 'stack_set_max_concurrency_count', 'stack_set_max_concurrency_percentage', 'stack_set_operation_type', 'stack_set_regions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProvisionedProduct.ProvisioningPreferencesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnServiceAction.DefinitionParameterProperty
class CfnServiceAction_DefinitionParameterPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parameter key.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the parameter.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicecatalog-serviceaction-definitionparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    definition_parameter_property = servicecatalog.CfnServiceAction.DefinitionParameterProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnServiceAction.DefinitionParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CloudFormationProductProps
class CloudFormationProductPropsDef(BaseStruct):
    owner: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The owner of the product.\n')
    product_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the product.\n')
    product_versions: typing.Union[typing.Sequence[typing.Union[models.aws_servicecatalog.CloudFormationProductVersionDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration of the product version.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the product. Default: - No description provided\n')
    distributor: typing.Optional[str] = pydantic.Field(None, description='The distributor of the product. Default: - No distributor provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Controls language for logging and errors. Default: - English\n')
    replace_product_version_ids: typing.Optional[bool] = pydantic.Field(None, description='Whether to give provisioning artifacts a new unique identifier when the product attributes or provisioning artifacts is updated. Default: false\n')
    support_description: typing.Optional[str] = pydantic.Field(None, description='The support information about the product. Default: - No support description provided\n')
    support_email: typing.Optional[str] = pydantic.Field(None, description='The contact email for product support. Default: - No support email provided\n')
    support_url: typing.Optional[str] = pydantic.Field(None, description='The contact URL for product support. Default: - No support URL provided\n')
    tag_options: typing.Optional[models.aws_servicecatalog.TagOptionsDef] = pydantic.Field(None, description='TagOptions associated directly to a product. Default: - No tagOptions provided\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk as cdk\n\n\n    class S3BucketProduct(servicecatalog.ProductStack):\n        def __init__(self, scope, id):\n            super().__init__(scope, id)\n\n            s3.Bucket(self, "BucketProduct")\n\n    product = servicecatalog.CloudFormationProduct(self, "Product",\n        product_name="My Product",\n        owner="Product Owner",\n        product_versions=[servicecatalog.CloudFormationProductVersion(\n            product_version_name="v1",\n            cloud_formation_template=servicecatalog.CloudFormationTemplate.from_product_stack(S3BucketProduct(self, "S3BucketProduct"))\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['owner', 'product_name', 'product_versions', 'description', 'distributor', 'message_language', 'replace_product_version_ids', 'support_description', 'support_email', 'support_url', 'tag_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CloudFormationProductProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CloudFormationProductVersion
class CloudFormationProductVersionDef(BaseStruct):
    cloud_formation_template: typing.Union[models.aws_servicecatalog.CloudFormationTemplateDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The S3 template that points to the provisioning version template.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the product version. Default: - No description provided\n')
    product_version_name: typing.Optional[str] = pydantic.Field(None, description='The name of the product version. Default: - No product version name provided\n')
    validate_template: typing.Optional[bool] = pydantic.Field(None, description='Whether the specified product template will be validated by CloudFormation. If turned off, an invalid template configuration can be stored. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    # cloud_formation_template: servicecatalog.CloudFormationTemplate\n\n    cloud_formation_product_version = servicecatalog.CloudFormationProductVersion(\n        cloud_formation_template=cloud_formation_template,\n\n        # the properties below are optional\n        description="description",\n        product_version_name="productVersionName",\n        validate_template=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_formation_template', 'description', 'product_version_name', 'validate_template']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CloudFormationProductVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CloudFormationRuleConstraintOptions
class CloudFormationRuleConstraintOptionsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English\n')
    rule: typing.Union[_REQUIRED_INIT_PARAM, models.aws_servicecatalog.TemplateRuleDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The rule with condition and assertions to apply to template.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk as cdk\n\n    # portfolio: servicecatalog.Portfolio\n    # product: servicecatalog.CloudFormationProduct\n\n\n    portfolio.constrain_cloud_formation_parameters(product,\n        rule=servicecatalog.TemplateRule(\n            rule_name="testInstanceType",\n            condition=Fn.condition_equals(Fn.ref("Environment"), "test"),\n            assertions=[servicecatalog.TemplateRuleAssertion(\n                assert=Fn.condition_contains(["t2.micro", "t2.small"], Fn.ref("InstanceType")),\n                description="For test environment, the instance type should be small"\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'message_language', 'rule']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CloudFormationRuleConstraintOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CloudFormationTemplateConfig
class CloudFormationTemplateConfigDef(BaseStruct):
    http_url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The http url of the template in S3.\n')
    asset_bucket: typing.Optional[typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef]] = pydantic.Field(None, description='The S3 bucket containing product stack assets. Default: - None - no assets are used in this product\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_s3 as s3\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    # bucket: s3.Bucket\n\n    cloud_formation_template_config = servicecatalog.CloudFormationTemplateConfig(\n        http_url="httpUrl",\n\n        # the properties below are optional\n        asset_bucket=bucket\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_url', 'asset_bucket']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CloudFormationTemplateConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CommonConstraintOptions
class CommonConstraintOptionsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_sns as sns\n\n    # portfolio: servicecatalog.Portfolio\n    # product: servicecatalog.CloudFormationProduct\n\n\n    topic1 = sns.Topic(self, "Topic1")\n    portfolio.notify_on_stack_events(product, topic1)\n\n    topic2 = sns.Topic(self, "Topic2")\n    portfolio.notify_on_stack_events(product, topic2,\n        description="description for topic2"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'message_language']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CommonConstraintOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.PortfolioProps
class PortfolioPropsDef(BaseStruct):
    display_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the portfolio.\n')
    provider_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The provider name.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Description for portfolio. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The message language. Controls language for status logging and errors. Default: - English\n')
    tag_options: typing.Optional[models.aws_servicecatalog.TagOptionsDef] = pydantic.Field(None, description='TagOptions associated directly to a portfolio. Default: - No tagOptions provided\n\n:exampleMetadata: infused\n\nExample::\n\n    servicecatalog.Portfolio(self, "Portfolio",\n        display_name="MyPortfolio",\n        provider_name="MyTeam"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['display_name', 'provider_name', 'description', 'message_language', 'tag_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.PortfolioProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.PortfolioShareOptions
class PortfolioShareOptionsDef(BaseStruct):
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The message language of the share. Controls status and error message language for share. Default: - English\n')
    share_tag_options: typing.Optional[bool] = pydantic.Field(None, description='Whether to share tagOptions as a part of the portfolio share. Default: - share not specified\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    portfolio_share_options = servicecatalog.PortfolioShareOptions(\n        message_language=servicecatalog.MessageLanguage.EN,\n        share_tag_options=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['message_language', 'share_tag_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.PortfolioShareOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.ProductStackHistoryProps
class ProductStackHistoryPropsDef(BaseStruct):
    current_version_locked: typing.Union[bool, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='If this is set to true, the ProductStack will not be overwritten if a snapshot is found for the currentVersionName.\n')
    current_version_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The current version name of the ProductStack.\n')
    product_stack: typing.Union[models.aws_servicecatalog.ProductStackDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ProductStack whose history will be retained as a snapshot.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the product version. Default: - No description provided\n')
    directory: typing.Optional[str] = pydantic.Field(None, description="The directory where template snapshots will be stored. Default: 'product-stack-snapshots'\n")
    validate_template: typing.Optional[bool] = pydantic.Field(None, description='Whether the specified product template will be validated by CloudFormation. If turned off, an invalid template configuration can be stored. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    class S3BucketProduct(servicecatalog.ProductStack):\n        def __init__(self, scope, id):\n            super().__init__(scope, id)\n\n            s3.Bucket(self, "BucketProductV2")\n\n    product_stack_history = servicecatalog.ProductStackHistory(self, "ProductStackHistory",\n        product_stack=S3BucketProduct(self, "S3BucketProduct"),\n        current_version_name="v2",\n        current_version_locked=True\n    )\n\n    product = servicecatalog.CloudFormationProduct(self, "MyFirstProduct",\n        product_name="My Product",\n        owner="Product Owner",\n        product_versions=[\n            product_stack_history.current_version()\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['current_version_locked', 'current_version_name', 'product_stack', 'description', 'directory', 'validate_template']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.ProductStackHistoryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.ProductStackHistoryPropsDefConfig] = pydantic.Field(None)


class ProductStackHistoryPropsDefConfig(pydantic.BaseModel):
    product_stack_config: typing.Optional[models.aws_servicecatalog.ProductStackDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicecatalog.ProductStackProps
class ProductStackPropsDef(BaseStruct):
    asset_bucket: typing.Optional[typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef]] = pydantic.Field(None, description='A Bucket can be passed to store assets, enabling ProductStack Asset support. Default: - No Bucket provided and Assets will not be supported.\n')
    memory_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of memory (in MiB) to allocate to the AWS Lambda function which replicates the files from the CDK bucket to the destination bucket. If you are deploying large files, you will need to increase this number accordingly. Default: 128\n')
    server_side_encryption: typing.Optional[aws_cdk.aws_s3_deployment.ServerSideEncryption] = pydantic.Field(None, description='A ServerSideEncryption can be enabled to encrypt assets that are put into assetBucket. Default: - No encryption is used\n')
    server_side_encryption_aws_kms_key_id: typing.Optional[str] = pydantic.Field(None, description='For AWS_KMS ServerSideEncryption a KMS KeyId must be provided which will be used to encrypt assets. Default: - No KMS KeyId and SSE_KMS encryption cannot be used\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_lambda as lambda_\n    import aws_cdk as cdk\n    from aws_cdk.aws_s3 import Bucket\n\n\n    class LambdaProduct(servicecatalog.ProductStack):\n        def __init__(self, scope, id, *, assetBucket=None, serverSideEncryption=None, serverSideEncryptionAwsKmsKeyId=None, memoryLimit=None):\n            super().__init__(scope, id, assetBucket=assetBucket, serverSideEncryption=serverSideEncryption, serverSideEncryptionAwsKmsKeyId=serverSideEncryptionAwsKmsKeyId, memoryLimit=memoryLimit)\n\n            lambda_.Function(self, "LambdaProduct",\n                runtime=lambda_.Runtime.PYTHON_3_9,\n                code=lambda_.Code.from_asset("./assets"),\n                handler="index.handler"\n            )\n\n    user_defined_bucket = Bucket(self, "UserDefinedBucket",\n        bucket_name="user-defined-bucket-for-product-stack-assets"\n    )\n\n    product = servicecatalog.CloudFormationProduct(self, "Product",\n        product_name="My Product",\n        owner="Product Owner",\n        product_versions=[servicecatalog.CloudFormationProductVersion(\n            product_version_name="v1",\n            cloud_formation_template=servicecatalog.CloudFormationTemplate.from_product_stack(LambdaProduct(self, "LambdaFunctionProduct",\n                asset_bucket=user_defined_bucket\n            ))\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['asset_bucket', 'memory_limit', 'server_side_encryption', 'server_side_encryption_aws_kms_key_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.ProductStackProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.StackSetsConstraintOptions
class StackSetsConstraintOptionsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English\n')
    accounts: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='List of accounts to deploy stacks to.\n')
    admin_role: typing.Union[_REQUIRED_INIT_PARAM, models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='IAM role used to administer the StackSets configuration.\n')
    execution_role_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='IAM role used to provision the products in the Stacks.\n')
    regions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='List of regions to deploy stacks to.\n')
    allow_stack_set_instance_operations: typing.Optional[bool] = pydantic.Field(None, description='Wether to allow end users to create, update, and delete stacks. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    # portfolio: servicecatalog.Portfolio\n    # product: servicecatalog.CloudFormationProduct\n\n\n    admin_role = iam.Role(self, "AdminRole",\n        assumed_by=iam.AccountRootPrincipal()\n    )\n\n    portfolio.deploy_with_stack_sets(product,\n        accounts=["012345678901", "012345678902", "012345678903"],\n        regions=["us-west-1", "us-east-1", "us-west-2", "us-east-1"],\n        admin_role=admin_role,\n        execution_role_name="SCStackSetExecutionRole",  # Name of role deployed in end users accounts.\n        allow_stack_set_instance_operations=True\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'message_language', 'accounts', 'admin_role', 'execution_role_name', 'regions', 'allow_stack_set_instance_operations']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.StackSetsConstraintOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.StackSetsConstraintOptionsDefConfig] = pydantic.Field(None)


class StackSetsConstraintOptionsDefConfig(pydantic.BaseModel):
    admin_role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicecatalog.TagOptionsProps
class TagOptionsPropsDef(BaseStruct):
    allowed_values_for_tags: typing.Union[typing.Mapping[str, typing.Sequence[str]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The values that are allowed to be set for specific tags. The keys of the map represent the tag keys, and the values of the map are a list of allowed values for that particular tag key.\n\n:exampleMetadata: infused\n\nExample::\n\n    # portfolio: servicecatalog.Portfolio\n    # product: servicecatalog.CloudFormationProduct\n\n\n    tag_options_for_portfolio = servicecatalog.TagOptions(self, "OrgTagOptions",\n        allowed_values_for_tags={\n            "Group": ["finance", "engineering", "marketing", "research"],\n            "CostCenter": ["01", "02", "03"]\n        }\n    )\n    portfolio.associate_tag_options(tag_options_for_portfolio)\n\n    tag_options_for_product = servicecatalog.TagOptions(self, "ProductTagOptions",\n        allowed_values_for_tags={\n            "Environment": ["dev", "alpha", "prod"]\n        }\n    )\n    product.associate_tag_options(tag_options_for_product)\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_values_for_tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.TagOptionsProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.TagUpdateConstraintOptions
class TagUpdateConstraintOptionsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint. Default: - No description provided\n')
    message_language: typing.Optional[aws_cdk.aws_servicecatalog.MessageLanguage] = pydantic.Field(None, description='The language code. Configures the language for error messages from service catalog. Default: - English\n')
    allow: typing.Optional[bool] = pydantic.Field(None, description='Toggle for if users should be allowed to change/update tags on provisioned products. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # portfolio: servicecatalog.Portfolio\n    # product: servicecatalog.CloudFormationProduct\n\n\n    # to disable tag updates:\n    portfolio.constrain_tag_updates(product,\n        allow=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'message_language', 'allow']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.TagUpdateConstraintOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.TemplateRule
class TemplateRuleDef(BaseStruct):
    assertions: typing.Union[typing.Sequence[typing.Union[models.aws_servicecatalog.TemplateRuleAssertionDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of assertions that make up the rule.\n')
    rule_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the rule.\n')
    condition: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='Specify when to apply rule with a rule-specific intrinsic function. Default: - no rule condition provided\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk as cdk\n\n    # portfolio: servicecatalog.Portfolio\n    # product: servicecatalog.CloudFormationProduct\n\n\n    portfolio.constrain_cloud_formation_parameters(product,\n        rule=servicecatalog.TemplateRule(\n            rule_name="testInstanceType",\n            condition=Fn.condition_equals(Fn.ref("Environment"), "test"),\n            assertions=[servicecatalog.TemplateRuleAssertion(\n                assert=Fn.condition_contains(["t2.micro", "t2.small"], Fn.ref("InstanceType")),\n                description="For test environment, the instance type should be small"\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assertions', 'rule_name', 'condition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.TemplateRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.TemplateRuleAssertion
class TemplateRuleAssertionDef(BaseStruct):
    assert_: typing.Union[models.UnsupportedResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The assertion condition.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the asssertion. Default: - no description provided for the assertion.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    # cfn_rule_condition_expression: cdk.ICfnRuleConditionExpression\n\n    template_rule_assertion = servicecatalog.TemplateRuleAssertion(\n        assert=cfn_rule_condition_expression,\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assert_', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.TemplateRuleAssertion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.TemplateRuleAssertionDefConfig] = pydantic.Field(None)


class TemplateRuleAssertionDefConfig(pydantic.BaseModel):
    assert__config: typing.Optional[models._interface_methods.CoreICfnRuleConditionExpressionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicecatalog.MessageLanguage
# skipping emum

#  autogenerated from aws_cdk.aws_servicecatalog.IPortfolio
#  skipping Interface

#  autogenerated from aws_cdk.aws_servicecatalog.IProduct
#  skipping Interface

#  autogenerated from aws_cdk.aws_servicecatalog.CfnAcceptedPortfolioShare
class CfnAcceptedPortfolioShareDef(BaseCfnResource):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'accept_language']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnAcceptedPortfolioShare'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefConfig] = pydantic.Field(None)


class CfnAcceptedPortfolioShareDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnAcceptedPortfolioShareDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAcceptedPortfolioShareDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAcceptedPortfolioShareDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAcceptedPortfolioShareDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAcceptedPortfolioShareDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAcceptedPortfolioShareDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAcceptedPortfolioShareDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAcceptedPortfolioShareDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAcceptedPortfolioShareDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAcceptedPortfolioShareDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAcceptedPortfolioShareDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAcceptedPortfolioShareDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAcceptedPortfolioShareDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAcceptedPortfolioShareDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAcceptedPortfolioShareDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProduct
class CfnCloudFormationProductDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the product.\n')
    owner: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The owner of the product.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the product.\n')
    distributor: typing.Optional[str] = pydantic.Field(None, description='The distributor of the product.\n')
    product_type: typing.Optional[str] = pydantic.Field(None, description='The type of product.\n')
    provisioning_artifact_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProduct_ProvisioningArtifactPropertiesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The configuration of the provisioning artifact (also known as a version).\n')
    replace_provisioning_artifacts: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='This property is turned off by default. If turned off, you can update provisioning artifacts or product attributes (such as description, distributor, name, owner, and more) and the associated provisioning artifacts will retain the same unique identifier. Provisioning artifacts are matched within the CloudFormationProduct resource, and only those that have been updated will be changed. Provisioning artifacts are matched by a combinaton of provisioning artifact template URL and name. If turned on, provisioning artifacts will be given a new unique identifier when you update the product or provisioning artifacts.\n')
    source_connection: typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProduct_SourceConnectionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A top level ``ProductViewDetail`` response containing details about the product’s connection. AWS Service Catalog returns this field for the ``CreateProduct`` , ``UpdateProduct`` , ``DescribeProductAsAdmin`` , and ``SearchProductAsAdmin`` APIs. This response contains the same fields as the ``ConnectionParameters`` request, with the addition of the ``LastSync`` response.\n')
    support_description: typing.Optional[str] = pydantic.Field(None, description='The support information about the product.\n')
    support_email: typing.Optional[str] = pydantic.Field(None, description='The contact email for product support.\n')
    support_url: typing.Optional[str] = pydantic.Field(None, description='The contact URL for product support. ``^https?:\\/\\//`` / is the pattern used to validate SupportUrl.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tags.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'owner', 'accept_language', 'description', 'distributor', 'product_type', 'provisioning_artifact_parameters', 'replace_provisioning_artifacts', 'source_connection', 'support_description', 'support_email', 'support_url', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['CodeStarParametersProperty', 'ConnectionParametersProperty', 'ProvisioningArtifactPropertiesProperty', 'SourceConnectionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProduct'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnCloudFormationProductDefConfig] = pydantic.Field(None)


class CfnCloudFormationProductDefConfig(pydantic.BaseModel):
    CodeStarParametersProperty: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefCodestarparameterspropertyParams]] = pydantic.Field(None, description='')
    ConnectionParametersProperty: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefConnectionparameterspropertyParams]] = pydantic.Field(None, description='')
    ProvisioningArtifactPropertiesProperty: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefProvisioningartifactpropertiespropertyParams]] = pydantic.Field(None, description='')
    SourceConnectionProperty: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefSourceconnectionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProductDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCloudFormationProductDefCodestarparameterspropertyParams(pydantic.BaseModel):
    artifact_path: str = pydantic.Field(..., description='')
    branch: str = pydantic.Field(..., description='')
    connection_arn: str = pydantic.Field(..., description='')
    repository: str = pydantic.Field(..., description='')
    ...

class CfnCloudFormationProductDefConnectionparameterspropertyParams(pydantic.BaseModel):
    code_star: typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProduct_CodeStarParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnCloudFormationProductDefProvisioningartifactpropertiespropertyParams(pydantic.BaseModel):
    info: typing.Any = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    disable_template_validation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCloudFormationProductDefSourceconnectionpropertyParams(pydantic.BaseModel):
    connection_parameters: typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProduct_ConnectionParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnCloudFormationProductDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCloudFormationProductDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCloudFormationProductDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCloudFormationProductDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCloudFormationProductDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCloudFormationProductDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCloudFormationProductDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCloudFormationProductDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCloudFormationProductDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCloudFormationProductDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCloudFormationProductDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCloudFormationProductDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCloudFormationProductDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCloudFormationProductDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProvisionedProduct
class CfnCloudFormationProvisionedProductDef(BaseCfnResource):
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    notification_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Passed to AWS CloudFormation . The SNS topic ARNs to which to publish stack-related events.\n')
    path_id: typing.Optional[str] = pydantic.Field(None, description='The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use `ListLaunchPaths <https://docs.aws.amazon.com/servicecatalog/latest/dg/API_ListLaunchPaths.html>`_ . .. epigraph:: You must provide the name or ID, but not both.\n')
    path_name: typing.Optional[str] = pydantic.Field(None, description='The name of the path. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use `ListLaunchPaths <https://docs.aws.amazon.com/servicecatalog/latest/dg/API_ListLaunchPaths.html>`_ . .. epigraph:: You must provide the name or ID, but not both.\n')
    product_id: typing.Optional[str] = pydantic.Field(None, description='The product identifier. .. epigraph:: You must specify either the ID or the name of the product, but not both.\n')
    product_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Service Catalog product. Each time a stack is created or updated, if ``ProductName`` is provided it will successfully resolve to ``ProductId`` as long as only one product exists in the account or Region with that ``ProductName`` . .. epigraph:: You must specify either the name or the ID of the product, but not both.\n')
    provisioned_product_name: typing.Optional[str] = pydantic.Field(None, description='A user-friendly name for the provisioned product. This value must be unique for the AWS account and cannot be updated after the product is provisioned.\n')
    provisioning_artifact_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the provisioning artifact (also known as a version). .. epigraph:: You must specify either the ID or the name of the provisioning artifact, but not both.\n')
    provisioning_artifact_name: typing.Optional[str] = pydantic.Field(None, description='The name of the provisioning artifact (also known as a version) for the product. This name must be unique for the product. .. epigraph:: You must specify either the name or the ID of the provisioning artifact, but not both. You must also specify either the name or the ID of the product, but not both.\n')
    provisioning_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProvisionedProduct_ProvisioningParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Parameters specified by the administrator that are required for provisioning the product.\n')
    provisioning_preferences: typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProvisionedProduct_ProvisioningPreferencesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='StackSet preferences that are required for provisioning the product or updating a provisioned product.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tags. .. epigraph:: Requires the provisioned product to have an `ResourceUpdateConstraint <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-resourceupdateconstraint.html>`_ resource with ``TagUpdatesOnProvisionedProduct`` set to ``ALLOWED`` to allow tag updates. If ``RESOURCE_UPDATE`` constraint is not present, tags updates are ignored.')
    _init_params: typing.ClassVar[list[str]] = ['accept_language', 'notification_arns', 'path_id', 'path_name', 'product_id', 'product_name', 'provisioned_product_name', 'provisioning_artifact_id', 'provisioning_artifact_name', 'provisioning_parameters', 'provisioning_preferences', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ProvisioningParameterProperty', 'ProvisioningPreferencesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProvisionedProduct'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefConfig] = pydantic.Field(None)


class CfnCloudFormationProvisionedProductDefConfig(pydantic.BaseModel):
    ProvisioningParameterProperty: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefProvisioningparameterpropertyParams]] = pydantic.Field(None, description='')
    ProvisioningPreferencesProperty: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefProvisioningpreferencespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnCloudFormationProvisionedProductDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_outputs_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCloudFormationProvisionedProductDefProvisioningparameterpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnCloudFormationProvisionedProductDefProvisioningpreferencespropertyParams(pydantic.BaseModel):
    stack_set_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    stack_set_failure_tolerance_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stack_set_failure_tolerance_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stack_set_max_concurrency_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stack_set_max_concurrency_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stack_set_operation_type: typing.Optional[str] = pydantic.Field(None, description='')
    stack_set_regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnCloudFormationProvisionedProductDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCloudFormationProvisionedProductDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCloudFormationProvisionedProductDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCloudFormationProvisionedProductDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCloudFormationProvisionedProductDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCloudFormationProvisionedProductDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCloudFormationProvisionedProductDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCloudFormationProvisionedProductDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCloudFormationProvisionedProductDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCloudFormationProvisionedProductDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCloudFormationProvisionedProductDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCloudFormationProvisionedProductDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCloudFormationProvisionedProductDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCloudFormationProvisionedProductDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnLaunchNotificationConstraint
class CfnLaunchNotificationConstraintDef(BaseCfnResource):
    notification_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The notification ARNs.\n')
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint.')
    _init_params: typing.ClassVar[list[str]] = ['notification_arns', 'portfolio_id', 'product_id', 'accept_language', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnLaunchNotificationConstraint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefConfig] = pydantic.Field(None)


class CfnLaunchNotificationConstraintDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchNotificationConstraintDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLaunchNotificationConstraintDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLaunchNotificationConstraintDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLaunchNotificationConstraintDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLaunchNotificationConstraintDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLaunchNotificationConstraintDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLaunchNotificationConstraintDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLaunchNotificationConstraintDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLaunchNotificationConstraintDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLaunchNotificationConstraintDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLaunchNotificationConstraintDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLaunchNotificationConstraintDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLaunchNotificationConstraintDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLaunchNotificationConstraintDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLaunchNotificationConstraintDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnLaunchRoleConstraint
class CfnLaunchRoleConstraintDef(BaseCfnResource):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint.\n')
    local_role_name: typing.Optional[str] = pydantic.Field(None, description="You are required to specify either the ``RoleArn`` or the ``LocalRoleName`` but can't use both. If you specify the ``LocalRoleName`` property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be account-agnostic so the administrator can create fewer resources per shared account. The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint.\n")
    role_arn: typing.Optional[str] = pydantic.Field(None, description="The ARN of the launch role. You are required to specify ``RoleArn`` or ``LocalRoleName`` but can't use both.")
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'product_id', 'accept_language', 'description', 'local_role_name', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnLaunchRoleConstraint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnLaunchRoleConstraintDefConfig] = pydantic.Field(None)


class CfnLaunchRoleConstraintDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchRoleConstraintDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLaunchRoleConstraintDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLaunchRoleConstraintDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLaunchRoleConstraintDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLaunchRoleConstraintDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLaunchRoleConstraintDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLaunchRoleConstraintDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLaunchRoleConstraintDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLaunchRoleConstraintDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLaunchRoleConstraintDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLaunchRoleConstraintDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLaunchRoleConstraintDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLaunchRoleConstraintDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLaunchRoleConstraintDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLaunchRoleConstraintDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnLaunchTemplateConstraint
class CfnLaunchTemplateConstraintDef(BaseCfnResource):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    rules: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The constraint rules.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint.')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'product_id', 'rules', 'accept_language', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnLaunchTemplateConstraint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefConfig] = pydantic.Field(None)


class CfnLaunchTemplateConstraintDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnLaunchTemplateConstraintDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLaunchTemplateConstraintDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLaunchTemplateConstraintDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLaunchTemplateConstraintDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLaunchTemplateConstraintDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLaunchTemplateConstraintDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLaunchTemplateConstraintDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLaunchTemplateConstraintDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLaunchTemplateConstraintDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLaunchTemplateConstraintDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLaunchTemplateConstraintDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLaunchTemplateConstraintDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLaunchTemplateConstraintDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLaunchTemplateConstraintDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLaunchTemplateConstraintDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnPortfolio
class CfnPortfolioDef(BaseCfnResource):
    display_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name to use for display purposes.\n')
    provider_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the portfolio provider.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the portfolio.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tags.')
    _init_params: typing.ClassVar[list[str]] = ['display_name', 'provider_name', 'accept_language', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnPortfolio'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnPortfolioDefConfig] = pydantic.Field(None)


class CfnPortfolioDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPortfolioDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPortfolioDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPortfolioDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPortfolioDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPortfolioDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPortfolioDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPortfolioDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPortfolioDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPortfolioDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPortfolioDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPortfolioDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPortfolioDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPortfolioDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPortfolioDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnPortfolioPrincipalAssociation
class CfnPortfolioPrincipalAssociationDef(BaseCfnResource):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    principal_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the principal ( IAM user, role, or group).\n')
    principal_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal type. The supported values are ``IAM`` and ``IAM_PATTERN`` .\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'principal_arn', 'principal_type', 'accept_language']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnPortfolioPrincipalAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefConfig] = pydantic.Field(None)


class CfnPortfolioPrincipalAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPortfolioPrincipalAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPortfolioPrincipalAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPortfolioPrincipalAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPortfolioPrincipalAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPortfolioPrincipalAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPortfolioPrincipalAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPortfolioPrincipalAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPortfolioPrincipalAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPortfolioPrincipalAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPortfolioPrincipalAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPortfolioPrincipalAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPortfolioPrincipalAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPortfolioPrincipalAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPortfolioPrincipalAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnPortfolioProductAssociation
class CfnPortfolioProductAssociationDef(BaseCfnResource):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    source_portfolio_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the source portfolio.')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'product_id', 'accept_language', 'source_portfolio_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnPortfolioProductAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnPortfolioProductAssociationDefConfig] = pydantic.Field(None)


class CfnPortfolioProductAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioProductAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPortfolioProductAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPortfolioProductAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPortfolioProductAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPortfolioProductAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPortfolioProductAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPortfolioProductAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPortfolioProductAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPortfolioProductAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPortfolioProductAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPortfolioProductAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPortfolioProductAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPortfolioProductAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPortfolioProductAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPortfolioProductAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnPortfolioShare
class CfnPortfolioShareDef(BaseCfnResource):
    account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS account ID. For example, ``123456789012`` .\n')
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    share_tag_options: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'portfolio_id', 'accept_language', 'share_tag_options']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnPortfolioShare'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnPortfolioShareDefConfig] = pydantic.Field(None)


class CfnPortfolioShareDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnPortfolioShareDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPortfolioShareDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPortfolioShareDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPortfolioShareDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPortfolioShareDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPortfolioShareDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPortfolioShareDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPortfolioShareDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPortfolioShareDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPortfolioShareDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPortfolioShareDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPortfolioShareDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPortfolioShareDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPortfolioShareDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPortfolioShareDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnResourceUpdateConstraint
class CfnResourceUpdateConstraintDef(BaseCfnResource):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    tag_update_on_provisioned_product: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='If set to ``ALLOWED`` , lets users change tags in a `CloudFormationProvisionedProduct <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-cloudformationprovisionedproduct.html>`_ resource. If set to ``NOT_ALLOWED`` , prevents users from changing tags in a `CloudFormationProvisionedProduct <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-cloudformationprovisionedproduct.html>`_ resource.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint.')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'product_id', 'tag_update_on_provisioned_product', 'accept_language', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnResourceUpdateConstraint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnResourceUpdateConstraintDefConfig] = pydantic.Field(None)


class CfnResourceUpdateConstraintDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnResourceUpdateConstraintDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnResourceUpdateConstraintDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourceUpdateConstraintDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceUpdateConstraintDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourceUpdateConstraintDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceUpdateConstraintDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourceUpdateConstraintDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourceUpdateConstraintDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourceUpdateConstraintDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourceUpdateConstraintDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourceUpdateConstraintDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceUpdateConstraintDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnResourceUpdateConstraintDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourceUpdateConstraintDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceUpdateConstraintDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnServiceAction
class CfnServiceActionDef(BaseCfnResource):
    definition: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnServiceAction_DefinitionParameterPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A map that defines the self-service action.\n')
    definition_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The self-service action definition type. For example, ``SSM_AUTOMATION`` .\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The self-service action name.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``en`` - English (default) - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The self-service action description.')
    _init_params: typing.ClassVar[list[str]] = ['definition', 'definition_type', 'name', 'accept_language', 'description']
    _method_names: typing.ClassVar[list[str]] = ['DefinitionParameterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnServiceAction'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnServiceActionDefConfig] = pydantic.Field(None)


class CfnServiceActionDefConfig(pydantic.BaseModel):
    DefinitionParameterProperty: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefDefinitionparameterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnServiceActionDefDefinitionparameterpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnServiceActionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnServiceActionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceActionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnServiceActionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceActionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnServiceActionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnServiceActionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnServiceActionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnServiceActionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnServiceActionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceActionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnServiceActionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnServiceActionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceActionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnServiceActionAssociation
class CfnServiceActionAssociationDef(BaseCfnResource):
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier. For example, ``prod-abcdzk7xy33qa`` .\n')
    provisioning_artifact_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the provisioning artifact. For example, ``pa-4abcdjnxjj6ne`` .\n')
    service_action_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The self-service action identifier. For example, ``act-fs7abcd89wxyz`` .')
    _init_params: typing.ClassVar[list[str]] = ['product_id', 'provisioning_artifact_id', 'service_action_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnServiceActionAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnServiceActionAssociationDefConfig] = pydantic.Field(None)


class CfnServiceActionAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnServiceActionAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnServiceActionAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnServiceActionAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceActionAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnServiceActionAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceActionAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnServiceActionAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnServiceActionAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnServiceActionAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnServiceActionAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnServiceActionAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceActionAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnServiceActionAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnServiceActionAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceActionAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnStackSetConstraint
class CfnStackSetConstraintDef(BaseCfnResource):
    account_list: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='One or more AWS accounts that will have access to the provisioned product.\n')
    admin_role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='AdminRole ARN.\n')
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description of the constraint.\n')
    execution_role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='ExecutionRole name.\n')
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    region_list: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='One or more AWS Regions where the provisioned product will be available. Applicable only to a ``CFN_STACKSET`` provisioned product type. The specified Regions should be within the list of Regions from the ``STACKSET`` constraint. To get the list of Regions in the ``STACKSET`` constraint, use the ``DescribeProvisioningParameters`` operation. If no values are specified, the default value is all Regions from the ``STACKSET`` constraint.\n')
    stack_instance_control: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Permission to create, update, and delete stack instances. Choose from ALLOWED and NOT_ALLOWED.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese')
    _init_params: typing.ClassVar[list[str]] = ['account_list', 'admin_role', 'description', 'execution_role', 'portfolio_id', 'product_id', 'region_list', 'stack_instance_control', 'accept_language']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnStackSetConstraint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnStackSetConstraintDefConfig] = pydantic.Field(None)


class CfnStackSetConstraintDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnStackSetConstraintDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnStackSetConstraintDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnStackSetConstraintDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStackSetConstraintDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnStackSetConstraintDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStackSetConstraintDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnStackSetConstraintDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnStackSetConstraintDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnStackSetConstraintDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnStackSetConstraintDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnStackSetConstraintDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStackSetConstraintDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnStackSetConstraintDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnStackSetConstraintDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStackSetConstraintDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnTagOption
class CfnTagOptionDef(BaseCfnResource):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The TagOption key.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The TagOption value.\n')
    active: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The TagOption active state.')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value', 'active']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnTagOption'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnTagOptionDefConfig] = pydantic.Field(None)


class CfnTagOptionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTagOptionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTagOptionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTagOptionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTagOptionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTagOptionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTagOptionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTagOptionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTagOptionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTagOptionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTagOptionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTagOptionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTagOptionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTagOptionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTagOptionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnTagOptionAssociation
class CfnTagOptionAssociationDef(BaseCfnResource):
    resource_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource identifier.\n')
    tag_option_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The TagOption identifier.')
    _init_params: typing.ClassVar[list[str]] = ['resource_id', 'tag_option_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnTagOptionAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_servicecatalog.CfnTagOptionAssociationDefConfig] = pydantic.Field(None)


class CfnTagOptionAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_servicecatalog.CfnTagOptionAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTagOptionAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTagOptionAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTagOptionAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTagOptionAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTagOptionAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTagOptionAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTagOptionAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTagOptionAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTagOptionAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTagOptionAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTagOptionAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTagOptionAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTagOptionAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTagOptionAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicecatalog.CfnAcceptedPortfolioShareProps
class CfnAcceptedPortfolioSharePropsDef(BaseCfnProperty):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-acceptedportfolioshare.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_accepted_portfolio_share_props = servicecatalog.CfnAcceptedPortfolioShareProps(\n        portfolio_id="portfolioId",\n\n        # the properties below are optional\n        accept_language="acceptLanguage"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'accept_language']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnAcceptedPortfolioShareProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProductProps
class CfnCloudFormationProductPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the product.\n')
    owner: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The owner of the product.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the product.\n')
    distributor: typing.Optional[str] = pydantic.Field(None, description='The distributor of the product.\n')
    product_type: typing.Optional[str] = pydantic.Field(None, description='The type of product.\n')
    provisioning_artifact_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProduct_ProvisioningArtifactPropertiesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The configuration of the provisioning artifact (also known as a version).\n')
    replace_provisioning_artifacts: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='This property is turned off by default. If turned off, you can update provisioning artifacts or product attributes (such as description, distributor, name, owner, and more) and the associated provisioning artifacts will retain the same unique identifier. Provisioning artifacts are matched within the CloudFormationProduct resource, and only those that have been updated will be changed. Provisioning artifacts are matched by a combinaton of provisioning artifact template URL and name. If turned on, provisioning artifacts will be given a new unique identifier when you update the product or provisioning artifacts.\n')
    source_connection: typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProduct_SourceConnectionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A top level ``ProductViewDetail`` response containing details about the product’s connection. AWS Service Catalog returns this field for the ``CreateProduct`` , ``UpdateProduct`` , ``DescribeProductAsAdmin`` , and ``SearchProductAsAdmin`` APIs. This response contains the same fields as the ``ConnectionParameters`` request, with the addition of the ``LastSync`` response.\n')
    support_description: typing.Optional[str] = pydantic.Field(None, description='The support information about the product.\n')
    support_email: typing.Optional[str] = pydantic.Field(None, description='The contact email for product support.\n')
    support_url: typing.Optional[str] = pydantic.Field(None, description='The contact URL for product support. ``^https?:\\/\\//`` / is the pattern used to validate SupportUrl.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tags.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-cloudformationproduct.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    # info: Any\n\n    cfn_cloud_formation_product_props = servicecatalog.CfnCloudFormationProductProps(\n        name="name",\n        owner="owner",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        description="description",\n        distributor="distributor",\n        product_type="productType",\n        provisioning_artifact_parameters=[servicecatalog.CfnCloudFormationProduct.ProvisioningArtifactPropertiesProperty(\n            info=info,\n\n            # the properties below are optional\n            description="description",\n            disable_template_validation=False,\n            name="name",\n            type="type"\n        )],\n        replace_provisioning_artifacts=False,\n        source_connection=servicecatalog.CfnCloudFormationProduct.SourceConnectionProperty(\n            connection_parameters=servicecatalog.CfnCloudFormationProduct.ConnectionParametersProperty(\n                code_star=servicecatalog.CfnCloudFormationProduct.CodeStarParametersProperty(\n                    artifact_path="artifactPath",\n                    branch="branch",\n                    connection_arn="connectionArn",\n                    repository="repository"\n                )\n            ),\n            type="type"\n        ),\n        support_description="supportDescription",\n        support_email="supportEmail",\n        support_url="supportUrl",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'owner', 'accept_language', 'description', 'distributor', 'product_type', 'provisioning_artifact_parameters', 'replace_provisioning_artifacts', 'source_connection', 'support_description', 'support_email', 'support_url', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProductProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnCloudFormationProvisionedProductProps
class CfnCloudFormationProvisionedProductPropsDef(BaseCfnProperty):
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    notification_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Passed to AWS CloudFormation . The SNS topic ARNs to which to publish stack-related events.\n')
    path_id: typing.Optional[str] = pydantic.Field(None, description='The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use `ListLaunchPaths <https://docs.aws.amazon.com/servicecatalog/latest/dg/API_ListLaunchPaths.html>`_ . .. epigraph:: You must provide the name or ID, but not both.\n')
    path_name: typing.Optional[str] = pydantic.Field(None, description='The name of the path. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use `ListLaunchPaths <https://docs.aws.amazon.com/servicecatalog/latest/dg/API_ListLaunchPaths.html>`_ . .. epigraph:: You must provide the name or ID, but not both.\n')
    product_id: typing.Optional[str] = pydantic.Field(None, description='The product identifier. .. epigraph:: You must specify either the ID or the name of the product, but not both.\n')
    product_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Service Catalog product. Each time a stack is created or updated, if ``ProductName`` is provided it will successfully resolve to ``ProductId`` as long as only one product exists in the account or Region with that ``ProductName`` . .. epigraph:: You must specify either the name or the ID of the product, but not both.\n')
    provisioned_product_name: typing.Optional[str] = pydantic.Field(None, description='A user-friendly name for the provisioned product. This value must be unique for the AWS account and cannot be updated after the product is provisioned.\n')
    provisioning_artifact_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the provisioning artifact (also known as a version). .. epigraph:: You must specify either the ID or the name of the provisioning artifact, but not both.\n')
    provisioning_artifact_name: typing.Optional[str] = pydantic.Field(None, description='The name of the provisioning artifact (also known as a version) for the product. This name must be unique for the product. .. epigraph:: You must specify either the name or the ID of the provisioning artifact, but not both. You must also specify either the name or the ID of the product, but not both.\n')
    provisioning_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProvisionedProduct_ProvisioningParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Parameters specified by the administrator that are required for provisioning the product.\n')
    provisioning_preferences: typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnCloudFormationProvisionedProduct_ProvisioningPreferencesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='StackSet preferences that are required for provisioning the product or updating a provisioned product.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tags. .. epigraph:: Requires the provisioned product to have an `ResourceUpdateConstraint <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-resourceupdateconstraint.html>`_ resource with ``TagUpdatesOnProvisionedProduct`` set to ``ALLOWED`` to allow tag updates. If ``RESOURCE_UPDATE`` constraint is not present, tags updates are ignored.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-cloudformationprovisionedproduct.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_cloud_formation_provisioned_product_props = servicecatalog.CfnCloudFormationProvisionedProductProps(\n        accept_language="acceptLanguage",\n        notification_arns=["notificationArns"],\n        path_id="pathId",\n        path_name="pathName",\n        product_id="productId",\n        product_name="productName",\n        provisioned_product_name="provisionedProductName",\n        provisioning_artifact_id="provisioningArtifactId",\n        provisioning_artifact_name="provisioningArtifactName",\n        provisioning_parameters=[servicecatalog.CfnCloudFormationProvisionedProduct.ProvisioningParameterProperty(\n            key="key",\n            value="value"\n        )],\n        provisioning_preferences=servicecatalog.CfnCloudFormationProvisionedProduct.ProvisioningPreferencesProperty(\n            stack_set_accounts=["stackSetAccounts"],\n            stack_set_failure_tolerance_count=123,\n            stack_set_failure_tolerance_percentage=123,\n            stack_set_max_concurrency_count=123,\n            stack_set_max_concurrency_percentage=123,\n            stack_set_operation_type="stackSetOperationType",\n            stack_set_regions=["stackSetRegions"]\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['accept_language', 'notification_arns', 'path_id', 'path_name', 'product_id', 'product_name', 'provisioned_product_name', 'provisioning_artifact_id', 'provisioning_artifact_name', 'provisioning_parameters', 'provisioning_preferences', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnCloudFormationProvisionedProductProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnLaunchNotificationConstraintProps
class CfnLaunchNotificationConstraintPropsDef(BaseCfnProperty):
    notification_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The notification ARNs.\n')
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-launchnotificationconstraint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_launch_notification_constraint_props = servicecatalog.CfnLaunchNotificationConstraintProps(\n        notification_arns=["notificationArns"],\n        portfolio_id="portfolioId",\n        product_id="productId",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['notification_arns', 'portfolio_id', 'product_id', 'accept_language', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnLaunchNotificationConstraintProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnLaunchRoleConstraintProps
class CfnLaunchRoleConstraintPropsDef(BaseCfnProperty):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint.\n')
    local_role_name: typing.Optional[str] = pydantic.Field(None, description="You are required to specify either the ``RoleArn`` or the ``LocalRoleName`` but can't use both. If you specify the ``LocalRoleName`` property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be account-agnostic so the administrator can create fewer resources per shared account. The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint.\n")
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the launch role. You are required to specify ``RoleArn`` or ``LocalRoleName`` but can\'t use both.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-launchroleconstraint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_launch_role_constraint_props = servicecatalog.CfnLaunchRoleConstraintProps(\n        portfolio_id="portfolioId",\n        product_id="productId",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        description="description",\n        local_role_name="localRoleName",\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'product_id', 'accept_language', 'description', 'local_role_name', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnLaunchRoleConstraintProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnLaunchTemplateConstraintProps
class CfnLaunchTemplateConstraintPropsDef(BaseCfnProperty):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    rules: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The constraint rules.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-launchtemplateconstraint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_launch_template_constraint_props = servicecatalog.CfnLaunchTemplateConstraintProps(\n        portfolio_id="portfolioId",\n        product_id="productId",\n        rules="rules",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'product_id', 'rules', 'accept_language', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnLaunchTemplateConstraintProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnPortfolioPrincipalAssociationProps
class CfnPortfolioPrincipalAssociationPropsDef(BaseCfnProperty):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    principal_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the principal ( IAM user, role, or group).\n')
    principal_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal type. The supported values are ``IAM`` and ``IAM_PATTERN`` .\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-portfolioprincipalassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_portfolio_principal_association_props = servicecatalog.CfnPortfolioPrincipalAssociationProps(\n        portfolio_id="portfolioId",\n        principal_arn="principalArn",\n        principal_type="principalType",\n\n        # the properties below are optional\n        accept_language="acceptLanguage"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'principal_arn', 'principal_type', 'accept_language']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnPortfolioPrincipalAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnPortfolioProductAssociationProps
class CfnPortfolioProductAssociationPropsDef(BaseCfnProperty):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    source_portfolio_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the source portfolio.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-portfolioproductassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_portfolio_product_association_props = servicecatalog.CfnPortfolioProductAssociationProps(\n        portfolio_id="portfolioId",\n        product_id="productId",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        source_portfolio_id="sourcePortfolioId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'product_id', 'accept_language', 'source_portfolio_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnPortfolioProductAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnPortfolioProps
class CfnPortfolioPropsDef(BaseCfnProperty):
    display_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name to use for display purposes.\n')
    provider_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the portfolio provider.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the portfolio.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tags.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-portfolio.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_portfolio_props = servicecatalog.CfnPortfolioProps(\n        display_name="displayName",\n        provider_name="providerName",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['display_name', 'provider_name', 'accept_language', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnPortfolioProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnPortfolioShareProps
class CfnPortfolioSharePropsDef(BaseCfnProperty):
    account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS account ID. For example, ``123456789012`` .\n')
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    share_tag_options: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-portfolioshare.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_portfolio_share_props = servicecatalog.CfnPortfolioShareProps(\n        account_id="accountId",\n        portfolio_id="portfolioId",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        share_tag_options=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'portfolio_id', 'accept_language', 'share_tag_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnPortfolioShareProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnResourceUpdateConstraintProps
class CfnResourceUpdateConstraintPropsDef(BaseCfnProperty):
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    tag_update_on_provisioned_product: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='If set to ``ALLOWED`` , lets users change tags in a `CloudFormationProvisionedProduct <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-cloudformationprovisionedproduct.html>`_ resource. If set to ``NOT_ALLOWED`` , prevents users from changing tags in a `CloudFormationProvisionedProduct <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-cloudformationprovisionedproduct.html>`_ resource.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the constraint.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-resourceupdateconstraint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_resource_update_constraint_props = servicecatalog.CfnResourceUpdateConstraintProps(\n        portfolio_id="portfolioId",\n        product_id="productId",\n        tag_update_on_provisioned_product="tagUpdateOnProvisionedProduct",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['portfolio_id', 'product_id', 'tag_update_on_provisioned_product', 'accept_language', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnResourceUpdateConstraintProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnServiceActionAssociationProps
class CfnServiceActionAssociationPropsDef(BaseCfnProperty):
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier. For example, ``prod-abcdzk7xy33qa`` .\n')
    provisioning_artifact_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the provisioning artifact. For example, ``pa-4abcdjnxjj6ne`` .\n')
    service_action_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The self-service action identifier. For example, ``act-fs7abcd89wxyz`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-serviceactionassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_service_action_association_props = servicecatalog.CfnServiceActionAssociationProps(\n        product_id="productId",\n        provisioning_artifact_id="provisioningArtifactId",\n        service_action_id="serviceActionId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['product_id', 'provisioning_artifact_id', 'service_action_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnServiceActionAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnServiceActionProps
class CfnServiceActionPropsDef(BaseCfnProperty):
    definition: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_servicecatalog.CfnServiceAction_DefinitionParameterPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A map that defines the self-service action.\n')
    definition_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The self-service action definition type. For example, ``SSM_AUTOMATION`` .\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The self-service action name.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``en`` - English (default) - ``jp`` - Japanese - ``zh`` - Chinese\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The self-service action description.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-serviceaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_service_action_props = servicecatalog.CfnServiceActionProps(\n        definition=[servicecatalog.CfnServiceAction.DefinitionParameterProperty(\n            key="key",\n            value="value"\n        )],\n        definition_type="definitionType",\n        name="name",\n\n        # the properties below are optional\n        accept_language="acceptLanguage",\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['definition', 'definition_type', 'name', 'accept_language', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnServiceActionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnStackSetConstraintProps
class CfnStackSetConstraintPropsDef(BaseCfnProperty):
    account_list: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='One or more AWS accounts that will have access to the provisioned product.\n')
    admin_role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='AdminRole ARN.\n')
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description of the constraint.\n')
    execution_role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='ExecutionRole name.\n')
    portfolio_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The portfolio identifier.\n')
    product_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The product identifier.\n')
    region_list: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='One or more AWS Regions where the provisioned product will be available. Applicable only to a ``CFN_STACKSET`` provisioned product type. The specified Regions should be within the list of Regions from the ``STACKSET`` constraint. To get the list of Regions in the ``STACKSET`` constraint, use the ``DescribeProvisioningParameters`` operation. If no values are specified, the default value is all Regions from the ``STACKSET`` constraint.\n')
    stack_instance_control: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Permission to create, update, and delete stack instances. Choose from ALLOWED and NOT_ALLOWED.\n')
    accept_language: typing.Optional[str] = pydantic.Field(None, description='The language code. - ``jp`` - Japanese - ``zh`` - Chinese\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-stacksetconstraint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_stack_set_constraint_props = servicecatalog.CfnStackSetConstraintProps(\n        account_list=["accountList"],\n        admin_role="adminRole",\n        description="description",\n        execution_role="executionRole",\n        portfolio_id="portfolioId",\n        product_id="productId",\n        region_list=["regionList"],\n        stack_instance_control="stackInstanceControl",\n\n        # the properties below are optional\n        accept_language="acceptLanguage"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_list', 'admin_role', 'description', 'execution_role', 'portfolio_id', 'product_id', 'region_list', 'stack_instance_control', 'accept_language']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnStackSetConstraintProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnTagOptionAssociationProps
class CfnTagOptionAssociationPropsDef(BaseCfnProperty):
    resource_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource identifier.\n')
    tag_option_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The TagOption identifier.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-tagoptionassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_tag_option_association_props = servicecatalog.CfnTagOptionAssociationProps(\n        resource_id="resourceId",\n        tag_option_id="tagOptionId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_id', 'tag_option_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnTagOptionAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicecatalog.CfnTagOptionProps
class CfnTagOptionPropsDef(BaseCfnProperty):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The TagOption key.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The TagOption value.\n')
    active: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The TagOption active state.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicecatalog-tagoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicecatalog as servicecatalog\n\n    cfn_tag_option_props = servicecatalog.CfnTagOptionProps(\n        key="key",\n        value="value",\n\n        # the properties below are optional\n        active=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value', 'active']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicecatalog.CfnTagOptionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CloudFormationTemplate: typing.Optional[dict[str, models.aws_servicecatalog.CloudFormationTemplateDef]] = pydantic.Field(None)
    Product: typing.Optional[dict[str, models.aws_servicecatalog.ProductDef]] = pydantic.Field(None)
    CloudFormationProduct: typing.Optional[dict[str, models.aws_servicecatalog.CloudFormationProductDef]] = pydantic.Field(None)
    Portfolio: typing.Optional[dict[str, models.aws_servicecatalog.PortfolioDef]] = pydantic.Field(None)
    ProductStack: typing.Optional[dict[str, models.aws_servicecatalog.ProductStackDef]] = pydantic.Field(None)
    ProductStackHistory: typing.Optional[dict[str, models.aws_servicecatalog.ProductStackHistoryDef]] = pydantic.Field(None)
    TagOptions: typing.Optional[dict[str, models.aws_servicecatalog.TagOptionsDef]] = pydantic.Field(None)
    CfnCloudFormationProduct_CodeStarParametersProperty: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProduct_CodeStarParametersPropertyDef]] = pydantic.Field(None)
    CfnCloudFormationProduct_ConnectionParametersProperty: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProduct_ConnectionParametersPropertyDef]] = pydantic.Field(None)
    CfnCloudFormationProduct_ProvisioningArtifactPropertiesProperty: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProduct_ProvisioningArtifactPropertiesPropertyDef]] = pydantic.Field(None)
    CfnCloudFormationProduct_SourceConnectionProperty: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProduct_SourceConnectionPropertyDef]] = pydantic.Field(None)
    CfnCloudFormationProvisionedProduct_ProvisioningParameterProperty: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProvisionedProduct_ProvisioningParameterPropertyDef]] = pydantic.Field(None)
    CfnCloudFormationProvisionedProduct_ProvisioningPreferencesProperty: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProvisionedProduct_ProvisioningPreferencesPropertyDef]] = pydantic.Field(None)
    CfnServiceAction_DefinitionParameterProperty: typing.Optional[dict[str, models.aws_servicecatalog.CfnServiceAction_DefinitionParameterPropertyDef]] = pydantic.Field(None)
    CloudFormationProductProps: typing.Optional[dict[str, models.aws_servicecatalog.CloudFormationProductPropsDef]] = pydantic.Field(None)
    CloudFormationProductVersion: typing.Optional[dict[str, models.aws_servicecatalog.CloudFormationProductVersionDef]] = pydantic.Field(None)
    CloudFormationRuleConstraintOptions: typing.Optional[dict[str, models.aws_servicecatalog.CloudFormationRuleConstraintOptionsDef]] = pydantic.Field(None)
    CloudFormationTemplateConfig: typing.Optional[dict[str, models.aws_servicecatalog.CloudFormationTemplateConfigDef]] = pydantic.Field(None)
    CommonConstraintOptions: typing.Optional[dict[str, models.aws_servicecatalog.CommonConstraintOptionsDef]] = pydantic.Field(None)
    PortfolioProps: typing.Optional[dict[str, models.aws_servicecatalog.PortfolioPropsDef]] = pydantic.Field(None)
    PortfolioShareOptions: typing.Optional[dict[str, models.aws_servicecatalog.PortfolioShareOptionsDef]] = pydantic.Field(None)
    ProductStackHistoryProps: typing.Optional[dict[str, models.aws_servicecatalog.ProductStackHistoryPropsDef]] = pydantic.Field(None)
    ProductStackProps: typing.Optional[dict[str, models.aws_servicecatalog.ProductStackPropsDef]] = pydantic.Field(None)
    StackSetsConstraintOptions: typing.Optional[dict[str, models.aws_servicecatalog.StackSetsConstraintOptionsDef]] = pydantic.Field(None)
    TagOptionsProps: typing.Optional[dict[str, models.aws_servicecatalog.TagOptionsPropsDef]] = pydantic.Field(None)
    TagUpdateConstraintOptions: typing.Optional[dict[str, models.aws_servicecatalog.TagUpdateConstraintOptionsDef]] = pydantic.Field(None)
    TemplateRule: typing.Optional[dict[str, models.aws_servicecatalog.TemplateRuleDef]] = pydantic.Field(None)
    TemplateRuleAssertion: typing.Optional[dict[str, models.aws_servicecatalog.TemplateRuleAssertionDef]] = pydantic.Field(None)
    CfnAcceptedPortfolioShare: typing.Optional[dict[str, models.aws_servicecatalog.CfnAcceptedPortfolioShareDef]] = pydantic.Field(None)
    CfnCloudFormationProduct: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProductDef]] = pydantic.Field(None)
    CfnCloudFormationProvisionedProduct: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProvisionedProductDef]] = pydantic.Field(None)
    CfnLaunchNotificationConstraint: typing.Optional[dict[str, models.aws_servicecatalog.CfnLaunchNotificationConstraintDef]] = pydantic.Field(None)
    CfnLaunchRoleConstraint: typing.Optional[dict[str, models.aws_servicecatalog.CfnLaunchRoleConstraintDef]] = pydantic.Field(None)
    CfnLaunchTemplateConstraint: typing.Optional[dict[str, models.aws_servicecatalog.CfnLaunchTemplateConstraintDef]] = pydantic.Field(None)
    CfnPortfolio: typing.Optional[dict[str, models.aws_servicecatalog.CfnPortfolioDef]] = pydantic.Field(None)
    CfnPortfolioPrincipalAssociation: typing.Optional[dict[str, models.aws_servicecatalog.CfnPortfolioPrincipalAssociationDef]] = pydantic.Field(None)
    CfnPortfolioProductAssociation: typing.Optional[dict[str, models.aws_servicecatalog.CfnPortfolioProductAssociationDef]] = pydantic.Field(None)
    CfnPortfolioShare: typing.Optional[dict[str, models.aws_servicecatalog.CfnPortfolioShareDef]] = pydantic.Field(None)
    CfnResourceUpdateConstraint: typing.Optional[dict[str, models.aws_servicecatalog.CfnResourceUpdateConstraintDef]] = pydantic.Field(None)
    CfnServiceAction: typing.Optional[dict[str, models.aws_servicecatalog.CfnServiceActionDef]] = pydantic.Field(None)
    CfnServiceActionAssociation: typing.Optional[dict[str, models.aws_servicecatalog.CfnServiceActionAssociationDef]] = pydantic.Field(None)
    CfnStackSetConstraint: typing.Optional[dict[str, models.aws_servicecatalog.CfnStackSetConstraintDef]] = pydantic.Field(None)
    CfnTagOption: typing.Optional[dict[str, models.aws_servicecatalog.CfnTagOptionDef]] = pydantic.Field(None)
    CfnTagOptionAssociation: typing.Optional[dict[str, models.aws_servicecatalog.CfnTagOptionAssociationDef]] = pydantic.Field(None)
    CfnAcceptedPortfolioShareProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnAcceptedPortfolioSharePropsDef]] = pydantic.Field(None)
    CfnCloudFormationProductProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProductPropsDef]] = pydantic.Field(None)
    CfnCloudFormationProvisionedProductProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnCloudFormationProvisionedProductPropsDef]] = pydantic.Field(None)
    CfnLaunchNotificationConstraintProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnLaunchNotificationConstraintPropsDef]] = pydantic.Field(None)
    CfnLaunchRoleConstraintProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnLaunchRoleConstraintPropsDef]] = pydantic.Field(None)
    CfnLaunchTemplateConstraintProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnLaunchTemplateConstraintPropsDef]] = pydantic.Field(None)
    CfnPortfolioPrincipalAssociationProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnPortfolioPrincipalAssociationPropsDef]] = pydantic.Field(None)
    CfnPortfolioProductAssociationProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnPortfolioProductAssociationPropsDef]] = pydantic.Field(None)
    CfnPortfolioProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnPortfolioPropsDef]] = pydantic.Field(None)
    CfnPortfolioShareProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnPortfolioSharePropsDef]] = pydantic.Field(None)
    CfnResourceUpdateConstraintProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnResourceUpdateConstraintPropsDef]] = pydantic.Field(None)
    CfnServiceActionAssociationProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnServiceActionAssociationPropsDef]] = pydantic.Field(None)
    CfnServiceActionProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnServiceActionPropsDef]] = pydantic.Field(None)
    CfnStackSetConstraintProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnStackSetConstraintPropsDef]] = pydantic.Field(None)
    CfnTagOptionAssociationProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnTagOptionAssociationPropsDef]] = pydantic.Field(None)
    CfnTagOptionProps: typing.Optional[dict[str, models.aws_servicecatalog.CfnTagOptionPropsDef]] = pydantic.Field(None)
    ...

import models
