from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_redshiftserverless.CfnNamespace.NamespaceProperty
class CfnNamespace_NamespacePropertyDef(BaseStruct):
    admin_username: typing.Optional[str] = pydantic.Field(None, description='The username of the administrator for the first database created in the namespace.\n')
    creation_date: typing.Optional[str] = pydantic.Field(None, description='The date of when the namespace was created.\n')
    db_name: typing.Optional[str] = pydantic.Field(None, description='The name of the first database created in the namespace.\n')
    default_iam_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.\n')
    iam_roles: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of IAM roles to associate with the namespace.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS Key Management Service key used to encrypt your data.\n')
    log_exports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.\n')
    namespace_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) associated with a namespace.\n')
    namespace_id: typing.Optional[str] = pydantic.Field(None, description='The unique identifier of a namespace.\n')
    namespace_name: typing.Optional[str] = pydantic.Field(None, description='The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in `Reserved Words <https://docs.aws.amazon.com//redshift/latest/dg/r_pg_keywords.html>`_ in the Amazon Redshift Database Developer Guide.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the namespace.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-redshiftserverless-namespace-namespace.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_redshiftserverless as redshiftserverless\n\n    namespace_property = redshiftserverless.CfnNamespace.NamespaceProperty(\n        admin_username="adminUsername",\n        creation_date="creationDate",\n        db_name="dbName",\n        default_iam_role_arn="defaultIamRoleArn",\n        iam_roles=["iamRoles"],\n        kms_key_id="kmsKeyId",\n        log_exports=["logExports"],\n        namespace_arn="namespaceArn",\n        namespace_id="namespaceId",\n        namespace_name="namespaceName",\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['admin_username', 'creation_date', 'db_name', 'default_iam_role_arn', 'iam_roles', 'kms_key_id', 'log_exports', 'namespace_arn', 'namespace_id', 'namespace_name', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnNamespace.NamespaceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_redshiftserverless.CfnWorkgroup.ConfigParameterProperty
class CfnWorkgroup_ConfigParameterPropertyDef(BaseStruct):
    parameter_key: typing.Optional[str] = pydantic.Field(None, description='The key of the parameter. The options are ``datestyle`` , ``enable_user_activity_logging`` , ``query_group`` , ``search_path`` , and ``max_query_execution_time`` .\n')
    parameter_value: typing.Optional[str] = pydantic.Field(None, description='The value of the parameter to set.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-redshiftserverless-workgroup-configparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_redshiftserverless as redshiftserverless\n\n    config_parameter_property = redshiftserverless.CfnWorkgroup.ConfigParameterProperty(\n        parameter_key="parameterKey",\n        parameter_value="parameterValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameter_key', 'parameter_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnWorkgroup.ConfigParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_redshiftserverless.CfnWorkgroup.EndpointProperty
class CfnWorkgroup_EndpointPropertyDef(BaseStruct):
    address: typing.Optional[str] = pydantic.Field(None, description='The DNS address of the VPC endpoint.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port that Amazon Redshift Serverless listens on.\n')
    vpc_endpoints: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_VpcEndpointPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of ``VpcEndpoint`` objects.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-redshiftserverless-workgroup-endpoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_redshiftserverless as redshiftserverless\n\n    endpoint_property = redshiftserverless.CfnWorkgroup.EndpointProperty(\n        address="address",\n        port=123,\n        vpc_endpoints=[redshiftserverless.CfnWorkgroup.VpcEndpointProperty(\n            network_interfaces=[redshiftserverless.CfnWorkgroup.NetworkInterfaceProperty(\n                availability_zone="availabilityZone",\n                network_interface_id="networkInterfaceId",\n                private_ip_address="privateIpAddress",\n                subnet_id="subnetId"\n            )],\n            vpc_endpoint_id="vpcEndpointId",\n            vpc_id="vpcId"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['address', 'port', 'vpc_endpoints']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnWorkgroup.EndpointProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_redshiftserverless.CfnWorkgroup.NetworkInterfaceProperty
class CfnWorkgroup_NetworkInterfacePropertyDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The availability Zone.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The unique identifier of the network interface.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address of the network interface within the subnet.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The unique identifier of the subnet.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-redshiftserverless-workgroup-networkinterface.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_redshiftserverless as redshiftserverless\n\n    network_interface_property = redshiftserverless.CfnWorkgroup.NetworkInterfaceProperty(\n        availability_zone="availabilityZone",\n        network_interface_id="networkInterfaceId",\n        private_ip_address="privateIpAddress",\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'network_interface_id', 'private_ip_address', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnWorkgroup.NetworkInterfaceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_redshiftserverless.CfnWorkgroup.VpcEndpointProperty
class CfnWorkgroup_VpcEndpointPropertyDef(BaseStruct):
    network_interfaces: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_NetworkInterfacePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more network interfaces of the endpoint. Also known as an interface endpoint.\n')
    vpc_endpoint_id: typing.Optional[str] = pydantic.Field(None, description='The connection endpoint ID for connecting to Amazon Redshift Serverless.\n')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='The VPC identifier that the endpoint is associated with.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-redshiftserverless-workgroup-vpcendpoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_redshiftserverless as redshiftserverless\n\n    vpc_endpoint_property = redshiftserverless.CfnWorkgroup.VpcEndpointProperty(\n        network_interfaces=[redshiftserverless.CfnWorkgroup.NetworkInterfaceProperty(\n            availability_zone="availabilityZone",\n            network_interface_id="networkInterfaceId",\n            private_ip_address="privateIpAddress",\n            subnet_id="subnetId"\n        )],\n        vpc_endpoint_id="vpcEndpointId",\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['network_interfaces', 'vpc_endpoint_id', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnWorkgroup.VpcEndpointProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_redshiftserverless.CfnWorkgroup.WorkgroupProperty
class CfnWorkgroup_WorkgroupPropertyDef(BaseStruct):
    base_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).\n')
    config_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_ConfigParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of parameters to set for advanced control over a database. The options are ``auto_mv`` , ``datestyle`` , ``enable_case_sensitivity_identifier`` , ``enable_user_activity_logging`` , ``query_group`` , , ``search_path`` , and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see `Query monitoring metrics for Amazon Redshift Serverless <https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless>`_ .\n')
    creation_date: typing.Optional[str] = pydantic.Field(None, description='The creation date of the workgroup.\n')
    endpoint: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_EndpointPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The endpoint that is created from the workgroup.\n')
    enhanced_vpc_routing: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.\n')
    namespace_name: typing.Optional[str] = pydantic.Field(None, description='The namespace the workgroup is associated with.\n')
    publicly_accessible: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A value that specifies whether the workgroup can be accessible from a public network.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of security group IDs to associate with the workgroup.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the workgroup.\n')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of subnet IDs the workgroup is associated with.\n')
    workgroup_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) that links to the workgroup.\n')
    workgroup_id: typing.Optional[str] = pydantic.Field(None, description='The unique identifier of the workgroup.\n')
    workgroup_name: typing.Optional[str] = pydantic.Field(None, description='The name of the workgroup.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-redshiftserverless-workgroup-workgroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_redshiftserverless as redshiftserverless\n\n    workgroup_property = redshiftserverless.CfnWorkgroup.WorkgroupProperty(\n        base_capacity=123,\n        config_parameters=[redshiftserverless.CfnWorkgroup.ConfigParameterProperty(\n            parameter_key="parameterKey",\n            parameter_value="parameterValue"\n        )],\n        creation_date="creationDate",\n        endpoint=redshiftserverless.CfnWorkgroup.EndpointProperty(\n            address="address",\n            port=123,\n            vpc_endpoints=[redshiftserverless.CfnWorkgroup.VpcEndpointProperty(\n                network_interfaces=[redshiftserverless.CfnWorkgroup.NetworkInterfaceProperty(\n                    availability_zone="availabilityZone",\n                    network_interface_id="networkInterfaceId",\n                    private_ip_address="privateIpAddress",\n                    subnet_id="subnetId"\n                )],\n                vpc_endpoint_id="vpcEndpointId",\n                vpc_id="vpcId"\n            )]\n        ),\n        enhanced_vpc_routing=False,\n        namespace_name="namespaceName",\n        publicly_accessible=False,\n        security_group_ids=["securityGroupIds"],\n        status="status",\n        subnet_ids=["subnetIds"],\n        workgroup_arn="workgroupArn",\n        workgroup_id="workgroupId",\n        workgroup_name="workgroupName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_capacity', 'config_parameters', 'creation_date', 'endpoint', 'enhanced_vpc_routing', 'namespace_name', 'publicly_accessible', 'security_group_ids', 'status', 'subnet_ids', 'workgroup_arn', 'workgroup_id', 'workgroup_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnWorkgroup.WorkgroupProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_redshiftserverless.CfnNamespace
class CfnNamespaceDef(BaseCfnResource):
    namespace_name: str = pydantic.Field(..., description='The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in `Reserved Words <https://docs.aws.amazon.com//redshift/latest/dg/r_pg_keywords.html>`_ in the Amazon Redshift Database Developer Guide.\n')
    admin_username: typing.Optional[str] = pydantic.Field(None, description='The username of the administrator for the primary database created in the namespace.\n')
    admin_user_password: typing.Optional[str] = pydantic.Field(None, description='The password of the administrator for the primary database created in the namespace.\n')
    db_name: typing.Optional[str] = pydantic.Field(None, description='The name of the primary database created in the namespace.\n')
    default_iam_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.\n')
    final_snapshot_name: typing.Optional[str] = pydantic.Field(None, description='The name of the snapshot to be created before the namespace is deleted.\n')
    final_snapshot_retention_period: typing.Union[int, float, None] = pydantic.Field(None, description='How long to retain the final snapshot.\n')
    iam_roles: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of IAM roles to associate with the namespace.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS Key Management Service key used to encrypt your data.\n')
    log_exports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The types of logs the namespace can export. Available export types are ``userlog`` , ``connectionlog`` , and ``useractivitylog`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The map of the key-value pairs used to tag the namespace.')
    _init_params: typing.ClassVar[list[str]] = ['namespace_name', 'admin_username', 'admin_user_password', 'db_name', 'default_iam_role_arn', 'final_snapshot_name', 'final_snapshot_retention_period', 'iam_roles', 'kms_key_id', 'log_exports', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['NamespaceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnNamespace'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNamespaceDefConfig] = pydantic.Field(None)


class CfnNamespaceDefConfig(pydantic.BaseModel):
    NamespaceProperty: typing.Optional[list[CfnNamespaceDefNamespacepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnNamespaceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNamespaceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNamespaceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNamespaceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNamespaceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNamespaceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNamespaceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNamespaceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNamespaceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNamespaceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNamespaceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNamespaceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNamespaceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNamespaceDefNamespacepropertyParams(pydantic.BaseModel):
    admin_username: typing.Optional[str] = pydantic.Field(None, description='')
    creation_date: typing.Optional[str] = pydantic.Field(None, description='')
    db_name: typing.Optional[str] = pydantic.Field(None, description='')
    default_iam_role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    iam_roles: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    log_exports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    namespace_arn: typing.Optional[str] = pydantic.Field(None, description='')
    namespace_id: typing.Optional[str] = pydantic.Field(None, description='')
    namespace_name: typing.Optional[str] = pydantic.Field(None, description='')
    status: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNamespaceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNamespaceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNamespaceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNamespaceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNamespaceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNamespaceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNamespaceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNamespaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNamespaceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNamespaceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNamespaceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNamespaceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNamespaceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNamespaceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_redshiftserverless.CfnWorkgroup
class CfnWorkgroupDef(BaseCfnResource):
    workgroup_name: str = pydantic.Field(..., description='The name of the workgroup.\n')
    base_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The base compute capacity of the workgroup in Redshift Processing Units (RPUs).\n')
    config_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_ConfigParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of parameters to set for finer control over a database. Available options are ``datestyle`` , ``enable_user_activity_logging`` , ``query_group`` , ``search_path`` , and ``max_query_execution_time`` .\n')
    enhanced_vpc_routing: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.\n')
    namespace_name: typing.Optional[str] = pydantic.Field(None, description='The namespace the workgroup is associated with.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.\n')
    publicly_accessible: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A value that specifies whether the workgroup can be accessible from a public network.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of security group IDs to associate with the workgroup.\n')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of subnet IDs the workgroup is associated with.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The map of the key-value pairs used to tag the workgroup.')
    _init_params: typing.ClassVar[list[str]] = ['workgroup_name', 'base_capacity', 'config_parameters', 'enhanced_vpc_routing', 'namespace_name', 'port', 'publicly_accessible', 'security_group_ids', 'subnet_ids', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ConfigParameterProperty', 'EndpointProperty', 'NetworkInterfaceProperty', 'VpcEndpointProperty', 'WorkgroupProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnWorkgroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnWorkgroupDefConfig] = pydantic.Field(None)


class CfnWorkgroupDefConfig(pydantic.BaseModel):
    ConfigParameterProperty: typing.Optional[list[CfnWorkgroupDefConfigparameterpropertyParams]] = pydantic.Field(None, description='')
    EndpointProperty: typing.Optional[list[CfnWorkgroupDefEndpointpropertyParams]] = pydantic.Field(None, description='')
    NetworkInterfaceProperty: typing.Optional[list[CfnWorkgroupDefNetworkinterfacepropertyParams]] = pydantic.Field(None, description='')
    VpcEndpointProperty: typing.Optional[list[CfnWorkgroupDefVpcendpointpropertyParams]] = pydantic.Field(None, description='')
    WorkgroupProperty: typing.Optional[list[CfnWorkgroupDefWorkgrouppropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnWorkgroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnWorkgroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnWorkgroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnWorkgroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnWorkgroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnWorkgroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnWorkgroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnWorkgroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnWorkgroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnWorkgroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnWorkgroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnWorkgroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnWorkgroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_workgroup_config_parameters_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_workgroup_endpoint_vpc_endpoints_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_workgroup_enhanced_vpc_routing_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_workgroup_publicly_accessible_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnWorkgroupDefConfigparameterpropertyParams(pydantic.BaseModel):
    parameter_key: typing.Optional[str] = pydantic.Field(None, description='')
    parameter_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnWorkgroupDefEndpointpropertyParams(pydantic.BaseModel):
    address: typing.Optional[str] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    vpc_endpoints: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_VpcEndpointPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnWorkgroupDefNetworkinterfacepropertyParams(pydantic.BaseModel):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnWorkgroupDefVpcendpointpropertyParams(pydantic.BaseModel):
    network_interfaces: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_NetworkInterfacePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    vpc_endpoint_id: typing.Optional[str] = pydantic.Field(None, description='')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnWorkgroupDefWorkgrouppropertyParams(pydantic.BaseModel):
    base_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    config_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_ConfigParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    creation_date: typing.Optional[str] = pydantic.Field(None, description='')
    endpoint: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_EndpointPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    enhanced_vpc_routing: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    namespace_name: typing.Optional[str] = pydantic.Field(None, description='')
    publicly_accessible: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    status: typing.Optional[str] = pydantic.Field(None, description='')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    workgroup_arn: typing.Optional[str] = pydantic.Field(None, description='')
    workgroup_id: typing.Optional[str] = pydantic.Field(None, description='')
    workgroup_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnWorkgroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnWorkgroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnWorkgroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnWorkgroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnWorkgroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnWorkgroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnWorkgroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnWorkgroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnWorkgroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnWorkgroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnWorkgroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnWorkgroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnWorkgroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnWorkgroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_redshiftserverless.CfnNamespaceProps
class CfnNamespacePropsDef(BaseCfnProperty):
    namespace_name: str = pydantic.Field(..., description='The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in `Reserved Words <https://docs.aws.amazon.com//redshift/latest/dg/r_pg_keywords.html>`_ in the Amazon Redshift Database Developer Guide.\n')
    admin_username: typing.Optional[str] = pydantic.Field(None, description='The username of the administrator for the primary database created in the namespace.\n')
    admin_user_password: typing.Optional[str] = pydantic.Field(None, description='The password of the administrator for the primary database created in the namespace.\n')
    db_name: typing.Optional[str] = pydantic.Field(None, description='The name of the primary database created in the namespace.\n')
    default_iam_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.\n')
    final_snapshot_name: typing.Optional[str] = pydantic.Field(None, description='The name of the snapshot to be created before the namespace is deleted.\n')
    final_snapshot_retention_period: typing.Union[int, float, None] = pydantic.Field(None, description='How long to retain the final snapshot.\n')
    iam_roles: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of IAM roles to associate with the namespace.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS Key Management Service key used to encrypt your data.\n')
    log_exports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The types of logs the namespace can export. Available export types are ``userlog`` , ``connectionlog`` , and ``useractivitylog`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The map of the key-value pairs used to tag the namespace.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-redshiftserverless-namespace.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_redshiftserverless as redshiftserverless\n\n    cfn_namespace_props = redshiftserverless.CfnNamespaceProps(\n        namespace_name="namespaceName",\n\n        # the properties below are optional\n        admin_username="adminUsername",\n        admin_user_password="adminUserPassword",\n        db_name="dbName",\n        default_iam_role_arn="defaultIamRoleArn",\n        final_snapshot_name="finalSnapshotName",\n        final_snapshot_retention_period=123,\n        iam_roles=["iamRoles"],\n        kms_key_id="kmsKeyId",\n        log_exports=["logExports"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace_name', 'admin_username', 'admin_user_password', 'db_name', 'default_iam_role_arn', 'final_snapshot_name', 'final_snapshot_retention_period', 'iam_roles', 'kms_key_id', 'log_exports', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnNamespaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_redshiftserverless.CfnWorkgroupProps
class CfnWorkgroupPropsDef(BaseCfnProperty):
    workgroup_name: str = pydantic.Field(..., description='The name of the workgroup.\n')
    base_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The base compute capacity of the workgroup in Redshift Processing Units (RPUs).\n')
    config_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_redshiftserverless.CfnWorkgroup_ConfigParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of parameters to set for finer control over a database. Available options are ``datestyle`` , ``enable_user_activity_logging`` , ``query_group`` , ``search_path`` , and ``max_query_execution_time`` .\n')
    enhanced_vpc_routing: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.\n')
    namespace_name: typing.Optional[str] = pydantic.Field(None, description='The namespace the workgroup is associated with.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.\n')
    publicly_accessible: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A value that specifies whether the workgroup can be accessible from a public network.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of security group IDs to associate with the workgroup.\n')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of subnet IDs the workgroup is associated with.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The map of the key-value pairs used to tag the workgroup.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-redshiftserverless-workgroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_redshiftserverless as redshiftserverless\n\n    cfn_workgroup_props = redshiftserverless.CfnWorkgroupProps(\n        workgroup_name="workgroupName",\n\n        # the properties below are optional\n        base_capacity=123,\n        config_parameters=[redshiftserverless.CfnWorkgroup.ConfigParameterProperty(\n            parameter_key="parameterKey",\n            parameter_value="parameterValue"\n        )],\n        enhanced_vpc_routing=False,\n        namespace_name="namespaceName",\n        port=123,\n        publicly_accessible=False,\n        security_group_ids=["securityGroupIds"],\n        subnet_ids=["subnetIds"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['workgroup_name', 'base_capacity', 'config_parameters', 'enhanced_vpc_routing', 'namespace_name', 'port', 'publicly_accessible', 'security_group_ids', 'subnet_ids', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_redshiftserverless.CfnWorkgroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnNamespace_NamespaceProperty: typing.Optional[dict[str, CfnNamespace_NamespacePropertyDef]] = pydantic.Field(None)
    CfnWorkgroup_ConfigParameterProperty: typing.Optional[dict[str, CfnWorkgroup_ConfigParameterPropertyDef]] = pydantic.Field(None)
    CfnWorkgroup_EndpointProperty: typing.Optional[dict[str, CfnWorkgroup_EndpointPropertyDef]] = pydantic.Field(None)
    CfnWorkgroup_NetworkInterfaceProperty: typing.Optional[dict[str, CfnWorkgroup_NetworkInterfacePropertyDef]] = pydantic.Field(None)
    CfnWorkgroup_VpcEndpointProperty: typing.Optional[dict[str, CfnWorkgroup_VpcEndpointPropertyDef]] = pydantic.Field(None)
    CfnWorkgroup_WorkgroupProperty: typing.Optional[dict[str, CfnWorkgroup_WorkgroupPropertyDef]] = pydantic.Field(None)
    CfnNamespace: typing.Optional[dict[str, CfnNamespaceDef]] = pydantic.Field(None)
    CfnWorkgroup: typing.Optional[dict[str, CfnWorkgroupDef]] = pydantic.Field(None)
    CfnNamespaceProps: typing.Optional[dict[str, CfnNamespacePropsDef]] = pydantic.Field(None)
    CfnWorkgroupProps: typing.Optional[dict[str, CfnWorkgroupPropsDef]] = pydantic.Field(None)
    ...
