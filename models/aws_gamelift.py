from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_gamelift.CfnAlias.RoutingStrategyProperty
class CfnAlias_RoutingStrategyPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A type of routing strategy. Possible routing types include the following: - *SIMPLE* - The alias resolves to one specific fleet. Use this type when routing to active fleets. - *TERMINAL* - The alias does not resolve to a fleet but instead can be used to display a message to the user. A terminal alias throws a ``TerminalRoutingStrategyException`` with the message that you specified in the ``Message`` property.\n')
    fleet_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for a fleet that the alias points to. If you specify ``SIMPLE`` for the ``Type`` property, you must specify this property.\n')
    message: typing.Optional[str] = pydantic.Field(None, description='The message text to be used with a terminal routing strategy. If you specify ``TERMINAL`` for the ``Type`` property, you must specify this property.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-alias-routingstrategy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    routing_strategy_property = gamelift.CfnAlias.RoutingStrategyProperty(\n        type="type",\n\n        # the properties below are optional\n        fleet_id="fleetId",\n        message="message"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'fleet_id', 'message']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnAlias.RoutingStrategyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnBuild.StorageLocationProperty
class CfnBuild_StorageLocationPropertyDef(BaseStruct):
    bucket: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="An Amazon S3 bucket identifier. The name of the S3 bucket. .. epigraph:: Amazon GameLift doesn't support uploading from Amazon S3 buckets with names that contain a dot (.).\n")
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the zip file that contains the build files or script files.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARNfor an IAM role that allows Amazon GameLift to access the S3 bucket.\n')
    object_version: typing.Optional[str] = pydantic.Field(None, description='A version of a stored file to retrieve, if the object versioning feature is turned on for the S3 bucket. Use this parameter to specify a specific version. If this parameter isn\'t set, Amazon GameLift retrieves the latest version of the file.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-build-storagelocation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    storage_location_property = gamelift.CfnBuild.StorageLocationProperty(\n        bucket="bucket",\n        key="key",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        object_version="objectVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'key', 'role_arn', 'object_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnBuild.StorageLocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerDefinitionProperty
class CfnContainerGroupDefinition_ContainerDefinitionPropertyDef(BaseStruct):
    container_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The container definition identifier. Container names are unique within a container group definition.\n')
    image_uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URI to the image that $short; copied and deployed to a container fleet. For a more specific identifier, see ``ResolvedImageDigest`` .\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="A command that's passed to the container on startup. Each argument for the command is an additional string in the array. See the `ContainerDefinition::command <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command>`_ parameter in the *Amazon Elastic Container Service API reference.*\n")
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of CPU units that are reserved for the container. Note: 1 vCPU unit equals 1024 CPU units. If no resources are reserved, the container shares the total CPU limit for the container group. *Related data type:* ``ContainerGroupDefinition$TotalCpuLimit``\n')
    depends_on: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerDependencyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.\n')
    entry_point: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The entry point that's passed to the container on startup. If there are multiple arguments, each argument is an additional string in the array. See the `ContainerDefinition::entryPoint <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint>`_ parameter in the *Amazon Elastic Container Service API Reference* .\n")
    environment: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerEnvironmentPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="A set of environment variables that's passed to the container on startup. See the `ContainerDefinition::environment <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment>`_ parameter in the *Amazon Elastic Container Service API Reference* .\n")
    essential: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the container is vital to the container group. If an essential container fails, the entire container group is restarted.\n')
    health_check: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerHealthCheckPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="A configuration for a non-terminal health check. A container, which automatically restarts if it stops functioning, also restarts if it fails this health check. If an essential container in the daemon group fails a health check, the entire container group is restarted. The essential container in the replica group doesn't use this health check mechanism, because the Amazon GameLift Agent automatically handles the task.\n")
    memory_limits: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_MemoryLimitsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The amount of memory that Amazon GameLift makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation. *Related data type:* ``ContainerGroupDefinition$TotalMemoryLimit``\n")
    port_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_PortConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Defines the ports that are available to assign to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's ``ConnectionPortRange`` .\n")
    resolved_image_digest: typing.Optional[str] = pydantic.Field(None, description='A unique and immutable identifier for the container image that is deployed to a container fleet. The digest is a SHA 256 hash of the container image manifest.\n')
    working_directory: typing.Optional[str] = pydantic.Field(None, description='The directory in the container where commands are run. See the `ContainerDefinition::workingDirectory <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory>`_ parameter in the *Amazon Elastic Container Service API Reference* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-containergroupdefinition-containerdefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    container_definition_property = gamelift.CfnContainerGroupDefinition.ContainerDefinitionProperty(\n        container_name="containerName",\n        image_uri="imageUri",\n\n        # the properties below are optional\n        command=["command"],\n        cpu=123,\n        depends_on=[gamelift.CfnContainerGroupDefinition.ContainerDependencyProperty(\n            condition="condition",\n            container_name="containerName"\n        )],\n        entry_point=["entryPoint"],\n        environment=[gamelift.CfnContainerGroupDefinition.ContainerEnvironmentProperty(\n            name="name",\n            value="value"\n        )],\n        essential=False,\n        health_check=gamelift.CfnContainerGroupDefinition.ContainerHealthCheckProperty(\n            command=["command"],\n\n            # the properties below are optional\n            interval=123,\n            retries=123,\n            start_period=123,\n            timeout=123\n        ),\n        memory_limits=gamelift.CfnContainerGroupDefinition.MemoryLimitsProperty(\n            hard_limit=123,\n            soft_limit=123\n        ),\n        port_configuration=gamelift.CfnContainerGroupDefinition.PortConfigurationProperty(\n            container_port_ranges=[gamelift.CfnContainerGroupDefinition.ContainerPortRangeProperty(\n                from_port=123,\n                protocol="protocol",\n                to_port=123\n            )]\n        ),\n        resolved_image_digest="resolvedImageDigest",\n        working_directory="workingDirectory"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_name', 'image_uri', 'command', 'cpu', 'depends_on', 'entry_point', 'environment', 'essential', 'health_check', 'memory_limits', 'port_configuration', 'resolved_image_digest', 'working_directory']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerDefinitionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerDependencyProperty
class CfnContainerGroupDefinition_ContainerDependencyPropertyDef(BaseStruct):
    condition: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The condition that the dependency container must reach before the dependent container can start. Valid conditions include:. - START - The dependency container must have started. - COMPLETE - The dependency container has run to completion (exits). Use this condition with nonessential containers, such as those that run a script and then exit. The dependency container can't be an essential container. - SUCCESS - The dependency container has run to completion and exited with a zero status. The dependency container can't be an essential container. - HEALTHY - The dependency container has passed its Docker health check. Use this condition with dependency containers that have health checks configured. This condition is confirmed at container group startup only.\n")
    container_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive label for the container definition that this container depends on.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-containergroupdefinition-containerdependency.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    container_dependency_property = gamelift.CfnContainerGroupDefinition.ContainerDependencyProperty(\n        condition="condition",\n        container_name="containerName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['condition', 'container_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerDependencyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerEnvironmentProperty
class CfnContainerGroupDefinition_ContainerEnvironmentPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The environment variable name.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The environment variable value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-containergroupdefinition-containerenvironment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    container_environment_property = gamelift.CfnContainerGroupDefinition.ContainerEnvironmentProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerEnvironmentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerHealthCheckProperty
class CfnContainerGroupDefinition_ContainerHealthCheckPropertyDef(BaseStruct):
    command: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="A string array that specifies the command that the container runs to determine if it's healthy.\n")
    interval: typing.Union[int, float, None] = pydantic.Field(None, description='The time period (in seconds) between each health check.\n')
    retries: typing.Union[int, float, None] = pydantic.Field(None, description='The number of times to retry a failed health check before the container is considered unhealthy. The first run of the command does not count as a retry.\n')
    start_period: typing.Union[int, float, None] = pydantic.Field(None, description='The optional grace period (in seconds) to give a container time to bootstrap before the first failed health check counts toward the number of retries.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The time period (in seconds) to wait for a health check to succeed before a failed health check is counted.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-containergroupdefinition-containerhealthcheck.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    container_health_check_property = gamelift.CfnContainerGroupDefinition.ContainerHealthCheckProperty(\n        command=["command"],\n\n        # the properties below are optional\n        interval=123,\n        retries=123,\n        start_period=123,\n        timeout=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['command', 'interval', 'retries', 'start_period', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerHealthCheckProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerPortRangeProperty
class CfnContainerGroupDefinition_ContainerPortRangePropertyDef(BaseStruct):
    from_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='A starting value for the range of allowed port numbers.\n')
    protocol: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The network protocol that these ports support.\n')
    to_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than ``FromPort`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-containergroupdefinition-containerportrange.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    container_port_range_property = gamelift.CfnContainerGroupDefinition.ContainerPortRangeProperty(\n        from_port=123,\n        protocol="protocol",\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_port', 'protocol', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinition.ContainerPortRangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinition.MemoryLimitsProperty
class CfnContainerGroupDefinition_MemoryLimitsPropertyDef(BaseStruct):
    hard_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The hard limit of memory to reserve for the container.\n')
    soft_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of memory that is reserved for the container.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-containergroupdefinition-memorylimits.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    memory_limits_property = gamelift.CfnContainerGroupDefinition.MemoryLimitsProperty(\n        hard_limit=123,\n        soft_limit=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hard_limit', 'soft_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinition.MemoryLimitsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinition.PortConfigurationProperty
class CfnContainerGroupDefinition_PortConfigurationPropertyDef(BaseStruct):
    container_port_ranges: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerPortRangePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies one or more ranges of ports on a container.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-containergroupdefinition-portconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    port_configuration_property = gamelift.CfnContainerGroupDefinition.PortConfigurationProperty(\n        container_port_ranges=[gamelift.CfnContainerGroupDefinition.ContainerPortRangeProperty(\n            from_port=123,\n            protocol="protocol",\n            to_port=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_port_ranges']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinition.PortConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.AnywhereConfigurationProperty
class CfnFleet_AnywhereConfigurationPropertyDef(BaseStruct):
    cost: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cost to run your fleet per hour. Amazon GameLift uses the provided cost of your fleet to balance usage in queues. For more information about queues, see `Setting up queues <https://docs.aws.amazon.com/gamelift/latest/developerguide/queues-intro.html>`_ in the *Amazon GameLift Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-anywhereconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    anywhere_configuration_property = gamelift.CfnFleet.AnywhereConfigurationProperty(\n        cost="cost"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cost']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.AnywhereConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.CertificateConfigurationProperty
class CfnFleet_CertificateConfigurationPropertyDef(BaseStruct):
    certificate_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values include: - *GENERATED* - Generate a TLS/SSL certificate for this fleet. - *DISABLED* - (default) Do not generate a TLS/SSL certificate for this fleet.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-certificateconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    certificate_configuration_property = gamelift.CfnFleet.CertificateConfigurationProperty(\n        certificate_type="certificateType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.CertificateConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.ConnectionPortRangeProperty
class CfnFleet_ConnectionPortRangePropertyDef(BaseStruct):
    from_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Starting value for the port range.\n')
    to_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Ending value for the port. Port numbers are end-inclusive. This value must be equal to or greater than ``FromPort`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-connectionportrange.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    connection_port_range_property = gamelift.CfnFleet.ConnectionPortRangeProperty(\n        from_port=123,\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_port', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.ConnectionPortRangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.ContainerGroupsConfigurationProperty
class CfnFleet_ContainerGroupsConfigurationPropertyDef(BaseStruct):
    connection_port_range: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_gamelift.CfnFleet_ConnectionPortRangePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="A set of ports to allow inbound traffic, including game clients, to connect to processes running in the container fleet. Connection ports are dynamically mapped to container ports, which are assigned to individual processes running in a container. The connection port range must have enough ports to map to all container ports across a fleet instance. To calculate the minimum connection ports needed, use the following formula: *[Total number of container ports as defined for containers in the replica container group] * [Desired or calculated number of replica container groups per instance] + [Total number of container ports as defined for containers in the daemon container group]* As a best practice, double the minimum number of connection ports. .. epigraph:: Use the fleet's ``EC2InboundPermissions`` property to control external access to connection ports. Set this property to the connection port numbers that you want to open access to. See ``IpPermission`` for more details.\n")
    container_group_definition_names: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The list of container group definition names to deploy to a new container fleet.\n')
    container_groups_per_instance: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ContainerGroupsPerInstancePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The number of container groups per instance.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-containergroupsconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    container_groups_configuration_property = gamelift.CfnFleet.ContainerGroupsConfigurationProperty(\n        connection_port_range=gamelift.CfnFleet.ConnectionPortRangeProperty(\n            from_port=123,\n            to_port=123\n        ),\n        container_group_definition_names=["containerGroupDefinitionNames"],\n\n        # the properties below are optional\n        container_groups_per_instance=gamelift.CfnFleet.ContainerGroupsPerInstanceProperty(\n            desired_replica_container_groups_per_instance=123,\n            max_replica_container_groups_per_instance=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_port_range', 'container_group_definition_names', 'container_groups_per_instance']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.ContainerGroupsConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.ContainerGroupsPerInstanceProperty
class CfnFleet_ContainerGroupsPerInstancePropertyDef(BaseStruct):
    desired_replica_container_groups_per_instance: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of replica container groups to place on each fleet instance.\n')
    max_replica_container_groups_per_instance: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum possible number of replica container groups that each fleet instance can have.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-containergroupsperinstance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    container_groups_per_instance_property = gamelift.CfnFleet.ContainerGroupsPerInstanceProperty(\n        desired_replica_container_groups_per_instance=123,\n        max_replica_container_groups_per_instance=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['desired_replica_container_groups_per_instance', 'max_replica_container_groups_per_instance']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.ContainerGroupsPerInstanceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.IpPermissionProperty
class CfnFleet_IpPermissionPropertyDef(BaseStruct):
    from_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='A starting value for a range of allowed port numbers. For fleets using Linux builds, only ports ``22`` and ``1026-60000`` are valid. For fleets using Windows builds, only ports ``1026-60000`` are valid.\n')
    ip_range: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: " ``000.000.000.000/[subnet mask]`` " or optionally the shortened version " ``0.0.0.0/[subnet mask]`` ".\n')
    protocol: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The network communication protocol used by the fleet.\n')
    to_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than ``FromPort`` . For fleets using Linux builds, only ports ``22`` and ``1026-60000`` are valid. For fleets using Windows builds, only ports ``1026-60000`` are valid.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-ippermission.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    ip_permission_property = gamelift.CfnFleet.IpPermissionProperty(\n        from_port=123,\n        ip_range="ipRange",\n        protocol="protocol",\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_port', 'ip_range', 'protocol', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.IpPermissionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.LocationCapacityProperty
class CfnFleet_LocationCapacityPropertyDef(BaseStruct):
    desired_ec2_instances: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description="The number of Amazon EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits. Changes in desired instance value can take up to 1 minute to be reflected when viewing the fleet's capacity settings.\n")
    max_size: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The maximum number of instances that are allowed in the specified fleet location. If this parameter is not set, the default is 1.\n')
    min_size: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum number of instances that are allowed in the specified fleet location. If this parameter is not set, the default is 0.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-locationcapacity.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    location_capacity_property = gamelift.CfnFleet.LocationCapacityProperty(\n        desired_ec2_instances=123,\n        max_size=123,\n        min_size=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['desired_ec2_instances', 'max_size', 'min_size']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.LocationCapacityProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.LocationConfigurationProperty
class CfnFleet_LocationConfigurationPropertyDef(BaseStruct):
    location: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An AWS Region code, such as ``us-west-2`` .\n')
    location_capacity: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_LocationCapacityPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Current resource capacity settings for managed EC2 fleets and container fleets. For multi-location fleets, location values might refer to a fleet\'s remote location or its home Region. *Returned by:* `DescribeFleetCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetCapacity.html>`_ , `DescribeFleetLocationCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetLocationCapacity.html>`_ , `UpdateFleetCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateFleetCapacity.html>`_\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-locationconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    location_configuration_property = gamelift.CfnFleet.LocationConfigurationProperty(\n        location="location",\n\n        # the properties below are optional\n        location_capacity=gamelift.CfnFleet.LocationCapacityProperty(\n            desired_ec2_instances=123,\n            max_size=123,\n            min_size=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['location', 'location_capacity']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.LocationConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.ResourceCreationLimitPolicyProperty
class CfnFleet_ResourceCreationLimitPolicyPropertyDef(BaseStruct):
    new_game_sessions_per_creator: typing.Union[int, float, None] = pydantic.Field(None, description="A policy that puts limits on the number of game sessions that a player can create within a specified span of time. With this policy, you can control players' ability to consume available resources. The policy is evaluated when a player tries to create a new game session. On receiving a ``CreateGameSession`` request, Amazon GameLift checks that the player (identified by ``CreatorId`` ) has created fewer than game session limit in the specified time period.\n")
    policy_period_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='The time span used in evaluating the resource creation limit policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-resourcecreationlimitpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    resource_creation_limit_policy_property = gamelift.CfnFleet.ResourceCreationLimitPolicyProperty(\n        new_game_sessions_per_creator=123,\n        policy_period_in_minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['new_game_sessions_per_creator', 'policy_period_in_minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.ResourceCreationLimitPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.RuntimeConfigurationProperty
class CfnFleet_RuntimeConfigurationPropertyDef(BaseStruct):
    game_session_activation_timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of time (in seconds) allowed to launch a new game session and have it report ready to host players. During this time, the game session is in status ``ACTIVATING`` . If the game session does not become active before the timeout, it is ended and the game session status is changed to ``TERMINATED`` .\n')
    max_concurrent_game_session_activations: typing.Union[int, float, None] = pydantic.Field(None, description='The number of game sessions in status ``ACTIVATING`` to allow on an instance or container. This setting limits the instance resources that can be used for new game activations at any one time.\n')
    server_processes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ServerProcessPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A collection of server process configurations that identify what server processes to run on fleet computes.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-runtimeconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    runtime_configuration_property = gamelift.CfnFleet.RuntimeConfigurationProperty(\n        game_session_activation_timeout_seconds=123,\n        max_concurrent_game_session_activations=123,\n        server_processes=[gamelift.CfnFleet.ServerProcessProperty(\n            concurrent_executions=123,\n            launch_path="launchPath",\n\n            # the properties below are optional\n            parameters="parameters"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['game_session_activation_timeout_seconds', 'max_concurrent_game_session_activations', 'server_processes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.RuntimeConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.ScalingPolicyProperty
class CfnFleet_ScalingPolicyPropertyDef(BaseStruct):
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment. For detailed descriptions of fleet metrics, see `Monitor Amazon GameLift with Amazon CloudWatch <https://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html>`_ . - *ActivatingGameSessions* -- Game sessions in the process of being created. - *ActiveGameSessions* -- Game sessions that are currently running. - *ActiveInstances* -- Fleet instances that are currently running at least one game session. - *AvailableGameSessions* -- Additional game sessions that fleet could host simultaneously, given current capacity. - *AvailablePlayerSessions* -- Empty player slots in currently active game sessions. This includes game sessions that are not currently accepting players. Reserved player slots are not included. - *CurrentPlayerSessions* -- Player slots in active game sessions that are being used by a player or are reserved for a player. - *IdleInstances* -- Active instances that are currently hosting zero game sessions. - *PercentAvailableGameSessions* -- Unused percentage of the total number of game sessions that a fleet could host simultaneously, given current capacity. Use this metric for a target-based scaling policy. - *PercentIdleInstances* -- Percentage of the total number of active instances that are hosting zero game sessions. - *QueueDepth* -- Pending game session placement requests, in any queue, where the current fleet is the top-priority destination. - *WaitTime* -- Current wait time for pending game session placement requests, in any queue, where the current fleet is the top-priority destination.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.\n")
    comparison_operator: typing.Optional[str] = pydantic.Field(None, description='Comparison operator to use when measuring a metric against the threshold value.\n')
    evaluation_periods: typing.Union[int, float, None] = pydantic.Field(None, description='Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.\n')
    location: typing.Optional[str] = pydantic.Field(None, description='The fleet location.\n')
    policy_type: typing.Optional[str] = pydantic.Field(None, description="The type of scaling policy to create. For a target-based policy, set the parameter *MetricName* to 'PercentAvailableGameSessions' and specify a *TargetConfiguration* . For a rule-based policy set the following parameters: *MetricName* , *ComparisonOperator* , *Threshold* , *EvaluationPeriods* , *ScalingAdjustmentType* , and *ScalingAdjustment* .\n")
    scaling_adjustment: typing.Union[int, float, None] = pydantic.Field(None, description='Amount of adjustment to make, based on the scaling adjustment type.\n')
    scaling_adjustment_type: typing.Optional[str] = pydantic.Field(None, description="The type of adjustment to make to a fleet's instance count. - *ChangeInCapacity* -- add (or subtract) the scaling adjustment value from the current instance count. Positive values scale up while negative values scale down. - *ExactCapacity* -- set the instance count to the scaling adjustment value. - *PercentChangeInCapacity* -- increase or reduce the current instance count by the scaling adjustment, read as a percentage. Positive values scale up while negative values scale down.\n")
    status: typing.Optional[str] = pydantic.Field(None, description='Current status of the scaling policy. The scaling policy can be in force only when in an ``ACTIVE`` status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change. - *ACTIVE* -- The scaling policy can be used for auto-scaling a fleet. - *UPDATE_REQUESTED* -- A request to update the scaling policy has been received. - *UPDATING* -- A change is being made to the scaling policy. - *DELETE_REQUESTED* -- A request to delete the scaling policy has been received. - *DELETING* -- The scaling policy is being deleted. - *DELETED* -- The scaling policy has been deleted. - *ERROR* -- An error occurred in creating the policy. It should be removed and recreated.\n')
    target_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_TargetConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that contains settings for a target-based scaling policy.\n')
    threshold: typing.Union[int, float, None] = pydantic.Field(None, description='Metric value used to trigger a scaling event.\n')
    update_status: typing.Optional[str] = pydantic.Field(None, description='The current status of the fleet\'s scaling policies in a requested fleet location. The status ``PENDING_UPDATE`` indicates that an update was requested for the fleet but has not yet been completed for the location.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-scalingpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    scaling_policy_property = gamelift.CfnFleet.ScalingPolicyProperty(\n        metric_name="metricName",\n        name="name",\n\n        # the properties below are optional\n        comparison_operator="comparisonOperator",\n        evaluation_periods=123,\n        location="location",\n        policy_type="policyType",\n        scaling_adjustment=123,\n        scaling_adjustment_type="scalingAdjustmentType",\n        status="status",\n        target_configuration=gamelift.CfnFleet.TargetConfigurationProperty(\n            target_value=123\n        ),\n        threshold=123,\n        update_status="updateStatus"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric_name', 'name', 'comparison_operator', 'evaluation_periods', 'location', 'policy_type', 'scaling_adjustment', 'scaling_adjustment_type', 'status', 'target_configuration', 'threshold', 'update_status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.ScalingPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.ServerProcessProperty
class CfnFleet_ServerProcessPropertyDef(BaseStruct):
    concurrent_executions: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of server processes using this configuration that run concurrently on each instance or container..\n')
    launch_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The location of a game build executable or Realtime script. Game builds and Realtime scripts are installed on instances at the root: - Windows (custom game builds only): ``C:\\game`` . Example: " ``C:\\game\\MyGame\\server.exe`` " - Linux: ``/local/game`` . Examples: " ``/local/game/MyGame/server.exe`` " or " ``/local/game/MyRealtimeScript.js`` " .. epigraph:: Amazon GameLift doesn\'t support the use of setup scripts that launch the game executable. For custom game builds, this parameter must indicate the executable that calls the server SDK operations ``initSDK()`` and ``ProcessReady()`` .\n')
    parameters: typing.Optional[str] = pydantic.Field(None, description='An optional list of parameters to pass to the server executable or Realtime script on launch. Length Constraints: Minimum length of 1. Maximum length of 1024. Pattern: [A-Za-z0-9_:.+/\\- =@{},?\'[]"]+\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-serverprocess.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    server_process_property = gamelift.CfnFleet.ServerProcessProperty(\n        concurrent_executions=123,\n        launch_path="launchPath",\n\n        # the properties below are optional\n        parameters="parameters"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['concurrent_executions', 'launch_path', 'parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.ServerProcessProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleet.TargetConfigurationProperty
class CfnFleet_TargetConfigurationPropertyDef(BaseStruct):
    target_value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description="Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-fleet-targetconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    target_configuration_property = gamelift.CfnFleet.TargetConfigurationProperty(\n        target_value=123\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['target_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet.TargetConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameServerGroup.AutoScalingPolicyProperty
class CfnGameServerGroup_AutoScalingPolicyPropertyDef(BaseStruct):
    target_tracking_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_gamelift.CfnGameServerGroup_TargetTrackingConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Settings for a target-based scaling policy applied to Auto Scaling group. These settings are used to create a target-based policy that tracks the GameLift FleetIQ metric ``PercentUtilizedGameServers`` and specifies a target value for the metric. As player usage changes, the policy triggers to adjust the game server group capacity so that the metric returns to the target value.\n')
    estimated_instance_warmup: typing.Union[int, float, None] = pydantic.Field(None, description='Length of time, in seconds, it takes for a new instance to start new game server processes and register with Amazon GameLift FleetIQ. Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up, because it avoids prematurely starting new instances.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-gameservergroup-autoscalingpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    auto_scaling_policy_property = gamelift.CfnGameServerGroup.AutoScalingPolicyProperty(\n        target_tracking_configuration=gamelift.CfnGameServerGroup.TargetTrackingConfigurationProperty(\n            target_value=123\n        ),\n\n        # the properties below are optional\n        estimated_instance_warmup=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target_tracking_configuration', 'estimated_instance_warmup']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameServerGroup.AutoScalingPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameServerGroup.InstanceDefinitionProperty
class CfnGameServerGroup_InstanceDefinitionPropertyDef(BaseStruct):
    instance_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An Amazon EC2 instance type designation.\n')
    weighted_capacity: typing.Optional[str] = pydantic.Field(None, description='Instance weighting that indicates how much this instance type contributes to the total capacity of a game server group. Instance weights are used by Amazon GameLift FleetIQ to calculate the instance type\'s cost per unit hour and better identify the most cost-effective options. For detailed information on weighting instance capacity, see `Instance Weighting <https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-weighting.html>`_ in the *Amazon Elastic Compute Cloud Auto Scaling User Guide* . Default value is "1".\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-gameservergroup-instancedefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    instance_definition_property = gamelift.CfnGameServerGroup.InstanceDefinitionProperty(\n        instance_type="instanceType",\n\n        # the properties below are optional\n        weighted_capacity="weightedCapacity"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_type', 'weighted_capacity']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameServerGroup.InstanceDefinitionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameServerGroup.LaunchTemplateProperty
class CfnGameServerGroup_LaunchTemplatePropertyDef(BaseStruct):
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for an existing Amazon EC2 launch template.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='A readable identifier for an existing Amazon EC2 launch template.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The version of the Amazon EC2 launch template to use. If no version is specified, the default version will be used. With Amazon EC2, you can specify a default version for a launch template. If none is set, the default is the first version created.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-gameservergroup-launchtemplate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    launch_template_property = gamelift.CfnGameServerGroup.LaunchTemplateProperty(\n        launch_template_id="launchTemplateId",\n        launch_template_name="launchTemplateName",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_id', 'launch_template_name', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameServerGroup.LaunchTemplateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameServerGroup.TargetTrackingConfigurationProperty
class CfnGameServerGroup_TargetTrackingConfigurationPropertyDef(BaseStruct):
    target_value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Desired value to use with a game server group target-based scaling policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-gameservergroup-targettrackingconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    target_tracking_configuration_property = gamelift.CfnGameServerGroup.TargetTrackingConfigurationProperty(\n        target_value=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameServerGroup.TargetTrackingConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameSessionQueue.DestinationProperty
class CfnGameSessionQueue_DestinationPropertyDef(BaseStruct):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['destination_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameSessionQueue.DestinationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameSessionQueue.FilterConfigurationProperty
class CfnGameSessionQueue_FilterConfigurationPropertyDef(BaseStruct):
    allowed_locations: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of locations to allow game session placement in, in the form of AWS Region codes such as ``us-west-2`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-gamesessionqueue-filterconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    filter_configuration_property = gamelift.CfnGameSessionQueue.FilterConfigurationProperty(\n        allowed_locations=["allowedLocations"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_locations']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameSessionQueue.FilterConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameSessionQueue.GameSessionQueueDestinationProperty
class CfnGameSessionQueue_GameSessionQueueDestinationPropertyDef(BaseStruct):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) that is assigned to fleet or fleet alias. ARNs, which include a fleet ID or alias ID and a Region name, provide a unique identifier across all Regions.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-gamesessionqueue-gamesessionqueuedestination.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    game_session_queue_destination_property = gamelift.CfnGameSessionQueue.GameSessionQueueDestinationProperty(\n        destination_arn="destinationArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameSessionQueue.GameSessionQueueDestinationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameSessionQueue.PlayerLatencyPolicyProperty
class CfnGameSessionQueue_PlayerLatencyPolicyPropertyDef(BaseStruct):
    maximum_individual_player_latency_milliseconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.\n')
    policy_duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The length of time, in seconds, that the policy is enforced while placing a new game session. A null value for this property means that the policy is enforced until the queue times out.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-gamesessionqueue-playerlatencypolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    player_latency_policy_property = gamelift.CfnGameSessionQueue.PlayerLatencyPolicyProperty(\n        maximum_individual_player_latency_milliseconds=123,\n        policy_duration_seconds=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['maximum_individual_player_latency_milliseconds', 'policy_duration_seconds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameSessionQueue.PlayerLatencyPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameSessionQueue.PriorityConfigurationProperty
class CfnGameSessionQueue_PriorityConfigurationPropertyDef(BaseStruct):
    location_order: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The prioritization order to use for fleet locations, when the ``PriorityOrder`` property includes ``LOCATION`` . Locations are identified by AWS Region codes such as ``us-west-2`` . Each location can only be listed once.\n')
    priority_order: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The recommended sequence to use when prioritizing where to place new game sessions. Each type can only be listed once. - ``LATENCY`` -- FleetIQ prioritizes locations where the average player latency (provided in each game session request) is lowest. - ``COST`` -- FleetIQ prioritizes destinations with the lowest current hosting costs. Cost is evaluated based on the location, instance type, and fleet type (Spot or On-Demand) for each destination in the queue. - ``DESTINATION`` -- FleetIQ prioritizes based on the order that destinations are listed in the queue configuration. - ``LOCATION`` -- FleetIQ prioritizes based on the provided order of locations, as defined in ``LocationOrder`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-gamesessionqueue-priorityconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    priority_configuration_property = gamelift.CfnGameSessionQueue.PriorityConfigurationProperty(\n        location_order=["locationOrder"],\n        priority_order=["priorityOrder"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['location_order', 'priority_order']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameSessionQueue.PriorityConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnMatchmakingConfiguration.GamePropertyProperty
class CfnMatchmakingConfiguration_GamePropertyPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The game property identifier.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The game property value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-matchmakingconfiguration-gameproperty.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    game_property_property = gamelift.CfnMatchmakingConfiguration.GamePropertyProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnMatchmakingConfiguration.GamePropertyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnScript.S3LocationProperty
class CfnScript_S3LocationPropertyDef(BaseStruct):
    bucket: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="An Amazon S3 bucket identifier. Thename of the S3 bucket. .. epigraph:: Amazon GameLift doesn't support uploading from Amazon S3 buckets with names that contain a dot (.).\n")
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the zip file that contains the build files or script files.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name ( `ARN <https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html>`_ ) for an IAM role that allows Amazon GameLift to access the S3 bucket.\n')
    object_version: typing.Optional[str] = pydantic.Field(None, description='The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from an S3 bucket that you own. Use this parameter to specify a specific version of the file. If not set, the latest version of the file is retrieved.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gamelift-script-s3location.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    s3_location_property = gamelift.CfnScript.S3LocationProperty(\n        bucket="bucket",\n        key="key",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        object_version="objectVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'key', 'role_arn', 'object_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnScript.S3LocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnAlias
class CfnAliasDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive label that is associated with an alias. Alias names do not need to be unique.\n')
    routing_strategy: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_gamelift.CfnAlias_RoutingStrategyPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The routing configuration, including routing type and fleet target, for the alias.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A human-readable description of the alias.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'routing_strategy', 'description']
    _method_names: typing.ClassVar[list[str]] = ['RoutingStrategyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnAlias'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnAliasDefConfig] = pydantic.Field(None)


class CfnAliasDefConfig(pydantic.BaseModel):
    RoutingStrategyProperty: typing.Optional[list[models.aws_gamelift.CfnAliasDefRoutingstrategypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnAliasDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnAliasDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnAliasDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnAliasDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnAliasDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnAliasDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnAliasDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnAliasDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnAliasDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnAliasDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnAliasDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnAliasDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnAliasDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAliasDefRoutingstrategypropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    fleet_id: typing.Optional[str] = pydantic.Field(None, description='')
    message: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAliasDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAliasDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAliasDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAliasDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAliasDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAliasDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAliasDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAliasDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAliasDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAliasDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAliasDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAliasDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAliasDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAliasDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnBuild
class CfnBuildDef(BaseCfnResource):
    name: typing.Optional[str] = pydantic.Field(None, description='A descriptive label that is associated with a build. Build names do not need to be unique.\n')
    operating_system: typing.Optional[str] = pydantic.Field(None, description="The operating system that your game server binaries run on. This value determines the type of fleet resources that you use for this build. If your game build contains multiple executables, they all must run on the same operating system. You must specify a valid operating system in this request. There is no default value. You can't change a build's operating system later. .. epigraph:: Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the `Amazon Linux 2 FAQs <https://docs.aws.amazon.com/https://aws.amazon.com/amazon-linux-2/faqs/>`_ . For game servers that are hosted on AL2 and use Amazon GameLift server SDK 4.x., first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See `Migrate to Amazon GameLift server SDK version 5. <https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html>`_\n")
    server_sdk_version: typing.Optional[str] = pydantic.Field(None, description='A server SDK version you used when integrating your game server build with Amazon GameLift. For more information see `Integrate games with custom game servers <https://docs.aws.amazon.com/gamelift/latest/developerguide/integration-custom-intro.html>`_ . By default Amazon GameLift sets this value to ``4.0.2`` .\n')
    storage_location: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnBuild_StorageLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information indicating where your game build files are stored. Use this parameter only when creating a build with files stored in an Amazon S3 bucket that you own. The storage location must specify an Amazon S3 bucket name and key. The location must also specify a role ARN that you set up to allow Amazon GameLift to access your Amazon S3 bucket. The S3 bucket and your new build must be in the same Region. If a ``StorageLocation`` is specified, the size of your file can be found in your Amazon S3 bucket. Amazon GameLift will report a ``SizeOnDisk`` of 0.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='Version information that is associated with this build. Version strings do not need to be unique.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'operating_system', 'server_sdk_version', 'storage_location', 'version']
    _method_names: typing.ClassVar[list[str]] = ['StorageLocationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnBuild'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnBuildDefConfig] = pydantic.Field(None)


class CfnBuildDefConfig(pydantic.BaseModel):
    StorageLocationProperty: typing.Optional[list[models.aws_gamelift.CfnBuildDefStoragelocationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnBuildDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnBuildDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnBuildDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnBuildDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnBuildDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnBuildDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnBuildDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnBuildDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnBuildDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnBuildDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnBuildDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnBuildDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnBuildDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnBuildDefStoragelocationpropertyParams(pydantic.BaseModel):
    bucket: str = pydantic.Field(..., description='')
    key: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    object_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnBuildDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnBuildDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBuildDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnBuildDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBuildDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnBuildDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnBuildDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnBuildDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnBuildDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnBuildDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBuildDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnBuildDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnBuildDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBuildDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinition
class CfnContainerGroupDefinitionDef(BaseCfnResource):
    container_definitions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerDefinitionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The set of container definitions that are included in the container group.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive identifier for the container group definition. The name value is unique in an AWS Region.\n')
    operating_system: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The platform required for all containers in the container group definition. .. epigraph:: Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the `Amazon Linux 2 FAQs <https://docs.aws.amazon.com/https://aws.amazon.com/amazon-linux-2/faqs/>`_ . For game servers that are hosted on AL2 and use Amazon GameLift server SDK 4.x., first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See `Migrate to Amazon GameLift server SDK version 5. <https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html>`_\n')
    total_cpu_limit: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of CPU units on a fleet instance to allocate for the container group. All containers in the group share these resources. This property is an integer value in CPU units (1 vCPU is equal to 1024 CPU units). You can set additional limits for each ``ContainerDefinition`` in the group. If individual containers have limits, this value must be equal to or greater than the sum of all container-specific CPU limits in the group. For more details on memory allocation, see the `Container fleet design guide <https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet>`_ .\n')
    total_memory_limit: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of memory (in MiB) on a fleet instance to allocate for the container group. All containers in the group share these resources. You can set additional limits for each ``ContainerDefinition`` in the group. If individual containers have limits, this value must meet the following requirements: - Equal to or greater than the sum of all container-specific soft memory limits in the group. - Equal to or greater than any container-specific hard limits in the group. For more details on memory allocation, see the `Container fleet design guide <https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet>`_ .\n')
    scheduling_strategy: typing.Optional[str] = pydantic.Field(None, description='The method for deploying the container group across fleet instances. A replica container group might have multiple copies on each fleet instance. A daemon container group maintains only one copy per fleet instance.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['container_definitions', 'name', 'operating_system', 'total_cpu_limit', 'total_memory_limit', 'scheduling_strategy', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ContainerDefinitionProperty', 'ContainerDependencyProperty', 'ContainerEnvironmentProperty', 'ContainerHealthCheckProperty', 'ContainerPortRangeProperty', 'MemoryLimitsProperty', 'PortConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnContainerGroupDefinitionDefConfig] = pydantic.Field(None)


class CfnContainerGroupDefinitionDefConfig(pydantic.BaseModel):
    ContainerDefinitionProperty: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefContainerdefinitionpropertyParams]] = pydantic.Field(None, description='')
    ContainerDependencyProperty: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefContainerdependencypropertyParams]] = pydantic.Field(None, description='')
    ContainerEnvironmentProperty: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefContainerenvironmentpropertyParams]] = pydantic.Field(None, description='')
    ContainerHealthCheckProperty: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefContainerhealthcheckpropertyParams]] = pydantic.Field(None, description='')
    ContainerPortRangeProperty: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefContainerportrangepropertyParams]] = pydantic.Field(None, description='')
    MemoryLimitsProperty: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefMemorylimitspropertyParams]] = pydantic.Field(None, description='')
    PortConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefPortconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnContainerGroupDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnContainerGroupDefinitionDefContainerdefinitionpropertyParams(pydantic.BaseModel):
    container_name: str = pydantic.Field(..., description='')
    image_uri: str = pydantic.Field(..., description='')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='')
    depends_on: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerDependencyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    entry_point: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    environment: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerEnvironmentPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    essential: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    health_check: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerHealthCheckPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    memory_limits: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_MemoryLimitsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    port_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_PortConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    resolved_image_digest: typing.Optional[str] = pydantic.Field(None, description='')
    working_directory: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnContainerGroupDefinitionDefContainerdependencypropertyParams(pydantic.BaseModel):
    condition: str = pydantic.Field(..., description='')
    container_name: str = pydantic.Field(..., description='')
    ...

class CfnContainerGroupDefinitionDefContainerenvironmentpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnContainerGroupDefinitionDefContainerhealthcheckpropertyParams(pydantic.BaseModel):
    command: typing.Sequence[str] = pydantic.Field(..., description='')
    interval: typing.Union[int, float, None] = pydantic.Field(None, description='')
    retries: typing.Union[int, float, None] = pydantic.Field(None, description='')
    start_period: typing.Union[int, float, None] = pydantic.Field(None, description='')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnContainerGroupDefinitionDefContainerportrangepropertyParams(pydantic.BaseModel):
    from_port: typing.Union[int, float] = pydantic.Field(..., description='')
    protocol: str = pydantic.Field(..., description='')
    to_port: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnContainerGroupDefinitionDefMemorylimitspropertyParams(pydantic.BaseModel):
    hard_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    soft_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnContainerGroupDefinitionDefPortconfigurationpropertyParams(pydantic.BaseModel):
    container_port_ranges: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerPortRangePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnContainerGroupDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnContainerGroupDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContainerGroupDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnContainerGroupDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContainerGroupDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnContainerGroupDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnContainerGroupDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnContainerGroupDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnContainerGroupDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnContainerGroupDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContainerGroupDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnContainerGroupDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnContainerGroupDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContainerGroupDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnFleet
class CfnFleetDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive label that is associated with a fleet. Fleet names do not need to be unique.\n')
    anywhere_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_AnywhereConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Amazon GameLift Anywhere configuration options.\n')
    apply_capacity: typing.Optional[str] = pydantic.Field(None, description="Current resource capacity settings for managed EC2 fleets and container fleets. For multi-location fleets, location values might refer to a fleet's remote location or its home Region. *Returned by:* `DescribeFleetCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetCapacity.html>`_ , `DescribeFleetLocationCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetLocationCapacity.html>`_ , `UpdateFleetCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateFleetCapacity.html>`_\n")
    build_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for a build to be deployed on the new fleet. If you are deploying the fleet with a custom game build, you must specify this property. The build must have been successfully uploaded to Amazon GameLift and be in a ``READY`` status. This fleet setting cannot be changed once the fleet is created.\n')
    certificate_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_CertificateConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Prompts Amazon GameLift to generate a TLS/SSL certificate for the fleet. Amazon GameLift uses the certificates to encrypt traffic between game clients and the game servers running on Amazon GameLift. By default, the ``CertificateConfiguration`` is ``DISABLED`` . You can't change this property after you create the fleet. AWS Certificate Manager (ACM) certificates expire after 13 months. Certificate expiration can cause fleets to fail, preventing players from connecting to instances in the fleet. We recommend you replace fleets before 13 months, consider using fleet aliases for a smooth transition. .. epigraph:: ACM isn't available in all AWS regions. A fleet creation request with certificate generation enabled in an unsupported Region, fails with a 4xx error. For more information about the supported Regions, see `Supported Regions <https://docs.aws.amazon.com/acm/latest/userguide/acm-regions.html>`_ in the *AWS Certificate Manager User Guide* .\n")
    compute_type: typing.Optional[str] = pydantic.Field(None, description='The type of compute resource used to host your game servers. - ``EC2``  The game server build is deployed to Amazon EC2 instances for cloud hosting. This is the default setting. - ``CONTAINER``  Container images with your game server build and supporting software are deployed to Amazon EC2 instances for cloud hosting. With this compute type, you must specify the ``ContainerGroupsConfiguration`` parameter. - ``ANYWHERE``  Game servers or container images with your game server and supporting software are deployed to compute resources that are provided and managed by you. With this compute type, you can also set the ``AnywhereConfiguration`` parameter.\n')
    container_groups_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ContainerGroupsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='*This data type is used with the Amazon GameLift containers feature, which is currently in public preview.*. Configuration details for a set of container groups, for use when creating a fleet with compute type ``CONTAINER`` . *Used with:* ``CreateFleet``\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the fleet.\n')
    desired_ec2_instances: typing.Union[int, float, None] = pydantic.Field(None, description='The number of EC2 instances that you want this fleet to host. When creating a new fleet, GameLift automatically sets this value to "1" and initiates a single instance. Once the fleet is active, update this value to trigger GameLift to add or remove instances from the fleet.\n')
    ec2_inbound_permissions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_IpPermissionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The IP address ranges and port settings that allow inbound traffic to access game server processes and other processes on this fleet. Set this parameter for EC2 and container fleets. You can leave this parameter empty when creating the fleet, but you must call ``UpdateFleetPortSettings`` to set it before players can connect to game sessions. As a best practice, we recommend opening ports for remote access only when you need them and closing them when you're finished. For Realtime Servers fleets, Amazon GameLift automatically sets TCP and UDP ranges. To manage inbound access for a container fleet, set this parameter to the same port numbers that you set for the fleet's connection port range. During the life of the fleet, update this parameter to control which connection ports are open to inbound traffic.\n")
    ec2_instance_type: typing.Optional[str] = pydantic.Field(None, description='The Amazon GameLift-supported Amazon EC2 instance type to use with EC2 and container fleets. Instance type determines the computing resources that will be used to host your game servers, including CPU, memory, storage, and networking capacity. See `Amazon Elastic Compute Cloud Instance Types <https://docs.aws.amazon.com/ec2/instance-types/>`_ for detailed descriptions of Amazon EC2 instance types.\n')
    fleet_type: typing.Optional[str] = pydantic.Field(None, description="Indicates whether to use On-Demand or Spot instances for this fleet. By default, this property is set to ``ON_DEMAND`` . Learn more about when to use `On-Demand versus Spot Instances <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-ec2-instances.html#gamelift-ec2-instances-spot>`_ . This fleet property can't be changed after the fleet is created.\n")
    instance_role_arn: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for an IAM role with access permissions to other AWS services. Any application that runs on an instance in the fleet--including install scripts, server processes, and other processes--can use these permissions to interact with AWS resources that you own or have access to. For more information about using the role with your game server builds, see `Communicate with other AWS resources from your fleets <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-resources.html>`_ . This attribute is used with fleets where ``ComputeType`` is "EC2" or "Container".\n')
    instance_role_credentials_provider: typing.Optional[str] = pydantic.Field(None, description='Indicates that fleet instances maintain a shared credentials file for the IAM role defined in ``InstanceRoleArn`` . Shared credentials allow applications that are deployed with the game server executable to communicate with other AWS resources. This property is used only when the game server is integrated with the server SDK version 5.x. For more information about using shared credentials, see `Communicate with other AWS resources from your fleets <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-resources.html>`_ . This attribute is used with fleets where ``ComputeType`` is "EC2" or "Container".\n')
    locations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_LocationConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="A set of remote locations to deploy additional instances to and manage as part of the fleet. This parameter can only be used when creating fleets in AWS Regions that support multiple locations. You can add any Amazon GameLift-supported AWS Region as a remote location, in the form of an AWS Region code, such as ``us-west-2`` or Local Zone code. To create a fleet with instances in the home Region only, don't set this parameter. When using this parameter, Amazon GameLift requires you to include your home location in the request.\n")
    log_paths: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(deprecated) This parameter is no longer used. When hosting a custom game build, specify where Amazon GameLift should store log files using the Amazon GameLift server API call ProcessReady()\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of instances that are allowed in the specified fleet location. If this parameter is not set, the default is 1.\n')
    metric_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of an AWS CloudWatch metric group to add this fleet to. A metric group is used to aggregate the metrics for multiple fleets. You can specify an existing metric group name or set a new name to create a new metric group. A fleet can be included in only one metric group at a time.\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of instances that are allowed in the specified fleet location. If this parameter is not set, the default is 0.\n')
    new_game_session_protection_policy: typing.Optional[str] = pydantic.Field(None, description='The status of termination protection for active game sessions on the fleet. By default, this property is set to ``NoProtection`` . - *NoProtection* - Game sessions can be terminated during active gameplay as a result of a scale-down event. - *FullProtection* - Game sessions in ``ACTIVE`` status cannot be terminated during a scale-down event.\n')
    peer_vpc_aws_account_id: typing.Optional[str] = pydantic.Field(None, description='Used when peering your Amazon GameLift fleet with a VPC, the unique identifier for the AWS account that owns the VPC. You can find your account ID in the AWS Management Console under account settings.\n')
    peer_vpc_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for a VPC with resources to be accessed by your Amazon GameLift fleet. The VPC must be in the same Region as your fleet. To look up a VPC ID, use the `VPC Dashboard <https://docs.aws.amazon.com/vpc/>`_ in the AWS Management Console . Learn more about VPC peering in `VPC Peering with Amazon GameLift Fleets <https://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html>`_ .\n')
    resource_creation_limit_policy: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ResourceCreationLimitPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A policy that limits the number of game sessions that an individual player can create on instances in this fleet within a specified span of time.\n')
    runtime_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_RuntimeConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Instructions for how to launch and maintain server processes on instances in the fleet. The runtime configuration defines one or more server process configurations, each identifying a build executable or Realtime script file and the number of processes of that type to run concurrently. .. epigraph:: The ``RuntimeConfiguration`` parameter is required unless the fleet is being configured using the older parameters ``ServerLaunchPath`` and ``ServerLaunchParameters`` , which are still supported for backward compatibility.\n')
    scaling_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ScalingPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.\n')
    script_id: typing.Optional[str] = pydantic.Field(None, description="The unique identifier for a Realtime configuration script to be deployed on fleet instances. You can use either the script ID or ARN. Scripts must be uploaded to Amazon GameLift prior to creating the fleet. This fleet property cannot be changed later. .. epigraph:: You can't use the ``!Ref`` command to reference a script created with a CloudFormation template for the fleet property ``ScriptId`` . Instead, use ``Fn::GetAtt Script.Arn`` or ``Fn::GetAtt Script.Id`` to retrieve either of these properties as input for ``ScriptId`` . Alternatively, enter a ``ScriptId`` string manually.\n")
    server_launch_parameters: typing.Optional[str] = pydantic.Field(None, description='(deprecated) This parameter is no longer used but is retained for backward compatibility. Instead, specify server launch parameters in the RuntimeConfiguration parameter. A request must specify either a runtime configuration or values for both ServerLaunchParameters and ServerLaunchPath.\n')
    server_launch_path: typing.Optional[str] = pydantic.Field(None, description='(deprecated) This parameter is no longer used. Instead, specify a server launch path using the RuntimeConfiguration parameter. Requests that specify a server launch path and launch parameters instead of a runtime configuration will continue to work.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'anywhere_configuration', 'apply_capacity', 'build_id', 'certificate_configuration', 'compute_type', 'container_groups_configuration', 'description', 'desired_ec2_instances', 'ec2_inbound_permissions', 'ec2_instance_type', 'fleet_type', 'instance_role_arn', 'instance_role_credentials_provider', 'locations', 'log_paths', 'max_size', 'metric_groups', 'min_size', 'new_game_session_protection_policy', 'peer_vpc_aws_account_id', 'peer_vpc_id', 'resource_creation_limit_policy', 'runtime_configuration', 'scaling_policies', 'script_id', 'server_launch_parameters', 'server_launch_path']
    _method_names: typing.ClassVar[list[str]] = ['AnywhereConfigurationProperty', 'CertificateConfigurationProperty', 'ConnectionPortRangeProperty', 'ContainerGroupsConfigurationProperty', 'ContainerGroupsPerInstanceProperty', 'IpPermissionProperty', 'LocationCapacityProperty', 'LocationConfigurationProperty', 'ResourceCreationLimitPolicyProperty', 'RuntimeConfigurationProperty', 'ScalingPolicyProperty', 'ServerProcessProperty', 'TargetConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnFleetDefConfig] = pydantic.Field(None)


class CfnFleetDefConfig(pydantic.BaseModel):
    AnywhereConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefAnywhereconfigurationpropertyParams]] = pydantic.Field(None, description='')
    CertificateConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefCertificateconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ConnectionPortRangeProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefConnectionportrangepropertyParams]] = pydantic.Field(None, description='')
    ContainerGroupsConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefContainergroupsconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ContainerGroupsPerInstanceProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefContainergroupsperinstancepropertyParams]] = pydantic.Field(None, description='')
    IpPermissionProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefIppermissionpropertyParams]] = pydantic.Field(None, description='')
    LocationCapacityProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefLocationcapacitypropertyParams]] = pydantic.Field(None, description='')
    LocationConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefLocationconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ResourceCreationLimitPolicyProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefResourcecreationlimitpolicypropertyParams]] = pydantic.Field(None, description='')
    RuntimeConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefRuntimeconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ScalingPolicyProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefScalingpolicypropertyParams]] = pydantic.Field(None, description='')
    ServerProcessProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefServerprocesspropertyParams]] = pydantic.Field(None, description='')
    TargetConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnFleetDefTargetconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnFleetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnFleetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnFleetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnFleetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnFleetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnFleetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnFleetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnFleetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnFleetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnFleetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnFleetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnFleetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnFleetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnFleetDefAnywhereconfigurationpropertyParams(pydantic.BaseModel):
    cost: str = pydantic.Field(..., description='')
    ...

class CfnFleetDefCertificateconfigurationpropertyParams(pydantic.BaseModel):
    certificate_type: str = pydantic.Field(..., description='')
    ...

class CfnFleetDefConnectionportrangepropertyParams(pydantic.BaseModel):
    from_port: typing.Union[int, float] = pydantic.Field(..., description='')
    to_port: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnFleetDefContainergroupsconfigurationpropertyParams(pydantic.BaseModel):
    connection_port_range: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ConnectionPortRangePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    container_group_definition_names: typing.Sequence[str] = pydantic.Field(..., description='')
    container_groups_per_instance: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ContainerGroupsPerInstancePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnFleetDefContainergroupsperinstancepropertyParams(pydantic.BaseModel):
    desired_replica_container_groups_per_instance: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_replica_container_groups_per_instance: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnFleetDefIppermissionpropertyParams(pydantic.BaseModel):
    from_port: typing.Union[int, float] = pydantic.Field(..., description='')
    ip_range: str = pydantic.Field(..., description='')
    protocol: str = pydantic.Field(..., description='')
    to_port: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnFleetDefLocationcapacitypropertyParams(pydantic.BaseModel):
    desired_ec2_instances: typing.Union[int, float] = pydantic.Field(..., description='')
    max_size: typing.Union[int, float] = pydantic.Field(..., description='')
    min_size: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnFleetDefLocationconfigurationpropertyParams(pydantic.BaseModel):
    location: str = pydantic.Field(..., description='')
    location_capacity: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_LocationCapacityPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnFleetDefResourcecreationlimitpolicypropertyParams(pydantic.BaseModel):
    new_game_sessions_per_creator: typing.Union[int, float, None] = pydantic.Field(None, description='')
    policy_period_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnFleetDefRuntimeconfigurationpropertyParams(pydantic.BaseModel):
    game_session_activation_timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_concurrent_game_session_activations: typing.Union[int, float, None] = pydantic.Field(None, description='')
    server_processes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ServerProcessPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnFleetDefScalingpolicypropertyParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    comparison_operator: typing.Optional[str] = pydantic.Field(None, description='')
    evaluation_periods: typing.Union[int, float, None] = pydantic.Field(None, description='')
    location: typing.Optional[str] = pydantic.Field(None, description='')
    policy_type: typing.Optional[str] = pydantic.Field(None, description='')
    scaling_adjustment: typing.Union[int, float, None] = pydantic.Field(None, description='')
    scaling_adjustment_type: typing.Optional[str] = pydantic.Field(None, description='')
    status: typing.Optional[str] = pydantic.Field(None, description='')
    target_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_TargetConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    threshold: typing.Union[int, float, None] = pydantic.Field(None, description='')
    update_status: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFleetDefServerprocesspropertyParams(pydantic.BaseModel):
    concurrent_executions: typing.Union[int, float] = pydantic.Field(..., description='')
    launch_path: str = pydantic.Field(..., description='')
    parameters: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFleetDefTargetconfigurationpropertyParams(pydantic.BaseModel):
    target_value: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnFleetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFleetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFleetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFleetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFleetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFleetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFleetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFleetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFleetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFleetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFleetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnFleetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFleetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFleetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnGameServerGroup
class CfnGameServerGroupDef(BaseCfnResource):
    game_server_group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A developer-defined identifier for the game server group. The name is unique for each Region in each AWS account.\n')
    instance_definitions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameServerGroup_InstanceDefinitionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The set of Amazon EC2 instance types that Amazon GameLift FleetIQ can use when balancing and automatically scaling instances in the corresponding Auto Scaling group.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name ( `ARN <https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html>`_ ) for an IAM role that allows Amazon GameLift to access your Amazon EC2 Auto Scaling groups.\n')
    auto_scaling_policy: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameServerGroup_AutoScalingPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting. The scaling policy uses the metric ``"PercentUtilizedGameServers"`` to maintain a buffer of idle game servers that can immediately accommodate new games and players. After the Auto Scaling group is created, update this value directly in the Auto Scaling group using the AWS console or APIs.\n')
    balancing_strategy: typing.Optional[str] = pydantic.Field(None, description='Indicates how Amazon GameLift FleetIQ balances the use of Spot Instances and On-Demand Instances in the game server group. Method options include the following: - ``SPOT_ONLY`` - Only Spot Instances are used in the game server group. If Spot Instances are unavailable or not viable for game hosting, the game server group provides no hosting capacity until Spot Instances can again be used. Until then, no new instances are started, and the existing nonviable Spot Instances are terminated (after current gameplay ends) and are not replaced. - ``SPOT_PREFERRED`` - (default value) Spot Instances are used whenever available in the game server group. If Spot Instances are unavailable, the game server group continues to provide hosting capacity by falling back to On-Demand Instances. Existing nonviable Spot Instances are terminated (after current gameplay ends) and are replaced with new On-Demand Instances. - ``ON_DEMAND_ONLY`` - Only On-Demand Instances are used in the game server group. No Spot Instances are used, even when available, while this balancing strategy is in force.\n')
    delete_option: typing.Optional[str] = pydantic.Field(None, description='The type of delete to perform. To delete a game server group, specify the ``DeleteOption`` . Options include the following: - ``SAFE_DELETE``  (default) Terminates the game server group and Amazon EC2 Auto Scaling group only when it has no game servers that are in ``UTILIZED`` status. - ``FORCE_DELETE``  Terminates the game server group, including all active game servers regardless of their utilization status, and the Amazon EC2 Auto Scaling group. - ``RETAIN``  Does a safe delete of the game server group but retains the Amazon EC2 Auto Scaling group as is.\n')
    game_server_protection_policy: typing.Optional[str] = pydantic.Field(None, description='A flag that indicates whether instances in the game server group are protected from early termination. Unprotected instances that have active game servers running might be terminated during a scale-down event, causing players to be dropped from the game. Protected instances cannot be terminated while there are active game servers running except in the event of a forced game server group deletion (see ). An exception to this is with Spot Instances, which can be terminated by AWS regardless of protection status.\n')
    launch_template: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameServerGroup_LaunchTemplatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Amazon EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group. You can specify the template using either the template name or ID. For help with creating a launch template, see `Creating a Launch Template for an Auto Scaling Group <https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html>`_ in the *Amazon Elastic Compute Cloud Auto Scaling User Guide* . After the Auto Scaling group is created, update this value directly in the Auto Scaling group using the AWS console or APIs. .. epigraph:: If you specify network interfaces in your launch template, you must explicitly set the property ``AssociatePublicIpAddress`` to "true". If no network interface is specified in the launch template, Amazon GameLift FleetIQ uses your account\'s default VPC.\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of instances allowed in the Amazon EC2 Auto Scaling group. During automatic scaling events, Amazon GameLift FleetIQ and EC2 do not scale up the group above this maximum. After the Auto Scaling group is created, update this value directly in the Auto Scaling group using the AWS console or APIs.\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of instances allowed in the Amazon EC2 Auto Scaling group. During automatic scaling events, Amazon GameLift FleetIQ and Amazon EC2 do not scale down the group below this minimum. In production, this value should be set to at least 1. After the Auto Scaling group is created, update this value directly in the Auto Scaling group using the AWS console or APIs.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new game server group resource. Tags are developer-defined key-value pairs. Tagging AWS resources is useful for resource management, access management, and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags, respectively. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.\n')
    vpc_subnets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="A list of virtual private cloud (VPC) subnets to use with instances in the game server group. By default, all Amazon GameLift FleetIQ-supported Availability Zones are used. You can use this parameter to specify VPCs that you've set up. This property cannot be updated after the game server group is created, and the corresponding Auto Scaling group will always use the property value that is set with this request, even if the Auto Scaling group is updated directly.")
    _init_params: typing.ClassVar[list[str]] = ['game_server_group_name', 'instance_definitions', 'role_arn', 'auto_scaling_policy', 'balancing_strategy', 'delete_option', 'game_server_protection_policy', 'launch_template', 'max_size', 'min_size', 'tags', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = ['AutoScalingPolicyProperty', 'InstanceDefinitionProperty', 'LaunchTemplateProperty', 'TargetTrackingConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameServerGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnGameServerGroupDefConfig] = pydantic.Field(None)


class CfnGameServerGroupDefConfig(pydantic.BaseModel):
    AutoScalingPolicyProperty: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefAutoscalingpolicypropertyParams]] = pydantic.Field(None, description='')
    InstanceDefinitionProperty: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefInstancedefinitionpropertyParams]] = pydantic.Field(None, description='')
    LaunchTemplateProperty: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefLaunchtemplatepropertyParams]] = pydantic.Field(None, description='')
    TargetTrackingConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefTargettrackingconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnGameServerGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnGameServerGroupDefAutoscalingpolicypropertyParams(pydantic.BaseModel):
    target_tracking_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameServerGroup_TargetTrackingConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    estimated_instance_warmup: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnGameServerGroupDefInstancedefinitionpropertyParams(pydantic.BaseModel):
    instance_type: str = pydantic.Field(..., description='')
    weighted_capacity: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGameServerGroupDefLaunchtemplatepropertyParams(pydantic.BaseModel):
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='')
    version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGameServerGroupDefTargettrackingconfigurationpropertyParams(pydantic.BaseModel):
    target_value: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnGameServerGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGameServerGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGameServerGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGameServerGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGameServerGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGameServerGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGameServerGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGameServerGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGameServerGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGameServerGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGameServerGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGameServerGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGameServerGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGameServerGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnGameSessionQueue
class CfnGameSessionQueueDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive label that is associated with game session queue. Queue names must be unique within each Region.\n')
    custom_event_data: typing.Optional[str] = pydantic.Field(None, description='Information to be added to all events that are related to this game session queue.\n')
    destinations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameSessionQueue_DestinationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of fleets and/or fleet aliases that can be used to fulfill game session placement requests in the queue. Destinations are identified by either a fleet ARN or a fleet alias ARN, and are listed in order of placement preference.\n')
    filter_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameSessionQueue_FilterConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A list of locations where a queue is allowed to place new game sessions. Locations are specified in the form of AWS Region codes, such as ``us-west-2`` . If this parameter is not set, game sessions can be placed in any queue location.\n')
    notification_target: typing.Optional[str] = pydantic.Field(None, description='An SNS topic ARN that is set up to receive game session placement notifications. See `Setting up notifications for game session placement <https://docs.aws.amazon.com/gamelift/latest/developerguide/queue-notification.html>`_ .\n')
    player_latency_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameSessionQueue_PlayerLatencyPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A set of policies that act as a sliding cap on player latency. FleetIQ works to deliver low latency for most players in a game session. These policies ensure that no individual player can be placed into a game with unreasonably high latency. Use multiple policies to gradually relax latency requirements a step at a time. Multiple policies are applied based on their maximum allowed latency, starting with the lowest value.\n')
    priority_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameSessionQueue_PriorityConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Custom settings to use when prioritizing destinations and locations for game session placements. This configuration replaces the FleetIQ default prioritization process. Priority types that are not explicitly named will be automatically applied at the end of the prioritization process.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new game session queue resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.\n')
    timeout_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time, in seconds, that a new game session placement request remains in the queue. When a request exceeds this time, the game session placement changes to a ``TIMED_OUT`` status. By default, this property is set to ``600`` .')
    _init_params: typing.ClassVar[list[str]] = ['name', 'custom_event_data', 'destinations', 'filter_configuration', 'notification_target', 'player_latency_policies', 'priority_configuration', 'tags', 'timeout_in_seconds']
    _method_names: typing.ClassVar[list[str]] = ['DestinationProperty', 'FilterConfigurationProperty', 'GameSessionQueueDestinationProperty', 'PlayerLatencyPolicyProperty', 'PriorityConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameSessionQueue'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnGameSessionQueueDefConfig] = pydantic.Field(None)


class CfnGameSessionQueueDefConfig(pydantic.BaseModel):
    DestinationProperty: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefDestinationpropertyParams]] = pydantic.Field(None, description='')
    FilterConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefFilterconfigurationpropertyParams]] = pydantic.Field(None, description='')
    GameSessionQueueDestinationProperty: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefGamesessionqueuedestinationpropertyParams]] = pydantic.Field(None, description='')
    PlayerLatencyPolicyProperty: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefPlayerlatencypolicypropertyParams]] = pydantic.Field(None, description='')
    PriorityConfigurationProperty: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefPriorityconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnGameSessionQueueDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnGameSessionQueueDefDestinationpropertyParams(pydantic.BaseModel):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGameSessionQueueDefFilterconfigurationpropertyParams(pydantic.BaseModel):
    allowed_locations: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnGameSessionQueueDefGamesessionqueuedestinationpropertyParams(pydantic.BaseModel):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGameSessionQueueDefPlayerlatencypolicypropertyParams(pydantic.BaseModel):
    maximum_individual_player_latency_milliseconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    policy_duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnGameSessionQueueDefPriorityconfigurationpropertyParams(pydantic.BaseModel):
    location_order: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    priority_order: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnGameSessionQueueDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGameSessionQueueDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGameSessionQueueDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGameSessionQueueDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGameSessionQueueDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGameSessionQueueDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGameSessionQueueDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGameSessionQueueDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGameSessionQueueDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGameSessionQueueDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGameSessionQueueDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGameSessionQueueDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGameSessionQueueDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGameSessionQueueDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnLocation
class CfnLocationDef(BaseCfnResource):
    location_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive name for the custom location.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Rareference* .')
    _init_params: typing.ClassVar[list[str]] = ['location_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnLocation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnLocationDefConfig] = pydantic.Field(None)


class CfnLocationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnLocationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnLocationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnLocationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnLocationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnLocationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnLocationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnLocationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnLocationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnLocationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnLocationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnLocationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnLocationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnLocationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnLocationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLocationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLocationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLocationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLocationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLocationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLocationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLocationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLocationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLocationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnMatchmakingConfiguration
class CfnMatchmakingConfigurationDef(BaseCfnResource):
    acceptance_required: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='A flag that determines whether a match that was created with this configuration must be accepted by the matched players. To require acceptance, set to ``TRUE`` . With this option enabled, matchmaking tickets use the status ``REQUIRES_ACCEPTANCE`` to indicate when a completed potential match is waiting for player acceptance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the matchmaking configuration. This name is used to identify the configuration associated with a matchmaking request or ticket.\n')
    request_timeout_seconds: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out. Requests that fail due to timing out can be resubmitted as needed.\n')
    rule_set_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN value. A matchmaking configuration can only use rule sets that are defined in the same Region.\n')
    acceptance_timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.\n')
    additional_player_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies a match for a single 10-person team, and the additional player count is set to 2, 10 players will be selected for the match and 2 more player slots will be open for future players. This parameter is not used if ``FlexMatchMode`` is set to ``STANDALONE`` .\n")
    backfill_mode: typing.Optional[str] = pydantic.Field(None, description='The method used to backfill game sessions that are created with this matchmaking configuration. Specify ``MANUAL`` when your game manages backfill requests manually or does not use the match backfill feature. Specify ``AUTOMATIC`` to have GameLift create a ``StartMatchBackfill`` request whenever a game session has one or more open slots. Learn more about manual and automatic backfill in `Backfill Existing Games with FlexMatch <https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html>`_ . Automatic backfill is not available when ``FlexMatchMode`` is set to ``STANDALONE`` .\n')
    creation_time: typing.Optional[str] = pydantic.Field(None, description='A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example ``"1469498468.057"`` ).\n')
    custom_event_data: typing.Optional[str] = pydantic.Field(None, description='Information to add to all events related to the matchmaking configuration.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the matchmaking configuration.\n')
    flex_match_mode: typing.Optional[str] = pydantic.Field(None, description='Indicates whether this matchmaking configuration is being used with Amazon GameLift hosting or as a standalone matchmaking solution. - *STANDALONE* - FlexMatch forms matches and returns match information, including players and team assignments, in a `MatchmakingSucceeded <https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded>`_ event. - *WITH_QUEUE* - FlexMatch forms matches and uses the specified Amazon GameLift queue to start a game session for the match.\n')
    game_properties: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnMatchmakingConfiguration_GamePropertyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A set of custom properties for a game session, formatted as key-value pairs. These properties are passed to a game server process with a request to start a new game session. See `Start a Game Session <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession>`_ . This parameter is not used if ``FlexMatchMode`` is set to ``STANDALONE`` .\n')
    game_session_data: typing.Optional[str] = pydantic.Field(None, description='A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session. See `Start a Game Session <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession>`_ . This parameter is not used if ``FlexMatchMode`` is set to ``STANDALONE`` .\n')
    game_session_queue_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Name ( `ARN <https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html>`_ ) that is assigned to a Amazon GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is ``arn:aws:gamelift:<region>::gamesessionqueue/<queue name>`` . Queues can be located in any Region. Queues are used to start new Amazon GameLift-hosted game sessions for matches that are created with this matchmaking configuration. If ``FlexMatchMode`` is set to ``STANDALONE`` , do not set this parameter.\n')
    notification_target: typing.Optional[str] = pydantic.Field(None, description='An SNS topic ARN that is set up to receive matchmaking notifications. See `Setting up notifications for matchmaking <https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html>`_ for more information.\n')
    rule_set_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name ( `ARN <https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html>`_ ) associated with the GameLift matchmaking rule set resource that this configuration uses.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.')
    _init_params: typing.ClassVar[list[str]] = ['acceptance_required', 'name', 'request_timeout_seconds', 'rule_set_name', 'acceptance_timeout_seconds', 'additional_player_count', 'backfill_mode', 'creation_time', 'custom_event_data', 'description', 'flex_match_mode', 'game_properties', 'game_session_data', 'game_session_queue_arns', 'notification_target', 'rule_set_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['GamePropertyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnMatchmakingConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnMatchmakingConfigurationDefConfig] = pydantic.Field(None)


class CfnMatchmakingConfigurationDefConfig(pydantic.BaseModel):
    GamePropertyProperty: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefGamepropertypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnMatchmakingConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnMatchmakingConfigurationDefGamepropertypropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnMatchmakingConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMatchmakingConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMatchmakingConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMatchmakingConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMatchmakingConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMatchmakingConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMatchmakingConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMatchmakingConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMatchmakingConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMatchmakingConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMatchmakingConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMatchmakingConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMatchmakingConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMatchmakingConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnMatchmakingRuleSet
class CfnMatchmakingRuleSetDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the matchmaking rule set. A matchmaking configuration identifies the rule set it uses by this name value. Note that the rule set name is different from the optional ``name`` field in the rule set body.\n')
    rule_set_body: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A collection of matchmaking rules, formatted as a JSON string. Comments are not allowed in JSON, but most elements support a description field.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new matchmaking rule set resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'rule_set_body', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnMatchmakingRuleSet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnMatchmakingRuleSetDefConfig] = pydantic.Field(None)


class CfnMatchmakingRuleSetDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnMatchmakingRuleSetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnMatchmakingRuleSetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMatchmakingRuleSetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMatchmakingRuleSetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMatchmakingRuleSetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMatchmakingRuleSetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMatchmakingRuleSetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMatchmakingRuleSetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMatchmakingRuleSetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMatchmakingRuleSetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMatchmakingRuleSetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMatchmakingRuleSetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMatchmakingRuleSetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMatchmakingRuleSetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMatchmakingRuleSetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnScript
class CfnScriptDef(BaseCfnResource):
    storage_location: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_gamelift.CfnScript_S3LocationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The location of the Amazon S3 bucket where a zipped file containing your Realtime scripts is stored. The storage location must specify the Amazon S3 bucket name, the zip file name (the "key"), and a role ARN that allows Amazon GameLift to access the Amazon S3 storage location. The S3 bucket must be in the same Region where you want to create a new script. By default, Amazon GameLift uploads the latest version of the zip file; if you have S3 object versioning turned on, you can use the ``ObjectVersion`` parameter to specify an earlier version.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A descriptive label that is associated with a script. Script names do not need to be unique.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new script resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The version that is associated with a build or script. Version strings do not need to be unique.')
    _init_params: typing.ClassVar[list[str]] = ['storage_location', 'name', 'tags', 'version']
    _method_names: typing.ClassVar[list[str]] = ['S3LocationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnScript'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_gamelift.CfnScriptDefConfig] = pydantic.Field(None)


class CfnScriptDefConfig(pydantic.BaseModel):
    S3LocationProperty: typing.Optional[list[models.aws_gamelift.CfnScriptDefS3LocationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_gamelift.CfnScriptDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_gamelift.CfnScriptDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_gamelift.CfnScriptDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_gamelift.CfnScriptDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_gamelift.CfnScriptDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_gamelift.CfnScriptDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_gamelift.CfnScriptDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_gamelift.CfnScriptDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_gamelift.CfnScriptDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_gamelift.CfnScriptDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_gamelift.CfnScriptDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_gamelift.CfnScriptDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_gamelift.CfnScriptDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnScriptDefS3LocationpropertyParams(pydantic.BaseModel):
    bucket: str = pydantic.Field(..., description='')
    key: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    object_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScriptDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnScriptDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScriptDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnScriptDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScriptDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnScriptDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnScriptDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnScriptDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnScriptDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnScriptDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScriptDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnScriptDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnScriptDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScriptDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_gamelift.CfnAliasProps
class CfnAliasPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive label that is associated with an alias. Alias names do not need to be unique.\n')
    routing_strategy: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_gamelift.CfnAlias_RoutingStrategyPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The routing configuration, including routing type and fleet target, for the alias.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A human-readable description of the alias.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-alias.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_alias_props = gamelift.CfnAliasProps(\n        name="name",\n        routing_strategy=gamelift.CfnAlias.RoutingStrategyProperty(\n            type="type",\n\n            # the properties below are optional\n            fleet_id="fleetId",\n            message="message"\n        ),\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'routing_strategy', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnAliasProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnBuildProps
class CfnBuildPropsDef(BaseCfnProperty):
    name: typing.Optional[str] = pydantic.Field(None, description='A descriptive label that is associated with a build. Build names do not need to be unique.\n')
    operating_system: typing.Optional[str] = pydantic.Field(None, description="The operating system that your game server binaries run on. This value determines the type of fleet resources that you use for this build. If your game build contains multiple executables, they all must run on the same operating system. You must specify a valid operating system in this request. There is no default value. You can't change a build's operating system later. .. epigraph:: Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the `Amazon Linux 2 FAQs <https://docs.aws.amazon.com/https://aws.amazon.com/amazon-linux-2/faqs/>`_ . For game servers that are hosted on AL2 and use Amazon GameLift server SDK 4.x., first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See `Migrate to Amazon GameLift server SDK version 5. <https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html>`_\n")
    server_sdk_version: typing.Optional[str] = pydantic.Field(None, description='A server SDK version you used when integrating your game server build with Amazon GameLift. For more information see `Integrate games with custom game servers <https://docs.aws.amazon.com/gamelift/latest/developerguide/integration-custom-intro.html>`_ . By default Amazon GameLift sets this value to ``4.0.2`` .\n')
    storage_location: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnBuild_StorageLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information indicating where your game build files are stored. Use this parameter only when creating a build with files stored in an Amazon S3 bucket that you own. The storage location must specify an Amazon S3 bucket name and key. The location must also specify a role ARN that you set up to allow Amazon GameLift to access your Amazon S3 bucket. The S3 bucket and your new build must be in the same Region. If a ``StorageLocation`` is specified, the size of your file can be found in your Amazon S3 bucket. Amazon GameLift will report a ``SizeOnDisk`` of 0.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='Version information that is associated with this build. Version strings do not need to be unique.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-build.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_build_props = gamelift.CfnBuildProps(\n        name="name",\n        operating_system="operatingSystem",\n        server_sdk_version="serverSdkVersion",\n        storage_location=gamelift.CfnBuild.StorageLocationProperty(\n            bucket="bucket",\n            key="key",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            object_version="objectVersion"\n        ),\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'operating_system', 'server_sdk_version', 'storage_location', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnBuildProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnContainerGroupDefinitionProps
class CfnContainerGroupDefinitionPropsDef(BaseCfnProperty):
    container_definitions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnContainerGroupDefinition_ContainerDefinitionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The set of container definitions that are included in the container group.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive identifier for the container group definition. The name value is unique in an AWS Region.\n')
    operating_system: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The platform required for all containers in the container group definition. .. epigraph:: Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the `Amazon Linux 2 FAQs <https://docs.aws.amazon.com/https://aws.amazon.com/amazon-linux-2/faqs/>`_ . For game servers that are hosted on AL2 and use Amazon GameLift server SDK 4.x., first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See `Migrate to Amazon GameLift server SDK version 5. <https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html>`_\n')
    total_cpu_limit: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of CPU units on a fleet instance to allocate for the container group. All containers in the group share these resources. This property is an integer value in CPU units (1 vCPU is equal to 1024 CPU units). You can set additional limits for each ``ContainerDefinition`` in the group. If individual containers have limits, this value must be equal to or greater than the sum of all container-specific CPU limits in the group. For more details on memory allocation, see the `Container fleet design guide <https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet>`_ .\n')
    total_memory_limit: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of memory (in MiB) on a fleet instance to allocate for the container group. All containers in the group share these resources. You can set additional limits for each ``ContainerDefinition`` in the group. If individual containers have limits, this value must meet the following requirements: - Equal to or greater than the sum of all container-specific soft memory limits in the group. - Equal to or greater than any container-specific hard limits in the group. For more details on memory allocation, see the `Container fleet design guide <https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet>`_ .\n')
    scheduling_strategy: typing.Optional[str] = pydantic.Field(None, description='The method for deploying the container group across fleet instances. A replica container group might have multiple copies on each fleet instance. A daemon container group maintains only one copy per fleet instance.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-containergroupdefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_container_group_definition_props = gamelift.CfnContainerGroupDefinitionProps(\n        container_definitions=[gamelift.CfnContainerGroupDefinition.ContainerDefinitionProperty(\n            container_name="containerName",\n            image_uri="imageUri",\n\n            # the properties below are optional\n            command=["command"],\n            cpu=123,\n            depends_on=[gamelift.CfnContainerGroupDefinition.ContainerDependencyProperty(\n                condition="condition",\n                container_name="containerName"\n            )],\n            entry_point=["entryPoint"],\n            environment=[gamelift.CfnContainerGroupDefinition.ContainerEnvironmentProperty(\n                name="name",\n                value="value"\n            )],\n            essential=False,\n            health_check=gamelift.CfnContainerGroupDefinition.ContainerHealthCheckProperty(\n                command=["command"],\n\n                # the properties below are optional\n                interval=123,\n                retries=123,\n                start_period=123,\n                timeout=123\n            ),\n            memory_limits=gamelift.CfnContainerGroupDefinition.MemoryLimitsProperty(\n                hard_limit=123,\n                soft_limit=123\n            ),\n            port_configuration=gamelift.CfnContainerGroupDefinition.PortConfigurationProperty(\n                container_port_ranges=[gamelift.CfnContainerGroupDefinition.ContainerPortRangeProperty(\n                    from_port=123,\n                    protocol="protocol",\n                    to_port=123\n                )]\n            ),\n            resolved_image_digest="resolvedImageDigest",\n            working_directory="workingDirectory"\n        )],\n        name="name",\n        operating_system="operatingSystem",\n        total_cpu_limit=123,\n        total_memory_limit=123,\n\n        # the properties below are optional\n        scheduling_strategy="schedulingStrategy",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_definitions', 'name', 'operating_system', 'total_cpu_limit', 'total_memory_limit', 'scheduling_strategy', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnContainerGroupDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnFleetProps
class CfnFleetPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive label that is associated with a fleet. Fleet names do not need to be unique.\n')
    anywhere_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_AnywhereConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Amazon GameLift Anywhere configuration options.\n')
    apply_capacity: typing.Optional[str] = pydantic.Field(None, description="Current resource capacity settings for managed EC2 fleets and container fleets. For multi-location fleets, location values might refer to a fleet's remote location or its home Region. *Returned by:* `DescribeFleetCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetCapacity.html>`_ , `DescribeFleetLocationCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetLocationCapacity.html>`_ , `UpdateFleetCapacity <https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateFleetCapacity.html>`_\n")
    build_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for a build to be deployed on the new fleet. If you are deploying the fleet with a custom game build, you must specify this property. The build must have been successfully uploaded to Amazon GameLift and be in a ``READY`` status. This fleet setting cannot be changed once the fleet is created.\n')
    certificate_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_CertificateConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Prompts Amazon GameLift to generate a TLS/SSL certificate for the fleet. Amazon GameLift uses the certificates to encrypt traffic between game clients and the game servers running on Amazon GameLift. By default, the ``CertificateConfiguration`` is ``DISABLED`` . You can't change this property after you create the fleet. AWS Certificate Manager (ACM) certificates expire after 13 months. Certificate expiration can cause fleets to fail, preventing players from connecting to instances in the fleet. We recommend you replace fleets before 13 months, consider using fleet aliases for a smooth transition. .. epigraph:: ACM isn't available in all AWS regions. A fleet creation request with certificate generation enabled in an unsupported Region, fails with a 4xx error. For more information about the supported Regions, see `Supported Regions <https://docs.aws.amazon.com/acm/latest/userguide/acm-regions.html>`_ in the *AWS Certificate Manager User Guide* .\n")
    compute_type: typing.Optional[str] = pydantic.Field(None, description='The type of compute resource used to host your game servers. - ``EC2``  The game server build is deployed to Amazon EC2 instances for cloud hosting. This is the default setting. - ``CONTAINER``  Container images with your game server build and supporting software are deployed to Amazon EC2 instances for cloud hosting. With this compute type, you must specify the ``ContainerGroupsConfiguration`` parameter. - ``ANYWHERE``  Game servers or container images with your game server and supporting software are deployed to compute resources that are provided and managed by you. With this compute type, you can also set the ``AnywhereConfiguration`` parameter.\n')
    container_groups_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ContainerGroupsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='*This data type is used with the Amazon GameLift containers feature, which is currently in public preview.*. Configuration details for a set of container groups, for use when creating a fleet with compute type ``CONTAINER`` . *Used with:* ``CreateFleet``\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the fleet.\n')
    desired_ec2_instances: typing.Union[int, float, None] = pydantic.Field(None, description='The number of EC2 instances that you want this fleet to host. When creating a new fleet, GameLift automatically sets this value to "1" and initiates a single instance. Once the fleet is active, update this value to trigger GameLift to add or remove instances from the fleet.\n')
    ec2_inbound_permissions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_IpPermissionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The IP address ranges and port settings that allow inbound traffic to access game server processes and other processes on this fleet. Set this parameter for EC2 and container fleets. You can leave this parameter empty when creating the fleet, but you must call ``UpdateFleetPortSettings`` to set it before players can connect to game sessions. As a best practice, we recommend opening ports for remote access only when you need them and closing them when you're finished. For Realtime Servers fleets, Amazon GameLift automatically sets TCP and UDP ranges. To manage inbound access for a container fleet, set this parameter to the same port numbers that you set for the fleet's connection port range. During the life of the fleet, update this parameter to control which connection ports are open to inbound traffic.\n")
    ec2_instance_type: typing.Optional[str] = pydantic.Field(None, description='The Amazon GameLift-supported Amazon EC2 instance type to use with EC2 and container fleets. Instance type determines the computing resources that will be used to host your game servers, including CPU, memory, storage, and networking capacity. See `Amazon Elastic Compute Cloud Instance Types <https://docs.aws.amazon.com/ec2/instance-types/>`_ for detailed descriptions of Amazon EC2 instance types.\n')
    fleet_type: typing.Optional[str] = pydantic.Field(None, description="Indicates whether to use On-Demand or Spot instances for this fleet. By default, this property is set to ``ON_DEMAND`` . Learn more about when to use `On-Demand versus Spot Instances <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-ec2-instances.html#gamelift-ec2-instances-spot>`_ . This fleet property can't be changed after the fleet is created.\n")
    instance_role_arn: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for an IAM role with access permissions to other AWS services. Any application that runs on an instance in the fleet--including install scripts, server processes, and other processes--can use these permissions to interact with AWS resources that you own or have access to. For more information about using the role with your game server builds, see `Communicate with other AWS resources from your fleets <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-resources.html>`_ . This attribute is used with fleets where ``ComputeType`` is "EC2" or "Container".\n')
    instance_role_credentials_provider: typing.Optional[str] = pydantic.Field(None, description='Indicates that fleet instances maintain a shared credentials file for the IAM role defined in ``InstanceRoleArn`` . Shared credentials allow applications that are deployed with the game server executable to communicate with other AWS resources. This property is used only when the game server is integrated with the server SDK version 5.x. For more information about using shared credentials, see `Communicate with other AWS resources from your fleets <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-resources.html>`_ . This attribute is used with fleets where ``ComputeType`` is "EC2" or "Container".\n')
    locations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_LocationConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="A set of remote locations to deploy additional instances to and manage as part of the fleet. This parameter can only be used when creating fleets in AWS Regions that support multiple locations. You can add any Amazon GameLift-supported AWS Region as a remote location, in the form of an AWS Region code, such as ``us-west-2`` or Local Zone code. To create a fleet with instances in the home Region only, don't set this parameter. When using this parameter, Amazon GameLift requires you to include your home location in the request.\n")
    log_paths: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(deprecated) This parameter is no longer used. When hosting a custom game build, specify where Amazon GameLift should store log files using the Amazon GameLift server API call ProcessReady()\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of instances that are allowed in the specified fleet location. If this parameter is not set, the default is 1.\n')
    metric_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of an AWS CloudWatch metric group to add this fleet to. A metric group is used to aggregate the metrics for multiple fleets. You can specify an existing metric group name or set a new name to create a new metric group. A fleet can be included in only one metric group at a time.\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of instances that are allowed in the specified fleet location. If this parameter is not set, the default is 0.\n')
    new_game_session_protection_policy: typing.Optional[str] = pydantic.Field(None, description='The status of termination protection for active game sessions on the fleet. By default, this property is set to ``NoProtection`` . - *NoProtection* - Game sessions can be terminated during active gameplay as a result of a scale-down event. - *FullProtection* - Game sessions in ``ACTIVE`` status cannot be terminated during a scale-down event.\n')
    peer_vpc_aws_account_id: typing.Optional[str] = pydantic.Field(None, description='Used when peering your Amazon GameLift fleet with a VPC, the unique identifier for the AWS account that owns the VPC. You can find your account ID in the AWS Management Console under account settings.\n')
    peer_vpc_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for a VPC with resources to be accessed by your Amazon GameLift fleet. The VPC must be in the same Region as your fleet. To look up a VPC ID, use the `VPC Dashboard <https://docs.aws.amazon.com/vpc/>`_ in the AWS Management Console . Learn more about VPC peering in `VPC Peering with Amazon GameLift Fleets <https://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html>`_ .\n')
    resource_creation_limit_policy: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ResourceCreationLimitPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A policy that limits the number of game sessions that an individual player can create on instances in this fleet within a specified span of time.\n')
    runtime_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_RuntimeConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Instructions for how to launch and maintain server processes on instances in the fleet. The runtime configuration defines one or more server process configurations, each identifying a build executable or Realtime script file and the number of processes of that type to run concurrently. .. epigraph:: The ``RuntimeConfiguration`` parameter is required unless the fleet is being configured using the older parameters ``ServerLaunchPath`` and ``ServerLaunchParameters`` , which are still supported for backward compatibility.\n')
    scaling_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnFleet_ScalingPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.\n')
    script_id: typing.Optional[str] = pydantic.Field(None, description="The unique identifier for a Realtime configuration script to be deployed on fleet instances. You can use either the script ID or ARN. Scripts must be uploaded to Amazon GameLift prior to creating the fleet. This fleet property cannot be changed later. .. epigraph:: You can't use the ``!Ref`` command to reference a script created with a CloudFormation template for the fleet property ``ScriptId`` . Instead, use ``Fn::GetAtt Script.Arn`` or ``Fn::GetAtt Script.Id`` to retrieve either of these properties as input for ``ScriptId`` . Alternatively, enter a ``ScriptId`` string manually.\n")
    server_launch_parameters: typing.Optional[str] = pydantic.Field(None, description='(deprecated) This parameter is no longer used but is retained for backward compatibility. Instead, specify server launch parameters in the RuntimeConfiguration parameter. A request must specify either a runtime configuration or values for both ServerLaunchParameters and ServerLaunchPath.\n')
    server_launch_path: typing.Optional[str] = pydantic.Field(None, description='(deprecated) This parameter is no longer used. Instead, specify a server launch path using the RuntimeConfiguration parameter. Requests that specify a server launch path and launch parameters instead of a runtime configuration will continue to work.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-fleet.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_fleet_props = gamelift.CfnFleetProps(\n        name="name",\n\n        # the properties below are optional\n        anywhere_configuration=gamelift.CfnFleet.AnywhereConfigurationProperty(\n            cost="cost"\n        ),\n        apply_capacity="applyCapacity",\n        build_id="buildId",\n        certificate_configuration=gamelift.CfnFleet.CertificateConfigurationProperty(\n            certificate_type="certificateType"\n        ),\n        compute_type="computeType",\n        container_groups_configuration=gamelift.CfnFleet.ContainerGroupsConfigurationProperty(\n            connection_port_range=gamelift.CfnFleet.ConnectionPortRangeProperty(\n                from_port=123,\n                to_port=123\n            ),\n            container_group_definition_names=["containerGroupDefinitionNames"],\n\n            # the properties below are optional\n            container_groups_per_instance=gamelift.CfnFleet.ContainerGroupsPerInstanceProperty(\n                desired_replica_container_groups_per_instance=123,\n                max_replica_container_groups_per_instance=123\n            )\n        ),\n        description="description",\n        desired_ec2_instances=123,\n        ec2_inbound_permissions=[gamelift.CfnFleet.IpPermissionProperty(\n            from_port=123,\n            ip_range="ipRange",\n            protocol="protocol",\n            to_port=123\n        )],\n        ec2_instance_type="ec2InstanceType",\n        fleet_type="fleetType",\n        instance_role_arn="instanceRoleArn",\n        instance_role_credentials_provider="instanceRoleCredentialsProvider",\n        locations=[gamelift.CfnFleet.LocationConfigurationProperty(\n            location="location",\n\n            # the properties below are optional\n            location_capacity=gamelift.CfnFleet.LocationCapacityProperty(\n                desired_ec2_instances=123,\n                max_size=123,\n                min_size=123\n            )\n        )],\n        log_paths=["logPaths"],\n        max_size=123,\n        metric_groups=["metricGroups"],\n        min_size=123,\n        new_game_session_protection_policy="newGameSessionProtectionPolicy",\n        peer_vpc_aws_account_id="peerVpcAwsAccountId",\n        peer_vpc_id="peerVpcId",\n        resource_creation_limit_policy=gamelift.CfnFleet.ResourceCreationLimitPolicyProperty(\n            new_game_sessions_per_creator=123,\n            policy_period_in_minutes=123\n        ),\n        runtime_configuration=gamelift.CfnFleet.RuntimeConfigurationProperty(\n            game_session_activation_timeout_seconds=123,\n            max_concurrent_game_session_activations=123,\n            server_processes=[gamelift.CfnFleet.ServerProcessProperty(\n                concurrent_executions=123,\n                launch_path="launchPath",\n\n                # the properties below are optional\n                parameters="parameters"\n            )]\n        ),\n        scaling_policies=[gamelift.CfnFleet.ScalingPolicyProperty(\n            metric_name="metricName",\n            name="name",\n\n            # the properties below are optional\n            comparison_operator="comparisonOperator",\n            evaluation_periods=123,\n            location="location",\n            policy_type="policyType",\n            scaling_adjustment=123,\n            scaling_adjustment_type="scalingAdjustmentType",\n            status="status",\n            target_configuration=gamelift.CfnFleet.TargetConfigurationProperty(\n                target_value=123\n            ),\n            threshold=123,\n            update_status="updateStatus"\n        )],\n        script_id="scriptId",\n        server_launch_parameters="serverLaunchParameters",\n        server_launch_path="serverLaunchPath"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'anywhere_configuration', 'apply_capacity', 'build_id', 'certificate_configuration', 'compute_type', 'container_groups_configuration', 'description', 'desired_ec2_instances', 'ec2_inbound_permissions', 'ec2_instance_type', 'fleet_type', 'instance_role_arn', 'instance_role_credentials_provider', 'locations', 'log_paths', 'max_size', 'metric_groups', 'min_size', 'new_game_session_protection_policy', 'peer_vpc_aws_account_id', 'peer_vpc_id', 'resource_creation_limit_policy', 'runtime_configuration', 'scaling_policies', 'script_id', 'server_launch_parameters', 'server_launch_path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnFleetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameServerGroupProps
class CfnGameServerGroupPropsDef(BaseCfnProperty):
    game_server_group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A developer-defined identifier for the game server group. The name is unique for each Region in each AWS account.\n')
    instance_definitions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameServerGroup_InstanceDefinitionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The set of Amazon EC2 instance types that Amazon GameLift FleetIQ can use when balancing and automatically scaling instances in the corresponding Auto Scaling group.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name ( `ARN <https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html>`_ ) for an IAM role that allows Amazon GameLift to access your Amazon EC2 Auto Scaling groups.\n')
    auto_scaling_policy: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameServerGroup_AutoScalingPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting. The scaling policy uses the metric ``"PercentUtilizedGameServers"`` to maintain a buffer of idle game servers that can immediately accommodate new games and players. After the Auto Scaling group is created, update this value directly in the Auto Scaling group using the AWS console or APIs.\n')
    balancing_strategy: typing.Optional[str] = pydantic.Field(None, description='Indicates how Amazon GameLift FleetIQ balances the use of Spot Instances and On-Demand Instances in the game server group. Method options include the following: - ``SPOT_ONLY`` - Only Spot Instances are used in the game server group. If Spot Instances are unavailable or not viable for game hosting, the game server group provides no hosting capacity until Spot Instances can again be used. Until then, no new instances are started, and the existing nonviable Spot Instances are terminated (after current gameplay ends) and are not replaced. - ``SPOT_PREFERRED`` - (default value) Spot Instances are used whenever available in the game server group. If Spot Instances are unavailable, the game server group continues to provide hosting capacity by falling back to On-Demand Instances. Existing nonviable Spot Instances are terminated (after current gameplay ends) and are replaced with new On-Demand Instances. - ``ON_DEMAND_ONLY`` - Only On-Demand Instances are used in the game server group. No Spot Instances are used, even when available, while this balancing strategy is in force.\n')
    delete_option: typing.Optional[str] = pydantic.Field(None, description='The type of delete to perform. To delete a game server group, specify the ``DeleteOption`` . Options include the following: - ``SAFE_DELETE``  (default) Terminates the game server group and Amazon EC2 Auto Scaling group only when it has no game servers that are in ``UTILIZED`` status. - ``FORCE_DELETE``  Terminates the game server group, including all active game servers regardless of their utilization status, and the Amazon EC2 Auto Scaling group. - ``RETAIN``  Does a safe delete of the game server group but retains the Amazon EC2 Auto Scaling group as is.\n')
    game_server_protection_policy: typing.Optional[str] = pydantic.Field(None, description='A flag that indicates whether instances in the game server group are protected from early termination. Unprotected instances that have active game servers running might be terminated during a scale-down event, causing players to be dropped from the game. Protected instances cannot be terminated while there are active game servers running except in the event of a forced game server group deletion (see ). An exception to this is with Spot Instances, which can be terminated by AWS regardless of protection status.\n')
    launch_template: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameServerGroup_LaunchTemplatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Amazon EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group. You can specify the template using either the template name or ID. For help with creating a launch template, see `Creating a Launch Template for an Auto Scaling Group <https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html>`_ in the *Amazon Elastic Compute Cloud Auto Scaling User Guide* . After the Auto Scaling group is created, update this value directly in the Auto Scaling group using the AWS console or APIs. .. epigraph:: If you specify network interfaces in your launch template, you must explicitly set the property ``AssociatePublicIpAddress`` to "true". If no network interface is specified in the launch template, Amazon GameLift FleetIQ uses your account\'s default VPC.\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of instances allowed in the Amazon EC2 Auto Scaling group. During automatic scaling events, Amazon GameLift FleetIQ and EC2 do not scale up the group above this maximum. After the Auto Scaling group is created, update this value directly in the Auto Scaling group using the AWS console or APIs.\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of instances allowed in the Amazon EC2 Auto Scaling group. During automatic scaling events, Amazon GameLift FleetIQ and Amazon EC2 do not scale down the group below this minimum. In production, this value should be set to at least 1. After the Auto Scaling group is created, update this value directly in the Auto Scaling group using the AWS console or APIs.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new game server group resource. Tags are developer-defined key-value pairs. Tagging AWS resources is useful for resource management, access management, and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags, respectively. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.\n')
    vpc_subnets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of virtual private cloud (VPC) subnets to use with instances in the game server group. By default, all Amazon GameLift FleetIQ-supported Availability Zones are used. You can use this parameter to specify VPCs that you\'ve set up. This property cannot be updated after the game server group is created, and the corresponding Auto Scaling group will always use the property value that is set with this request, even if the Auto Scaling group is updated directly.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-gameservergroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_game_server_group_props = gamelift.CfnGameServerGroupProps(\n        game_server_group_name="gameServerGroupName",\n        instance_definitions=[gamelift.CfnGameServerGroup.InstanceDefinitionProperty(\n            instance_type="instanceType",\n\n            # the properties below are optional\n            weighted_capacity="weightedCapacity"\n        )],\n        role_arn="roleArn",\n\n        # the properties below are optional\n        auto_scaling_policy=gamelift.CfnGameServerGroup.AutoScalingPolicyProperty(\n            target_tracking_configuration=gamelift.CfnGameServerGroup.TargetTrackingConfigurationProperty(\n                target_value=123\n            ),\n\n            # the properties below are optional\n            estimated_instance_warmup=123\n        ),\n        balancing_strategy="balancingStrategy",\n        delete_option="deleteOption",\n        game_server_protection_policy="gameServerProtectionPolicy",\n        launch_template=gamelift.CfnGameServerGroup.LaunchTemplateProperty(\n            launch_template_id="launchTemplateId",\n            launch_template_name="launchTemplateName",\n            version="version"\n        ),\n        max_size=123,\n        min_size=123,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        vpc_subnets=["vpcSubnets"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['game_server_group_name', 'instance_definitions', 'role_arn', 'auto_scaling_policy', 'balancing_strategy', 'delete_option', 'game_server_protection_policy', 'launch_template', 'max_size', 'min_size', 'tags', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameServerGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnGameSessionQueueProps
class CfnGameSessionQueuePropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive label that is associated with game session queue. Queue names must be unique within each Region.\n')
    custom_event_data: typing.Optional[str] = pydantic.Field(None, description='Information to be added to all events that are related to this game session queue.\n')
    destinations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameSessionQueue_DestinationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of fleets and/or fleet aliases that can be used to fulfill game session placement requests in the queue. Destinations are identified by either a fleet ARN or a fleet alias ARN, and are listed in order of placement preference.\n')
    filter_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameSessionQueue_FilterConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A list of locations where a queue is allowed to place new game sessions. Locations are specified in the form of AWS Region codes, such as ``us-west-2`` . If this parameter is not set, game sessions can be placed in any queue location.\n')
    notification_target: typing.Optional[str] = pydantic.Field(None, description='An SNS topic ARN that is set up to receive game session placement notifications. See `Setting up notifications for game session placement <https://docs.aws.amazon.com/gamelift/latest/developerguide/queue-notification.html>`_ .\n')
    player_latency_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameSessionQueue_PlayerLatencyPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A set of policies that act as a sliding cap on player latency. FleetIQ works to deliver low latency for most players in a game session. These policies ensure that no individual player can be placed into a game with unreasonably high latency. Use multiple policies to gradually relax latency requirements a step at a time. Multiple policies are applied based on their maximum allowed latency, starting with the lowest value.\n')
    priority_configuration: typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnGameSessionQueue_PriorityConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Custom settings to use when prioritizing destinations and locations for game session placements. This configuration replaces the FleetIQ default prioritization process. Priority types that are not explicitly named will be automatically applied at the end of the prioritization process.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new game session queue resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.\n')
    timeout_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time, in seconds, that a new game session placement request remains in the queue. When a request exceeds this time, the game session placement changes to a ``TIMED_OUT`` status. By default, this property is set to ``600`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-gamesessionqueue.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_game_session_queue_props = gamelift.CfnGameSessionQueueProps(\n        name="name",\n\n        # the properties below are optional\n        custom_event_data="customEventData",\n        destinations=[gamelift.CfnGameSessionQueue.DestinationProperty(\n            destination_arn="destinationArn"\n        )],\n        filter_configuration=gamelift.CfnGameSessionQueue.FilterConfigurationProperty(\n            allowed_locations=["allowedLocations"]\n        ),\n        notification_target="notificationTarget",\n        player_latency_policies=[gamelift.CfnGameSessionQueue.PlayerLatencyPolicyProperty(\n            maximum_individual_player_latency_milliseconds=123,\n            policy_duration_seconds=123\n        )],\n        priority_configuration=gamelift.CfnGameSessionQueue.PriorityConfigurationProperty(\n            location_order=["locationOrder"],\n            priority_order=["priorityOrder"]\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        timeout_in_seconds=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'custom_event_data', 'destinations', 'filter_configuration', 'notification_target', 'player_latency_policies', 'priority_configuration', 'tags', 'timeout_in_seconds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnGameSessionQueueProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnLocationProps
class CfnLocationPropsDef(BaseCfnProperty):
    location_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A descriptive name for the custom location.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Rareference* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-location.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_location_props = gamelift.CfnLocationProps(\n        location_name="locationName",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['location_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnLocationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnMatchmakingConfigurationProps
class CfnMatchmakingConfigurationPropsDef(BaseCfnProperty):
    acceptance_required: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='A flag that determines whether a match that was created with this configuration must be accepted by the matched players. To require acceptance, set to ``TRUE`` . With this option enabled, matchmaking tickets use the status ``REQUIRES_ACCEPTANCE`` to indicate when a completed potential match is waiting for player acceptance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the matchmaking configuration. This name is used to identify the configuration associated with a matchmaking request or ticket.\n')
    request_timeout_seconds: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out. Requests that fail due to timing out can be resubmitted as needed.\n')
    rule_set_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN value. A matchmaking configuration can only use rule sets that are defined in the same Region.\n')
    acceptance_timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required.\n')
    additional_player_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies a match for a single 10-person team, and the additional player count is set to 2, 10 players will be selected for the match and 2 more player slots will be open for future players. This parameter is not used if ``FlexMatchMode`` is set to ``STANDALONE`` .\n")
    backfill_mode: typing.Optional[str] = pydantic.Field(None, description='The method used to backfill game sessions that are created with this matchmaking configuration. Specify ``MANUAL`` when your game manages backfill requests manually or does not use the match backfill feature. Specify ``AUTOMATIC`` to have GameLift create a ``StartMatchBackfill`` request whenever a game session has one or more open slots. Learn more about manual and automatic backfill in `Backfill Existing Games with FlexMatch <https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html>`_ . Automatic backfill is not available when ``FlexMatchMode`` is set to ``STANDALONE`` .\n')
    creation_time: typing.Optional[str] = pydantic.Field(None, description='A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example ``"1469498468.057"`` ).\n')
    custom_event_data: typing.Optional[str] = pydantic.Field(None, description='Information to add to all events related to the matchmaking configuration.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the matchmaking configuration.\n')
    flex_match_mode: typing.Optional[str] = pydantic.Field(None, description='Indicates whether this matchmaking configuration is being used with Amazon GameLift hosting or as a standalone matchmaking solution. - *STANDALONE* - FlexMatch forms matches and returns match information, including players and team assignments, in a `MatchmakingSucceeded <https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded>`_ event. - *WITH_QUEUE* - FlexMatch forms matches and uses the specified Amazon GameLift queue to start a game session for the match.\n')
    game_properties: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_gamelift.CfnMatchmakingConfiguration_GamePropertyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A set of custom properties for a game session, formatted as key-value pairs. These properties are passed to a game server process with a request to start a new game session. See `Start a Game Session <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession>`_ . This parameter is not used if ``FlexMatchMode`` is set to ``STANDALONE`` .\n')
    game_session_data: typing.Optional[str] = pydantic.Field(None, description='A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session. See `Start a Game Session <https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession>`_ . This parameter is not used if ``FlexMatchMode`` is set to ``STANDALONE`` .\n')
    game_session_queue_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Name ( `ARN <https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html>`_ ) that is assigned to a Amazon GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is ``arn:aws:gamelift:<region>::gamesessionqueue/<queue name>`` . Queues can be located in any Region. Queues are used to start new Amazon GameLift-hosted game sessions for matches that are created with this matchmaking configuration. If ``FlexMatchMode`` is set to ``STANDALONE`` , do not set this parameter.\n')
    notification_target: typing.Optional[str] = pydantic.Field(None, description='An SNS topic ARN that is set up to receive matchmaking notifications. See `Setting up notifications for matchmaking <https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html>`_ for more information.\n')
    rule_set_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name ( `ARN <https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html>`_ ) associated with the GameLift matchmaking rule set resource that this configuration uses.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-matchmakingconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_matchmaking_configuration_props = gamelift.CfnMatchmakingConfigurationProps(\n        acceptance_required=False,\n        name="name",\n        request_timeout_seconds=123,\n        rule_set_name="ruleSetName",\n\n        # the properties below are optional\n        acceptance_timeout_seconds=123,\n        additional_player_count=123,\n        backfill_mode="backfillMode",\n        creation_time="creationTime",\n        custom_event_data="customEventData",\n        description="description",\n        flex_match_mode="flexMatchMode",\n        game_properties=[gamelift.CfnMatchmakingConfiguration.GamePropertyProperty(\n            key="key",\n            value="value"\n        )],\n        game_session_data="gameSessionData",\n        game_session_queue_arns=["gameSessionQueueArns"],\n        notification_target="notificationTarget",\n        rule_set_arn="ruleSetArn",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['acceptance_required', 'name', 'request_timeout_seconds', 'rule_set_name', 'acceptance_timeout_seconds', 'additional_player_count', 'backfill_mode', 'creation_time', 'custom_event_data', 'description', 'flex_match_mode', 'game_properties', 'game_session_data', 'game_session_queue_arns', 'notification_target', 'rule_set_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnMatchmakingConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnMatchmakingRuleSetProps
class CfnMatchmakingRuleSetPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the matchmaking rule set. A matchmaking configuration identifies the rule set it uses by this name value. Note that the rule set name is different from the optional ``name`` field in the rule set body.\n')
    rule_set_body: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A collection of matchmaking rules, formatted as a JSON string. Comments are not allowed in JSON, but most elements support a description field.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new matchmaking rule set resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-matchmakingruleset.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_matchmaking_rule_set_props = gamelift.CfnMatchmakingRuleSetProps(\n        name="name",\n        rule_set_body="ruleSetBody",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'rule_set_body', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnMatchmakingRuleSetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_gamelift.CfnScriptProps
class CfnScriptPropsDef(BaseCfnProperty):
    storage_location: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_gamelift.CfnScript_S3LocationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The location of the Amazon S3 bucket where a zipped file containing your Realtime scripts is stored. The storage location must specify the Amazon S3 bucket name, the zip file name (the "key"), and a role ARN that allows Amazon GameLift to access the Amazon S3 storage location. The S3 bucket must be in the same Region where you want to create a new script. By default, Amazon GameLift uploads the latest version of the zip file; if you have S3 object versioning turned on, you can use the ``ObjectVersion`` parameter to specify an earlier version.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A descriptive label that is associated with a script. Script names do not need to be unique.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of labels to assign to the new script resource. Tags are developer-defined key-value pairs. Tagging AWS resources are useful for resource management, access management and cost allocation. For more information, see `Tagging AWS Resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference* . Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General Reference for actual tagging limits.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The version that is associated with a build or script. Version strings do not need to be unique.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-gamelift-script.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_gamelift as gamelift\n\n    cfn_script_props = gamelift.CfnScriptProps(\n        storage_location=gamelift.CfnScript.S3LocationProperty(\n            bucket="bucket",\n            key="key",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            object_version="objectVersion"\n        ),\n\n        # the properties below are optional\n        name="name",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['storage_location', 'name', 'tags', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_gamelift.CfnScriptProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnAlias_RoutingStrategyProperty: typing.Optional[dict[str, models.aws_gamelift.CfnAlias_RoutingStrategyPropertyDef]] = pydantic.Field(None)
    CfnBuild_StorageLocationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnBuild_StorageLocationPropertyDef]] = pydantic.Field(None)
    CfnContainerGroupDefinition_ContainerDefinitionProperty: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinition_ContainerDefinitionPropertyDef]] = pydantic.Field(None)
    CfnContainerGroupDefinition_ContainerDependencyProperty: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinition_ContainerDependencyPropertyDef]] = pydantic.Field(None)
    CfnContainerGroupDefinition_ContainerEnvironmentProperty: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinition_ContainerEnvironmentPropertyDef]] = pydantic.Field(None)
    CfnContainerGroupDefinition_ContainerHealthCheckProperty: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinition_ContainerHealthCheckPropertyDef]] = pydantic.Field(None)
    CfnContainerGroupDefinition_ContainerPortRangeProperty: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinition_ContainerPortRangePropertyDef]] = pydantic.Field(None)
    CfnContainerGroupDefinition_MemoryLimitsProperty: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinition_MemoryLimitsPropertyDef]] = pydantic.Field(None)
    CfnContainerGroupDefinition_PortConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinition_PortConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFleet_AnywhereConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_AnywhereConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFleet_CertificateConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_CertificateConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFleet_ConnectionPortRangeProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_ConnectionPortRangePropertyDef]] = pydantic.Field(None)
    CfnFleet_ContainerGroupsConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_ContainerGroupsConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFleet_ContainerGroupsPerInstanceProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_ContainerGroupsPerInstancePropertyDef]] = pydantic.Field(None)
    CfnFleet_IpPermissionProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_IpPermissionPropertyDef]] = pydantic.Field(None)
    CfnFleet_LocationCapacityProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_LocationCapacityPropertyDef]] = pydantic.Field(None)
    CfnFleet_LocationConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_LocationConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFleet_ResourceCreationLimitPolicyProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_ResourceCreationLimitPolicyPropertyDef]] = pydantic.Field(None)
    CfnFleet_RuntimeConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_RuntimeConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFleet_ScalingPolicyProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_ScalingPolicyPropertyDef]] = pydantic.Field(None)
    CfnFleet_ServerProcessProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_ServerProcessPropertyDef]] = pydantic.Field(None)
    CfnFleet_TargetConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnFleet_TargetConfigurationPropertyDef]] = pydantic.Field(None)
    CfnGameServerGroup_AutoScalingPolicyProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameServerGroup_AutoScalingPolicyPropertyDef]] = pydantic.Field(None)
    CfnGameServerGroup_InstanceDefinitionProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameServerGroup_InstanceDefinitionPropertyDef]] = pydantic.Field(None)
    CfnGameServerGroup_LaunchTemplateProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameServerGroup_LaunchTemplatePropertyDef]] = pydantic.Field(None)
    CfnGameServerGroup_TargetTrackingConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameServerGroup_TargetTrackingConfigurationPropertyDef]] = pydantic.Field(None)
    CfnGameSessionQueue_DestinationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameSessionQueue_DestinationPropertyDef]] = pydantic.Field(None)
    CfnGameSessionQueue_FilterConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameSessionQueue_FilterConfigurationPropertyDef]] = pydantic.Field(None)
    CfnGameSessionQueue_GameSessionQueueDestinationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameSessionQueue_GameSessionQueueDestinationPropertyDef]] = pydantic.Field(None)
    CfnGameSessionQueue_PlayerLatencyPolicyProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameSessionQueue_PlayerLatencyPolicyPropertyDef]] = pydantic.Field(None)
    CfnGameSessionQueue_PriorityConfigurationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnGameSessionQueue_PriorityConfigurationPropertyDef]] = pydantic.Field(None)
    CfnMatchmakingConfiguration_GamePropertyProperty: typing.Optional[dict[str, models.aws_gamelift.CfnMatchmakingConfiguration_GamePropertyPropertyDef]] = pydantic.Field(None)
    CfnScript_S3LocationProperty: typing.Optional[dict[str, models.aws_gamelift.CfnScript_S3LocationPropertyDef]] = pydantic.Field(None)
    CfnAlias: typing.Optional[dict[str, models.aws_gamelift.CfnAliasDef]] = pydantic.Field(None)
    CfnBuild: typing.Optional[dict[str, models.aws_gamelift.CfnBuildDef]] = pydantic.Field(None)
    CfnContainerGroupDefinition: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinitionDef]] = pydantic.Field(None)
    CfnFleet: typing.Optional[dict[str, models.aws_gamelift.CfnFleetDef]] = pydantic.Field(None)
    CfnGameServerGroup: typing.Optional[dict[str, models.aws_gamelift.CfnGameServerGroupDef]] = pydantic.Field(None)
    CfnGameSessionQueue: typing.Optional[dict[str, models.aws_gamelift.CfnGameSessionQueueDef]] = pydantic.Field(None)
    CfnLocation: typing.Optional[dict[str, models.aws_gamelift.CfnLocationDef]] = pydantic.Field(None)
    CfnMatchmakingConfiguration: typing.Optional[dict[str, models.aws_gamelift.CfnMatchmakingConfigurationDef]] = pydantic.Field(None)
    CfnMatchmakingRuleSet: typing.Optional[dict[str, models.aws_gamelift.CfnMatchmakingRuleSetDef]] = pydantic.Field(None)
    CfnScript: typing.Optional[dict[str, models.aws_gamelift.CfnScriptDef]] = pydantic.Field(None)
    CfnAliasProps: typing.Optional[dict[str, models.aws_gamelift.CfnAliasPropsDef]] = pydantic.Field(None)
    CfnBuildProps: typing.Optional[dict[str, models.aws_gamelift.CfnBuildPropsDef]] = pydantic.Field(None)
    CfnContainerGroupDefinitionProps: typing.Optional[dict[str, models.aws_gamelift.CfnContainerGroupDefinitionPropsDef]] = pydantic.Field(None)
    CfnFleetProps: typing.Optional[dict[str, models.aws_gamelift.CfnFleetPropsDef]] = pydantic.Field(None)
    CfnGameServerGroupProps: typing.Optional[dict[str, models.aws_gamelift.CfnGameServerGroupPropsDef]] = pydantic.Field(None)
    CfnGameSessionQueueProps: typing.Optional[dict[str, models.aws_gamelift.CfnGameSessionQueuePropsDef]] = pydantic.Field(None)
    CfnLocationProps: typing.Optional[dict[str, models.aws_gamelift.CfnLocationPropsDef]] = pydantic.Field(None)
    CfnMatchmakingConfigurationProps: typing.Optional[dict[str, models.aws_gamelift.CfnMatchmakingConfigurationPropsDef]] = pydantic.Field(None)
    CfnMatchmakingRuleSetProps: typing.Optional[dict[str, models.aws_gamelift.CfnMatchmakingRuleSetPropsDef]] = pydantic.Field(None)
    CfnScriptProps: typing.Optional[dict[str, models.aws_gamelift.CfnScriptPropsDef]] = pydantic.Field(None)
    ...

import models
