from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_glue.CfnClassifier.CsvClassifierProperty
class CfnClassifier_CsvClassifierPropertyDef(BaseStruct):
    allow_single_column: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables the processing of files that contain only one column.\n')
    contains_custom_datatype: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    contains_header: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the CSV file contains a header. A value of ``UNKNOWN`` specifies that the classifier will detect whether the CSV file contains headings. A value of ``PRESENT`` specifies that the CSV file contains headings. A value of ``ABSENT`` specifies that the CSV file does not contain headings.\n')
    custom_datatype_configured: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables the custom datatype to be configured.\n')
    delimiter: typing.Optional[str] = pydantic.Field(None, description='A custom symbol to denote what separates each column entry in the row.\n')
    disable_value_trimming: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies not to trim values before identifying the type of column values. The default value is ``true`` .\n')
    header: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of strings representing column names.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the classifier.\n')
    quote_symbol: typing.Optional[str] = pydantic.Field(None, description='A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-classifier-csvclassifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    csv_classifier_property = glue.CfnClassifier.CsvClassifierProperty(\n        allow_single_column=False,\n        contains_custom_datatype=["containsCustomDatatype"],\n        contains_header="containsHeader",\n        custom_datatype_configured=False,\n        delimiter="delimiter",\n        disable_value_trimming=False,\n        header=["header"],\n        name="name",\n        quote_symbol="quoteSymbol"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_single_column', 'contains_custom_datatype', 'contains_header', 'custom_datatype_configured', 'delimiter', 'disable_value_trimming', 'header', 'name', 'quote_symbol']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnClassifier.CsvClassifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnClassifier.GrokClassifierProperty
class CfnClassifier_GrokClassifierPropertyDef(BaseStruct):
    classification: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.\n')
    grok_pattern: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in `Writing Custom Classifiers <https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html>`_ .\n')
    custom_patterns: typing.Optional[str] = pydantic.Field(None, description='Optional custom grok patterns defined by this classifier. For more information, see custom patterns in `Writing Custom Classifiers <https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html>`_ .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the classifier.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-classifier-grokclassifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    grok_classifier_property = glue.CfnClassifier.GrokClassifierProperty(\n        classification="classification",\n        grok_pattern="grokPattern",\n\n        # the properties below are optional\n        custom_patterns="customPatterns",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['classification', 'grok_pattern', 'custom_patterns', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnClassifier.GrokClassifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnClassifier.JsonClassifierProperty
class CfnClassifier_JsonClassifierPropertyDef(BaseStruct):
    json_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A ``JsonPath`` string defining the JSON data for the classifier to classify. AWS Glue supports a subset of ``JsonPath`` , as described in `Writing JsonPath Custom Classifiers <https://docs.aws.amazon.com/glue/latest/dg/custom-classifier.html#custom-classifier-json>`_ .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the classifier.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-classifier-jsonclassifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    json_classifier_property = glue.CfnClassifier.JsonClassifierProperty(\n        json_path="jsonPath",\n\n        # the properties below are optional\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['json_path', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnClassifier.JsonClassifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnClassifier.XMLClassifierProperty
class CfnClassifier_XMLClassifierPropertyDef(BaseStruct):
    classification: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An identifier of the data format that the classifier matches.\n')
    row_tag: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The XML tag designating the element that contains each record in an XML document being parsed. This can\'t identify a self-closing element (closed by ``/>`` ). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, ``<row item_a="A" item_b="B"></row>`` is okay, but ``<row item_a="A" item_b="B" />`` is not).\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the classifier.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-classifier-xmlclassifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    x_mLClassifier_property = glue.CfnClassifier.XMLClassifierProperty(\n        classification="classification",\n        row_tag="rowTag",\n\n        # the properties below are optional\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['classification', 'row_tag', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnClassifier.XMLClassifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnConnection.ConnectionInputProperty
class CfnConnection_ConnectionInputPropertyDef(BaseStruct):
    connection_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the connection. Currently, these types are supported:. - ``JDBC`` - Designates a connection to a database through Java Database Connectivity (JDBC). ``JDBC`` Connections use the following ConnectionParameters. - Required: All of ( ``HOST`` , ``PORT`` , ``JDBC_ENGINE`` ) or ``JDBC_CONNECTION_URL`` . - Required: All of ( ``USERNAME`` , ``PASSWORD`` ) or ``SECRET_ID`` . - Optional: ``JDBC_ENFORCE_SSL`` , ``CUSTOM_JDBC_CERT`` , ``CUSTOM_JDBC_CERT_STRING`` , ``SKIP_CUSTOM_JDBC_CERT_VALIDATION`` . These parameters are used to configure SSL with JDBC. - ``KAFKA`` - Designates a connection to an Apache Kafka streaming platform. ``KAFKA`` Connections use the following ConnectionParameters. - Required: ``KAFKA_BOOTSTRAP_SERVERS`` . - Optional: ``KAFKA_SSL_ENABLED`` , ``KAFKA_CUSTOM_CERT`` , ``KAFKA_SKIP_CUSTOM_CERT_VALIDATION`` . These parameters are used to configure SSL with ``KAFKA`` . - Optional: ``KAFKA_CLIENT_KEYSTORE`` , ``KAFKA_CLIENT_KEYSTORE_PASSWORD`` , ``KAFKA_CLIENT_KEY_PASSWORD`` , ``ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD`` , ``ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD`` . These parameters are used to configure TLS client configuration with SSL in ``KAFKA`` . - Optional: ``KAFKA_SASL_MECHANISM`` . Can be specified as ``SCRAM-SHA-512`` , ``GSSAPI`` , or ``AWS_MSK_IAM`` . - Optional: ``KAFKA_SASL_SCRAM_USERNAME`` , ``KAFKA_SASL_SCRAM_PASSWORD`` , ``ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD`` . These parameters are used to configure SASL/SCRAM-SHA-512 authentication with ``KAFKA`` . - Optional: ``KAFKA_SASL_GSSAPI_KEYTAB`` , ``KAFKA_SASL_GSSAPI_KRB5_CONF`` , ``KAFKA_SASL_GSSAPI_SERVICE`` , ``KAFKA_SASL_GSSAPI_PRINCIPAL`` . These parameters are used to configure SASL/GSSAPI authentication with ``KAFKA`` . - ``MONGODB`` - Designates a connection to a MongoDB document database. ``MONGODB`` Connections use the following ConnectionParameters. - Required: ``CONNECTION_URL`` . - Required: All of ( ``USERNAME`` , ``PASSWORD`` ) or ``SECRET_ID`` . - ``NETWORK`` - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC). ``NETWORK`` Connections do not require ConnectionParameters. Instead, provide a PhysicalConnectionRequirements. - ``MARKETPLACE`` - Uses configuration settings contained in a connector purchased from AWS Marketplace to read from and write to data stores that are not natively supported by AWS Glue . ``MARKETPLACE`` Connections use the following ConnectionParameters. - Required: ``CONNECTOR_TYPE`` , ``CONNECTOR_URL`` , ``CONNECTOR_CLASS_NAME`` , ``CONNECTION_URL`` . - Required for ``JDBC`` ``CONNECTOR_TYPE`` connections: All of ( ``USERNAME`` , ``PASSWORD`` ) or ``SECRET_ID`` . - ``CUSTOM`` - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by AWS Glue . ``SFTP`` is not supported. For more information about how optional ConnectionProperties are used to configure features in AWS Glue , consult `AWS Glue connection properties <https://docs.aws.amazon.com/glue/latest/dg/connection-defining.html>`_ . For more information about how optional ConnectionProperties are used to configure features in AWS Glue Studio, consult `Using connectors and connections <https://docs.aws.amazon.com/glue/latest/ug/connectors-chapter.html>`_ .\n')
    connection_properties: typing.Any = pydantic.Field(None, description='These key-value pairs define parameters for the connection.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the connection.\n')
    match_criteria: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of criteria that can be used in selecting this connection.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection. Connection will not function as expected without a name.\n')
    physical_connection_requirements: typing.Union[models.UnsupportedResource, models.aws_glue.CfnConnection_PhysicalConnectionRequirementsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A map of physical connection requirements, such as virtual private cloud (VPC) and ``SecurityGroup`` , that are needed to successfully make this connection.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # connection_properties: Any\n\n    connection_input_property = glue.CfnConnection.ConnectionInputProperty(\n        connection_type="connectionType",\n\n        # the properties below are optional\n        connection_properties=connection_properties,\n        description="description",\n        match_criteria=["matchCriteria"],\n        name="name",\n        physical_connection_requirements=glue.CfnConnection.PhysicalConnectionRequirementsProperty(\n            availability_zone="availabilityZone",\n            security_group_id_list=["securityGroupIdList"],\n            subnet_id="subnetId"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_type', 'connection_properties', 'description', 'match_criteria', 'name', 'physical_connection_requirements']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnConnection.ConnectionInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnConnection.PhysicalConnectionRequirementsProperty
class CfnConnection_PhysicalConnectionRequirementsPropertyDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description="The connection's Availability Zone. This field is redundant because the specified subnet implies the Availability Zone to be used. Currently the field must be populated, but it will be deprecated in the future.\n")
    security_group_id_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security group ID list used by the connection.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The subnet ID used by the connection.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-physicalconnectionrequirements.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    physical_connection_requirements_property = glue.CfnConnection.PhysicalConnectionRequirementsProperty(\n        availability_zone="availabilityZone",\n        security_group_id_list=["securityGroupIdList"],\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'security_group_id_list', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnConnection.PhysicalConnectionRequirementsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.CatalogTargetProperty
class CfnCrawler_CatalogTargetPropertyDef(BaseStruct):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a ``Catalog`` connection type paired with a ``NETWORK`` Connection type.\n')
    database_name: typing.Optional[str] = pydantic.Field(None, description='The name of the database to be synchronized.\n')
    dlq_event_queue_arn: typing.Optional[str] = pydantic.Field(None, description='A valid Amazon dead-letter SQS ARN. For example, ``arn:aws:sqs:region:account:deadLetterQueue`` .\n')
    event_queue_arn: typing.Optional[str] = pydantic.Field(None, description='A valid Amazon SQS ARN. For example, ``arn:aws:sqs:region:account:sqs`` .\n')
    tables: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the tables to be synchronized.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-catalogtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    catalog_target_property = glue.CfnCrawler.CatalogTargetProperty(\n        connection_name="connectionName",\n        database_name="databaseName",\n        dlq_event_queue_arn="dlqEventQueueArn",\n        event_queue_arn="eventQueueArn",\n        tables=["tables"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_name', 'database_name', 'dlq_event_queue_arn', 'event_queue_arn', 'tables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.CatalogTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.DeltaTargetProperty
class CfnCrawler_DeltaTargetPropertyDef(BaseStruct):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection to use to connect to the Delta table target.\n')
    create_native_delta_table: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.\n')
    delta_tables: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the Amazon S3 paths to the Delta tables.\n')
    write_manifest: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether to write the manifest files to the Delta table path.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-deltatarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    delta_target_property = glue.CfnCrawler.DeltaTargetProperty(\n        connection_name="connectionName",\n        create_native_delta_table=False,\n        delta_tables=["deltaTables"],\n        write_manifest=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_name', 'create_native_delta_table', 'delta_tables', 'write_manifest']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.DeltaTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.DynamoDBTargetProperty
class CfnCrawler_DynamoDBTargetPropertyDef(BaseStruct):
    path: typing.Optional[str] = pydantic.Field(None, description='The name of the DynamoDB table to crawl.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-dynamodbtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    dynamo_dBTarget_property = glue.CfnCrawler.DynamoDBTargetProperty(\n        path="path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.DynamoDBTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.IcebergTargetProperty
class CfnCrawler_IcebergTargetPropertyDef(BaseStruct):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection to use to connect to the Iceberg target.\n')
    exclusions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of glob patterns used to exclude from the crawl. For more information, see `Catalog Tables with a Crawler <https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html>`_ .\n')
    maximum_traversal_depth: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Iceberg metadata folder in your Amazon S3 path. Used to limit the crawler run time.\n')
    paths: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='One or more Amazon S3 paths that contains Iceberg metadata folders as ``s3://bucket/prefix`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-icebergtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    iceberg_target_property = glue.CfnCrawler.IcebergTargetProperty(\n        connection_name="connectionName",\n        exclusions=["exclusions"],\n        maximum_traversal_depth=123,\n        paths=["paths"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_name', 'exclusions', 'maximum_traversal_depth', 'paths']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.IcebergTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.JdbcTargetProperty
class CfnCrawler_JdbcTargetPropertyDef(BaseStruct):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection to use to connect to the JDBC target.\n')
    exclusions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of glob patterns used to exclude from the crawl. For more information, see `Catalog Tables with a Crawler <https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html>`_ .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path of the JDBC target.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-jdbctarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    jdbc_target_property = glue.CfnCrawler.JdbcTargetProperty(\n        connection_name="connectionName",\n        exclusions=["exclusions"],\n        path="path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_name', 'exclusions', 'path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.JdbcTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.MongoDBTargetProperty
class CfnCrawler_MongoDBTargetPropertyDef(BaseStruct):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path of the Amazon DocumentDB or MongoDB target (database/collection).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-mongodbtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    mongo_dBTarget_property = glue.CfnCrawler.MongoDBTargetProperty(\n        connection_name="connectionName",\n        path="path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_name', 'path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.MongoDBTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.RecrawlPolicyProperty
class CfnCrawler_RecrawlPolicyPropertyDef(BaseStruct):
    recrawl_behavior: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run. A value of ``CRAWL_EVERYTHING`` specifies crawling the entire dataset again. A value of ``CRAWL_NEW_FOLDERS_ONLY`` specifies crawling only folders that were added since the last crawler run. A value of ``CRAWL_EVENT_MODE`` specifies crawling only the changes identified by Amazon S3 events.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-recrawlpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    recrawl_policy_property = glue.CfnCrawler.RecrawlPolicyProperty(\n        recrawl_behavior="recrawlBehavior"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['recrawl_behavior']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.RecrawlPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.S3TargetProperty
class CfnCrawler_S3TargetPropertyDef(BaseStruct):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).\n')
    dlq_event_queue_arn: typing.Optional[str] = pydantic.Field(None, description='A valid Amazon dead-letter SQS ARN. For example, ``arn:aws:sqs:region:account:deadLetterQueue`` .\n')
    event_queue_arn: typing.Optional[str] = pydantic.Field(None, description='A valid Amazon SQS ARN. For example, ``arn:aws:sqs:region:account:sqs`` .\n')
    exclusions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of glob patterns used to exclude from the crawl. For more information, see `Catalog Tables with a Crawler <https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html>`_ .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the Amazon S3 target.\n')
    sample_size: typing.Union[int, float, None] = pydantic.Field(None, description='Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-s3target.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    s3_target_property = glue.CfnCrawler.S3TargetProperty(\n        connection_name="connectionName",\n        dlq_event_queue_arn="dlqEventQueueArn",\n        event_queue_arn="eventQueueArn",\n        exclusions=["exclusions"],\n        path="path",\n        sample_size=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_name', 'dlq_event_queue_arn', 'event_queue_arn', 'exclusions', 'path', 'sample_size']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.S3TargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.ScheduleProperty
class CfnCrawler_SchedulePropertyDef(BaseStruct):
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='A ``cron`` expression used to specify the schedule. For more information, see `Time-Based Schedules for Jobs and Crawlers <https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html>`_ . For example, to run something every day at 12:15 UTC, specify ``cron(15 12 * * ? *)`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-schedule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    schedule_property = glue.CfnCrawler.ScheduleProperty(\n        schedule_expression="scheduleExpression"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schedule_expression']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.ScheduleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.SchemaChangePolicyProperty
class CfnCrawler_SchemaChangePolicyPropertyDef(BaseStruct):
    delete_behavior: typing.Optional[str] = pydantic.Field(None, description='The deletion behavior when the crawler finds a deleted object. A value of ``LOG`` specifies that if a table or partition is found to no longer exist, do not delete it, only log that it was found to no longer exist. A value of ``DELETE_FROM_DATABASE`` specifies that if a table or partition is found to have been removed, delete it from the database. A value of ``DEPRECATE_IN_DATABASE`` specifies that if a table has been found to no longer exist, to add a property to the table that says "DEPRECATED" and includes a timestamp with the time of deprecation.\n')
    update_behavior: typing.Optional[str] = pydantic.Field(None, description='The update behavior when the crawler finds a changed schema. A value of ``LOG`` specifies that if a table or a partition already exists, and a change is detected, do not update it, only log that a change was detected. Add new tables and new partitions (including on existing tables). A value of ``UPDATE_IN_DATABASE`` specifies that if a table or partition already exists, and a change is detected, update it. Add new tables and partitions.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-schemachangepolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    schema_change_policy_property = glue.CfnCrawler.SchemaChangePolicyProperty(\n        delete_behavior="deleteBehavior",\n        update_behavior="updateBehavior"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_behavior', 'update_behavior']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.SchemaChangePolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawler.TargetsProperty
class CfnCrawler_TargetsPropertyDef(BaseStruct):
    catalog_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_CatalogTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies AWS Glue Data Catalog targets.\n')
    delta_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_DeltaTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies an array of Delta data store targets.\n')
    dynamo_db_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_DynamoDBTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies Amazon DynamoDB targets.\n')
    iceberg_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_IcebergTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    jdbc_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_JdbcTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies JDBC targets.\n')
    mongo_db_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_MongoDBTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of Mongo DB targets.\n')
    s3_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_S3TargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies Amazon Simple Storage Service (Amazon S3) targets.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-targets.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    targets_property = glue.CfnCrawler.TargetsProperty(\n        catalog_targets=[glue.CfnCrawler.CatalogTargetProperty(\n            connection_name="connectionName",\n            database_name="databaseName",\n            dlq_event_queue_arn="dlqEventQueueArn",\n            event_queue_arn="eventQueueArn",\n            tables=["tables"]\n        )],\n        delta_targets=[glue.CfnCrawler.DeltaTargetProperty(\n            connection_name="connectionName",\n            create_native_delta_table=False,\n            delta_tables=["deltaTables"],\n            write_manifest=False\n        )],\n        dynamo_db_targets=[glue.CfnCrawler.DynamoDBTargetProperty(\n            path="path"\n        )],\n        iceberg_targets=[glue.CfnCrawler.IcebergTargetProperty(\n            connection_name="connectionName",\n            exclusions=["exclusions"],\n            maximum_traversal_depth=123,\n            paths=["paths"]\n        )],\n        jdbc_targets=[glue.CfnCrawler.JdbcTargetProperty(\n            connection_name="connectionName",\n            exclusions=["exclusions"],\n            path="path"\n        )],\n        mongo_db_targets=[glue.CfnCrawler.MongoDBTargetProperty(\n            connection_name="connectionName",\n            path="path"\n        )],\n        s3_targets=[glue.CfnCrawler.S3TargetProperty(\n            connection_name="connectionName",\n            dlq_event_queue_arn="dlqEventQueueArn",\n            event_queue_arn="eventQueueArn",\n            exclusions=["exclusions"],\n            path="path",\n            sample_size=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_targets', 'delta_targets', 'dynamo_db_targets', 'iceberg_targets', 'jdbc_targets', 'mongo_db_targets', 's3_targets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler.TargetsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDatabase.DatabaseIdentifierProperty
class CfnDatabase_DatabaseIdentifierPropertyDef(BaseStruct):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the Data Catalog in which the database resides.\n')
    database_name: typing.Optional[str] = pydantic.Field(None, description='The name of the catalog database.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region of the target database.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-database-databaseidentifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    database_identifier_property = glue.CfnDatabase.DatabaseIdentifierProperty(\n        catalog_id="catalogId",\n        database_name="databaseName",\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDatabase.DatabaseIdentifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDatabase.DatabaseInputProperty
class CfnDatabase_DatabaseInputPropertyDef(BaseStruct):
    create_table_default_permissions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnDatabase_PrincipalPrivilegesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Creates a set of default permissions on the table for principals. Used by AWS Lake Formation . Not used in the normal course of AWS Glue operations.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the database.\n')
    federated_database: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDatabase_FederatedDatabasePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A ``FederatedDatabase`` structure that references an entity outside the AWS Glue Data Catalog .\n')
    location_uri: typing.Optional[str] = pydantic.Field(None, description='The location of the database (for example, an HDFS path).\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.\n')
    parameters: typing.Any = pydantic.Field(None, description='These key-value pairs define parameters and properties of the database.\n')
    target_database: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDatabase_DatabaseIdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A ``DatabaseIdentifier`` structure that describes a target database for resource linking.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-database-databaseinput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n\n    database_input_property = glue.CfnDatabase.DatabaseInputProperty(\n        create_table_default_permissions=[glue.CfnDatabase.PrincipalPrivilegesProperty(\n            permissions=["permissions"],\n            principal=glue.CfnDatabase.DataLakePrincipalProperty(\n                data_lake_principal_identifier="dataLakePrincipalIdentifier"\n            )\n        )],\n        description="description",\n        federated_database=glue.CfnDatabase.FederatedDatabaseProperty(\n            connection_name="connectionName",\n            identifier="identifier"\n        ),\n        location_uri="locationUri",\n        name="name",\n        parameters=parameters,\n        target_database=glue.CfnDatabase.DatabaseIdentifierProperty(\n            catalog_id="catalogId",\n            database_name="databaseName",\n            region="region"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['create_table_default_permissions', 'description', 'federated_database', 'location_uri', 'name', 'parameters', 'target_database']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDatabase.DatabaseInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDatabase.DataLakePrincipalProperty
class CfnDatabase_DataLakePrincipalPropertyDef(BaseStruct):
    data_lake_principal_identifier: typing.Optional[str] = pydantic.Field(None, description='An identifier for the AWS Lake Formation principal.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-database-datalakeprincipal.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    data_lake_principal_property = glue.CfnDatabase.DataLakePrincipalProperty(\n        data_lake_principal_identifier="dataLakePrincipalIdentifier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_lake_principal_identifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDatabase.DataLakePrincipalProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDatabase.FederatedDatabaseProperty
class CfnDatabase_FederatedDatabasePropertyDef(BaseStruct):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection to the external metastore.\n')
    identifier: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for the federated database.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-database-federateddatabase.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    federated_database_property = glue.CfnDatabase.FederatedDatabaseProperty(\n        connection_name="connectionName",\n        identifier="identifier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_name', 'identifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDatabase.FederatedDatabaseProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDatabase.PrincipalPrivilegesProperty
class CfnDatabase_PrincipalPrivilegesPropertyDef(BaseStruct):
    permissions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The permissions that are granted to the principal.\n')
    principal: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDatabase_DataLakePrincipalPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The principal who is granted permissions.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-database-principalprivileges.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    principal_privileges_property = glue.CfnDatabase.PrincipalPrivilegesProperty(\n        permissions=["permissions"],\n        principal=glue.CfnDatabase.DataLakePrincipalProperty(\n            data_lake_principal_identifier="dataLakePrincipalIdentifier"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['permissions', 'principal']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDatabase.PrincipalPrivilegesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDataCatalogEncryptionSettings.ConnectionPasswordEncryptionProperty
class CfnDataCatalogEncryptionSettings_ConnectionPasswordEncryptionPropertyDef(BaseStruct):
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='An AWS KMS key that is used to encrypt the connection password. If connection password protection is enabled, the caller of ``CreateConnection`` and ``UpdateConnection`` needs at least ``kms:Encrypt`` permission on the specified AWS KMS key, to encrypt passwords before storing them in the Data Catalog. You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.\n')
    return_connection_password_encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='When the ``ReturnConnectionPasswordEncrypted`` flag is set to "true", passwords remain encrypted in the responses of ``GetConnection`` and ``GetConnections`` . This encryption takes effect independently from catalog encryption.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-datacatalogencryptionsettings-connectionpasswordencryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    connection_password_encryption_property = glue.CfnDataCatalogEncryptionSettings.ConnectionPasswordEncryptionProperty(\n        kms_key_id="kmsKeyId",\n        return_connection_password_encrypted=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['kms_key_id', 'return_connection_password_encrypted']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDataCatalogEncryptionSettings.ConnectionPasswordEncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDataCatalogEncryptionSettings.DataCatalogEncryptionSettingsProperty
class CfnDataCatalogEncryptionSettings_DataCatalogEncryptionSettingsPropertyDef(BaseStruct):
    connection_password_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDataCatalogEncryptionSettings_ConnectionPasswordEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of ``CreateConnection`` or ``UpdateConnection`` and store it in the ``ENCRYPTED_PASSWORD`` field in the connection properties. You can enable catalog encryption or only password encryption.\n')
    encryption_at_rest: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDataCatalogEncryptionSettings_EncryptionAtRestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the encryption-at-rest configuration for the Data Catalog.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-datacatalogencryptionsettings-datacatalogencryptionsettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    data_catalog_encryption_settings_property = glue.CfnDataCatalogEncryptionSettings.DataCatalogEncryptionSettingsProperty(\n        connection_password_encryption=glue.CfnDataCatalogEncryptionSettings.ConnectionPasswordEncryptionProperty(\n            kms_key_id="kmsKeyId",\n            return_connection_password_encrypted=False\n        ),\n        encryption_at_rest=glue.CfnDataCatalogEncryptionSettings.EncryptionAtRestProperty(\n            catalog_encryption_mode="catalogEncryptionMode",\n            sse_aws_kms_key_id="sseAwsKmsKeyId"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_password_encryption', 'encryption_at_rest']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDataCatalogEncryptionSettings.DataCatalogEncryptionSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDataCatalogEncryptionSettings.EncryptionAtRestProperty
class CfnDataCatalogEncryptionSettings_EncryptionAtRestPropertyDef(BaseStruct):
    catalog_encryption_mode: typing.Optional[str] = pydantic.Field(None, description='The encryption-at-rest mode for encrypting Data Catalog data.\n')
    sse_aws_kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS KMS key to use for encryption at rest.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-datacatalogencryptionsettings-encryptionatrest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    encryption_at_rest_property = glue.CfnDataCatalogEncryptionSettings.EncryptionAtRestProperty(\n        catalog_encryption_mode="catalogEncryptionMode",\n        sse_aws_kms_key_id="sseAwsKmsKeyId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_encryption_mode', 'sse_aws_kms_key_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDataCatalogEncryptionSettings.EncryptionAtRestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDataQualityRuleset.DataQualityTargetTableProperty
class CfnDataQualityRuleset_DataQualityTargetTablePropertyDef(BaseStruct):
    database_name: typing.Optional[str] = pydantic.Field(None, description='The name of the database where the AWS Glue table exists.\n')
    table_name: typing.Optional[str] = pydantic.Field(None, description='The name of the AWS Glue table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-dataqualityruleset-dataqualitytargettable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    data_quality_target_table_property = glue.CfnDataQualityRuleset.DataQualityTargetTableProperty(\n        database_name="databaseName",\n        table_name="tableName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'table_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDataQualityRuleset.DataQualityTargetTableProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnJob.ConnectionsListProperty
class CfnJob_ConnectionsListPropertyDef(BaseStruct):
    connections: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of connections used by the job.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-job-connectionslist.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    connections_list_property = glue.CfnJob.ConnectionsListProperty(\n        connections=["connections"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connections']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnJob.ConnectionsListProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnJob.ExecutionPropertyProperty
class CfnJob_ExecutionPropertyPropertyDef(BaseStruct):
    max_concurrent_runs: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-job-executionproperty.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    execution_property_property = glue.CfnJob.ExecutionPropertyProperty(\n        max_concurrent_runs=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_concurrent_runs']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnJob.ExecutionPropertyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnJob.JobCommandProperty
class CfnJob_JobCommandPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the job command. For an Apache Spark ETL job, this must be ``glueetl`` . For a Python shell job, it must be ``pythonshell`` . For an Apache Spark streaming ETL job, this must be ``gluestreaming`` . For a Ray job, this must be ``glueray`` .\n')
    python_version: typing.Optional[str] = pydantic.Field(None, description='The Python version being used to execute a Python shell job. Allowed values are 3 or 3.9. Version 2 is deprecated.\n')
    runtime: typing.Optional[str] = pydantic.Field(None, description='In Ray jobs, Runtime is used to specify the versions of Ray, Python and additional libraries available in your environment. This field is not used in other job types. For supported runtime environment values, see `Working with Ray jobs <https://docs.aws.amazon.com/glue/latest/dg/ray-jobs-section.html>`_ in the AWS Glue Developer Guide.\n')
    script_location: typing.Optional[str] = pydantic.Field(None, description='Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that executes a job (required).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-job-jobcommand.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    job_command_property = glue.CfnJob.JobCommandProperty(\n        name="name",\n        python_version="pythonVersion",\n        runtime="runtime",\n        script_location="scriptLocation"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'python_version', 'runtime', 'script_location']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnJob.JobCommandProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnJob.NotificationPropertyProperty
class CfnJob_NotificationPropertyPropertyDef(BaseStruct):
    notify_delay_after: typing.Union[int, float, None] = pydantic.Field(None, description='After a job run starts, the number of minutes to wait before sending a job run delay notification.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-job-notificationproperty.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    notification_property_property = glue.CfnJob.NotificationPropertyProperty(\n        notify_delay_after=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['notify_delay_after']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnJob.NotificationPropertyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnMLTransform.FindMatchesParametersProperty
class CfnMLTransform_FindMatchesParametersPropertyDef(BaseStruct):
    primary_key_column_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.\n')
    accuracy_cost_tradeoff: typing.Union[int, float, None] = pydantic.Field(None, description='The value that is selected when tuning your transform for a balance between accuracy and cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A value of 0.0 means a bias purely for cost, which results in a less accurate ``FindMatches`` transform, sometimes with unacceptable accuracy. Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall. Cost measures how many compute resources, and thus money, are consumed to run the transform.\n')
    enforce_provided_labels: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The value to switch on or off to force the output to match the provided labels from users. If the value is ``True`` , the ``find matches`` transform forces the output to match the provided labels. The results override the normal conflation results. If the value is ``False`` , the ``find matches`` transform does not ensure all the labels provided are respected, and the results rely on the trained model. Note that setting this value to true may increase the conflation execution time.\n')
    precision_recall_tradeoff: typing.Union[int, float, None] = pydantic.Field(None, description='The value selected when tuning your transform for a balance between precision and recall. A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall, and choosing values close to 0.0 results in very low precision. The precision metric indicates how often your model is correct when it predicts a match. The recall metric indicates that for an actual match, how often your model predicts the match.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-mltransform-findmatchesparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    find_matches_parameters_property = glue.CfnMLTransform.FindMatchesParametersProperty(\n        primary_key_column_name="primaryKeyColumnName",\n\n        # the properties below are optional\n        accuracy_cost_tradeoff=123,\n        enforce_provided_labels=False,\n        precision_recall_tradeoff=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['primary_key_column_name', 'accuracy_cost_tradeoff', 'enforce_provided_labels', 'precision_recall_tradeoff']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnMLTransform.FindMatchesParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnMLTransform.GlueTablesProperty
class CfnMLTransform_GlueTablesPropertyDef(BaseStruct):
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A database name in the AWS Glue Data Catalog .\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A table name in the AWS Glue Data Catalog .\n')
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for the AWS Glue Data Catalog .\n')
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection to the AWS Glue Data Catalog .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-mltransform-gluetables.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    glue_tables_property = glue.CfnMLTransform.GlueTablesProperty(\n        database_name="databaseName",\n        table_name="tableName",\n\n        # the properties below are optional\n        catalog_id="catalogId",\n        connection_name="connectionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'table_name', 'catalog_id', 'connection_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnMLTransform.GlueTablesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnMLTransform.InputRecordTablesProperty
class CfnMLTransform_InputRecordTablesPropertyDef(BaseStruct):
    glue_tables: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnMLTransform_GlueTablesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The database and table in the AWS Glue Data Catalog that is used for input or output data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-mltransform-inputrecordtables.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    input_record_tables_property = glue.CfnMLTransform.InputRecordTablesProperty(\n        glue_tables=[glue.CfnMLTransform.GlueTablesProperty(\n            database_name="databaseName",\n            table_name="tableName",\n\n            # the properties below are optional\n            catalog_id="catalogId",\n            connection_name="connectionName"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['glue_tables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnMLTransform.InputRecordTablesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnMLTransform.MLUserDataEncryptionProperty
class CfnMLTransform_MLUserDataEncryptionPropertyDef(BaseStruct):
    ml_user_data_encryption_mode: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The encryption mode applied to user data. Valid values are:. - DISABLED: encryption is disabled. - SSEKMS: use of server-side encryption with AWS Key Management Service (SSE-KMS) for user data stored in Amazon S3.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID for the customer-provided KMS key.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-mltransform-mluserdataencryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    m_lUser_data_encryption_property = glue.CfnMLTransform.MLUserDataEncryptionProperty(\n        ml_user_data_encryption_mode="mlUserDataEncryptionMode",\n\n        # the properties below are optional\n        kms_key_id="kmsKeyId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ml_user_data_encryption_mode', 'kms_key_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnMLTransform.MLUserDataEncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnMLTransform.TransformEncryptionProperty
class CfnMLTransform_TransformEncryptionPropertyDef(BaseStruct):
    ml_user_data_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnMLTransform_MLUserDataEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption-at-rest settings of the transform that apply to accessing user data.\n')
    task_run_security_configuration_name: typing.Optional[str] = pydantic.Field(None, description='The name of the security configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-mltransform-transformencryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    transform_encryption_property = glue.CfnMLTransform.TransformEncryptionProperty(\n        ml_user_data_encryption=glue.CfnMLTransform.MLUserDataEncryptionProperty(\n            ml_user_data_encryption_mode="mlUserDataEncryptionMode",\n\n            # the properties below are optional\n            kms_key_id="kmsKeyId"\n        ),\n        task_run_security_configuration_name="taskRunSecurityConfigurationName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ml_user_data_encryption', 'task_run_security_configuration_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnMLTransform.TransformEncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnMLTransform.TransformParametersProperty
class CfnMLTransform_TransformParametersPropertyDef(BaseStruct):
    transform_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of machine learning transform. ``FIND_MATCHES`` is the only option. For information about the types of machine learning transforms, see `Creating Machine Learning Transforms <https://docs.aws.amazon.com/glue/latest/dg/add-job-machine-learning-transform.html>`_ .\n')
    find_matches_parameters: typing.Union[models.UnsupportedResource, models.aws_glue.CfnMLTransform_FindMatchesParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters for the find matches algorithm.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-mltransform-transformparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    transform_parameters_property = glue.CfnMLTransform.TransformParametersProperty(\n        transform_type="transformType",\n\n        # the properties below are optional\n        find_matches_parameters=glue.CfnMLTransform.FindMatchesParametersProperty(\n            primary_key_column_name="primaryKeyColumnName",\n\n            # the properties below are optional\n            accuracy_cost_tradeoff=123,\n            enforce_provided_labels=False,\n            precision_recall_tradeoff=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['transform_type', 'find_matches_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnMLTransform.TransformParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartition.ColumnProperty
class CfnPartition_ColumnPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the ``Column`` .\n')
    comment: typing.Optional[str] = pydantic.Field(None, description='A free-form text comment.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The data type of the ``Column`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-partition-column.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    column_property = glue.CfnPartition.ColumnProperty(\n        name="name",\n\n        # the properties below are optional\n        comment="comment",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'comment', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition.ColumnProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartition.OrderProperty
class CfnPartition_OrderPropertyDef(BaseStruct):
    column: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the column.\n')
    sort_order: typing.Union[int, float, None] = pydantic.Field(None, description='Indicates that the column is sorted in ascending order ( ``== 1`` ), or in descending order ( ``==0`` ).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-partition-order.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    order_property = glue.CfnPartition.OrderProperty(\n        column="column",\n\n        # the properties below are optional\n        sort_order=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['column', 'sort_order']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition.OrderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartition.PartitionInputProperty
class CfnPartition_PartitionInputPropertyDef(BaseStruct):
    values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input. The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise AWS Glue will add the values to the wrong keys.\n')
    parameters: typing.Any = pydantic.Field(None, description='These key-value pairs define partition parameters.\n')
    storage_descriptor: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_StorageDescriptorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Provides information about the physical location where the partition is stored.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-partition-partitioninput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n    # skewed_column_value_location_maps: Any\n\n    partition_input_property = glue.CfnPartition.PartitionInputProperty(\n        values=["values"],\n\n        # the properties below are optional\n        parameters=parameters,\n        storage_descriptor=glue.CfnPartition.StorageDescriptorProperty(\n            bucket_columns=["bucketColumns"],\n            columns=[glue.CfnPartition.ColumnProperty(\n                name="name",\n\n                # the properties below are optional\n                comment="comment",\n                type="type"\n            )],\n            compressed=False,\n            input_format="inputFormat",\n            location="location",\n            number_of_buckets=123,\n            output_format="outputFormat",\n            parameters=parameters,\n            schema_reference=glue.CfnPartition.SchemaReferenceProperty(\n                schema_id=glue.CfnPartition.SchemaIdProperty(\n                    registry_name="registryName",\n                    schema_arn="schemaArn",\n                    schema_name="schemaName"\n                ),\n                schema_version_id="schemaVersionId",\n                schema_version_number=123\n            ),\n            serde_info=glue.CfnPartition.SerdeInfoProperty(\n                name="name",\n                parameters=parameters,\n                serialization_library="serializationLibrary"\n            ),\n            skewed_info=glue.CfnPartition.SkewedInfoProperty(\n                skewed_column_names=["skewedColumnNames"],\n                skewed_column_value_location_maps=skewed_column_value_location_maps,\n                skewed_column_values=["skewedColumnValues"]\n            ),\n            sort_columns=[glue.CfnPartition.OrderProperty(\n                column="column",\n\n                # the properties below are optional\n                sort_order=123\n            )],\n            stored_as_sub_directories=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['values', 'parameters', 'storage_descriptor']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition.PartitionInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartition.SchemaIdProperty
class CfnPartition_SchemaIdPropertyDef(BaseStruct):
    registry_name: typing.Optional[str] = pydantic.Field(None, description='The name of the schema registry that contains the schema.\n')
    schema_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the schema. One of ``SchemaArn`` or ``SchemaName`` has to be provided.\n')
    schema_name: typing.Optional[str] = pydantic.Field(None, description='The name of the schema. One of ``SchemaArn`` or ``SchemaName`` has to be provided.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-partition-schemaid.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    schema_id_property = glue.CfnPartition.SchemaIdProperty(\n        registry_name="registryName",\n        schema_arn="schemaArn",\n        schema_name="schemaName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['registry_name', 'schema_arn', 'schema_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition.SchemaIdProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartition.SchemaReferenceProperty
class CfnPartition_SchemaReferencePropertyDef(BaseStruct):
    schema_id: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_SchemaIdPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure that contains schema identity fields. Either this or the ``SchemaVersionId`` has to be provided.\n')
    schema_version_id: typing.Optional[str] = pydantic.Field(None, description='The unique ID assigned to a version of the schema. Either this or the ``SchemaId`` has to be provided.\n')
    schema_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the schema.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-partition-schemareference.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    schema_reference_property = glue.CfnPartition.SchemaReferenceProperty(\n        schema_id=glue.CfnPartition.SchemaIdProperty(\n            registry_name="registryName",\n            schema_arn="schemaArn",\n            schema_name="schemaName"\n        ),\n        schema_version_id="schemaVersionId",\n        schema_version_number=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schema_id', 'schema_version_id', 'schema_version_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition.SchemaReferenceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartition.SerdeInfoProperty
class CfnPartition_SerdeInfoPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='Name of the SerDe.\n')
    parameters: typing.Any = pydantic.Field(None, description='These key-value pairs define initialization parameters for the SerDe.\n')
    serialization_library: typing.Optional[str] = pydantic.Field(None, description='Usually the class that implements the SerDe. An example is ``org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-partition-serdeinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n\n    serde_info_property = glue.CfnPartition.SerdeInfoProperty(\n        name="name",\n        parameters=parameters,\n        serialization_library="serializationLibrary"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'parameters', 'serialization_library']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition.SerdeInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartition.SkewedInfoProperty
class CfnPartition_SkewedInfoPropertyDef(BaseStruct):
    skewed_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of names of columns that contain skewed values.\n')
    skewed_column_value_location_maps: typing.Any = pydantic.Field(None, description='A mapping of skewed values to the columns that contain them.\n')
    skewed_column_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of values that appear so frequently as to be considered skewed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-partition-skewedinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # skewed_column_value_location_maps: Any\n\n    skewed_info_property = glue.CfnPartition.SkewedInfoProperty(\n        skewed_column_names=["skewedColumnNames"],\n        skewed_column_value_location_maps=skewed_column_value_location_maps,\n        skewed_column_values=["skewedColumnValues"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['skewed_column_names', 'skewed_column_value_location_maps', 'skewed_column_values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition.SkewedInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartition.StorageDescriptorProperty
class CfnPartition_StorageDescriptorPropertyDef(BaseStruct):
    bucket_columns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of reducer grouping columns, clustering columns, and bucketing columns in the table.\n')
    columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_ColumnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of the ``Columns`` in the table.\n')
    compressed: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='``True`` if the data in the table is compressed, or ``False`` if not.\n')
    input_format: typing.Optional[str] = pydantic.Field(None, description='The input format: ``SequenceFileInputFormat`` (binary), or ``TextInputFormat`` , or a custom format.\n')
    location: typing.Optional[str] = pydantic.Field(None, description='The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.\n')
    number_of_buckets: typing.Union[int, float, None] = pydantic.Field(None, description='The number of buckets. You must specify this property if the partition contains any dimension columns.\n')
    output_format: typing.Optional[str] = pydantic.Field(None, description='The output format: ``SequenceFileOutputFormat`` (binary), or ``IgnoreKeyTextOutputFormat`` , or a custom format.\n')
    parameters: typing.Any = pydantic.Field(None, description='The user-supplied properties in key-value form.\n')
    schema_reference: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_SchemaReferencePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that references a schema stored in the AWS Glue Schema Registry.\n')
    serde_info: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_SerdeInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The serialization/deserialization (SerDe) information.\n')
    skewed_info: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_SkewedInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The information about values that appear frequently in a column (skewed values).\n')
    sort_columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_OrderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list specifying the sort order of each bucket in the table.\n')
    stored_as_sub_directories: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='``True`` if the table data is stored in subdirectories, or ``False`` if not.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-partition-storagedescriptor.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n    # skewed_column_value_location_maps: Any\n\n    storage_descriptor_property = glue.CfnPartition.StorageDescriptorProperty(\n        bucket_columns=["bucketColumns"],\n        columns=[glue.CfnPartition.ColumnProperty(\n            name="name",\n\n            # the properties below are optional\n            comment="comment",\n            type="type"\n        )],\n        compressed=False,\n        input_format="inputFormat",\n        location="location",\n        number_of_buckets=123,\n        output_format="outputFormat",\n        parameters=parameters,\n        schema_reference=glue.CfnPartition.SchemaReferenceProperty(\n            schema_id=glue.CfnPartition.SchemaIdProperty(\n                registry_name="registryName",\n                schema_arn="schemaArn",\n                schema_name="schemaName"\n            ),\n            schema_version_id="schemaVersionId",\n            schema_version_number=123\n        ),\n        serde_info=glue.CfnPartition.SerdeInfoProperty(\n            name="name",\n            parameters=parameters,\n            serialization_library="serializationLibrary"\n        ),\n        skewed_info=glue.CfnPartition.SkewedInfoProperty(\n            skewed_column_names=["skewedColumnNames"],\n            skewed_column_value_location_maps=skewed_column_value_location_maps,\n            skewed_column_values=["skewedColumnValues"]\n        ),\n        sort_columns=[glue.CfnPartition.OrderProperty(\n            column="column",\n\n            # the properties below are optional\n            sort_order=123\n        )],\n        stored_as_sub_directories=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_columns', 'columns', 'compressed', 'input_format', 'location', 'number_of_buckets', 'output_format', 'parameters', 'schema_reference', 'serde_info', 'skewed_info', 'sort_columns', 'stored_as_sub_directories']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition.StorageDescriptorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSchema.RegistryProperty
class CfnSchema_RegistryPropertyDef(BaseStruct):
    arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the registry.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the registry.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-schema-registry.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    registry_property = glue.CfnSchema.RegistryProperty(\n        arn="arn",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchema.RegistryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSchema.SchemaVersionProperty
class CfnSchema_SchemaVersionPropertyDef(BaseStruct):
    is_latest: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates if this version is the latest version of the schema.\n')
    version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the schema.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-schema-schemaversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    schema_version_property = glue.CfnSchema.SchemaVersionProperty(\n        is_latest=False,\n        version_number=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['is_latest', 'version_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchema.SchemaVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSchemaVersion.SchemaProperty
class CfnSchemaVersion_SchemaPropertyDef(BaseStruct):
    registry_name: typing.Optional[str] = pydantic.Field(None, description='The name of the registry where the schema is stored. Either ``SchemaArn`` , or ``SchemaName`` and ``RegistryName`` has to be provided.\n')
    schema_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the schema. Either ``SchemaArn`` , or ``SchemaName`` and ``RegistryName`` has to be provided.\n')
    schema_name: typing.Optional[str] = pydantic.Field(None, description='The name of the schema. Either ``SchemaArn`` , or ``SchemaName`` and ``RegistryName`` has to be provided.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-schemaversion-schema.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    schema_property = glue.CfnSchemaVersion.SchemaProperty(\n        registry_name="registryName",\n        schema_arn="schemaArn",\n        schema_name="schemaName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['registry_name', 'schema_arn', 'schema_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchemaVersion.SchemaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSecurityConfiguration.CloudWatchEncryptionProperty
class CfnSecurityConfiguration_CloudWatchEncryptionPropertyDef(BaseStruct):
    cloud_watch_encryption_mode: typing.Optional[str] = pydantic.Field(None, description='The encryption mode to use for CloudWatch data.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-cloudwatchencryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    cloud_watch_encryption_property = glue.CfnSecurityConfiguration.CloudWatchEncryptionProperty(\n        cloud_watch_encryption_mode="cloudWatchEncryptionMode",\n        kms_key_arn="kmsKeyArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_encryption_mode', 'kms_key_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSecurityConfiguration.CloudWatchEncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSecurityConfiguration.EncryptionConfigurationProperty
class CfnSecurityConfiguration_EncryptionConfigurationPropertyDef(BaseStruct):
    cloud_watch_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnSecurityConfiguration_CloudWatchEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption configuration for Amazon CloudWatch.\n')
    job_bookmarks_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnSecurityConfiguration_JobBookmarksEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption configuration for job bookmarks.\n')
    s3_encryptions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnSecurityConfiguration_S3EncryptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The encyption configuration for Amazon Simple Storage Service (Amazon S3) data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-encryptionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    encryption_configuration_property = glue.CfnSecurityConfiguration.EncryptionConfigurationProperty(\n        cloud_watch_encryption=glue.CfnSecurityConfiguration.CloudWatchEncryptionProperty(\n            cloud_watch_encryption_mode="cloudWatchEncryptionMode",\n            kms_key_arn="kmsKeyArn"\n        ),\n        job_bookmarks_encryption=glue.CfnSecurityConfiguration.JobBookmarksEncryptionProperty(\n            job_bookmarks_encryption_mode="jobBookmarksEncryptionMode",\n            kms_key_arn="kmsKeyArn"\n        ),\n        s3_encryptions=[glue.CfnSecurityConfiguration.S3EncryptionProperty(\n            kms_key_arn="kmsKeyArn",\n            s3_encryption_mode="s3EncryptionMode"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_encryption', 'job_bookmarks_encryption', 's3_encryptions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSecurityConfiguration.EncryptionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSecurityConfiguration.JobBookmarksEncryptionProperty
class CfnSecurityConfiguration_JobBookmarksEncryptionPropertyDef(BaseStruct):
    job_bookmarks_encryption_mode: typing.Optional[str] = pydantic.Field(None, description='The encryption mode to use for job bookmarks data.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-jobbookmarksencryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    job_bookmarks_encryption_property = glue.CfnSecurityConfiguration.JobBookmarksEncryptionProperty(\n        job_bookmarks_encryption_mode="jobBookmarksEncryptionMode",\n        kms_key_arn="kmsKeyArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['job_bookmarks_encryption_mode', 'kms_key_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSecurityConfiguration.JobBookmarksEncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSecurityConfiguration.S3EncryptionProperty
class CfnSecurityConfiguration_S3EncryptionPropertyDef(BaseStruct):
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.\n')
    s3_encryption_mode: typing.Optional[str] = pydantic.Field(None, description='The encryption mode to use for Amazon S3 data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-s3encryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    s3_encryption_property = glue.CfnSecurityConfiguration.S3EncryptionProperty(\n        kms_key_arn="kmsKeyArn",\n        s3_encryption_mode="s3EncryptionMode"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['kms_key_arn', 's3_encryption_mode']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSecurityConfiguration.S3EncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.ColumnProperty
class CfnTable_ColumnPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the ``Column`` .\n')
    comment: typing.Optional[str] = pydantic.Field(None, description='A free-form text comment.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The data type of the ``Column`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-column.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    column_property = glue.CfnTable.ColumnProperty(\n        name="name",\n\n        # the properties below are optional\n        comment="comment",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'comment', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.ColumnProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.IcebergInputProperty
class CfnTable_IcebergInputPropertyDef(BaseStruct):
    metadata_operation: typing.Optional[str] = pydantic.Field(None, description='A required metadata operation. Can only be set to ``CREATE`` .\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The table version for the Iceberg table. Defaults to 2.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-iceberginput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    iceberg_input_property = glue.CfnTable.IcebergInputProperty(\n        metadata_operation="metadataOperation",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metadata_operation', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.IcebergInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.OpenTableFormatInputProperty
class CfnTable_OpenTableFormatInputPropertyDef(BaseStruct):
    iceberg_input: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_IcebergInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies an ``IcebergInput`` structure that defines an Apache Iceberg metadata table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-opentableformatinput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    open_table_format_input_property = glue.CfnTable.OpenTableFormatInputProperty(\n        iceberg_input=glue.CfnTable.IcebergInputProperty(\n            metadata_operation="metadataOperation",\n            version="version"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['iceberg_input']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.OpenTableFormatInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.OrderProperty
class CfnTable_OrderPropertyDef(BaseStruct):
    column: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the column.\n')
    sort_order: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates that the column is sorted in ascending order ( ``== 1`` ), or in descending order ( ``==0`` ).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-order.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    order_property = glue.CfnTable.OrderProperty(\n        column="column",\n        sort_order=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['column', 'sort_order']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.OrderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.SchemaIdProperty
class CfnTable_SchemaIdPropertyDef(BaseStruct):
    registry_name: typing.Optional[str] = pydantic.Field(None, description='The name of the schema registry that contains the schema.\n')
    schema_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the schema. One of ``SchemaArn`` or ``SchemaName`` has to be provided.\n')
    schema_name: typing.Optional[str] = pydantic.Field(None, description='The name of the schema. One of ``SchemaArn`` or ``SchemaName`` has to be provided.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-schemaid.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    schema_id_property = glue.CfnTable.SchemaIdProperty(\n        registry_name="registryName",\n        schema_arn="schemaArn",\n        schema_name="schemaName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['registry_name', 'schema_arn', 'schema_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.SchemaIdProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.SchemaReferenceProperty
class CfnTable_SchemaReferencePropertyDef(BaseStruct):
    schema_id: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_SchemaIdPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure that contains schema identity fields. Either this or the ``SchemaVersionId`` has to be provided.\n')
    schema_version_id: typing.Optional[str] = pydantic.Field(None, description='The unique ID assigned to a version of the schema. Either this or the ``SchemaId`` has to be provided.\n')
    schema_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the schema.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-schemareference.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    schema_reference_property = glue.CfnTable.SchemaReferenceProperty(\n        schema_id=glue.CfnTable.SchemaIdProperty(\n            registry_name="registryName",\n            schema_arn="schemaArn",\n            schema_name="schemaName"\n        ),\n        schema_version_id="schemaVersionId",\n        schema_version_number=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schema_id', 'schema_version_id', 'schema_version_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.SchemaReferenceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.SerdeInfoProperty
class CfnTable_SerdeInfoPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='Name of the SerDe.\n')
    parameters: typing.Any = pydantic.Field(None, description='These key-value pairs define initialization parameters for the SerDe.\n')
    serialization_library: typing.Optional[str] = pydantic.Field(None, description='Usually the class that implements the SerDe. An example is ``org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-serdeinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n\n    serde_info_property = glue.CfnTable.SerdeInfoProperty(\n        name="name",\n        parameters=parameters,\n        serialization_library="serializationLibrary"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'parameters', 'serialization_library']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.SerdeInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.SkewedInfoProperty
class CfnTable_SkewedInfoPropertyDef(BaseStruct):
    skewed_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of names of columns that contain skewed values.\n')
    skewed_column_value_location_maps: typing.Any = pydantic.Field(None, description='A mapping of skewed values to the columns that contain them.\n')
    skewed_column_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of values that appear so frequently as to be considered skewed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-skewedinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # skewed_column_value_location_maps: Any\n\n    skewed_info_property = glue.CfnTable.SkewedInfoProperty(\n        skewed_column_names=["skewedColumnNames"],\n        skewed_column_value_location_maps=skewed_column_value_location_maps,\n        skewed_column_values=["skewedColumnValues"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['skewed_column_names', 'skewed_column_value_location_maps', 'skewed_column_values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.SkewedInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.StorageDescriptorProperty
class CfnTable_StorageDescriptorPropertyDef(BaseStruct):
    bucket_columns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of reducer grouping columns, clustering columns, and bucketing columns in the table.\n')
    columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_ColumnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of the ``Columns`` in the table.\n')
    compressed: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='``True`` if the data in the table is compressed, or ``False`` if not.\n')
    input_format: typing.Optional[str] = pydantic.Field(None, description='The input format: ``SequenceFileInputFormat`` (binary), or ``TextInputFormat`` , or a custom format.\n')
    location: typing.Optional[str] = pydantic.Field(None, description='The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.\n')
    number_of_buckets: typing.Union[int, float, None] = pydantic.Field(None, description='Must be specified if the table contains any dimension columns.\n')
    output_format: typing.Optional[str] = pydantic.Field(None, description='The output format: ``SequenceFileOutputFormat`` (binary), or ``IgnoreKeyTextOutputFormat`` , or a custom format.\n')
    parameters: typing.Any = pydantic.Field(None, description='The user-supplied properties in key-value form.\n')
    schema_reference: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_SchemaReferencePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that references a schema stored in the AWS Glue Schema Registry.\n')
    serde_info: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_SerdeInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The serialization/deserialization (SerDe) information.\n')
    skewed_info: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_SkewedInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The information about values that appear frequently in a column (skewed values).\n')
    sort_columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_OrderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list specifying the sort order of each bucket in the table.\n')
    stored_as_sub_directories: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='``True`` if the table data is stored in subdirectories, or ``False`` if not.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n    # skewed_column_value_location_maps: Any\n\n    storage_descriptor_property = glue.CfnTable.StorageDescriptorProperty(\n        bucket_columns=["bucketColumns"],\n        columns=[glue.CfnTable.ColumnProperty(\n            name="name",\n\n            # the properties below are optional\n            comment="comment",\n            type="type"\n        )],\n        compressed=False,\n        input_format="inputFormat",\n        location="location",\n        number_of_buckets=123,\n        output_format="outputFormat",\n        parameters=parameters,\n        schema_reference=glue.CfnTable.SchemaReferenceProperty(\n            schema_id=glue.CfnTable.SchemaIdProperty(\n                registry_name="registryName",\n                schema_arn="schemaArn",\n                schema_name="schemaName"\n            ),\n            schema_version_id="schemaVersionId",\n            schema_version_number=123\n        ),\n        serde_info=glue.CfnTable.SerdeInfoProperty(\n            name="name",\n            parameters=parameters,\n            serialization_library="serializationLibrary"\n        ),\n        skewed_info=glue.CfnTable.SkewedInfoProperty(\n            skewed_column_names=["skewedColumnNames"],\n            skewed_column_value_location_maps=skewed_column_value_location_maps,\n            skewed_column_values=["skewedColumnValues"]\n        ),\n        sort_columns=[glue.CfnTable.OrderProperty(\n            column="column",\n            sort_order=123\n        )],\n        stored_as_sub_directories=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_columns', 'columns', 'compressed', 'input_format', 'location', 'number_of_buckets', 'output_format', 'parameters', 'schema_reference', 'serde_info', 'skewed_info', 'sort_columns', 'stored_as_sub_directories']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.StorageDescriptorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.TableIdentifierProperty
class CfnTable_TableIdentifierPropertyDef(BaseStruct):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the Data Catalog in which the table resides.\n')
    database_name: typing.Optional[str] = pydantic.Field(None, description='The name of the catalog database that contains the target table.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the target table.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region of the target table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableidentifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    table_identifier_property = glue.CfnTable.TableIdentifierProperty(\n        catalog_id="catalogId",\n        database_name="databaseName",\n        name="name",\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'name', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.TableIdentifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTable.TableInputProperty
class CfnTable_TableInputPropertyDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the table.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The table name. For Hive compatibility, this is folded to lowercase when it is stored.\n')
    owner: typing.Optional[str] = pydantic.Field(None, description='The table owner. Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.\n')
    parameters: typing.Any = pydantic.Field(None, description='These key-value pairs define properties associated with the table.\n')
    partition_keys: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_ColumnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When you create a table used by Amazon Athena, and you do not specify any ``partitionKeys`` , you must at least set the value of ``partitionKeys`` to an empty list. For example: ``"PartitionKeys": []``\n')
    retention: typing.Union[int, float, None] = pydantic.Field(None, description='The retention time for this table.\n')
    storage_descriptor: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_StorageDescriptorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A storage descriptor containing information about the physical storage of this table.\n')
    table_type: typing.Optional[str] = pydantic.Field(None, description='The type of this table. AWS Glue will create tables with the ``EXTERNAL_TABLE`` type. Other services, such as Athena, may create tables with additional table types. AWS Glue related table types: - **EXTERNAL_TABLE** - Hive compatible attribute - indicates a non-Hive managed table. - **GOVERNED** - Used by AWS Lake Formation . The AWS Glue Data Catalog understands ``GOVERNED`` .\n')
    target_table: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_TableIdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A ``TableIdentifier`` structure that describes a target table for resource linking.\n')
    view_expanded_text: typing.Optional[str] = pydantic.Field(None, description='Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.\n')
    view_original_text: typing.Optional[str] = pydantic.Field(None, description='Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations. If the table is a ``VIRTUAL_VIEW`` , certain Athena configuration encoded in base64.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n    # skewed_column_value_location_maps: Any\n\n    table_input_property = glue.CfnTable.TableInputProperty(\n        description="description",\n        name="name",\n        owner="owner",\n        parameters=parameters,\n        partition_keys=[glue.CfnTable.ColumnProperty(\n            name="name",\n\n            # the properties below are optional\n            comment="comment",\n            type="type"\n        )],\n        retention=123,\n        storage_descriptor=glue.CfnTable.StorageDescriptorProperty(\n            bucket_columns=["bucketColumns"],\n            columns=[glue.CfnTable.ColumnProperty(\n                name="name",\n\n                # the properties below are optional\n                comment="comment",\n                type="type"\n            )],\n            compressed=False,\n            input_format="inputFormat",\n            location="location",\n            number_of_buckets=123,\n            output_format="outputFormat",\n            parameters=parameters,\n            schema_reference=glue.CfnTable.SchemaReferenceProperty(\n                schema_id=glue.CfnTable.SchemaIdProperty(\n                    registry_name="registryName",\n                    schema_arn="schemaArn",\n                    schema_name="schemaName"\n                ),\n                schema_version_id="schemaVersionId",\n                schema_version_number=123\n            ),\n            serde_info=glue.CfnTable.SerdeInfoProperty(\n                name="name",\n                parameters=parameters,\n                serialization_library="serializationLibrary"\n            ),\n            skewed_info=glue.CfnTable.SkewedInfoProperty(\n                skewed_column_names=["skewedColumnNames"],\n                skewed_column_value_location_maps=skewed_column_value_location_maps,\n                skewed_column_values=["skewedColumnValues"]\n            ),\n            sort_columns=[glue.CfnTable.OrderProperty(\n                column="column",\n                sort_order=123\n            )],\n            stored_as_sub_directories=False\n        ),\n        table_type="tableType",\n        target_table=glue.CfnTable.TableIdentifierProperty(\n            catalog_id="catalogId",\n            database_name="databaseName",\n            name="name",\n            region="region"\n        ),\n        view_expanded_text="viewExpandedText",\n        view_original_text="viewOriginalText"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'name', 'owner', 'parameters', 'partition_keys', 'retention', 'storage_descriptor', 'table_type', 'target_table', 'view_expanded_text', 'view_original_text']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable.TableInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTrigger.ActionProperty
class CfnTrigger_ActionPropertyDef(BaseStruct):
    arguments: typing.Any = pydantic.Field(None, description='The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes. For information about how to specify and consume your own job arguments, see `Calling AWS Glue APIs in Python <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html>`_ in the *AWS Glue Developer Guide* . For information about the key-value pairs that AWS Glue consumes to set up your job, see the `Special Parameters Used by AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html>`_ topic in the developer guide.\n')
    crawler_name: typing.Optional[str] = pydantic.Field(None, description='The name of the crawler to be used with this action.\n')
    job_name: typing.Optional[str] = pydantic.Field(None, description='The name of a job to be executed.\n')
    notification_property: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_NotificationPropertyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies configuration properties of a job run notification.\n')
    security_configuration: typing.Optional[str] = pydantic.Field(None, description='The name of the ``SecurityConfiguration`` structure to be used with this action.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # arguments_: Any\n\n    action_property = glue.CfnTrigger.ActionProperty(\n        arguments=arguments_,\n        crawler_name="crawlerName",\n        job_name="jobName",\n        notification_property=glue.CfnTrigger.NotificationPropertyProperty(\n            notify_delay_after=123\n        ),\n        security_configuration="securityConfiguration",\n        timeout=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arguments', 'crawler_name', 'job_name', 'notification_property', 'security_configuration', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTrigger.ActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTrigger.ConditionProperty
class CfnTrigger_ConditionPropertyDef(BaseStruct):
    crawler_name: typing.Optional[str] = pydantic.Field(None, description='The name of the crawler to which this condition applies.\n')
    crawl_state: typing.Optional[str] = pydantic.Field(None, description='The state of the crawler to which this condition applies.\n')
    job_name: typing.Optional[str] = pydantic.Field(None, description='The name of the job whose ``JobRuns`` this condition applies to, and on which this trigger waits.\n')
    logical_operator: typing.Optional[str] = pydantic.Field(None, description='A logical operator.\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The condition state. Currently, the values supported are ``SUCCEEDED`` , ``STOPPED`` , ``TIMEOUT`` , and ``FAILED`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    condition_property = glue.CfnTrigger.ConditionProperty(\n        crawler_name="crawlerName",\n        crawl_state="crawlState",\n        job_name="jobName",\n        logical_operator="logicalOperator",\n        state="state"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['crawler_name', 'crawl_state', 'job_name', 'logical_operator', 'state']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTrigger.ConditionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTrigger.EventBatchingConditionProperty
class CfnTrigger_EventBatchingConditionPropertyDef(BaseStruct):
    batch_size: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.\n')
    batch_window: typing.Union[int, float, None] = pydantic.Field(None, description='Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-eventbatchingcondition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    event_batching_condition_property = glue.CfnTrigger.EventBatchingConditionProperty(\n        batch_size=123,\n\n        # the properties below are optional\n        batch_window=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['batch_size', 'batch_window']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTrigger.EventBatchingConditionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTrigger.NotificationPropertyProperty
class CfnTrigger_NotificationPropertyPropertyDef(BaseStruct):
    notify_delay_after: typing.Union[int, float, None] = pydantic.Field(None, description='After a job run starts, the number of minutes to wait before sending a job run delay notification.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    notification_property_property = glue.CfnTrigger.NotificationPropertyProperty(\n        notify_delay_after=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['notify_delay_after']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTrigger.NotificationPropertyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTrigger.PredicateProperty
class CfnTrigger_PredicatePropertyDef(BaseStruct):
    conditions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_ConditionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of the conditions that determine when the trigger will fire.\n')
    logical: typing.Optional[str] = pydantic.Field(None, description='An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-predicate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    predicate_property = glue.CfnTrigger.PredicateProperty(\n        conditions=[glue.CfnTrigger.ConditionProperty(\n            crawler_name="crawlerName",\n            crawl_state="crawlState",\n            job_name="jobName",\n            logical_operator="logicalOperator",\n            state="state"\n        )],\n        logical="logical"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['conditions', 'logical']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTrigger.PredicateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnClassifier
class CfnClassifierDef(BaseCfnResource):
    csv_classifier: typing.Union[models.UnsupportedResource, models.aws_glue.CfnClassifier_CsvClassifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A classifier for comma-separated values (CSV).\n')
    grok_classifier: typing.Union[models.UnsupportedResource, models.aws_glue.CfnClassifier_GrokClassifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A classifier that uses ``grok`` .\n')
    json_classifier: typing.Union[models.UnsupportedResource, models.aws_glue.CfnClassifier_JsonClassifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A classifier for JSON content.\n')
    xml_classifier: typing.Union[models.UnsupportedResource, models.aws_glue.CfnClassifier_XMLClassifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A classifier for XML content.')
    _init_params: typing.ClassVar[list[str]] = ['csv_classifier', 'grok_classifier', 'json_classifier', 'xml_classifier']
    _method_names: typing.ClassVar[list[str]] = ['CsvClassifierProperty', 'GrokClassifierProperty', 'JsonClassifierProperty', 'XMLClassifierProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnClassifier'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnClassifierDefConfig] = pydantic.Field(None)


class CfnClassifierDefConfig(pydantic.BaseModel):
    CsvClassifierProperty: typing.Optional[list[models.aws_glue.CfnClassifierDefCsvclassifierpropertyParams]] = pydantic.Field(None, description='')
    GrokClassifierProperty: typing.Optional[list[models.aws_glue.CfnClassifierDefGrokclassifierpropertyParams]] = pydantic.Field(None, description='')
    JsonClassifierProperty: typing.Optional[list[models.aws_glue.CfnClassifierDefJsonclassifierpropertyParams]] = pydantic.Field(None, description='')
    XMLClassifierProperty: typing.Optional[list[models.aws_glue.CfnClassifierDefXmlclassifierpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnClassifierDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnClassifierDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnClassifierDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnClassifierDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnClassifierDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnClassifierDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnClassifierDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnClassifierDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnClassifierDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnClassifierDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnClassifierDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnClassifierDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnClassifierDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnClassifierDefCsvclassifierpropertyParams(pydantic.BaseModel):
    allow_single_column: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    contains_custom_datatype: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    contains_header: typing.Optional[str] = pydantic.Field(None, description='')
    custom_datatype_configured: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    delimiter: typing.Optional[str] = pydantic.Field(None, description='')
    disable_value_trimming: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    header: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    quote_symbol: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClassifierDefGrokclassifierpropertyParams(pydantic.BaseModel):
    classification: str = pydantic.Field(..., description='')
    grok_pattern: str = pydantic.Field(..., description='')
    custom_patterns: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClassifierDefJsonclassifierpropertyParams(pydantic.BaseModel):
    json_path: str = pydantic.Field(..., description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClassifierDefXmlclassifierpropertyParams(pydantic.BaseModel):
    classification: str = pydantic.Field(..., description='')
    row_tag: str = pydantic.Field(..., description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClassifierDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnClassifierDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClassifierDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnClassifierDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClassifierDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnClassifierDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnClassifierDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnClassifierDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnClassifierDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnClassifierDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClassifierDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnClassifierDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnClassifierDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClassifierDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnConnection
class CfnConnectionDef(BaseCfnResource):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the data catalog to create the catalog object in. Currently, this should be the AWS account ID. .. epigraph:: To specify the account ID, you can use the ``Ref`` intrinsic function with the ``AWS::AccountId`` pseudo parameter. For example: ``!Ref AWS::AccountId`` .\n')
    connection_input: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnConnection_ConnectionInputPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The connection that you want to create.')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'connection_input']
    _method_names: typing.ClassVar[list[str]] = ['ConnectionInputProperty', 'PhysicalConnectionRequirementsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnConnection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnConnectionDefConfig] = pydantic.Field(None)


class CfnConnectionDefConfig(pydantic.BaseModel):
    ConnectionInputProperty: typing.Optional[list[models.aws_glue.CfnConnectionDefConnectioninputpropertyParams]] = pydantic.Field(None, description='')
    PhysicalConnectionRequirementsProperty: typing.Optional[list[models.aws_glue.CfnConnectionDefPhysicalconnectionrequirementspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnConnectionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnConnectionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnConnectionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnConnectionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnConnectionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnConnectionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnConnectionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnConnectionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnConnectionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnConnectionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnConnectionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnConnectionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnConnectionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnConnectionDefConnectioninputpropertyParams(pydantic.BaseModel):
    connection_type: str = pydantic.Field(..., description='')
    connection_properties: typing.Any = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    match_criteria: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    physical_connection_requirements: typing.Union[models.UnsupportedResource, models.aws_glue.CfnConnection_PhysicalConnectionRequirementsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnConnectionDefPhysicalconnectionrequirementspropertyParams(pydantic.BaseModel):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    security_group_id_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConnectionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConnectionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConnectionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConnectionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConnectionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConnectionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConnectionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConnectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConnectionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConnectionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConnectionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConnectionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConnectionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConnectionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnCrawler
class CfnCrawlerDef(BaseCfnResource):
    role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.\n")
    targets: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnCrawler_TargetsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A collection of targets to crawl.\n')
    classifiers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of UTF-8 strings that specify the names of custom classifiers that are associated with the crawler.\n')
    configuration: typing.Optional[str] = pydantic.Field(None, description="Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see `Configuring a Crawler <https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html>`_ .\n")
    crawler_security_configuration: typing.Optional[str] = pydantic.Field(None, description='The name of the ``SecurityConfiguration`` structure to be used by this crawler.\n')
    database_name: typing.Optional[str] = pydantic.Field(None, description="The name of the database in which the crawler's output is stored.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the crawler.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the crawler.\n')
    recrawl_policy: typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_RecrawlPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.\n')
    schedule: typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_SchedulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='For scheduled crawlers, the schedule when the crawler runs.\n')
    schema_change_policy: typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_SchemaChangePolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The policy that specifies update and delete behaviors for the crawler. The policy tells the crawler what to do in the event that it detects a change in a table that already exists in the customer's database at the time of the crawl. The ``SchemaChangePolicy`` does not affect whether or how new tables and partitions are added. New tables and partitions are always created regardless of the ``SchemaChangePolicy`` on a crawler. The SchemaChangePolicy consists of two components, ``UpdateBehavior`` and ``DeleteBehavior`` .\n")
    table_prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix added to the names of tables that are created.\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this crawler.')
    _init_params: typing.ClassVar[list[str]] = ['role', 'targets', 'classifiers', 'configuration', 'crawler_security_configuration', 'database_name', 'description', 'name', 'recrawl_policy', 'schedule', 'schema_change_policy', 'table_prefix', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['CatalogTargetProperty', 'DeltaTargetProperty', 'DynamoDBTargetProperty', 'IcebergTargetProperty', 'JdbcTargetProperty', 'MongoDBTargetProperty', 'RecrawlPolicyProperty', 'S3TargetProperty', 'ScheduleProperty', 'SchemaChangePolicyProperty', 'TargetsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawler'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnCrawlerDefConfig] = pydantic.Field(None)


class CfnCrawlerDefConfig(pydantic.BaseModel):
    CatalogTargetProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefCatalogtargetpropertyParams]] = pydantic.Field(None, description='')
    DeltaTargetProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefDeltatargetpropertyParams]] = pydantic.Field(None, description='')
    DynamoDBTargetProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefDynamodbtargetpropertyParams]] = pydantic.Field(None, description='')
    IcebergTargetProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefIcebergtargetpropertyParams]] = pydantic.Field(None, description='')
    JdbcTargetProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefJdbctargetpropertyParams]] = pydantic.Field(None, description='')
    MongoDBTargetProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefMongodbtargetpropertyParams]] = pydantic.Field(None, description='')
    RecrawlPolicyProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefRecrawlpolicypropertyParams]] = pydantic.Field(None, description='')
    S3TargetProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefS3TargetpropertyParams]] = pydantic.Field(None, description='')
    ScheduleProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefSchedulepropertyParams]] = pydantic.Field(None, description='')
    SchemaChangePolicyProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefSchemachangepolicypropertyParams]] = pydantic.Field(None, description='')
    TargetsProperty: typing.Optional[list[models.aws_glue.CfnCrawlerDefTargetspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnCrawlerDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnCrawlerDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnCrawlerDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnCrawlerDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnCrawlerDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnCrawlerDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnCrawlerDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnCrawlerDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnCrawlerDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnCrawlerDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnCrawlerDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnCrawlerDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnCrawlerDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCrawlerDefCatalogtargetpropertyParams(pydantic.BaseModel):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='')
    database_name: typing.Optional[str] = pydantic.Field(None, description='')
    dlq_event_queue_arn: typing.Optional[str] = pydantic.Field(None, description='')
    event_queue_arn: typing.Optional[str] = pydantic.Field(None, description='')
    tables: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefDeltatargetpropertyParams(pydantic.BaseModel):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='')
    create_native_delta_table: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    delta_tables: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    write_manifest: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefDynamodbtargetpropertyParams(pydantic.BaseModel):
    path: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefIcebergtargetpropertyParams(pydantic.BaseModel):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='')
    exclusions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    maximum_traversal_depth: typing.Union[int, float, None] = pydantic.Field(None, description='')
    paths: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefJdbctargetpropertyParams(pydantic.BaseModel):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='')
    exclusions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefMongodbtargetpropertyParams(pydantic.BaseModel):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefRecrawlpolicypropertyParams(pydantic.BaseModel):
    recrawl_behavior: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefS3TargetpropertyParams(pydantic.BaseModel):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='')
    dlq_event_queue_arn: typing.Optional[str] = pydantic.Field(None, description='')
    event_queue_arn: typing.Optional[str] = pydantic.Field(None, description='')
    exclusions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    sample_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefSchedulepropertyParams(pydantic.BaseModel):
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefSchemachangepolicypropertyParams(pydantic.BaseModel):
    delete_behavior: typing.Optional[str] = pydantic.Field(None, description='')
    update_behavior: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefTargetspropertyParams(pydantic.BaseModel):
    catalog_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_CatalogTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    delta_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_DeltaTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    dynamo_db_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_DynamoDBTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    iceberg_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_IcebergTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    jdbc_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_JdbcTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    mongo_db_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_MongoDBTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    s3_targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_S3TargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnCrawlerDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCrawlerDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCrawlerDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCrawlerDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCrawlerDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCrawlerDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCrawlerDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCrawlerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCrawlerDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCrawlerDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCrawlerDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCrawlerDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCrawlerDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCrawlerDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnDatabase
class CfnDatabaseDef(BaseCfnResource):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS account ID for the account in which to create the catalog object. .. epigraph:: To specify the account ID, you can use the ``Ref`` intrinsic function with the ``AWS::AccountId`` pseudo parameter. For example: ``!Ref AWS::AccountId``\n')
    database_input: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnDatabase_DatabaseInputPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metadata for the database.')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_input']
    _method_names: typing.ClassVar[list[str]] = ['DataLakePrincipalProperty', 'DatabaseIdentifierProperty', 'DatabaseInputProperty', 'FederatedDatabaseProperty', 'PrincipalPrivilegesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDatabase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnDatabaseDefConfig] = pydantic.Field(None)


class CfnDatabaseDefConfig(pydantic.BaseModel):
    DataLakePrincipalProperty: typing.Optional[list[models.aws_glue.CfnDatabaseDefDatalakeprincipalpropertyParams]] = pydantic.Field(None, description='')
    DatabaseIdentifierProperty: typing.Optional[list[models.aws_glue.CfnDatabaseDefDatabaseidentifierpropertyParams]] = pydantic.Field(None, description='')
    DatabaseInputProperty: typing.Optional[list[models.aws_glue.CfnDatabaseDefDatabaseinputpropertyParams]] = pydantic.Field(None, description='')
    FederatedDatabaseProperty: typing.Optional[list[models.aws_glue.CfnDatabaseDefFederateddatabasepropertyParams]] = pydantic.Field(None, description='')
    PrincipalPrivilegesProperty: typing.Optional[list[models.aws_glue.CfnDatabaseDefPrincipalprivilegespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnDatabaseDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnDatabaseDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnDatabaseDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnDatabaseDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnDatabaseDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnDatabaseDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnDatabaseDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnDatabaseDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnDatabaseDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnDatabaseDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnDatabaseDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnDatabaseDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnDatabaseDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDatabaseDefDatalakeprincipalpropertyParams(pydantic.BaseModel):
    data_lake_principal_identifier: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDatabaseDefDatabaseidentifierpropertyParams(pydantic.BaseModel):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='')
    database_name: typing.Optional[str] = pydantic.Field(None, description='')
    region: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDatabaseDefDatabaseinputpropertyParams(pydantic.BaseModel):
    create_table_default_permissions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnDatabase_PrincipalPrivilegesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    federated_database: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDatabase_FederatedDatabasePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    location_uri: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    target_database: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDatabase_DatabaseIdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDatabaseDefFederateddatabasepropertyParams(pydantic.BaseModel):
    connection_name: typing.Optional[str] = pydantic.Field(None, description='')
    identifier: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDatabaseDefPrincipalprivilegespropertyParams(pydantic.BaseModel):
    permissions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    principal: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDatabase_DataLakePrincipalPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDatabaseDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDatabaseDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDatabaseDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDatabaseDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDatabaseDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDatabaseDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDatabaseDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDatabaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDatabaseDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDatabaseDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDatabaseDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDatabaseDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDatabaseDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDatabaseDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnDataCatalogEncryptionSettings
class CfnDataCatalogEncryptionSettingsDef(BaseCfnResource):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the Data Catalog in which the settings are created.\n')
    data_catalog_encryption_settings: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnDataCatalogEncryptionSettings_DataCatalogEncryptionSettingsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains configuration information for maintaining Data Catalog security.')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'data_catalog_encryption_settings']
    _method_names: typing.ClassVar[list[str]] = ['ConnectionPasswordEncryptionProperty', 'DataCatalogEncryptionSettingsProperty', 'EncryptionAtRestProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDataCatalogEncryptionSettings'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnDataCatalogEncryptionSettingsDefConfig] = pydantic.Field(None)


class CfnDataCatalogEncryptionSettingsDefConfig(pydantic.BaseModel):
    ConnectionPasswordEncryptionProperty: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefConnectionpasswordencryptionpropertyParams]] = pydantic.Field(None, description='')
    DataCatalogEncryptionSettingsProperty: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefDatacatalogencryptionsettingspropertyParams]] = pydantic.Field(None, description='')
    EncryptionAtRestProperty: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefEncryptionatrestpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnDataCatalogEncryptionSettingsDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDataCatalogEncryptionSettingsDefConnectionpasswordencryptionpropertyParams(pydantic.BaseModel):
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    return_connection_password_encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDataCatalogEncryptionSettingsDefDatacatalogencryptionsettingspropertyParams(pydantic.BaseModel):
    connection_password_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDataCatalogEncryptionSettings_ConnectionPasswordEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    encryption_at_rest: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDataCatalogEncryptionSettings_EncryptionAtRestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDataCatalogEncryptionSettingsDefEncryptionatrestpropertyParams(pydantic.BaseModel):
    catalog_encryption_mode: typing.Optional[str] = pydantic.Field(None, description='')
    sse_aws_kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDataCatalogEncryptionSettingsDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDataCatalogEncryptionSettingsDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataCatalogEncryptionSettingsDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDataCatalogEncryptionSettingsDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataCatalogEncryptionSettingsDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDataCatalogEncryptionSettingsDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDataCatalogEncryptionSettingsDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDataCatalogEncryptionSettingsDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDataCatalogEncryptionSettingsDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDataCatalogEncryptionSettingsDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataCatalogEncryptionSettingsDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDataCatalogEncryptionSettingsDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDataCatalogEncryptionSettingsDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataCatalogEncryptionSettingsDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnDataQualityRuleset
class CfnDataQualityRulesetDef(BaseCfnResource):
    client_token: typing.Optional[str] = pydantic.Field(None, description='Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the data quality ruleset.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the data quality ruleset.\n')
    ruleset: typing.Optional[str] = pydantic.Field(None, description='A Data Quality Definition Language (DQDL) ruleset. For more information see the AWS Glue Developer Guide.\n')
    tags: typing.Any = pydantic.Field(None, description='A list of tags applied to the data quality ruleset.\n')
    target_table: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDataQualityRuleset_DataQualityTargetTablePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object representing an AWS Glue table.')
    _init_params: typing.ClassVar[list[str]] = ['client_token', 'description', 'name', 'ruleset', 'tags', 'target_table']
    _method_names: typing.ClassVar[list[str]] = ['DataQualityTargetTableProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDataQualityRuleset'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnDataQualityRulesetDefConfig] = pydantic.Field(None)


class CfnDataQualityRulesetDefConfig(pydantic.BaseModel):
    DataQualityTargetTableProperty: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefDataqualitytargettablepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnDataQualityRulesetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDataQualityRulesetDefDataqualitytargettablepropertyParams(pydantic.BaseModel):
    database_name: typing.Optional[str] = pydantic.Field(None, description='')
    table_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDataQualityRulesetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDataQualityRulesetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataQualityRulesetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDataQualityRulesetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataQualityRulesetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDataQualityRulesetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDataQualityRulesetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDataQualityRulesetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDataQualityRulesetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDataQualityRulesetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataQualityRulesetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDataQualityRulesetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDataQualityRulesetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataQualityRulesetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnDevEndpoint
class CfnDevEndpointDef(BaseCfnResource):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role used in this ``DevEndpoint`` .\n')
    arguments: typing.Any = pydantic.Field(None, description='A map of arguments used to configure the ``DevEndpoint`` . Valid arguments are: - ``"--enable-glue-datacatalog": ""`` - ``"GLUE_PYTHON_VERSION": "3"`` - ``"GLUE_PYTHON_VERSION": "2"`` You can specify a version of Python support for development endpoints by using the ``Arguments`` parameter in the ``CreateDevEndpoint`` or ``UpdateDevEndpoint`` APIs. If no arguments are provided, the version defaults to Python 2.\n')
    endpoint_name: typing.Optional[str] = pydantic.Field(None, description='The name of the ``DevEndpoint`` .\n')
    extra_jars_s3_path: typing.Optional[str] = pydantic.Field(None, description='The path to one or more Java ``.jar`` files in an S3 bucket that should be loaded in your ``DevEndpoint`` . .. epigraph:: You can only use pure Java/Scala libraries with a ``DevEndpoint`` .\n')
    extra_python_libs_s3_path: typing.Optional[str] = pydantic.Field(None, description='The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your ``DevEndpoint`` . Multiple values must be complete paths separated by a comma. .. epigraph:: You can only use pure Python libraries with a ``DevEndpoint`` . Libraries that rely on C extensions, such as the `pandas <https://docs.aws.amazon.com/http://pandas.pydata.org/>`_ Python data analysis library, are not currently supported.\n')
    glue_version: typing.Optional[str] = pydantic.Field(None, description='The AWS Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. For more information about the available AWS Glue versions and corresponding Spark and Python versions, see `Glue version <https://docs.aws.amazon.com/glue/latest/dg/add-job.html>`_ in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the ``Arguments`` parameter in the ``CreateDevEndpoint`` or ``UpdateDevEndpoint`` APIs. If no arguments are provided, the version defaults to Python 2.\n')
    number_of_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='The number of AWS Glue Data Processing Units (DPUs) allocated to this ``DevEndpoint`` .\n')
    number_of_workers: typing.Union[int, float, None] = pydantic.Field(None, description='The number of workers of a defined ``workerType`` that are allocated to the development endpoint. The maximum number of workers you can define are 299 for ``G.1X`` , and 149 for ``G.2X`` .\n')
    public_key: typing.Optional[str] = pydantic.Field(None, description='The public key to be used by this ``DevEndpoint`` for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.\n')
    public_keys: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of public keys to be used by the ``DevEndpoints`` for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client. .. epigraph:: If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the ``UpdateDevEndpoint`` API operation with the public key content in the ``deletePublicKeys`` attribute, and the list of new keys in the ``addPublicKeys`` attribute.\n')
    security_configuration: typing.Optional[str] = pydantic.Field(None, description='The name of the ``SecurityConfiguration`` structure to be used with this ``DevEndpoint`` .\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of security group identifiers used in this ``DevEndpoint`` .\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The subnet ID for this ``DevEndpoint`` .\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this DevEndpoint.\n')
    worker_type: typing.Optional[str] = pydantic.Field(None, description='The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X. - For the ``Standard`` worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker. - For the ``G.1X`` worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs. - For the ``G.2X`` worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs. Known issue: when a development endpoint is created with the ``G.2X`` ``WorkerType`` configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'arguments', 'endpoint_name', 'extra_jars_s3_path', 'extra_python_libs_s3_path', 'glue_version', 'number_of_nodes', 'number_of_workers', 'public_key', 'public_keys', 'security_configuration', 'security_group_ids', 'subnet_id', 'tags', 'worker_type']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDevEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnDevEndpointDefConfig] = pydantic.Field(None)


class CfnDevEndpointDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnDevEndpointDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnDevEndpointDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnDevEndpointDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnDevEndpointDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnDevEndpointDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnDevEndpointDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnDevEndpointDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnDevEndpointDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnDevEndpointDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnDevEndpointDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnDevEndpointDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnDevEndpointDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnDevEndpointDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDevEndpointDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDevEndpointDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDevEndpointDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDevEndpointDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDevEndpointDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDevEndpointDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDevEndpointDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDevEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDevEndpointDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDevEndpointDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDevEndpointDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDevEndpointDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDevEndpointDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDevEndpointDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnJob
class CfnJobDef(BaseCfnResource):
    command: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnJob_JobCommandPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The code that executes a job.\n')
    role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name or Amazon Resource Name (ARN) of the IAM role associated with this job.\n')
    allocated_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='This parameter is no longer supported. Use ``MaxCapacity`` instead. The number of capacity units that are allocated to this job.\n')
    connections: typing.Union[models.UnsupportedResource, models.aws_glue.CfnJob_ConnectionsListPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The connections used for this job.\n')
    default_arguments: typing.Any = pydantic.Field(None, description='The default arguments for this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes. For information about how to specify and consume your own job arguments, see `Calling AWS Glue APIs in Python <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html>`_ in the *AWS Glue Developer Guide* . For information about the key-value pairs that AWS Glue consumes to set up your job, see `Special Parameters Used by AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html>`_ in the *AWS Glue Developer Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the job.\n')
    execution_class: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. Only jobs with AWS Glue version 3.0 and above and command type ``glueetl`` will be allowed to set ``ExecutionClass`` to ``FLEX`` . The flexible execution class is available for Spark jobs.\n')
    execution_property: typing.Union[models.UnsupportedResource, models.aws_glue.CfnJob_ExecutionPropertyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The maximum number of concurrent runs that are allowed for this job.\n')
    glue_version: typing.Optional[str] = pydantic.Field(None, description='Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for jobs of type Spark. For more information about the available AWS Glue versions and corresponding Spark and Python versions, see `Glue version <https://docs.aws.amazon.com/glue/latest/dg/add-job.html>`_ in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.\n')
    log_uri: typing.Optional[str] = pydantic.Field(None, description='This field is reserved for future use.\n')
    max_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. Do not set ``Max Capacity`` if using ``WorkerType`` and ``NumberOfWorkers`` . The value that can be allocated for ``MaxCapacity`` depends on whether you are running a Python shell job or an Apache Spark ETL job: - When you specify a Python shell job ( ``JobCommand.Name`` ="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. - When you specify an Apache Spark ETL job ( ``JobCommand.Name`` ="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.\n')
    max_retries: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times to retry this job after a JobRun fails.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name you assign to this job definition.\n')
    non_overridable_arguments: typing.Any = pydantic.Field(None, description='Non-overridable arguments for this job, specified as name-value pairs.\n')
    notification_property: typing.Union[models.UnsupportedResource, models.aws_glue.CfnJob_NotificationPropertyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies configuration properties of a notification.\n')
    number_of_workers: typing.Union[int, float, None] = pydantic.Field(None, description='The number of workers of a defined ``workerType`` that are allocated when a job runs. The maximum number of workers you can define are 299 for ``G.1X`` , and 149 for ``G.2X`` .\n')
    security_configuration: typing.Optional[str] = pydantic.Field(None, description='The name of the ``SecurityConfiguration`` structure to be used with this job.\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this job.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).\n')
    worker_type: typing.Optional[str] = pydantic.Field(None, description='The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs. - For the ``G.1X`` worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs. - For the ``G.2X`` worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs. - For the ``G.4X`` worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for AWS Glue version 3.0 or later Spark ETL jobs in the following AWS Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm). - For the ``G.8X`` worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for AWS Glue version 3.0 or later Spark ETL jobs, in the same AWS Regions as supported for the ``G.4X`` worker type. - For the ``G.025X`` worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for AWS Glue version 3.0 streaming jobs. - For the ``Z.2X`` worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.')
    _init_params: typing.ClassVar[list[str]] = ['command', 'role', 'allocated_capacity', 'connections', 'default_arguments', 'description', 'execution_class', 'execution_property', 'glue_version', 'log_uri', 'max_capacity', 'max_retries', 'name', 'non_overridable_arguments', 'notification_property', 'number_of_workers', 'security_configuration', 'tags', 'timeout', 'worker_type']
    _method_names: typing.ClassVar[list[str]] = ['ConnectionsListProperty', 'ExecutionPropertyProperty', 'JobCommandProperty', 'NotificationPropertyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnJob'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnJobDefConfig] = pydantic.Field(None)


class CfnJobDefConfig(pydantic.BaseModel):
    ConnectionsListProperty: typing.Optional[list[models.aws_glue.CfnJobDefConnectionslistpropertyParams]] = pydantic.Field(None, description='')
    ExecutionPropertyProperty: typing.Optional[list[models.aws_glue.CfnJobDefExecutionpropertypropertyParams]] = pydantic.Field(None, description='')
    JobCommandProperty: typing.Optional[list[models.aws_glue.CfnJobDefJobcommandpropertyParams]] = pydantic.Field(None, description='')
    NotificationPropertyProperty: typing.Optional[list[models.aws_glue.CfnJobDefNotificationpropertypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnJobDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnJobDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnJobDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnJobDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnJobDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnJobDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnJobDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnJobDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnJobDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnJobDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnJobDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnJobDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnJobDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnJobDefConnectionslistpropertyParams(pydantic.BaseModel):
    connections: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnJobDefExecutionpropertypropertyParams(pydantic.BaseModel):
    max_concurrent_runs: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnJobDefJobcommandpropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    python_version: typing.Optional[str] = pydantic.Field(None, description='')
    runtime: typing.Optional[str] = pydantic.Field(None, description='')
    script_location: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnJobDefNotificationpropertypropertyParams(pydantic.BaseModel):
    notify_delay_after: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnJobDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnJobDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnJobDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnJobDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnJobDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnJobDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnJobDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnJobDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnJobDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnJobDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnJobDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnJobDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnJobDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnJobDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnMLTransform
class CfnMLTransformDef(BaseCfnResource):
    input_record_tables: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnMLTransform_InputRecordTablesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of AWS Glue table definitions used by the transform.\n')
    role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both AWS Glue service role permissions to AWS Glue resources, and Amazon S3 permissions required by the transform. - This role needs AWS Glue service role permissions to allow access to resources in AWS Glue . See `Attach a Policy to IAM Users That Access AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html>`_ . - This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.\n')
    transform_parameters: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnMLTransform_TransformParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The algorithm-specific parameters that are associated with the machine learning transform.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A user-defined, long-form description text for the machine learning transform.\n')
    glue_version: typing.Optional[str] = pydantic.Field(None, description='This value determines which version of AWS Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see `AWS Glue Versions <https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions>`_ in the developer guide.\n')
    max_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of AWS Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the `AWS Glue pricing page <https://docs.aws.amazon.com/glue/pricing/>`_ . ``MaxCapacity`` is a mutually exclusive option with ``NumberOfWorkers`` and ``WorkerType`` . - If either ``NumberOfWorkers`` or ``WorkerType`` is set, then ``MaxCapacity`` cannot be set. - If ``MaxCapacity`` is set then neither ``NumberOfWorkers`` or ``WorkerType`` can be set. - If ``WorkerType`` is set, then ``NumberOfWorkers`` is required (and vice versa). - ``MaxCapacity`` and ``NumberOfWorkers`` must both be at least 1. When the ``WorkerType`` field is set to a value other than ``Standard`` , the ``MaxCapacity`` field is set automatically and becomes read-only.\n')
    max_retries: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times to retry after an ``MLTaskRun`` of the machine learning transform fails.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A user-defined name for the machine learning transform. Names are required to be unique. ``Name`` is optional:. - If you supply ``Name`` , the stack cannot be repeatedly created. - If ``Name`` is not provided, a randomly generated name will be used instead.\n')
    number_of_workers: typing.Union[int, float, None] = pydantic.Field(None, description='The number of workers of a defined ``workerType`` that are allocated when a task of the transform runs. If ``WorkerType`` is set, then ``NumberOfWorkers`` is required (and vice versa).\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this machine learning transform. You may use tags to limit access to the machine learning transform. For more information about tags in AWS Glue , see `AWS Tags in AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html>`_ in the developer guide.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The timeout in minutes of the machine learning transform.\n')
    transform_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnMLTransform_TransformEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS. Additionally, imported labels and trained transforms can now be encrypted using a customer provided KMS key.\n')
    worker_type: typing.Optional[str] = pydantic.Field(None, description='The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X. - For the ``Standard`` worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker. - For the ``G.1X`` worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker. - For the ``G.2X`` worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker. ``MaxCapacity`` is a mutually exclusive option with ``NumberOfWorkers`` and ``WorkerType`` . - If either ``NumberOfWorkers`` or ``WorkerType`` is set, then ``MaxCapacity`` cannot be set. - If ``MaxCapacity`` is set then neither ``NumberOfWorkers`` or ``WorkerType`` can be set. - If ``WorkerType`` is set, then ``NumberOfWorkers`` is required (and vice versa). - ``MaxCapacity`` and ``NumberOfWorkers`` must both be at least 1.')
    _init_params: typing.ClassVar[list[str]] = ['input_record_tables', 'role', 'transform_parameters', 'description', 'glue_version', 'max_capacity', 'max_retries', 'name', 'number_of_workers', 'tags', 'timeout', 'transform_encryption', 'worker_type']
    _method_names: typing.ClassVar[list[str]] = ['FindMatchesParametersProperty', 'GlueTablesProperty', 'InputRecordTablesProperty', 'MLUserDataEncryptionProperty', 'TransformEncryptionProperty', 'TransformParametersProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnMLTransform'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnMLTransformDefConfig] = pydantic.Field(None)


class CfnMLTransformDefConfig(pydantic.BaseModel):
    FindMatchesParametersProperty: typing.Optional[list[models.aws_glue.CfnMLTransformDefFindmatchesparameterspropertyParams]] = pydantic.Field(None, description='')
    GlueTablesProperty: typing.Optional[list[models.aws_glue.CfnMLTransformDefGluetablespropertyParams]] = pydantic.Field(None, description='')
    InputRecordTablesProperty: typing.Optional[list[models.aws_glue.CfnMLTransformDefInputrecordtablespropertyParams]] = pydantic.Field(None, description='')
    MLUserDataEncryptionProperty: typing.Optional[list[models.aws_glue.CfnMLTransformDefMluserdataencryptionpropertyParams]] = pydantic.Field(None, description='')
    TransformEncryptionProperty: typing.Optional[list[models.aws_glue.CfnMLTransformDefTransformencryptionpropertyParams]] = pydantic.Field(None, description='')
    TransformParametersProperty: typing.Optional[list[models.aws_glue.CfnMLTransformDefTransformparameterspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnMLTransformDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnMLTransformDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnMLTransformDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnMLTransformDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnMLTransformDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnMLTransformDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnMLTransformDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnMLTransformDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnMLTransformDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnMLTransformDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnMLTransformDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnMLTransformDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnMLTransformDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnMLTransformDefFindmatchesparameterspropertyParams(pydantic.BaseModel):
    primary_key_column_name: str = pydantic.Field(..., description='')
    accuracy_cost_tradeoff: typing.Union[int, float, None] = pydantic.Field(None, description='')
    enforce_provided_labels: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    precision_recall_tradeoff: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnMLTransformDefGluetablespropertyParams(pydantic.BaseModel):
    database_name: str = pydantic.Field(..., description='')
    table_name: str = pydantic.Field(..., description='')
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='')
    connection_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMLTransformDefInputrecordtablespropertyParams(pydantic.BaseModel):
    glue_tables: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnMLTransform_GlueTablesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnMLTransformDefMluserdataencryptionpropertyParams(pydantic.BaseModel):
    ml_user_data_encryption_mode: str = pydantic.Field(..., description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMLTransformDefTransformencryptionpropertyParams(pydantic.BaseModel):
    ml_user_data_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnMLTransform_MLUserDataEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    task_run_security_configuration_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMLTransformDefTransformparameterspropertyParams(pydantic.BaseModel):
    transform_type: str = pydantic.Field(..., description='')
    find_matches_parameters: typing.Union[models.UnsupportedResource, models.aws_glue.CfnMLTransform_FindMatchesParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnMLTransformDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMLTransformDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMLTransformDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMLTransformDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMLTransformDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMLTransformDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMLTransformDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMLTransformDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMLTransformDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMLTransformDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMLTransformDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMLTransformDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMLTransformDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMLTransformDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnPartition
class CfnPartitionDef(BaseCfnResource):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS account ID of the catalog in which the partion is to be created. .. epigraph:: To specify the account ID, you can use the ``Ref`` intrinsic function with the ``AWS::AccountId`` pseudo parameter. For example: ``!Ref AWS::AccountId``\n')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the catalog database in which to create the partition.\n')
    partition_input: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnPartition_PartitionInputPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The structure used to create and update a partition.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the metadata table in which the partition is to be created.')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'partition_input', 'table_name']
    _method_names: typing.ClassVar[list[str]] = ['ColumnProperty', 'OrderProperty', 'PartitionInputProperty', 'SchemaIdProperty', 'SchemaReferenceProperty', 'SerdeInfoProperty', 'SkewedInfoProperty', 'StorageDescriptorProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnPartitionDefConfig] = pydantic.Field(None)


class CfnPartitionDefConfig(pydantic.BaseModel):
    ColumnProperty: typing.Optional[list[models.aws_glue.CfnPartitionDefColumnpropertyParams]] = pydantic.Field(None, description='')
    OrderProperty: typing.Optional[list[models.aws_glue.CfnPartitionDefOrderpropertyParams]] = pydantic.Field(None, description='')
    PartitionInputProperty: typing.Optional[list[models.aws_glue.CfnPartitionDefPartitioninputpropertyParams]] = pydantic.Field(None, description='')
    SchemaIdProperty: typing.Optional[list[models.aws_glue.CfnPartitionDefSchemaidpropertyParams]] = pydantic.Field(None, description='')
    SchemaReferenceProperty: typing.Optional[list[models.aws_glue.CfnPartitionDefSchemareferencepropertyParams]] = pydantic.Field(None, description='')
    SerdeInfoProperty: typing.Optional[list[models.aws_glue.CfnPartitionDefSerdeinfopropertyParams]] = pydantic.Field(None, description='')
    SkewedInfoProperty: typing.Optional[list[models.aws_glue.CfnPartitionDefSkewedinfopropertyParams]] = pydantic.Field(None, description='')
    StorageDescriptorProperty: typing.Optional[list[models.aws_glue.CfnPartitionDefStoragedescriptorpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnPartitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnPartitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnPartitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnPartitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnPartitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnPartitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnPartitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnPartitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnPartitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnPartitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnPartitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnPartitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnPartitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPartitionDefColumnpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    comment: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPartitionDefOrderpropertyParams(pydantic.BaseModel):
    column: str = pydantic.Field(..., description='')
    sort_order: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnPartitionDefPartitioninputpropertyParams(pydantic.BaseModel):
    values: typing.Sequence[str] = pydantic.Field(..., description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    storage_descriptor: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_StorageDescriptorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPartitionDefSchemaidpropertyParams(pydantic.BaseModel):
    registry_name: typing.Optional[str] = pydantic.Field(None, description='')
    schema_arn: typing.Optional[str] = pydantic.Field(None, description='')
    schema_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPartitionDefSchemareferencepropertyParams(pydantic.BaseModel):
    schema_id: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_SchemaIdPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    schema_version_id: typing.Optional[str] = pydantic.Field(None, description='')
    schema_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnPartitionDefSerdeinfopropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    serialization_library: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPartitionDefSkewedinfopropertyParams(pydantic.BaseModel):
    skewed_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    skewed_column_value_location_maps: typing.Any = pydantic.Field(None, description='')
    skewed_column_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnPartitionDefStoragedescriptorpropertyParams(pydantic.BaseModel):
    bucket_columns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_ColumnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    compressed: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    input_format: typing.Optional[str] = pydantic.Field(None, description='')
    location: typing.Optional[str] = pydantic.Field(None, description='')
    number_of_buckets: typing.Union[int, float, None] = pydantic.Field(None, description='')
    output_format: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    schema_reference: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_SchemaReferencePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    serde_info: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_SerdeInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    skewed_info: typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_SkewedInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sort_columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnPartition_OrderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    stored_as_sub_directories: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnPartitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPartitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPartitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPartitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPartitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPartitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPartitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPartitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPartitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPartitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPartitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPartitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPartitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPartitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnRegistry
class CfnRegistryDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the registry.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the registry.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='AWS tags that contain a key value pair and may be searched by console, command line, or API.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnRegistry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnRegistryDefConfig] = pydantic.Field(None)


class CfnRegistryDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnRegistryDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnRegistryDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnRegistryDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnRegistryDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnRegistryDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnRegistryDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnRegistryDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnRegistryDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnRegistryDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnRegistryDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnRegistryDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnRegistryDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnRegistryDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRegistryDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRegistryDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRegistryDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRegistryDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRegistryDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRegistryDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRegistryDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRegistryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRegistryDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRegistryDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRegistryDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRegistryDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRegistryDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRegistryDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnSchema
class CfnSchemaDef(BaseCfnResource):
    compatibility: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The compatibility mode of the schema.\n')
    data_format: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The data format of the schema definition. Currently only ``AVRO`` is supported.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the schema to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.\n')
    schema_definition: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schema definition using the ``DataFormat`` setting for ``SchemaName`` .\n')
    checkpoint_version: typing.Union[models.UnsupportedResource, models.aws_glue.CfnSchema_SchemaVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specify the ``VersionNumber`` or the ``IsLatest`` for setting the checkpoint for the schema. This is only required for updating a checkpoint.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the schema if specified when created.\n')
    registry: typing.Union[models.UnsupportedResource, models.aws_glue.CfnSchema_RegistryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The registry where a schema is stored.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='AWS tags that contain a key value pair and may be searched by console, command line, or API.')
    _init_params: typing.ClassVar[list[str]] = ['compatibility', 'data_format', 'name', 'schema_definition', 'checkpoint_version', 'description', 'registry', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['RegistryProperty', 'SchemaVersionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchema'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnSchemaDefConfig] = pydantic.Field(None)


class CfnSchemaDefConfig(pydantic.BaseModel):
    RegistryProperty: typing.Optional[list[models.aws_glue.CfnSchemaDefRegistrypropertyParams]] = pydantic.Field(None, description='')
    SchemaVersionProperty: typing.Optional[list[models.aws_glue.CfnSchemaDefSchemaversionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnSchemaDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnSchemaDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnSchemaDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnSchemaDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnSchemaDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnSchemaDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnSchemaDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnSchemaDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnSchemaDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnSchemaDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnSchemaDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnSchemaDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnSchemaDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSchemaDefRegistrypropertyParams(pydantic.BaseModel):
    arn: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSchemaDefSchemaversionpropertyParams(pydantic.BaseModel):
    is_latest: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    version_number: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSchemaDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSchemaDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSchemaDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSchemaDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSchemaDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSchemaDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSchemaDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSchemaDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSchemaDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSchemaDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSchemaDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSchemaDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSchemaDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSchemaDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnSchemaVersion
class CfnSchemaVersionDef(BaseCfnResource):
    schema_: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnSchemaVersion_SchemaPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schema that includes the schema version.\n', alias='schema')
    schema_definition: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schema definition for the schema version.')
    _init_params: typing.ClassVar[list[str]] = ['schema', 'schema_definition']
    _method_names: typing.ClassVar[list[str]] = ['SchemaProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchemaVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnSchemaVersionDefConfig] = pydantic.Field(None)


class CfnSchemaVersionDefConfig(pydantic.BaseModel):
    SchemaProperty: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefSchemapropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnSchemaVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSchemaVersionDefSchemapropertyParams(pydantic.BaseModel):
    registry_name: typing.Optional[str] = pydantic.Field(None, description='')
    schema_arn: typing.Optional[str] = pydantic.Field(None, description='')
    schema_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSchemaVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSchemaVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSchemaVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSchemaVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSchemaVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSchemaVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSchemaVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSchemaVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSchemaVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSchemaVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSchemaVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSchemaVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSchemaVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSchemaVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnSchemaVersionMetadata
class CfnSchemaVersionMetadataDef(BaseCfnResource):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A metadata key in a key-value pair for metadata.\n')
    schema_version_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The version number of the schema.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="A metadata key's corresponding value.")
    _init_params: typing.ClassVar[list[str]] = ['key', 'schema_version_id', 'value']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchemaVersionMetadata'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnSchemaVersionMetadataDefConfig] = pydantic.Field(None)


class CfnSchemaVersionMetadataDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnSchemaVersionMetadataDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSchemaVersionMetadataDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSchemaVersionMetadataDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSchemaVersionMetadataDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSchemaVersionMetadataDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSchemaVersionMetadataDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSchemaVersionMetadataDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSchemaVersionMetadataDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSchemaVersionMetadataDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSchemaVersionMetadataDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSchemaVersionMetadataDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSchemaVersionMetadataDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSchemaVersionMetadataDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSchemaVersionMetadataDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSchemaVersionMetadataDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnSecurityConfiguration
class CfnSecurityConfigurationDef(BaseCfnResource):
    encryption_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnSecurityConfiguration_EncryptionConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The encryption configuration associated with this security configuration.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the security configuration.')
    _init_params: typing.ClassVar[list[str]] = ['encryption_configuration', 'name']
    _method_names: typing.ClassVar[list[str]] = ['CloudWatchEncryptionProperty', 'EncryptionConfigurationProperty', 'JobBookmarksEncryptionProperty', 'S3EncryptionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSecurityConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnSecurityConfigurationDefConfig] = pydantic.Field(None)


class CfnSecurityConfigurationDefConfig(pydantic.BaseModel):
    CloudWatchEncryptionProperty: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefCloudwatchencryptionpropertyParams]] = pydantic.Field(None, description='')
    EncryptionConfigurationProperty: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefEncryptionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    JobBookmarksEncryptionProperty: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefJobbookmarksencryptionpropertyParams]] = pydantic.Field(None, description='')
    S3EncryptionProperty: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefS3EncryptionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnSecurityConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSecurityConfigurationDefCloudwatchencryptionpropertyParams(pydantic.BaseModel):
    cloud_watch_encryption_mode: typing.Optional[str] = pydantic.Field(None, description='')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSecurityConfigurationDefEncryptionconfigurationpropertyParams(pydantic.BaseModel):
    cloud_watch_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnSecurityConfiguration_CloudWatchEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    job_bookmarks_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnSecurityConfiguration_JobBookmarksEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    s3_encryptions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnSecurityConfiguration_S3EncryptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnSecurityConfigurationDefJobbookmarksencryptionpropertyParams(pydantic.BaseModel):
    job_bookmarks_encryption_mode: typing.Optional[str] = pydantic.Field(None, description='')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSecurityConfigurationDefS3EncryptionpropertyParams(pydantic.BaseModel):
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    s3_encryption_mode: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSecurityConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecurityConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecurityConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecurityConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecurityConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecurityConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecurityConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecurityConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSecurityConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecurityConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnTable
class CfnTableDef(BaseCfnResource):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the Data Catalog in which to create the ``Table`` .\n')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.\n')
    table_input: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnTable_TableInputPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A structure used to define a table.\n')
    open_table_format_input: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_OpenTableFormatInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure representing an open format table.')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'table_input', 'open_table_format_input']
    _method_names: typing.ClassVar[list[str]] = ['ColumnProperty', 'IcebergInputProperty', 'OpenTableFormatInputProperty', 'OrderProperty', 'SchemaIdProperty', 'SchemaReferenceProperty', 'SerdeInfoProperty', 'SkewedInfoProperty', 'StorageDescriptorProperty', 'TableIdentifierProperty', 'TableInputProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnTableDefConfig] = pydantic.Field(None)


class CfnTableDefConfig(pydantic.BaseModel):
    ColumnProperty: typing.Optional[list[models.aws_glue.CfnTableDefColumnpropertyParams]] = pydantic.Field(None, description='')
    IcebergInputProperty: typing.Optional[list[models.aws_glue.CfnTableDefIceberginputpropertyParams]] = pydantic.Field(None, description='')
    OpenTableFormatInputProperty: typing.Optional[list[models.aws_glue.CfnTableDefOpentableformatinputpropertyParams]] = pydantic.Field(None, description='')
    OrderProperty: typing.Optional[list[models.aws_glue.CfnTableDefOrderpropertyParams]] = pydantic.Field(None, description='')
    SchemaIdProperty: typing.Optional[list[models.aws_glue.CfnTableDefSchemaidpropertyParams]] = pydantic.Field(None, description='')
    SchemaReferenceProperty: typing.Optional[list[models.aws_glue.CfnTableDefSchemareferencepropertyParams]] = pydantic.Field(None, description='')
    SerdeInfoProperty: typing.Optional[list[models.aws_glue.CfnTableDefSerdeinfopropertyParams]] = pydantic.Field(None, description='')
    SkewedInfoProperty: typing.Optional[list[models.aws_glue.CfnTableDefSkewedinfopropertyParams]] = pydantic.Field(None, description='')
    StorageDescriptorProperty: typing.Optional[list[models.aws_glue.CfnTableDefStoragedescriptorpropertyParams]] = pydantic.Field(None, description='')
    TableIdentifierProperty: typing.Optional[list[models.aws_glue.CfnTableDefTableidentifierpropertyParams]] = pydantic.Field(None, description='')
    TableInputProperty: typing.Optional[list[models.aws_glue.CfnTableDefTableinputpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnTableDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnTableDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnTableDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnTableDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnTableDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnTableDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnTableDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnTableDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnTableDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnTableDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnTableDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnTableDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnTableDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTableDefColumnpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    comment: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTableDefIceberginputpropertyParams(pydantic.BaseModel):
    metadata_operation: typing.Optional[str] = pydantic.Field(None, description='')
    version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTableDefOpentableformatinputpropertyParams(pydantic.BaseModel):
    iceberg_input: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_IcebergInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnTableDefOrderpropertyParams(pydantic.BaseModel):
    column: str = pydantic.Field(..., description='')
    sort_order: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnTableDefSchemaidpropertyParams(pydantic.BaseModel):
    registry_name: typing.Optional[str] = pydantic.Field(None, description='')
    schema_arn: typing.Optional[str] = pydantic.Field(None, description='')
    schema_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTableDefSchemareferencepropertyParams(pydantic.BaseModel):
    schema_id: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_SchemaIdPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    schema_version_id: typing.Optional[str] = pydantic.Field(None, description='')
    schema_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnTableDefSerdeinfopropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    serialization_library: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTableDefSkewedinfopropertyParams(pydantic.BaseModel):
    skewed_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    skewed_column_value_location_maps: typing.Any = pydantic.Field(None, description='')
    skewed_column_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnTableDefStoragedescriptorpropertyParams(pydantic.BaseModel):
    bucket_columns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_ColumnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    compressed: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    input_format: typing.Optional[str] = pydantic.Field(None, description='')
    location: typing.Optional[str] = pydantic.Field(None, description='')
    number_of_buckets: typing.Union[int, float, None] = pydantic.Field(None, description='')
    output_format: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    schema_reference: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_SchemaReferencePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    serde_info: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_SerdeInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    skewed_info: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_SkewedInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sort_columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_OrderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    stored_as_sub_directories: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnTableDefTableidentifierpropertyParams(pydantic.BaseModel):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='')
    database_name: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    region: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTableDefTableinputpropertyParams(pydantic.BaseModel):
    description: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    owner: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    partition_keys: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_ColumnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    retention: typing.Union[int, float, None] = pydantic.Field(None, description='')
    storage_descriptor: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_StorageDescriptorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    table_type: typing.Optional[str] = pydantic.Field(None, description='')
    target_table: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_TableIdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    view_expanded_text: typing.Optional[str] = pydantic.Field(None, description='')
    view_original_text: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTableDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTableDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTableDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTableDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTableDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTableDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTableDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTableDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTableDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTableDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTableDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTableDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTableDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTableDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnTrigger
class CfnTriggerDef(BaseCfnResource):
    actions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_ActionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions initiated by this trigger.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of trigger that this is.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of this trigger.\n')
    event_batching_condition: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_EventBatchingConditionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the trigger.\n')
    predicate: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_PredicatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The predicate of this trigger, which defines when it will fire.\n')
    schedule: typing.Optional[str] = pydantic.Field(None, description='A ``cron`` expression used to specify the schedule. For more information, see `Time-Based Schedules for Jobs and Crawlers <https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html>`_ in the *AWS Glue Developer Guide* . For example, to run something every day at 12:15 UTC, specify ``cron(15 12 * * ? *)`` .\n')
    start_on_creation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Set to true to start ``SCHEDULED`` and ``CONDITIONAL`` triggers when created. True is not supported for ``ON_DEMAND`` triggers.\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this trigger.\n')
    workflow_name: typing.Optional[str] = pydantic.Field(None, description='The name of the workflow associated with the trigger.')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'type', 'description', 'event_batching_condition', 'name', 'predicate', 'schedule', 'start_on_creation', 'tags', 'workflow_name']
    _method_names: typing.ClassVar[list[str]] = ['ActionProperty', 'ConditionProperty', 'EventBatchingConditionProperty', 'NotificationPropertyProperty', 'PredicateProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTrigger'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnTriggerDefConfig] = pydantic.Field(None)


class CfnTriggerDefConfig(pydantic.BaseModel):
    ActionProperty: typing.Optional[list[models.aws_glue.CfnTriggerDefActionpropertyParams]] = pydantic.Field(None, description='')
    ConditionProperty: typing.Optional[list[models.aws_glue.CfnTriggerDefConditionpropertyParams]] = pydantic.Field(None, description='')
    EventBatchingConditionProperty: typing.Optional[list[models.aws_glue.CfnTriggerDefEventbatchingconditionpropertyParams]] = pydantic.Field(None, description='')
    NotificationPropertyProperty: typing.Optional[list[models.aws_glue.CfnTriggerDefNotificationpropertypropertyParams]] = pydantic.Field(None, description='')
    PredicateProperty: typing.Optional[list[models.aws_glue.CfnTriggerDefPredicatepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnTriggerDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnTriggerDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnTriggerDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnTriggerDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnTriggerDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnTriggerDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnTriggerDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnTriggerDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnTriggerDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnTriggerDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnTriggerDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnTriggerDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnTriggerDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTriggerDefActionpropertyParams(pydantic.BaseModel):
    arguments: typing.Any = pydantic.Field(None, description='')
    crawler_name: typing.Optional[str] = pydantic.Field(None, description='')
    job_name: typing.Optional[str] = pydantic.Field(None, description='')
    notification_property: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_NotificationPropertyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    security_configuration: typing.Optional[str] = pydantic.Field(None, description='')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnTriggerDefConditionpropertyParams(pydantic.BaseModel):
    crawler_name: typing.Optional[str] = pydantic.Field(None, description='')
    crawl_state: typing.Optional[str] = pydantic.Field(None, description='')
    job_name: typing.Optional[str] = pydantic.Field(None, description='')
    logical_operator: typing.Optional[str] = pydantic.Field(None, description='')
    state: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTriggerDefEventbatchingconditionpropertyParams(pydantic.BaseModel):
    batch_size: typing.Union[int, float] = pydantic.Field(..., description='')
    batch_window: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnTriggerDefNotificationpropertypropertyParams(pydantic.BaseModel):
    notify_delay_after: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnTriggerDefPredicatepropertyParams(pydantic.BaseModel):
    conditions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_ConditionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    logical: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTriggerDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTriggerDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTriggerDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTriggerDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTriggerDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTriggerDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTriggerDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTriggerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTriggerDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTriggerDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTriggerDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTriggerDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTriggerDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTriggerDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnWorkflow
class CfnWorkflowDef(BaseCfnResource):
    default_run_properties: typing.Any = pydantic.Field(None, description='A collection of properties to be used as part of each execution of the workflow.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the workflow.\n')
    max_concurrent_runs: typing.Union[int, float, None] = pydantic.Field(None, description='You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the workflow representing the flow.\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this workflow.')
    _init_params: typing.ClassVar[list[str]] = ['default_run_properties', 'description', 'max_concurrent_runs', 'name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnWorkflow'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_glue.CfnWorkflowDefConfig] = pydantic.Field(None)


class CfnWorkflowDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_glue.CfnWorkflowDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_glue.CfnWorkflowDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_glue.CfnWorkflowDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_glue.CfnWorkflowDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_glue.CfnWorkflowDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_glue.CfnWorkflowDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_glue.CfnWorkflowDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_glue.CfnWorkflowDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_glue.CfnWorkflowDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_glue.CfnWorkflowDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_glue.CfnWorkflowDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_glue.CfnWorkflowDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_glue.CfnWorkflowDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnWorkflowDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnWorkflowDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnWorkflowDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnWorkflowDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnWorkflowDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnWorkflowDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnWorkflowDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnWorkflowDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnWorkflowDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnWorkflowDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnWorkflowDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnWorkflowDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnWorkflowDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnWorkflowDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_glue.CfnClassifierProps
class CfnClassifierPropsDef(BaseCfnProperty):
    csv_classifier: typing.Union[models.UnsupportedResource, models.aws_glue.CfnClassifier_CsvClassifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A classifier for comma-separated values (CSV).\n')
    grok_classifier: typing.Union[models.UnsupportedResource, models.aws_glue.CfnClassifier_GrokClassifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A classifier that uses ``grok`` .\n')
    json_classifier: typing.Union[models.UnsupportedResource, models.aws_glue.CfnClassifier_JsonClassifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A classifier for JSON content.\n')
    xml_classifier: typing.Union[models.UnsupportedResource, models.aws_glue.CfnClassifier_XMLClassifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A classifier for XML content.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-classifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    cfn_classifier_props = glue.CfnClassifierProps(\n        csv_classifier=glue.CfnClassifier.CsvClassifierProperty(\n            allow_single_column=False,\n            contains_custom_datatype=["containsCustomDatatype"],\n            contains_header="containsHeader",\n            custom_datatype_configured=False,\n            delimiter="delimiter",\n            disable_value_trimming=False,\n            header=["header"],\n            name="name",\n            quote_symbol="quoteSymbol"\n        ),\n        grok_classifier=glue.CfnClassifier.GrokClassifierProperty(\n            classification="classification",\n            grok_pattern="grokPattern",\n\n            # the properties below are optional\n            custom_patterns="customPatterns",\n            name="name"\n        ),\n        json_classifier=glue.CfnClassifier.JsonClassifierProperty(\n            json_path="jsonPath",\n\n            # the properties below are optional\n            name="name"\n        ),\n        xml_classifier=glue.CfnClassifier.XMLClassifierProperty(\n            classification="classification",\n            row_tag="rowTag",\n\n            # the properties below are optional\n            name="name"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['csv_classifier', 'grok_classifier', 'json_classifier', 'xml_classifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnClassifierProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnConnectionProps
class CfnConnectionPropsDef(BaseCfnProperty):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the data catalog to create the catalog object in. Currently, this should be the AWS account ID. .. epigraph:: To specify the account ID, you can use the ``Ref`` intrinsic function with the ``AWS::AccountId`` pseudo parameter. For example: ``!Ref AWS::AccountId`` .\n')
    connection_input: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnConnection_ConnectionInputPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The connection that you want to create.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-connection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # connection_properties: Any\n\n    cfn_connection_props = glue.CfnConnectionProps(\n        catalog_id="catalogId",\n        connection_input=glue.CfnConnection.ConnectionInputProperty(\n            connection_type="connectionType",\n\n            # the properties below are optional\n            connection_properties=connection_properties,\n            description="description",\n            match_criteria=["matchCriteria"],\n            name="name",\n            physical_connection_requirements=glue.CfnConnection.PhysicalConnectionRequirementsProperty(\n                availability_zone="availabilityZone",\n                security_group_id_list=["securityGroupIdList"],\n                subnet_id="subnetId"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'connection_input']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnConnectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnCrawlerProps
class CfnCrawlerPropsDef(BaseCfnProperty):
    role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.\n")
    targets: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnCrawler_TargetsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A collection of targets to crawl.\n')
    classifiers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of UTF-8 strings that specify the names of custom classifiers that are associated with the crawler.\n')
    configuration: typing.Optional[str] = pydantic.Field(None, description="Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see `Configuring a Crawler <https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html>`_ .\n")
    crawler_security_configuration: typing.Optional[str] = pydantic.Field(None, description='The name of the ``SecurityConfiguration`` structure to be used by this crawler.\n')
    database_name: typing.Optional[str] = pydantic.Field(None, description="The name of the database in which the crawler's output is stored.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the crawler.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the crawler.\n')
    recrawl_policy: typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_RecrawlPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.\n')
    schedule: typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_SchedulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='For scheduled crawlers, the schedule when the crawler runs.\n')
    schema_change_policy: typing.Union[models.UnsupportedResource, models.aws_glue.CfnCrawler_SchemaChangePolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The policy that specifies update and delete behaviors for the crawler. The policy tells the crawler what to do in the event that it detects a change in a table that already exists in the customer's database at the time of the crawl. The ``SchemaChangePolicy`` does not affect whether or how new tables and partitions are added. New tables and partitions are always created regardless of the ``SchemaChangePolicy`` on a crawler. The SchemaChangePolicy consists of two components, ``UpdateBehavior`` and ``DeleteBehavior`` .\n")
    table_prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix added to the names of tables that are created.\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this crawler.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # tags: Any\n\n    cfn_crawler_props = glue.CfnCrawlerProps(\n        role="role",\n        targets=glue.CfnCrawler.TargetsProperty(\n            catalog_targets=[glue.CfnCrawler.CatalogTargetProperty(\n                connection_name="connectionName",\n                database_name="databaseName",\n                dlq_event_queue_arn="dlqEventQueueArn",\n                event_queue_arn="eventQueueArn",\n                tables=["tables"]\n            )],\n            delta_targets=[glue.CfnCrawler.DeltaTargetProperty(\n                connection_name="connectionName",\n                create_native_delta_table=False,\n                delta_tables=["deltaTables"],\n                write_manifest=False\n            )],\n            dynamo_db_targets=[glue.CfnCrawler.DynamoDBTargetProperty(\n                path="path"\n            )],\n            iceberg_targets=[glue.CfnCrawler.IcebergTargetProperty(\n                connection_name="connectionName",\n                exclusions=["exclusions"],\n                maximum_traversal_depth=123,\n                paths=["paths"]\n            )],\n            jdbc_targets=[glue.CfnCrawler.JdbcTargetProperty(\n                connection_name="connectionName",\n                exclusions=["exclusions"],\n                path="path"\n            )],\n            mongo_db_targets=[glue.CfnCrawler.MongoDBTargetProperty(\n                connection_name="connectionName",\n                path="path"\n            )],\n            s3_targets=[glue.CfnCrawler.S3TargetProperty(\n                connection_name="connectionName",\n                dlq_event_queue_arn="dlqEventQueueArn",\n                event_queue_arn="eventQueueArn",\n                exclusions=["exclusions"],\n                path="path",\n                sample_size=123\n            )]\n        ),\n\n        # the properties below are optional\n        classifiers=["classifiers"],\n        configuration="configuration",\n        crawler_security_configuration="crawlerSecurityConfiguration",\n        database_name="databaseName",\n        description="description",\n        name="name",\n        recrawl_policy=glue.CfnCrawler.RecrawlPolicyProperty(\n            recrawl_behavior="recrawlBehavior"\n        ),\n        schedule=glue.CfnCrawler.ScheduleProperty(\n            schedule_expression="scheduleExpression"\n        ),\n        schema_change_policy=glue.CfnCrawler.SchemaChangePolicyProperty(\n            delete_behavior="deleteBehavior",\n            update_behavior="updateBehavior"\n        ),\n        table_prefix="tablePrefix",\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role', 'targets', 'classifiers', 'configuration', 'crawler_security_configuration', 'database_name', 'description', 'name', 'recrawl_policy', 'schedule', 'schema_change_policy', 'table_prefix', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnCrawlerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDatabaseProps
class CfnDatabasePropsDef(BaseCfnProperty):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS account ID for the account in which to create the catalog object. .. epigraph:: To specify the account ID, you can use the ``Ref`` intrinsic function with the ``AWS::AccountId`` pseudo parameter. For example: ``!Ref AWS::AccountId``\n')
    database_input: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnDatabase_DatabaseInputPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metadata for the database.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-database.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n\n    cfn_database_props = glue.CfnDatabaseProps(\n        catalog_id="catalogId",\n        database_input=glue.CfnDatabase.DatabaseInputProperty(\n            create_table_default_permissions=[glue.CfnDatabase.PrincipalPrivilegesProperty(\n                permissions=["permissions"],\n                principal=glue.CfnDatabase.DataLakePrincipalProperty(\n                    data_lake_principal_identifier="dataLakePrincipalIdentifier"\n                )\n            )],\n            description="description",\n            federated_database=glue.CfnDatabase.FederatedDatabaseProperty(\n                connection_name="connectionName",\n                identifier="identifier"\n            ),\n            location_uri="locationUri",\n            name="name",\n            parameters=parameters,\n            target_database=glue.CfnDatabase.DatabaseIdentifierProperty(\n                catalog_id="catalogId",\n                database_name="databaseName",\n                region="region"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_input']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDatabaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDataCatalogEncryptionSettingsProps
class CfnDataCatalogEncryptionSettingsPropsDef(BaseCfnProperty):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the Data Catalog in which the settings are created.\n')
    data_catalog_encryption_settings: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnDataCatalogEncryptionSettings_DataCatalogEncryptionSettingsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains configuration information for maintaining Data Catalog security.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-datacatalogencryptionsettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    cfn_data_catalog_encryption_settings_props = glue.CfnDataCatalogEncryptionSettingsProps(\n        catalog_id="catalogId",\n        data_catalog_encryption_settings=glue.CfnDataCatalogEncryptionSettings.DataCatalogEncryptionSettingsProperty(\n            connection_password_encryption=glue.CfnDataCatalogEncryptionSettings.ConnectionPasswordEncryptionProperty(\n                kms_key_id="kmsKeyId",\n                return_connection_password_encrypted=False\n            ),\n            encryption_at_rest=glue.CfnDataCatalogEncryptionSettings.EncryptionAtRestProperty(\n                catalog_encryption_mode="catalogEncryptionMode",\n                sse_aws_kms_key_id="sseAwsKmsKeyId"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'data_catalog_encryption_settings']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDataCatalogEncryptionSettingsProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDataQualityRulesetProps
class CfnDataQualityRulesetPropsDef(BaseCfnProperty):
    client_token: typing.Optional[str] = pydantic.Field(None, description='Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the data quality ruleset.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the data quality ruleset.\n')
    ruleset: typing.Optional[str] = pydantic.Field(None, description='A Data Quality Definition Language (DQDL) ruleset. For more information see the AWS Glue Developer Guide.\n')
    tags: typing.Any = pydantic.Field(None, description='A list of tags applied to the data quality ruleset.\n')
    target_table: typing.Union[models.UnsupportedResource, models.aws_glue.CfnDataQualityRuleset_DataQualityTargetTablePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object representing an AWS Glue table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-dataqualityruleset.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # tags: Any\n\n    cfn_data_quality_ruleset_props = glue.CfnDataQualityRulesetProps(\n        client_token="clientToken",\n        description="description",\n        name="name",\n        ruleset="ruleset",\n        tags=tags,\n        target_table=glue.CfnDataQualityRuleset.DataQualityTargetTableProperty(\n            database_name="databaseName",\n            table_name="tableName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_token', 'description', 'name', 'ruleset', 'tags', 'target_table']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDataQualityRulesetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnDevEndpointProps
class CfnDevEndpointPropsDef(BaseCfnProperty):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role used in this ``DevEndpoint`` .\n')
    arguments: typing.Any = pydantic.Field(None, description='A map of arguments used to configure the ``DevEndpoint`` . Valid arguments are: - ``"--enable-glue-datacatalog": ""`` - ``"GLUE_PYTHON_VERSION": "3"`` - ``"GLUE_PYTHON_VERSION": "2"`` You can specify a version of Python support for development endpoints by using the ``Arguments`` parameter in the ``CreateDevEndpoint`` or ``UpdateDevEndpoint`` APIs. If no arguments are provided, the version defaults to Python 2.\n')
    endpoint_name: typing.Optional[str] = pydantic.Field(None, description='The name of the ``DevEndpoint`` .\n')
    extra_jars_s3_path: typing.Optional[str] = pydantic.Field(None, description='The path to one or more Java ``.jar`` files in an S3 bucket that should be loaded in your ``DevEndpoint`` . .. epigraph:: You can only use pure Java/Scala libraries with a ``DevEndpoint`` .\n')
    extra_python_libs_s3_path: typing.Optional[str] = pydantic.Field(None, description='The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your ``DevEndpoint`` . Multiple values must be complete paths separated by a comma. .. epigraph:: You can only use pure Python libraries with a ``DevEndpoint`` . Libraries that rely on C extensions, such as the `pandas <https://docs.aws.amazon.com/http://pandas.pydata.org/>`_ Python data analysis library, are not currently supported.\n')
    glue_version: typing.Optional[str] = pydantic.Field(None, description='The AWS Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints. For more information about the available AWS Glue versions and corresponding Spark and Python versions, see `Glue version <https://docs.aws.amazon.com/glue/latest/dg/add-job.html>`_ in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the ``Arguments`` parameter in the ``CreateDevEndpoint`` or ``UpdateDevEndpoint`` APIs. If no arguments are provided, the version defaults to Python 2.\n')
    number_of_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='The number of AWS Glue Data Processing Units (DPUs) allocated to this ``DevEndpoint`` .\n')
    number_of_workers: typing.Union[int, float, None] = pydantic.Field(None, description='The number of workers of a defined ``workerType`` that are allocated to the development endpoint. The maximum number of workers you can define are 299 for ``G.1X`` , and 149 for ``G.2X`` .\n')
    public_key: typing.Optional[str] = pydantic.Field(None, description='The public key to be used by this ``DevEndpoint`` for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.\n')
    public_keys: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of public keys to be used by the ``DevEndpoints`` for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client. .. epigraph:: If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the ``UpdateDevEndpoint`` API operation with the public key content in the ``deletePublicKeys`` attribute, and the list of new keys in the ``addPublicKeys`` attribute.\n')
    security_configuration: typing.Optional[str] = pydantic.Field(None, description='The name of the ``SecurityConfiguration`` structure to be used with this ``DevEndpoint`` .\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of security group identifiers used in this ``DevEndpoint`` .\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The subnet ID for this ``DevEndpoint`` .\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this DevEndpoint.\n')
    worker_type: typing.Optional[str] = pydantic.Field(None, description='The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X. - For the ``Standard`` worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker. - For the ``G.1X`` worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs. - For the ``G.2X`` worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs. Known issue: when a development endpoint is created with the ``G.2X`` ``WorkerType`` configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-devendpoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # arguments_: Any\n    # tags: Any\n\n    cfn_dev_endpoint_props = glue.CfnDevEndpointProps(\n        role_arn="roleArn",\n\n        # the properties below are optional\n        arguments=arguments_,\n        endpoint_name="endpointName",\n        extra_jars_s3_path="extraJarsS3Path",\n        extra_python_libs_s3_path="extraPythonLibsS3Path",\n        glue_version="glueVersion",\n        number_of_nodes=123,\n        number_of_workers=123,\n        public_key="publicKey",\n        public_keys=["publicKeys"],\n        security_configuration="securityConfiguration",\n        security_group_ids=["securityGroupIds"],\n        subnet_id="subnetId",\n        tags=tags,\n        worker_type="workerType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'arguments', 'endpoint_name', 'extra_jars_s3_path', 'extra_python_libs_s3_path', 'glue_version', 'number_of_nodes', 'number_of_workers', 'public_key', 'public_keys', 'security_configuration', 'security_group_ids', 'subnet_id', 'tags', 'worker_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnDevEndpointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnJobProps
class CfnJobPropsDef(BaseCfnProperty):
    command: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnJob_JobCommandPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The code that executes a job.\n')
    role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name or Amazon Resource Name (ARN) of the IAM role associated with this job.\n')
    allocated_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='This parameter is no longer supported. Use ``MaxCapacity`` instead. The number of capacity units that are allocated to this job.\n')
    connections: typing.Union[models.UnsupportedResource, models.aws_glue.CfnJob_ConnectionsListPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The connections used for this job.\n')
    default_arguments: typing.Any = pydantic.Field(None, description='The default arguments for this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes. For information about how to specify and consume your own job arguments, see `Calling AWS Glue APIs in Python <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html>`_ in the *AWS Glue Developer Guide* . For information about the key-value pairs that AWS Glue consumes to set up your job, see `Special Parameters Used by AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html>`_ in the *AWS Glue Developer Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the job.\n')
    execution_class: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. Only jobs with AWS Glue version 3.0 and above and command type ``glueetl`` will be allowed to set ``ExecutionClass`` to ``FLEX`` . The flexible execution class is available for Spark jobs.\n')
    execution_property: typing.Union[models.UnsupportedResource, models.aws_glue.CfnJob_ExecutionPropertyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The maximum number of concurrent runs that are allowed for this job.\n')
    glue_version: typing.Optional[str] = pydantic.Field(None, description='Glue version determines the versions of Apache Spark and Python that AWS Glue supports. The Python version indicates the version supported for jobs of type Spark. For more information about the available AWS Glue versions and corresponding Spark and Python versions, see `Glue version <https://docs.aws.amazon.com/glue/latest/dg/add-job.html>`_ in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.\n')
    log_uri: typing.Optional[str] = pydantic.Field(None, description='This field is reserved for future use.\n')
    max_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. Do not set ``Max Capacity`` if using ``WorkerType`` and ``NumberOfWorkers`` . The value that can be allocated for ``MaxCapacity`` depends on whether you are running a Python shell job or an Apache Spark ETL job: - When you specify a Python shell job ( ``JobCommand.Name`` ="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. - When you specify an Apache Spark ETL job ( ``JobCommand.Name`` ="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.\n')
    max_retries: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times to retry this job after a JobRun fails.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name you assign to this job definition.\n')
    non_overridable_arguments: typing.Any = pydantic.Field(None, description='Non-overridable arguments for this job, specified as name-value pairs.\n')
    notification_property: typing.Union[models.UnsupportedResource, models.aws_glue.CfnJob_NotificationPropertyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies configuration properties of a notification.\n')
    number_of_workers: typing.Union[int, float, None] = pydantic.Field(None, description='The number of workers of a defined ``workerType`` that are allocated when a job runs. The maximum number of workers you can define are 299 for ``G.1X`` , and 149 for ``G.2X`` .\n')
    security_configuration: typing.Optional[str] = pydantic.Field(None, description='The name of the ``SecurityConfiguration`` structure to be used with this job.\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this job.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).\n')
    worker_type: typing.Optional[str] = pydantic.Field(None, description='The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs. - For the ``G.1X`` worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs. - For the ``G.2X`` worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs. - For the ``G.4X`` worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for AWS Glue version 3.0 or later Spark ETL jobs in the following AWS Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm). - For the ``G.8X`` worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for AWS Glue version 3.0 or later Spark ETL jobs, in the same AWS Regions as supported for the ``G.4X`` worker type. - For the ``G.025X`` worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for AWS Glue version 3.0 streaming jobs. - For the ``Z.2X`` worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # default_arguments: Any\n    # non_overridable_arguments: Any\n    # tags: Any\n\n    cfn_job_props = glue.CfnJobProps(\n        command=glue.CfnJob.JobCommandProperty(\n            name="name",\n            python_version="pythonVersion",\n            runtime="runtime",\n            script_location="scriptLocation"\n        ),\n        role="role",\n\n        # the properties below are optional\n        allocated_capacity=123,\n        connections=glue.CfnJob.ConnectionsListProperty(\n            connections=["connections"]\n        ),\n        default_arguments=default_arguments,\n        description="description",\n        execution_class="executionClass",\n        execution_property=glue.CfnJob.ExecutionPropertyProperty(\n            max_concurrent_runs=123\n        ),\n        glue_version="glueVersion",\n        log_uri="logUri",\n        max_capacity=123,\n        max_retries=123,\n        name="name",\n        non_overridable_arguments=non_overridable_arguments,\n        notification_property=glue.CfnJob.NotificationPropertyProperty(\n            notify_delay_after=123\n        ),\n        number_of_workers=123,\n        security_configuration="securityConfiguration",\n        tags=tags,\n        timeout=123,\n        worker_type="workerType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['command', 'role', 'allocated_capacity', 'connections', 'default_arguments', 'description', 'execution_class', 'execution_property', 'glue_version', 'log_uri', 'max_capacity', 'max_retries', 'name', 'non_overridable_arguments', 'notification_property', 'number_of_workers', 'security_configuration', 'tags', 'timeout', 'worker_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnJobProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnMLTransformProps
class CfnMLTransformPropsDef(BaseCfnProperty):
    input_record_tables: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnMLTransform_InputRecordTablesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of AWS Glue table definitions used by the transform.\n')
    role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both AWS Glue service role permissions to AWS Glue resources, and Amazon S3 permissions required by the transform. - This role needs AWS Glue service role permissions to allow access to resources in AWS Glue . See `Attach a Policy to IAM Users That Access AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html>`_ . - This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.\n')
    transform_parameters: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnMLTransform_TransformParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The algorithm-specific parameters that are associated with the machine learning transform.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A user-defined, long-form description text for the machine learning transform.\n')
    glue_version: typing.Optional[str] = pydantic.Field(None, description='This value determines which version of AWS Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see `AWS Glue Versions <https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions>`_ in the developer guide.\n')
    max_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of AWS Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the `AWS Glue pricing page <https://docs.aws.amazon.com/glue/pricing/>`_ . ``MaxCapacity`` is a mutually exclusive option with ``NumberOfWorkers`` and ``WorkerType`` . - If either ``NumberOfWorkers`` or ``WorkerType`` is set, then ``MaxCapacity`` cannot be set. - If ``MaxCapacity`` is set then neither ``NumberOfWorkers`` or ``WorkerType`` can be set. - If ``WorkerType`` is set, then ``NumberOfWorkers`` is required (and vice versa). - ``MaxCapacity`` and ``NumberOfWorkers`` must both be at least 1. When the ``WorkerType`` field is set to a value other than ``Standard`` , the ``MaxCapacity`` field is set automatically and becomes read-only.\n')
    max_retries: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times to retry after an ``MLTaskRun`` of the machine learning transform fails.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A user-defined name for the machine learning transform. Names are required to be unique. ``Name`` is optional:. - If you supply ``Name`` , the stack cannot be repeatedly created. - If ``Name`` is not provided, a randomly generated name will be used instead.\n')
    number_of_workers: typing.Union[int, float, None] = pydantic.Field(None, description='The number of workers of a defined ``workerType`` that are allocated when a task of the transform runs. If ``WorkerType`` is set, then ``NumberOfWorkers`` is required (and vice versa).\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this machine learning transform. You may use tags to limit access to the machine learning transform. For more information about tags in AWS Glue , see `AWS Tags in AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html>`_ in the developer guide.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The timeout in minutes of the machine learning transform.\n')
    transform_encryption: typing.Union[models.UnsupportedResource, models.aws_glue.CfnMLTransform_TransformEncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS. Additionally, imported labels and trained transforms can now be encrypted using a customer provided KMS key.\n')
    worker_type: typing.Optional[str] = pydantic.Field(None, description='The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X. - For the ``Standard`` worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker. - For the ``G.1X`` worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker. - For the ``G.2X`` worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker. ``MaxCapacity`` is a mutually exclusive option with ``NumberOfWorkers`` and ``WorkerType`` . - If either ``NumberOfWorkers`` or ``WorkerType`` is set, then ``MaxCapacity`` cannot be set. - If ``MaxCapacity`` is set then neither ``NumberOfWorkers`` or ``WorkerType`` can be set. - If ``WorkerType`` is set, then ``NumberOfWorkers`` is required (and vice versa). - ``MaxCapacity`` and ``NumberOfWorkers`` must both be at least 1.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-mltransform.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # tags: Any\n\n    cfn_mLTransform_props = glue.CfnMLTransformProps(\n        input_record_tables=glue.CfnMLTransform.InputRecordTablesProperty(\n            glue_tables=[glue.CfnMLTransform.GlueTablesProperty(\n                database_name="databaseName",\n                table_name="tableName",\n\n                # the properties below are optional\n                catalog_id="catalogId",\n                connection_name="connectionName"\n            )]\n        ),\n        role="role",\n        transform_parameters=glue.CfnMLTransform.TransformParametersProperty(\n            transform_type="transformType",\n\n            # the properties below are optional\n            find_matches_parameters=glue.CfnMLTransform.FindMatchesParametersProperty(\n                primary_key_column_name="primaryKeyColumnName",\n\n                # the properties below are optional\n                accuracy_cost_tradeoff=123,\n                enforce_provided_labels=False,\n                precision_recall_tradeoff=123\n            )\n        ),\n\n        # the properties below are optional\n        description="description",\n        glue_version="glueVersion",\n        max_capacity=123,\n        max_retries=123,\n        name="name",\n        number_of_workers=123,\n        tags=tags,\n        timeout=123,\n        transform_encryption=glue.CfnMLTransform.TransformEncryptionProperty(\n            ml_user_data_encryption=glue.CfnMLTransform.MLUserDataEncryptionProperty(\n                ml_user_data_encryption_mode="mlUserDataEncryptionMode",\n\n                # the properties below are optional\n                kms_key_id="kmsKeyId"\n            ),\n            task_run_security_configuration_name="taskRunSecurityConfigurationName"\n        ),\n        worker_type="workerType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input_record_tables', 'role', 'transform_parameters', 'description', 'glue_version', 'max_capacity', 'max_retries', 'name', 'number_of_workers', 'tags', 'timeout', 'transform_encryption', 'worker_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnMLTransformProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnPartitionProps
class CfnPartitionPropsDef(BaseCfnProperty):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS account ID of the catalog in which the partion is to be created. .. epigraph:: To specify the account ID, you can use the ``Ref`` intrinsic function with the ``AWS::AccountId`` pseudo parameter. For example: ``!Ref AWS::AccountId``\n')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the catalog database in which to create the partition.\n')
    partition_input: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnPartition_PartitionInputPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The structure used to create and update a partition.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the metadata table in which the partition is to be created.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-partition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n    # skewed_column_value_location_maps: Any\n\n    cfn_partition_props = glue.CfnPartitionProps(\n        catalog_id="catalogId",\n        database_name="databaseName",\n        partition_input=glue.CfnPartition.PartitionInputProperty(\n            values=["values"],\n\n            # the properties below are optional\n            parameters=parameters,\n            storage_descriptor=glue.CfnPartition.StorageDescriptorProperty(\n                bucket_columns=["bucketColumns"],\n                columns=[glue.CfnPartition.ColumnProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    comment="comment",\n                    type="type"\n                )],\n                compressed=False,\n                input_format="inputFormat",\n                location="location",\n                number_of_buckets=123,\n                output_format="outputFormat",\n                parameters=parameters,\n                schema_reference=glue.CfnPartition.SchemaReferenceProperty(\n                    schema_id=glue.CfnPartition.SchemaIdProperty(\n                        registry_name="registryName",\n                        schema_arn="schemaArn",\n                        schema_name="schemaName"\n                    ),\n                    schema_version_id="schemaVersionId",\n                    schema_version_number=123\n                ),\n                serde_info=glue.CfnPartition.SerdeInfoProperty(\n                    name="name",\n                    parameters=parameters,\n                    serialization_library="serializationLibrary"\n                ),\n                skewed_info=glue.CfnPartition.SkewedInfoProperty(\n                    skewed_column_names=["skewedColumnNames"],\n                    skewed_column_value_location_maps=skewed_column_value_location_maps,\n                    skewed_column_values=["skewedColumnValues"]\n                ),\n                sort_columns=[glue.CfnPartition.OrderProperty(\n                    column="column",\n\n                    # the properties below are optional\n                    sort_order=123\n                )],\n                stored_as_sub_directories=False\n            )\n        ),\n        table_name="tableName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'partition_input', 'table_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnPartitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnRegistryProps
class CfnRegistryPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the registry.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the registry.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='AWS tags that contain a key value pair and may be searched by console, command line, or API.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-registry.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    cfn_registry_props = glue.CfnRegistryProps(\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnRegistryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSchemaProps
class CfnSchemaPropsDef(BaseCfnProperty):
    compatibility: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The compatibility mode of the schema.\n')
    data_format: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The data format of the schema definition. Currently only ``AVRO`` is supported.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the schema to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.\n')
    schema_definition: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schema definition using the ``DataFormat`` setting for ``SchemaName`` .\n')
    checkpoint_version: typing.Union[models.UnsupportedResource, models.aws_glue.CfnSchema_SchemaVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specify the ``VersionNumber`` or the ``IsLatest`` for setting the checkpoint for the schema. This is only required for updating a checkpoint.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the schema if specified when created.\n')
    registry: typing.Union[models.UnsupportedResource, models.aws_glue.CfnSchema_RegistryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The registry where a schema is stored.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='AWS tags that contain a key value pair and may be searched by console, command line, or API.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-schema.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    cfn_schema_props = glue.CfnSchemaProps(\n        compatibility="compatibility",\n        data_format="dataFormat",\n        name="name",\n        schema_definition="schemaDefinition",\n\n        # the properties below are optional\n        checkpoint_version=glue.CfnSchema.SchemaVersionProperty(\n            is_latest=False,\n            version_number=123\n        ),\n        description="description",\n        registry=glue.CfnSchema.RegistryProperty(\n            arn="arn",\n            name="name"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['compatibility', 'data_format', 'name', 'schema_definition', 'checkpoint_version', 'description', 'registry', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchemaProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSchemaVersionMetadataProps
class CfnSchemaVersionMetadataPropsDef(BaseCfnProperty):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A metadata key in a key-value pair for metadata.\n')
    schema_version_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The version number of the schema.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A metadata key\'s corresponding value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-schemaversionmetadata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    cfn_schema_version_metadata_props = glue.CfnSchemaVersionMetadataProps(\n        key="key",\n        schema_version_id="schemaVersionId",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'schema_version_id', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchemaVersionMetadataProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSchemaVersionProps
class CfnSchemaVersionPropsDef(BaseCfnProperty):
    schema_: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnSchemaVersion_SchemaPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schema that includes the schema version.\n', alias='schema')
    schema_definition: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schema definition for the schema version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-schemaversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    cfn_schema_version_props = glue.CfnSchemaVersionProps(\n        schema=glue.CfnSchemaVersion.SchemaProperty(\n            registry_name="registryName",\n            schema_arn="schemaArn",\n            schema_name="schemaName"\n        ),\n        schema_definition="schemaDefinition"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schema', 'schema_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSchemaVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnSecurityConfigurationProps
class CfnSecurityConfigurationPropsDef(BaseCfnProperty):
    encryption_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnSecurityConfiguration_EncryptionConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The encryption configuration associated with this security configuration.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the security configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-securityconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    cfn_security_configuration_props = glue.CfnSecurityConfigurationProps(\n        encryption_configuration=glue.CfnSecurityConfiguration.EncryptionConfigurationProperty(\n            cloud_watch_encryption=glue.CfnSecurityConfiguration.CloudWatchEncryptionProperty(\n                cloud_watch_encryption_mode="cloudWatchEncryptionMode",\n                kms_key_arn="kmsKeyArn"\n            ),\n            job_bookmarks_encryption=glue.CfnSecurityConfiguration.JobBookmarksEncryptionProperty(\n                job_bookmarks_encryption_mode="jobBookmarksEncryptionMode",\n                kms_key_arn="kmsKeyArn"\n            ),\n            s3_encryptions=[glue.CfnSecurityConfiguration.S3EncryptionProperty(\n                kms_key_arn="kmsKeyArn",\n                s3_encryption_mode="s3EncryptionMode"\n            )]\n        ),\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['encryption_configuration', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnSecurityConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTableProps
class CfnTablePropsDef(BaseCfnProperty):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the Data Catalog in which to create the ``Table`` .\n')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.\n')
    table_input: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_glue.CfnTable_TableInputPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A structure used to define a table.\n')
    open_table_format_input: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTable_OpenTableFormatInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure representing an open format table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-table.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # parameters: Any\n    # skewed_column_value_location_maps: Any\n\n    cfn_table_props = glue.CfnTableProps(\n        catalog_id="catalogId",\n        database_name="databaseName",\n        table_input=glue.CfnTable.TableInputProperty(\n            description="description",\n            name="name",\n            owner="owner",\n            parameters=parameters,\n            partition_keys=[glue.CfnTable.ColumnProperty(\n                name="name",\n\n                # the properties below are optional\n                comment="comment",\n                type="type"\n            )],\n            retention=123,\n            storage_descriptor=glue.CfnTable.StorageDescriptorProperty(\n                bucket_columns=["bucketColumns"],\n                columns=[glue.CfnTable.ColumnProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    comment="comment",\n                    type="type"\n                )],\n                compressed=False,\n                input_format="inputFormat",\n                location="location",\n                number_of_buckets=123,\n                output_format="outputFormat",\n                parameters=parameters,\n                schema_reference=glue.CfnTable.SchemaReferenceProperty(\n                    schema_id=glue.CfnTable.SchemaIdProperty(\n                        registry_name="registryName",\n                        schema_arn="schemaArn",\n                        schema_name="schemaName"\n                    ),\n                    schema_version_id="schemaVersionId",\n                    schema_version_number=123\n                ),\n                serde_info=glue.CfnTable.SerdeInfoProperty(\n                    name="name",\n                    parameters=parameters,\n                    serialization_library="serializationLibrary"\n                ),\n                skewed_info=glue.CfnTable.SkewedInfoProperty(\n                    skewed_column_names=["skewedColumnNames"],\n                    skewed_column_value_location_maps=skewed_column_value_location_maps,\n                    skewed_column_values=["skewedColumnValues"]\n                ),\n                sort_columns=[glue.CfnTable.OrderProperty(\n                    column="column",\n                    sort_order=123\n                )],\n                stored_as_sub_directories=False\n            ),\n            table_type="tableType",\n            target_table=glue.CfnTable.TableIdentifierProperty(\n                catalog_id="catalogId",\n                database_name="databaseName",\n                name="name",\n                region="region"\n            ),\n            view_expanded_text="viewExpandedText",\n            view_original_text="viewOriginalText"\n        ),\n\n        # the properties below are optional\n        open_table_format_input=glue.CfnTable.OpenTableFormatInputProperty(\n            iceberg_input=glue.CfnTable.IcebergInputProperty(\n                metadata_operation="metadataOperation",\n                version="version"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'table_input', 'open_table_format_input']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTableProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnTriggerProps
class CfnTriggerPropsDef(BaseCfnProperty):
    actions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_ActionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions initiated by this trigger.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of trigger that this is.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of this trigger.\n')
    event_batching_condition: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_EventBatchingConditionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the trigger.\n')
    predicate: typing.Union[models.UnsupportedResource, models.aws_glue.CfnTrigger_PredicatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The predicate of this trigger, which defines when it will fire.\n')
    schedule: typing.Optional[str] = pydantic.Field(None, description='A ``cron`` expression used to specify the schedule. For more information, see `Time-Based Schedules for Jobs and Crawlers <https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html>`_ in the *AWS Glue Developer Guide* . For example, to run something every day at 12:15 UTC, specify ``cron(15 12 * * ? *)`` .\n')
    start_on_creation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Set to true to start ``SCHEDULED`` and ``CONDITIONAL`` triggers when created. True is not supported for ``ON_DEMAND`` triggers.\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this trigger.\n')
    workflow_name: typing.Optional[str] = pydantic.Field(None, description='The name of the workflow associated with the trigger.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # arguments_: Any\n    # tags: Any\n\n    cfn_trigger_props = glue.CfnTriggerProps(\n        actions=[glue.CfnTrigger.ActionProperty(\n            arguments=arguments_,\n            crawler_name="crawlerName",\n            job_name="jobName",\n            notification_property=glue.CfnTrigger.NotificationPropertyProperty(\n                notify_delay_after=123\n            ),\n            security_configuration="securityConfiguration",\n            timeout=123\n        )],\n        type="type",\n\n        # the properties below are optional\n        description="description",\n        event_batching_condition=glue.CfnTrigger.EventBatchingConditionProperty(\n            batch_size=123,\n\n            # the properties below are optional\n            batch_window=123\n        ),\n        name="name",\n        predicate=glue.CfnTrigger.PredicateProperty(\n            conditions=[glue.CfnTrigger.ConditionProperty(\n                crawler_name="crawlerName",\n                crawl_state="crawlState",\n                job_name="jobName",\n                logical_operator="logicalOperator",\n                state="state"\n            )],\n            logical="logical"\n        ),\n        schedule="schedule",\n        start_on_creation=False,\n        tags=tags,\n        workflow_name="workflowName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'type', 'description', 'event_batching_condition', 'name', 'predicate', 'schedule', 'start_on_creation', 'tags', 'workflow_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnTriggerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_glue.CfnWorkflowProps
class CfnWorkflowPropsDef(BaseCfnProperty):
    default_run_properties: typing.Any = pydantic.Field(None, description='A collection of properties to be used as part of each execution of the workflow.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the workflow.\n')
    max_concurrent_runs: typing.Union[int, float, None] = pydantic.Field(None, description='You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the workflow representing the flow.\n')
    tags: typing.Any = pydantic.Field(None, description='The tags to use with this workflow.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-workflow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_glue as glue\n\n    # default_run_properties: Any\n    # tags: Any\n\n    cfn_workflow_props = glue.CfnWorkflowProps(\n        default_run_properties=default_run_properties,\n        description="description",\n        max_concurrent_runs=123,\n        name="name",\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_run_properties', 'description', 'max_concurrent_runs', 'name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_glue.CfnWorkflowProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnClassifier_CsvClassifierProperty: typing.Optional[dict[str, models.aws_glue.CfnClassifier_CsvClassifierPropertyDef]] = pydantic.Field(None)
    CfnClassifier_GrokClassifierProperty: typing.Optional[dict[str, models.aws_glue.CfnClassifier_GrokClassifierPropertyDef]] = pydantic.Field(None)
    CfnClassifier_JsonClassifierProperty: typing.Optional[dict[str, models.aws_glue.CfnClassifier_JsonClassifierPropertyDef]] = pydantic.Field(None)
    CfnClassifier_XMLClassifierProperty: typing.Optional[dict[str, models.aws_glue.CfnClassifier_XMLClassifierPropertyDef]] = pydantic.Field(None)
    CfnConnection_ConnectionInputProperty: typing.Optional[dict[str, models.aws_glue.CfnConnection_ConnectionInputPropertyDef]] = pydantic.Field(None)
    CfnConnection_PhysicalConnectionRequirementsProperty: typing.Optional[dict[str, models.aws_glue.CfnConnection_PhysicalConnectionRequirementsPropertyDef]] = pydantic.Field(None)
    CfnCrawler_CatalogTargetProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_CatalogTargetPropertyDef]] = pydantic.Field(None)
    CfnCrawler_DeltaTargetProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_DeltaTargetPropertyDef]] = pydantic.Field(None)
    CfnCrawler_DynamoDBTargetProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_DynamoDBTargetPropertyDef]] = pydantic.Field(None)
    CfnCrawler_IcebergTargetProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_IcebergTargetPropertyDef]] = pydantic.Field(None)
    CfnCrawler_JdbcTargetProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_JdbcTargetPropertyDef]] = pydantic.Field(None)
    CfnCrawler_MongoDBTargetProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_MongoDBTargetPropertyDef]] = pydantic.Field(None)
    CfnCrawler_RecrawlPolicyProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_RecrawlPolicyPropertyDef]] = pydantic.Field(None)
    CfnCrawler_S3TargetProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_S3TargetPropertyDef]] = pydantic.Field(None)
    CfnCrawler_ScheduleProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_SchedulePropertyDef]] = pydantic.Field(None)
    CfnCrawler_SchemaChangePolicyProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_SchemaChangePolicyPropertyDef]] = pydantic.Field(None)
    CfnCrawler_TargetsProperty: typing.Optional[dict[str, models.aws_glue.CfnCrawler_TargetsPropertyDef]] = pydantic.Field(None)
    CfnDatabase_DatabaseIdentifierProperty: typing.Optional[dict[str, models.aws_glue.CfnDatabase_DatabaseIdentifierPropertyDef]] = pydantic.Field(None)
    CfnDatabase_DatabaseInputProperty: typing.Optional[dict[str, models.aws_glue.CfnDatabase_DatabaseInputPropertyDef]] = pydantic.Field(None)
    CfnDatabase_DataLakePrincipalProperty: typing.Optional[dict[str, models.aws_glue.CfnDatabase_DataLakePrincipalPropertyDef]] = pydantic.Field(None)
    CfnDatabase_FederatedDatabaseProperty: typing.Optional[dict[str, models.aws_glue.CfnDatabase_FederatedDatabasePropertyDef]] = pydantic.Field(None)
    CfnDatabase_PrincipalPrivilegesProperty: typing.Optional[dict[str, models.aws_glue.CfnDatabase_PrincipalPrivilegesPropertyDef]] = pydantic.Field(None)
    CfnDataCatalogEncryptionSettings_ConnectionPasswordEncryptionProperty: typing.Optional[dict[str, models.aws_glue.CfnDataCatalogEncryptionSettings_ConnectionPasswordEncryptionPropertyDef]] = pydantic.Field(None)
    CfnDataCatalogEncryptionSettings_DataCatalogEncryptionSettingsProperty: typing.Optional[dict[str, models.aws_glue.CfnDataCatalogEncryptionSettings_DataCatalogEncryptionSettingsPropertyDef]] = pydantic.Field(None)
    CfnDataCatalogEncryptionSettings_EncryptionAtRestProperty: typing.Optional[dict[str, models.aws_glue.CfnDataCatalogEncryptionSettings_EncryptionAtRestPropertyDef]] = pydantic.Field(None)
    CfnDataQualityRuleset_DataQualityTargetTableProperty: typing.Optional[dict[str, models.aws_glue.CfnDataQualityRuleset_DataQualityTargetTablePropertyDef]] = pydantic.Field(None)
    CfnJob_ConnectionsListProperty: typing.Optional[dict[str, models.aws_glue.CfnJob_ConnectionsListPropertyDef]] = pydantic.Field(None)
    CfnJob_ExecutionPropertyProperty: typing.Optional[dict[str, models.aws_glue.CfnJob_ExecutionPropertyPropertyDef]] = pydantic.Field(None)
    CfnJob_JobCommandProperty: typing.Optional[dict[str, models.aws_glue.CfnJob_JobCommandPropertyDef]] = pydantic.Field(None)
    CfnJob_NotificationPropertyProperty: typing.Optional[dict[str, models.aws_glue.CfnJob_NotificationPropertyPropertyDef]] = pydantic.Field(None)
    CfnMLTransform_FindMatchesParametersProperty: typing.Optional[dict[str, models.aws_glue.CfnMLTransform_FindMatchesParametersPropertyDef]] = pydantic.Field(None)
    CfnMLTransform_GlueTablesProperty: typing.Optional[dict[str, models.aws_glue.CfnMLTransform_GlueTablesPropertyDef]] = pydantic.Field(None)
    CfnMLTransform_InputRecordTablesProperty: typing.Optional[dict[str, models.aws_glue.CfnMLTransform_InputRecordTablesPropertyDef]] = pydantic.Field(None)
    CfnMLTransform_MLUserDataEncryptionProperty: typing.Optional[dict[str, models.aws_glue.CfnMLTransform_MLUserDataEncryptionPropertyDef]] = pydantic.Field(None)
    CfnMLTransform_TransformEncryptionProperty: typing.Optional[dict[str, models.aws_glue.CfnMLTransform_TransformEncryptionPropertyDef]] = pydantic.Field(None)
    CfnMLTransform_TransformParametersProperty: typing.Optional[dict[str, models.aws_glue.CfnMLTransform_TransformParametersPropertyDef]] = pydantic.Field(None)
    CfnPartition_ColumnProperty: typing.Optional[dict[str, models.aws_glue.CfnPartition_ColumnPropertyDef]] = pydantic.Field(None)
    CfnPartition_OrderProperty: typing.Optional[dict[str, models.aws_glue.CfnPartition_OrderPropertyDef]] = pydantic.Field(None)
    CfnPartition_PartitionInputProperty: typing.Optional[dict[str, models.aws_glue.CfnPartition_PartitionInputPropertyDef]] = pydantic.Field(None)
    CfnPartition_SchemaIdProperty: typing.Optional[dict[str, models.aws_glue.CfnPartition_SchemaIdPropertyDef]] = pydantic.Field(None)
    CfnPartition_SchemaReferenceProperty: typing.Optional[dict[str, models.aws_glue.CfnPartition_SchemaReferencePropertyDef]] = pydantic.Field(None)
    CfnPartition_SerdeInfoProperty: typing.Optional[dict[str, models.aws_glue.CfnPartition_SerdeInfoPropertyDef]] = pydantic.Field(None)
    CfnPartition_SkewedInfoProperty: typing.Optional[dict[str, models.aws_glue.CfnPartition_SkewedInfoPropertyDef]] = pydantic.Field(None)
    CfnPartition_StorageDescriptorProperty: typing.Optional[dict[str, models.aws_glue.CfnPartition_StorageDescriptorPropertyDef]] = pydantic.Field(None)
    CfnSchema_RegistryProperty: typing.Optional[dict[str, models.aws_glue.CfnSchema_RegistryPropertyDef]] = pydantic.Field(None)
    CfnSchema_SchemaVersionProperty: typing.Optional[dict[str, models.aws_glue.CfnSchema_SchemaVersionPropertyDef]] = pydantic.Field(None)
    CfnSchemaVersion_SchemaProperty: typing.Optional[dict[str, models.aws_glue.CfnSchemaVersion_SchemaPropertyDef]] = pydantic.Field(None)
    CfnSecurityConfiguration_CloudWatchEncryptionProperty: typing.Optional[dict[str, models.aws_glue.CfnSecurityConfiguration_CloudWatchEncryptionPropertyDef]] = pydantic.Field(None)
    CfnSecurityConfiguration_EncryptionConfigurationProperty: typing.Optional[dict[str, models.aws_glue.CfnSecurityConfiguration_EncryptionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnSecurityConfiguration_JobBookmarksEncryptionProperty: typing.Optional[dict[str, models.aws_glue.CfnSecurityConfiguration_JobBookmarksEncryptionPropertyDef]] = pydantic.Field(None)
    CfnSecurityConfiguration_S3EncryptionProperty: typing.Optional[dict[str, models.aws_glue.CfnSecurityConfiguration_S3EncryptionPropertyDef]] = pydantic.Field(None)
    CfnTable_ColumnProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_ColumnPropertyDef]] = pydantic.Field(None)
    CfnTable_IcebergInputProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_IcebergInputPropertyDef]] = pydantic.Field(None)
    CfnTable_OpenTableFormatInputProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_OpenTableFormatInputPropertyDef]] = pydantic.Field(None)
    CfnTable_OrderProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_OrderPropertyDef]] = pydantic.Field(None)
    CfnTable_SchemaIdProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_SchemaIdPropertyDef]] = pydantic.Field(None)
    CfnTable_SchemaReferenceProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_SchemaReferencePropertyDef]] = pydantic.Field(None)
    CfnTable_SerdeInfoProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_SerdeInfoPropertyDef]] = pydantic.Field(None)
    CfnTable_SkewedInfoProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_SkewedInfoPropertyDef]] = pydantic.Field(None)
    CfnTable_StorageDescriptorProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_StorageDescriptorPropertyDef]] = pydantic.Field(None)
    CfnTable_TableIdentifierProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_TableIdentifierPropertyDef]] = pydantic.Field(None)
    CfnTable_TableInputProperty: typing.Optional[dict[str, models.aws_glue.CfnTable_TableInputPropertyDef]] = pydantic.Field(None)
    CfnTrigger_ActionProperty: typing.Optional[dict[str, models.aws_glue.CfnTrigger_ActionPropertyDef]] = pydantic.Field(None)
    CfnTrigger_ConditionProperty: typing.Optional[dict[str, models.aws_glue.CfnTrigger_ConditionPropertyDef]] = pydantic.Field(None)
    CfnTrigger_EventBatchingConditionProperty: typing.Optional[dict[str, models.aws_glue.CfnTrigger_EventBatchingConditionPropertyDef]] = pydantic.Field(None)
    CfnTrigger_NotificationPropertyProperty: typing.Optional[dict[str, models.aws_glue.CfnTrigger_NotificationPropertyPropertyDef]] = pydantic.Field(None)
    CfnTrigger_PredicateProperty: typing.Optional[dict[str, models.aws_glue.CfnTrigger_PredicatePropertyDef]] = pydantic.Field(None)
    CfnClassifier: typing.Optional[dict[str, models.aws_glue.CfnClassifierDef]] = pydantic.Field(None)
    CfnConnection: typing.Optional[dict[str, models.aws_glue.CfnConnectionDef]] = pydantic.Field(None)
    CfnCrawler: typing.Optional[dict[str, models.aws_glue.CfnCrawlerDef]] = pydantic.Field(None)
    CfnDatabase: typing.Optional[dict[str, models.aws_glue.CfnDatabaseDef]] = pydantic.Field(None)
    CfnDataCatalogEncryptionSettings: typing.Optional[dict[str, models.aws_glue.CfnDataCatalogEncryptionSettingsDef]] = pydantic.Field(None)
    CfnDataQualityRuleset: typing.Optional[dict[str, models.aws_glue.CfnDataQualityRulesetDef]] = pydantic.Field(None)
    CfnDevEndpoint: typing.Optional[dict[str, models.aws_glue.CfnDevEndpointDef]] = pydantic.Field(None)
    CfnJob: typing.Optional[dict[str, models.aws_glue.CfnJobDef]] = pydantic.Field(None)
    CfnMLTransform: typing.Optional[dict[str, models.aws_glue.CfnMLTransformDef]] = pydantic.Field(None)
    CfnPartition: typing.Optional[dict[str, models.aws_glue.CfnPartitionDef]] = pydantic.Field(None)
    CfnRegistry: typing.Optional[dict[str, models.aws_glue.CfnRegistryDef]] = pydantic.Field(None)
    CfnSchema: typing.Optional[dict[str, models.aws_glue.CfnSchemaDef]] = pydantic.Field(None)
    CfnSchemaVersion: typing.Optional[dict[str, models.aws_glue.CfnSchemaVersionDef]] = pydantic.Field(None)
    CfnSchemaVersionMetadata: typing.Optional[dict[str, models.aws_glue.CfnSchemaVersionMetadataDef]] = pydantic.Field(None)
    CfnSecurityConfiguration: typing.Optional[dict[str, models.aws_glue.CfnSecurityConfigurationDef]] = pydantic.Field(None)
    CfnTable: typing.Optional[dict[str, models.aws_glue.CfnTableDef]] = pydantic.Field(None)
    CfnTrigger: typing.Optional[dict[str, models.aws_glue.CfnTriggerDef]] = pydantic.Field(None)
    CfnWorkflow: typing.Optional[dict[str, models.aws_glue.CfnWorkflowDef]] = pydantic.Field(None)
    CfnClassifierProps: typing.Optional[dict[str, models.aws_glue.CfnClassifierPropsDef]] = pydantic.Field(None)
    CfnConnectionProps: typing.Optional[dict[str, models.aws_glue.CfnConnectionPropsDef]] = pydantic.Field(None)
    CfnCrawlerProps: typing.Optional[dict[str, models.aws_glue.CfnCrawlerPropsDef]] = pydantic.Field(None)
    CfnDatabaseProps: typing.Optional[dict[str, models.aws_glue.CfnDatabasePropsDef]] = pydantic.Field(None)
    CfnDataCatalogEncryptionSettingsProps: typing.Optional[dict[str, models.aws_glue.CfnDataCatalogEncryptionSettingsPropsDef]] = pydantic.Field(None)
    CfnDataQualityRulesetProps: typing.Optional[dict[str, models.aws_glue.CfnDataQualityRulesetPropsDef]] = pydantic.Field(None)
    CfnDevEndpointProps: typing.Optional[dict[str, models.aws_glue.CfnDevEndpointPropsDef]] = pydantic.Field(None)
    CfnJobProps: typing.Optional[dict[str, models.aws_glue.CfnJobPropsDef]] = pydantic.Field(None)
    CfnMLTransformProps: typing.Optional[dict[str, models.aws_glue.CfnMLTransformPropsDef]] = pydantic.Field(None)
    CfnPartitionProps: typing.Optional[dict[str, models.aws_glue.CfnPartitionPropsDef]] = pydantic.Field(None)
    CfnRegistryProps: typing.Optional[dict[str, models.aws_glue.CfnRegistryPropsDef]] = pydantic.Field(None)
    CfnSchemaProps: typing.Optional[dict[str, models.aws_glue.CfnSchemaPropsDef]] = pydantic.Field(None)
    CfnSchemaVersionMetadataProps: typing.Optional[dict[str, models.aws_glue.CfnSchemaVersionMetadataPropsDef]] = pydantic.Field(None)
    CfnSchemaVersionProps: typing.Optional[dict[str, models.aws_glue.CfnSchemaVersionPropsDef]] = pydantic.Field(None)
    CfnSecurityConfigurationProps: typing.Optional[dict[str, models.aws_glue.CfnSecurityConfigurationPropsDef]] = pydantic.Field(None)
    CfnTableProps: typing.Optional[dict[str, models.aws_glue.CfnTablePropsDef]] = pydantic.Field(None)
    CfnTriggerProps: typing.Optional[dict[str, models.aws_glue.CfnTriggerPropsDef]] = pydantic.Field(None)
    CfnWorkflowProps: typing.Optional[dict[str, models.aws_glue.CfnWorkflowPropsDef]] = pydantic.Field(None)
    ...

import models
