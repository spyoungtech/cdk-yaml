from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_elasticsearch.ElasticsearchVersion
class ElasticsearchVersionDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.ElasticsearchVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ElasticsearchVersionDefConfig] = pydantic.Field(None)


class ElasticsearchVersionDefConfig(pydantic.BaseModel):
    of: typing.Optional[list[ElasticsearchVersionDefOfParams]] = pydantic.Field(None, description='Custom Elasticsearch version.')

class ElasticsearchVersionDefOfParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='custom version number.')
    return_config: typing.Optional[list[models.aws_elasticsearch.ElasticsearchVersionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_elasticsearch.Domain
class DomainDef(BaseConstruct, ConnectableMixin):
    version: models.aws_elasticsearch.ElasticsearchVersionDef = pydantic.Field(..., description='(deprecated) The Elasticsearch version that your domain will leverage.\n')
    access_policies: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='(deprecated) Domain Access policies. Default: - No access policies.\n')
    advanced_options: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='(deprecated) Additional options to specify for the Amazon ES domain. Default: - no advanced options are specified\n')
    automated_snapshot_start_hour: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) The hour in UTC during which the service takes an automated daily snapshot of the indices in the Amazon ES domain. Only applies for Elasticsearch versions below 5.3. Default: - Hourly automated snapshots not used\n')
    capacity: typing.Union[models.aws_elasticsearch.CapacityConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) The cluster capacity configuration for the Amazon ES domain. Default: - 1 r5.large.elasticsearch data node; no dedicated master nodes.\n')
    cognito_kibana_auth: typing.Union[models.aws_elasticsearch.CognitoOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) Configures Amazon ES to use Amazon Cognito authentication for Kibana. Default: - Cognito not used for authentication to Kibana.\n')
    custom_endpoint: typing.Union[models.aws_elasticsearch.CustomEndpointOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) To configure a custom domain configure these options. If you specify a Route53 hosted zone it will create a CNAME record and use DNS validation for the certificate Default: - no custom domain endpoint will be configured\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='(deprecated) Enforces a particular physical domain name. Default: - A name will be auto-generated.\n')
    ebs: typing.Union[models.aws_elasticsearch.EbsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) The configurations of Amazon Elastic Block Store (Amazon EBS) volumes that are attached to data nodes in the Amazon ES domain. For more information, see [Configuring EBS-based Storage] (https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-ebs) in the Amazon Elasticsearch Service Developer Guide. Default: - 10 GiB General Purpose (SSD) volumes per node.\n')
    enable_version_upgrade: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) To upgrade an Amazon ES domain to a new version of Elasticsearch rather than replacing the entire domain resource, use the EnableVersionUpgrade update policy. Default: - false\n')
    encryption_at_rest: typing.Union[models.aws_elasticsearch.EncryptionAtRestOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) Encryption at rest options for the cluster. Default: - No encryption at rest\n')
    enforce_https: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) True to require that all traffic to the domain arrive over HTTPS. Default: - false\n')
    fine_grained_access_control: typing.Union[models.aws_elasticsearch.AdvancedSecurityOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) Specifies options for fine-grained access control. Requires Elasticsearch version 6.7 or later. Enabling fine-grained access control also requires encryption of data at rest and node-to-node encryption, along with enforced HTTPS. Default: - fine-grained access control is disabled\n')
    logging: typing.Union[models.aws_elasticsearch.LoggingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) Configuration log publishing configuration options. Default: - No logs are published\n')
    node_to_node_encryption: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Specify true to enable node to node encryption. Requires Elasticsearch version 6.0 or later. Default: - Node to node encryption is not enabled.\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='(deprecated) Policy to apply when the domain is removed from the stack. Default: RemovalPolicy.RETAIN\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='(deprecated) The list of security groups that are associated with the VPC endpoints for the domain. Only used if ``vpc`` is specified. Default: - One new security group is created.\n')
    tls_security_policy: typing.Optional[aws_cdk.aws_elasticsearch.TLSSecurityPolicy] = pydantic.Field(None, description='(deprecated) The minimum TLS version required for traffic to the domain. Default: - TLSSecurityPolicy.TLS_1_0\n')
    use_unsigned_basic_auth: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Configures the domain so that unsigned basic auth is enabled. If no master user is provided a default master user with username ``admin`` and a dynamically generated password stored in KMS is created. The password can be retrieved by getting ``masterUserPassword`` from the domain instance. Setting this to true will also add an access policy that allows unsigned access, enable node to node encryption, encryption at rest. If conflicting settings are encountered (like disabling encryption at rest) enabling this setting will cause a failure. Default: - false\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='(deprecated) Place the domain inside this VPC. Default: - Domain is not placed in a VPC.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(deprecated) The specific vpc subnets the domain will be placed in. You must provide one subnet for each Availability Zone that your domain uses. For example, you must specify three subnet IDs for a three Availability Zone domain. Only used if ``vpc`` is specified. Default: - All private subnets.\n')
    zone_awareness: typing.Union[models.aws_elasticsearch.ZoneAwarenessConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) The cluster zone awareness configuration for the Amazon ES domain. Default: - no zone awareness (1 AZ)\n\n:stability: deprecated\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'access_policies', 'advanced_options', 'automated_snapshot_start_hour', 'capacity', 'cognito_kibana_auth', 'custom_endpoint', 'domain_name', 'ebs', 'enable_version_upgrade', 'encryption_at_rest', 'enforce_https', 'fine_grained_access_control', 'logging', 'node_to_node_encryption', 'removal_policy', 'security_groups', 'tls_security_policy', 'use_unsigned_basic_auth', 'vpc', 'vpc_subnets', 'zone_awareness']
    _method_names: typing.ClassVar[list[str]] = ['add_access_policies', 'apply_removal_policy', 'grant_index_read', 'grant_index_read_write', 'grant_index_write', 'grant_path_read', 'grant_path_read_write', 'grant_path_write', 'grant_read', 'grant_read_write', 'grant_write', 'metric', 'metric_automated_snapshot_failure', 'metric_cluster_index_writes_blocked', 'metric_cluster_status_red', 'metric_cluster_status_yellow', 'metric_cpu_utilization', 'metric_free_storage_space', 'metric_indexing_latency', 'metric_jvm_memory_pressure', 'metric_kms_key_error', 'metric_kms_key_inaccessible', 'metric_master_cpu_utilization', 'metric_master_jvm_memory_pressure', 'metric_nodes', 'metric_search_latency', 'metric_searchable_documents']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_domain_attributes', 'from_domain_endpoint']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.Domain'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_domain_attributes', 'from_domain_endpoint']
    ...


    from_domain_attributes: typing.Optional[DomainDefFromDomainAttributesParams] = pydantic.Field(None, description='(deprecated) Creates a Domain construct that represents an external domain.')
    from_domain_endpoint: typing.Optional[DomainDefFromDomainEndpointParams] = pydantic.Field(None, description='(deprecated) Creates a Domain construct that represents an external domain via domain endpoint.')
    resource_config: typing.Optional[DomainDefConfig] = pydantic.Field(None)


class DomainDefConfig(pydantic.BaseModel):
    add_access_policies: typing.Optional[list[DomainDefAddAccessPoliciesParams]] = pydantic.Field(None, description='(deprecated) Add policy statements to the domain access policy.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_index_read: typing.Optional[list[DomainDefGrantIndexReadParams]] = pydantic.Field(None, description='(deprecated) Grant read permissions for an index in this domain to an IAM principal (Role/Group/User).')
    grant_index_read_write: typing.Optional[list[DomainDefGrantIndexReadWriteParams]] = pydantic.Field(None, description='(deprecated) Grant read/write permissions for an index in this domain to an IAM principal (Role/Group/User).')
    grant_index_write: typing.Optional[list[DomainDefGrantIndexWriteParams]] = pydantic.Field(None, description='(deprecated) Grant write permissions for an index in this domain to an IAM principal (Role/Group/User).')
    grant_path_read: typing.Optional[list[DomainDefGrantPathReadParams]] = pydantic.Field(None, description='(deprecated) Grant read permissions for a specific path in this domain to an IAM principal (Role/Group/User).')
    grant_path_read_write: typing.Optional[list[DomainDefGrantPathReadWriteParams]] = pydantic.Field(None, description='(deprecated) Grant read/write permissions for a specific path in this domain to an IAM principal (Role/Group/User).')
    grant_path_write: typing.Optional[list[DomainDefGrantPathWriteParams]] = pydantic.Field(None, description='(deprecated) Grant write permissions for a specific path in this domain to an IAM principal (Role/Group/User).')
    grant_read: typing.Optional[list[DomainDefGrantReadParams]] = pydantic.Field(None, description='(deprecated) Grant read permissions for this domain and its contents to an IAM principal (Role/Group/User).')
    grant_read_write: typing.Optional[list[DomainDefGrantReadWriteParams]] = pydantic.Field(None, description='(deprecated) Grant read/write permissions for this domain and its contents to an IAM principal (Role/Group/User).')
    grant_write: typing.Optional[list[DomainDefGrantWriteParams]] = pydantic.Field(None, description='(deprecated) Grant write permissions for this domain and its contents to an IAM principal (Role/Group/User).')
    metric: typing.Optional[list[DomainDefMetricParams]] = pydantic.Field(None, description='(deprecated) Return the given named metric for this Domain.')
    metric_automated_snapshot_failure: typing.Optional[list[DomainDefMetricAutomatedSnapshotFailureParams]] = pydantic.Field(None, description='(deprecated) Metric for automated snapshot failures.')
    metric_cluster_index_writes_blocked: typing.Optional[list[DomainDefMetricClusterIndexWritesBlockedParams]] = pydantic.Field(None, description='(deprecated) Metric for the cluster blocking index writes.')
    metric_cluster_status_red: typing.Optional[list[DomainDefMetricClusterStatusRedParams]] = pydantic.Field(None, description='(deprecated) Metric for the time the cluster status is red.')
    metric_cluster_status_yellow: typing.Optional[list[DomainDefMetricClusterStatusYellowParams]] = pydantic.Field(None, description='(deprecated) Metric for the time the cluster status is yellow.')
    metric_cpu_utilization: typing.Optional[list[DomainDefMetricCpuUtilizationParams]] = pydantic.Field(None, description='(deprecated) Metric for CPU utilization.')
    metric_free_storage_space: typing.Optional[list[DomainDefMetricFreeStorageSpaceParams]] = pydantic.Field(None, description='(deprecated) Metric for the storage space of nodes in the cluster.')
    metric_indexing_latency: typing.Optional[list[DomainDefMetricIndexingLatencyParams]] = pydantic.Field(None, description='(deprecated) Metric for indexing latency.')
    metric_jvm_memory_pressure: typing.Optional[list[DomainDefMetricJvmMemoryPressureParams]] = pydantic.Field(None, description='(deprecated) Metric for JVM memory pressure.')
    metric_kms_key_error: typing.Optional[list[DomainDefMetricKmsKeyErrorParams]] = pydantic.Field(None, description='(deprecated) Metric for KMS key errors.')
    metric_kms_key_inaccessible: typing.Optional[list[DomainDefMetricKmsKeyInaccessibleParams]] = pydantic.Field(None, description='(deprecated) Metric for KMS key being inaccessible.')
    metric_master_cpu_utilization: typing.Optional[list[DomainDefMetricMasterCpuUtilizationParams]] = pydantic.Field(None, description='(deprecated) Metric for master CPU utilization.')
    metric_master_jvm_memory_pressure: typing.Optional[list[DomainDefMetricMasterJvmMemoryPressureParams]] = pydantic.Field(None, description='(deprecated) Metric for master JVM memory pressure.')
    metric_nodes: typing.Optional[list[DomainDefMetricNodesParams]] = pydantic.Field(None, description='(deprecated) Metric for the number of nodes.')
    metric_search_latency: typing.Optional[list[DomainDefMetricSearchLatencyParams]] = pydantic.Field(None, description='(deprecated) Metric for search latency.')
    metric_searchable_documents: typing.Optional[list[DomainDefMetricSearchableDocumentsParams]] = pydantic.Field(None, description='(deprecated) Metric for number of searchable documents.')
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)

class DomainDefAddAccessPoliciesParams(pydantic.BaseModel):
    access_policy_statements: list[models.aws_iam.PolicyStatementDef] = pydantic.Field(...)
    ...

class DomainDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class DomainDefFromDomainAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    domain_arn: str = pydantic.Field(..., description='(deprecated) The ARN of the Elasticsearch domain.\n')
    domain_endpoint: str = pydantic.Field(..., description='(deprecated) The domain endpoint of the Elasticsearch domain.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    ...

class DomainDefFromDomainEndpointParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    domain_endpoint: str = pydantic.Field(..., description="The domain's endpoint.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n")
    ...

class DomainDefGrantIndexReadParams(pydantic.BaseModel):
    index: str = pydantic.Field(..., description='The index to grant permissions for.\n')
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantIndexReadWriteParams(pydantic.BaseModel):
    index: str = pydantic.Field(..., description='The index to grant permissions for.\n')
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantIndexWriteParams(pydantic.BaseModel):
    index: str = pydantic.Field(..., description='The index to grant permissions for.\n')
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantPathReadParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path to grant permissions for.\n')
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantPathReadWriteParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path to grant permissions for.\n')
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantPathWriteParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path to grant permissions for.\n')
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantReadParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantReadWriteParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantWriteParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricAutomatedSnapshotFailureParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricClusterIndexWritesBlockedParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 1 minute\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricClusterStatusRedParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricClusterStatusYellowParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricCpuUtilizationParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricFreeStorageSpaceParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: minimum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricIndexingLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: p99 over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricJvmMemoryPressureParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricKmsKeyErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricKmsKeyInaccessibleParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricMasterCpuUtilizationParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricMasterJvmMemoryPressureParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricNodesParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: minimum over 1 hour\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricSearchLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: p99 over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricSearchableDocumentsParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_elasticsearch.AdvancedSecurityOptions
class AdvancedSecurityOptionsDef(BaseStruct):
    master_user_arn: typing.Optional[str] = pydantic.Field(None, description='(deprecated) ARN for the master user. Only specify this or masterUserName, but not both. Default: - fine-grained access control is disabled\n')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description='(deprecated) Username for the master user. Only specify this or masterUserArn, but not both. Default: - fine-grained access control is disabled\n')
    master_user_password: typing.Optional[models.SecretValueDef] = pydantic.Field(None, description='(deprecated) Password for the master user. You can use ``SecretValue.unsafePlainText`` to specify a password in plain text or use ``secretsmanager.Secret.fromSecretAttributes`` to reference a secret in Secrets Manager. Default: - A Secrets Manager generated password\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: infused\n\nExample::\n\n    domain = es.Domain(self, "Domain",\n        version=es.ElasticsearchVersion.V7_1,\n        enforce_https=True,\n        node_to_node_encryption=True,\n        encryption_at_rest=es.EncryptionAtRestOptions(\n            enabled=True\n        ),\n        fine_grained_access_control=es.AdvancedSecurityOptions(\n            master_user_name="master-user"\n        )\n    )\n\n    master_user_password = domain.master_user_password\n')
    _init_params: typing.ClassVar[list[str]] = ['master_user_arn', 'master_user_name', 'master_user_password']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.AdvancedSecurityOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CapacityConfig
class CapacityConfigDef(BaseStruct):
    data_node_instance_type: typing.Optional[str] = pydantic.Field(None, description='(deprecated) The instance type for your data nodes, such as ``m3.medium.elasticsearch``. For valid values, see `Supported Instance Types <https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-supported-instance-types.html>`_ in the Amazon Elasticsearch Service Developer Guide. Default: - r5.large.elasticsearch\n')
    data_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) The number of data nodes (instances) to use in the Amazon ES domain. Default: - 1\n')
    master_node_instance_type: typing.Optional[str] = pydantic.Field(None, description='(deprecated) The hardware configuration of the computer that hosts the dedicated master node, such as ``m3.medium.elasticsearch``. For valid values, see [Supported Instance Types] (https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-supported-instance-types.html) in the Amazon Elasticsearch Service Developer Guide. Default: - r5.large.elasticsearch\n')
    master_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) The number of instances to use for the master node. Default: - no dedicated master nodes\n')
    warm_instance_type: typing.Optional[str] = pydantic.Field(None, description='(deprecated) The instance type for your UltraWarm node, such as ``ultrawarm1.medium.elasticsearch``. For valid values, see [UltraWarm Storage Limits] (https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-limits.html#limits-ultrawarm) in the Amazon Elasticsearch Service Developer Guide. Default: - ultrawarm1.medium.elasticsearch\n')
    warm_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) The number of UltraWarm nodes (instances) to use in the Amazon ES domain. Default: - no UltraWarm nodes\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: infused\n\nExample::\n\n    domain = es.Domain(self, "Domain",\n        version=es.ElasticsearchVersion.V7_10,\n        capacity=es.CapacityConfig(\n            master_nodes=2,\n            warm_nodes=2,\n            warm_instance_type="ultrawarm1.medium.elasticsearch"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_node_instance_type', 'data_nodes', 'master_node_instance_type', 'master_nodes', 'warm_instance_type', 'warm_nodes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CapacityConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.AdvancedSecurityOptionsInputProperty
class CfnDomain_AdvancedSecurityOptionsInputPropertyDef(BaseStruct):
    anonymous_auth_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='``CfnDomain.AdvancedSecurityOptionsInputProperty.AnonymousAuthEnabled``.\n')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='True to enable fine-grained access control. You must also enable encryption of data at rest and node-to-node encryption.\n')
    internal_user_database_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='True to enable the internal user database.\n')
    master_user_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_MasterUserOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies information about the master user.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-advancedsecurityoptionsinput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    advanced_security_options_input_property = elasticsearch.CfnDomain.AdvancedSecurityOptionsInputProperty(\n        anonymous_auth_enabled=False,\n        enabled=False,\n        internal_user_database_enabled=False,\n        master_user_options=elasticsearch.CfnDomain.MasterUserOptionsProperty(\n            master_user_arn="masterUserArn",\n            master_user_name="masterUserName",\n            master_user_password="masterUserPassword"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['anonymous_auth_enabled', 'enabled', 'internal_user_database_enabled', 'master_user_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.AdvancedSecurityOptionsInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.CognitoOptionsProperty
class CfnDomain_CognitoOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards. See `Amazon Cognito authentication for OpenSearch Dashboards <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html>`_ .\n')
    identity_pool_id: typing.Optional[str] = pydantic.Field(None, description='The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication. Required if you enable Cognito authentication.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ``AmazonESCognitoAccess`` role that allows OpenSearch Service to configure your user pool and identity pool. Required if you enable Cognito authentication.\n')
    user_pool_id: typing.Optional[str] = pydantic.Field(None, description='The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication. Required if you enable Cognito authentication.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-cognitooptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    cognito_options_property = elasticsearch.CfnDomain.CognitoOptionsProperty(\n        enabled=False,\n        identity_pool_id="identityPoolId",\n        role_arn="roleArn",\n        user_pool_id="userPoolId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'identity_pool_id', 'role_arn', 'user_pool_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.CognitoOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.ColdStorageOptionsProperty
class CfnDomain_ColdStorageOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Whether to enable or disable cold storage on the domain. You must enable UltraWarm storage in order to enable cold storage.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-coldstorageoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    cold_storage_options_property = elasticsearch.CfnDomain.ColdStorageOptionsProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.ColdStorageOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.DomainEndpointOptionsProperty
class CfnDomain_DomainEndpointOptionsPropertyDef(BaseStruct):
    custom_endpoint: typing.Optional[str] = pydantic.Field(None, description='The fully qualified URL for your custom endpoint. Required if you enabled a custom endpoint for the domain.\n')
    custom_endpoint_certificate_arn: typing.Optional[str] = pydantic.Field(None, description="The AWS Certificate Manager ARN for your domain's SSL/TLS certificate. Required if you enabled a custom endpoint for the domain.\n")
    custom_endpoint_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='True to enable a custom endpoint for the domain. If enabled, you must also provide values for ``CustomEndpoint`` and ``CustomEndpointCertificateArn`` .\n')
    enforce_https: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='True to require that all traffic to the domain arrive over HTTPS.\n')
    tls_security_policy: typing.Optional[str] = pydantic.Field(None, description='The minimum TLS version required for traffic to the domain. Valid values are TLS 1.0 (default) or 1.2:. - ``Policy-Min-TLS-1-0-2019-07`` - ``Policy-Min-TLS-1-2-2019-07``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-domainendpointoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    domain_endpoint_options_property = elasticsearch.CfnDomain.DomainEndpointOptionsProperty(\n        custom_endpoint="customEndpoint",\n        custom_endpoint_certificate_arn="customEndpointCertificateArn",\n        custom_endpoint_enabled=False,\n        enforce_https=False,\n        tls_security_policy="tlsSecurityPolicy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_endpoint', 'custom_endpoint_certificate_arn', 'custom_endpoint_enabled', 'enforce_https', 'tls_security_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.DomainEndpointOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.EBSOptionsProperty
class CfnDomain_EBSOptionsPropertyDef(BaseStruct):
    ebs_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether Amazon EBS volumes are attached to data nodes in the OpenSearch Service domain.\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) that the volume supports. This property applies only to provisioned IOPS EBS volume types.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The size (in GiB) of the EBS volume for each data node. The minimum and maximum size of an EBS volume depends on the EBS volume type and the instance type to which it is attached. For more information, see `EBS volume size limits <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/limits.html#ebsresource>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='The EBS volume type to use with the OpenSearch Service domain, such as standard, gp2, or io1. For more information about each type, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-ebsoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    e_bSOptions_property = elasticsearch.CfnDomain.EBSOptionsProperty(\n        ebs_enabled=False,\n        iops=123,\n        volume_size=123,\n        volume_type="volumeType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ebs_enabled', 'iops', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.EBSOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.ElasticsearchClusterConfigProperty
class CfnDomain_ElasticsearchClusterConfigPropertyDef(BaseStruct):
    cold_storage_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_ColdStorageOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies cold storage options for the domain.\n')
    dedicated_master_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of instances to use for the master node. If you specify this property, you must specify true for the DedicatedMasterEnabled property.\n')
    dedicated_master_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether to use a dedicated master node for the OpenSearch Service domain. A dedicated master node is a cluster node that performs cluster management tasks, but doesn't hold data or respond to data upload requests. Dedicated master nodes offload cluster management tasks to increase the stability of your search clusters. See `Dedicated master nodes in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-dedicatedmasternodes.html>`_ .\n")
    dedicated_master_type: typing.Optional[str] = pydantic.Field(None, description='The hardware configuration of the computer that hosts the dedicated master node, such as ``m3.medium.elasticsearch`` . If you specify this property, you must specify true for the ``DedicatedMasterEnabled`` property. For valid values, see `Supported instance types in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html>`_ .\n')
    instance_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of data nodes (instances) to use in the OpenSearch Service domain.\n')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type for your data nodes, such as ``m3.medium.elasticsearch`` . For valid values, see `Supported instance types in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html>`_ .\n')
    warm_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of warm nodes in the cluster. Required if you enable warm storage.\n')
    warm_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Whether to enable warm storage for the cluster.\n')
    warm_type: typing.Optional[str] = pydantic.Field(None, description="The instance type for the cluster's warm nodes. Required if you enable warm storage.\n")
    zone_awareness_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_ZoneAwarenessConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies zone awareness configuration options. Only use if ``ZoneAwarenessEnabled`` is ``true`` .\n')
    zone_awareness_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to enable zone awareness for the OpenSearch Service domain. When you enable zone awareness, OpenSearch Service allocates the nodes and replica index shards that belong to a cluster across two Availability Zones (AZs) in the same region to prevent data loss and minimize downtime in the event of node or data center failure. Don\'t enable zone awareness if your cluster has no replica index shards or is a single-node cluster. For more information, see `Configuring a multi-AZ domain in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html>`_ .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-elasticsearchclusterconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    elasticsearch_cluster_config_property = elasticsearch.CfnDomain.ElasticsearchClusterConfigProperty(\n        cold_storage_options=elasticsearch.CfnDomain.ColdStorageOptionsProperty(\n            enabled=False\n        ),\n        dedicated_master_count=123,\n        dedicated_master_enabled=False,\n        dedicated_master_type="dedicatedMasterType",\n        instance_count=123,\n        instance_type="instanceType",\n        warm_count=123,\n        warm_enabled=False,\n        warm_type="warmType",\n        zone_awareness_config=elasticsearch.CfnDomain.ZoneAwarenessConfigProperty(\n            availability_zone_count=123\n        ),\n        zone_awareness_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cold_storage_options', 'dedicated_master_count', 'dedicated_master_enabled', 'dedicated_master_type', 'instance_count', 'instance_type', 'warm_count', 'warm_enabled', 'warm_type', 'zone_awareness_config', 'zone_awareness_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.ElasticsearchClusterConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.EncryptionAtRestOptionsProperty
class CfnDomain_EncryptionAtRestOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specify ``true`` to enable encryption at rest.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The KMS key ID. Takes the form ``1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a`` . Required if you enable encryption at rest.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-encryptionatrestoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    encryption_at_rest_options_property = elasticsearch.CfnDomain.EncryptionAtRestOptionsProperty(\n        enabled=False,\n        kms_key_id="kmsKeyId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'kms_key_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.EncryptionAtRestOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.LogPublishingOptionProperty
class CfnDomain_LogPublishingOptionPropertyDef(BaseStruct):
    cloud_watch_logs_log_group_arn: typing.Optional[str] = pydantic.Field(None, description='Specifies the CloudWatch log group to publish to. Required if you enable log publishing for the domain.\n')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='If ``true`` , enables the publishing of logs to CloudWatch. Default: ``false`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-logpublishingoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    log_publishing_option_property = elasticsearch.CfnDomain.LogPublishingOptionProperty(\n        cloud_watch_logs_log_group_arn="cloudWatchLogsLogGroupArn",\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_logs_log_group_arn', 'enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.LogPublishingOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.MasterUserOptionsProperty
class CfnDomain_MasterUserOptionsPropertyDef(BaseStruct):
    master_user_arn: typing.Optional[str] = pydantic.Field(None, description='ARN for the master user. Only specify if ``InternalUserDatabaseEnabled`` is false in ``AdvancedSecurityOptions`` .\n')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description='Username for the master user. Only specify if ``InternalUserDatabaseEnabled`` is true in ``AdvancedSecurityOptions`` .\n')
    master_user_password: typing.Optional[str] = pydantic.Field(None, description='Password for the master user. Only specify if ``InternalUserDatabaseEnabled`` is true in ``AdvancedSecurityOptions`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-masteruseroptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    master_user_options_property = elasticsearch.CfnDomain.MasterUserOptionsProperty(\n        master_user_arn="masterUserArn",\n        master_user_name="masterUserName",\n        master_user_password="masterUserPassword"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['master_user_arn', 'master_user_name', 'master_user_password']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.MasterUserOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.NodeToNodeEncryptionOptionsProperty
class CfnDomain_NodeToNodeEncryptionOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether node-to-node encryption is enabled, as a Boolean.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-nodetonodeencryptionoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    node_to_node_encryption_options_property = elasticsearch.CfnDomain.NodeToNodeEncryptionOptionsProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.NodeToNodeEncryptionOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.SnapshotOptionsProperty
class CfnDomain_SnapshotOptionsPropertyDef(BaseStruct):
    automated_snapshot_start_hour: typing.Union[int, float, None] = pydantic.Field(None, description='The hour in UTC during which the service takes an automated daily snapshot of the indices in the OpenSearch Service domain. For example, if you specify 0, OpenSearch Service takes an automated snapshot everyday between midnight and 1 am. You can specify a value between 0 and 23.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-snapshotoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    snapshot_options_property = elasticsearch.CfnDomain.SnapshotOptionsProperty(\n        automated_snapshot_start_hour=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['automated_snapshot_start_hour']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.SnapshotOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.VPCOptionsProperty
class CfnDomain_VPCOptionsPropertyDef(BaseStruct):
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The list of security group IDs that are associated with the VPC endpoints for the domain. If you don't provide a security group ID, OpenSearch Service uses the default security group for the VPC. To learn more, see `Security groups for your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html>`_ in the *Amazon VPC User Guide* .\n")
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Provide one subnet ID for each Availability Zone that your domain uses. For example, you must specify three subnet IDs for a three Availability Zone domain. To learn more, see `VPCs and subnets <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html>`_ in the *Amazon VPC User Guide* . Required if you\'re creating your domain inside a VPC.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-vpcoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    v_pCOptions_property = elasticsearch.CfnDomain.VPCOptionsProperty(\n        security_group_ids=["securityGroupIds"],\n        subnet_ids=["subnetIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['security_group_ids', 'subnet_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.VPCOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain.ZoneAwarenessConfigProperty
class CfnDomain_ZoneAwarenessConfigPropertyDef(BaseStruct):
    availability_zone_count: typing.Union[int, float, None] = pydantic.Field(None, description='If you enabled multiple Availability Zones (AZs), the number of AZs that you want the domain to use. Valid values are ``2`` and ``3`` . Default is 2.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticsearch-domain-zoneawarenessconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    zone_awareness_config_property = elasticsearch.CfnDomain.ZoneAwarenessConfigProperty(\n        availability_zone_count=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain.ZoneAwarenessConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.CognitoOptions
class CognitoOptionsDef(BaseStruct):
    identity_pool_id: str = pydantic.Field(..., description='(deprecated) The Amazon Cognito identity pool ID that you want Amazon ES to use for Kibana authentication.\n')
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='(deprecated) A role that allows Amazon ES to configure your user pool and identity pool. It must have the ``AmazonESCognitoAccess`` policy attached to it.\n')
    user_pool_id: str = pydantic.Field(..., description='(deprecated) The Amazon Cognito user pool ID that you want Amazon ES to use for Kibana authentication.\n\n:deprecated: use opensearchservice module instead\n\n:see: https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-cognito-auth.html\n:stability: deprecated\n:exampleMetadata: fixture=migrate-opensearch infused\n\nExample::\n\n    es.Domain(self, "Domain",\n        cognito_kibana_auth=es.CognitoOptions(\n            identity_pool_id="test-identity-pool-id",\n            user_pool_id="test-user-pool-id",\n            role=role\n        ),\n        version=elasticsearch_version\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['identity_pool_id', 'role', 'user_pool_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CognitoOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CognitoOptionsDefConfig] = pydantic.Field(None)


class CognitoOptionsDefConfig(pydantic.BaseModel):
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_elasticsearch.CustomEndpointOptions
class CustomEndpointOptionsDef(BaseStruct):
    domain_name: str = pydantic.Field(..., description='(deprecated) The custom domain name to assign.\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description='(deprecated) The certificate to use. Default: - create a new one\n')
    hosted_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='(deprecated) The hosted zone in Route53 to create the CNAME record in. Default: - do not create a CNAME\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: infused\n\nExample::\n\n    es.Domain(self, "Domain",\n        version=es.ElasticsearchVersion.V7_7,\n        custom_endpoint=es.CustomEndpointOptions(\n            domain_name="search.example.com"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'certificate', 'hosted_zone']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CustomEndpointOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.DomainAttributes
class DomainAttributesDef(BaseStruct):
    domain_arn: str = pydantic.Field(..., description='(deprecated) The ARN of the Elasticsearch domain.\n')
    domain_endpoint: str = pydantic.Field(..., description='(deprecated) The domain endpoint of the Elasticsearch domain.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    domain_attributes = elasticsearch.DomainAttributes(\n        domain_arn="domainArn",\n        domain_endpoint="domainEndpoint"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_arn', 'domain_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.DomainAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.DomainProps
class DomainPropsDef(BaseStruct):
    version: models.aws_elasticsearch.ElasticsearchVersionDef = pydantic.Field(..., description='(deprecated) The Elasticsearch version that your domain will leverage.\n')
    access_policies: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='(deprecated) Domain Access policies. Default: - No access policies.\n')
    advanced_options: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='(deprecated) Additional options to specify for the Amazon ES domain. Default: - no advanced options are specified\n')
    automated_snapshot_start_hour: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) The hour in UTC during which the service takes an automated daily snapshot of the indices in the Amazon ES domain. Only applies for Elasticsearch versions below 5.3. Default: - Hourly automated snapshots not used\n')
    capacity: typing.Union[models.aws_elasticsearch.CapacityConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) The cluster capacity configuration for the Amazon ES domain. Default: - 1 r5.large.elasticsearch data node; no dedicated master nodes.\n')
    cognito_kibana_auth: typing.Union[models.aws_elasticsearch.CognitoOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) Configures Amazon ES to use Amazon Cognito authentication for Kibana. Default: - Cognito not used for authentication to Kibana.\n')
    custom_endpoint: typing.Union[models.aws_elasticsearch.CustomEndpointOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) To configure a custom domain configure these options. If you specify a Route53 hosted zone it will create a CNAME record and use DNS validation for the certificate Default: - no custom domain endpoint will be configured\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='(deprecated) Enforces a particular physical domain name. Default: - A name will be auto-generated.\n')
    ebs: typing.Union[models.aws_elasticsearch.EbsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) The configurations of Amazon Elastic Block Store (Amazon EBS) volumes that are attached to data nodes in the Amazon ES domain. For more information, see [Configuring EBS-based Storage] (https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-ebs) in the Amazon Elasticsearch Service Developer Guide. Default: - 10 GiB General Purpose (SSD) volumes per node.\n')
    enable_version_upgrade: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) To upgrade an Amazon ES domain to a new version of Elasticsearch rather than replacing the entire domain resource, use the EnableVersionUpgrade update policy. Default: - false\n')
    encryption_at_rest: typing.Union[models.aws_elasticsearch.EncryptionAtRestOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) Encryption at rest options for the cluster. Default: - No encryption at rest\n')
    enforce_https: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) True to require that all traffic to the domain arrive over HTTPS. Default: - false\n')
    fine_grained_access_control: typing.Union[models.aws_elasticsearch.AdvancedSecurityOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) Specifies options for fine-grained access control. Requires Elasticsearch version 6.7 or later. Enabling fine-grained access control also requires encryption of data at rest and node-to-node encryption, along with enforced HTTPS. Default: - fine-grained access control is disabled\n')
    logging: typing.Union[models.aws_elasticsearch.LoggingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) Configuration log publishing configuration options. Default: - No logs are published\n')
    node_to_node_encryption: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Specify true to enable node to node encryption. Requires Elasticsearch version 6.0 or later. Default: - Node to node encryption is not enabled.\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='(deprecated) Policy to apply when the domain is removed from the stack. Default: RemovalPolicy.RETAIN\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='(deprecated) The list of security groups that are associated with the VPC endpoints for the domain. Only used if ``vpc`` is specified. Default: - One new security group is created.\n')
    tls_security_policy: typing.Optional[aws_cdk.aws_elasticsearch.TLSSecurityPolicy] = pydantic.Field(None, description='(deprecated) The minimum TLS version required for traffic to the domain. Default: - TLSSecurityPolicy.TLS_1_0\n')
    use_unsigned_basic_auth: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Configures the domain so that unsigned basic auth is enabled. If no master user is provided a default master user with username ``admin`` and a dynamically generated password stored in KMS is created. The password can be retrieved by getting ``masterUserPassword`` from the domain instance. Setting this to true will also add an access policy that allows unsigned access, enable node to node encryption, encryption at rest. If conflicting settings are encountered (like disabling encryption at rest) enabling this setting will cause a failure. Default: - false\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='(deprecated) Place the domain inside this VPC. Default: - Domain is not placed in a VPC.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(deprecated) The specific vpc subnets the domain will be placed in. You must provide one subnet for each Availability Zone that your domain uses. For example, you must specify three subnet IDs for a three Availability Zone domain. Only used if ``vpc`` is specified. Default: - All private subnets.\n')
    zone_awareness: typing.Union[models.aws_elasticsearch.ZoneAwarenessConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(deprecated) The cluster zone awareness configuration for the Amazon ES domain. Default: - no zone awareness (1 AZ)\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: infused\n\nExample::\n\n    domain = es.Domain(self, "Domain",\n        version=es.ElasticsearchVersion.V7_4,\n        ebs=es.EbsOptions(\n            volume_size=100,\n            volume_type=ec2.EbsDeviceVolumeType.GENERAL_PURPOSE_SSD\n        ),\n        node_to_node_encryption=True,\n        encryption_at_rest=es.EncryptionAtRestOptions(\n            enabled=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'access_policies', 'advanced_options', 'automated_snapshot_start_hour', 'capacity', 'cognito_kibana_auth', 'custom_endpoint', 'domain_name', 'ebs', 'enable_version_upgrade', 'encryption_at_rest', 'enforce_https', 'fine_grained_access_control', 'logging', 'node_to_node_encryption', 'removal_policy', 'security_groups', 'tls_security_policy', 'use_unsigned_basic_auth', 'vpc', 'vpc_subnets', 'zone_awareness']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.DomainProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.EbsOptions
class EbsOptionsDef(BaseStruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Specifies whether Amazon EBS volumes are attached to data nodes in the Amazon ES domain. Default: - true\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) The number of I/O operations per second (IOPS) that the volume supports. This property applies only to the Provisioned IOPS (SSD) EBS volume type. Default: - iops are not set.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) The size (in GiB) of the EBS volume for each data node. The minimum and maximum size of an EBS volume depends on the EBS volume type and the instance type to which it is attached. For more information, see [Configuring EBS-based Storage] (https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-ebs) in the Amazon Elasticsearch Service Developer Guide. Default: 10\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='(deprecated) The EBS volume type to use with the Amazon ES domain, such as standard, gp2, io1. For more information, see[Configuring EBS-based Storage] (https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-ebs) in the Amazon Elasticsearch Service Developer Guide. Default: gp2\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: infused\n\nExample::\n\n    prod_domain = es.Domain(self, "Domain",\n        version=es.ElasticsearchVersion.V7_1,\n        capacity=es.CapacityConfig(\n            master_nodes=5,\n            data_nodes=20\n        ),\n        ebs=es.EbsOptions(\n            volume_size=20\n        ),\n        zone_awareness=es.ZoneAwarenessConfig(\n            availability_zone_count=3\n        ),\n        logging=es.LoggingOptions(\n            slow_search_log_enabled=True,\n            app_log_enabled=True,\n            slow_index_log_enabled=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'iops', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.EbsOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.EncryptionAtRestOptions
class EncryptionAtRestOptionsDef(BaseStruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Specify true to enable encryption at rest. Default: - encryption at rest is disabled.\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='(deprecated) Supply if using KMS key for encryption at rest. Default: - uses default aws/es KMS key.\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: infused\n\nExample::\n\n    domain = es.Domain(self, "Domain",\n        version=es.ElasticsearchVersion.V7_1,\n        enforce_https=True,\n        node_to_node_encryption=True,\n        encryption_at_rest=es.EncryptionAtRestOptions(\n            enabled=True\n        ),\n        fine_grained_access_control=es.AdvancedSecurityOptions(\n            master_user_name="master-user"\n        )\n    )\n\n    master_user_password = domain.master_user_password\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'kms_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.EncryptionAtRestOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.LoggingOptions
class LoggingOptionsDef(BaseStruct):
    app_log_enabled: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Specify if Elasticsearch application logging should be set up. Requires Elasticsearch version 5.1 or later. Default: - false\n')
    app_log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='(deprecated) Log Elasticsearch application logs to this log group. Default: - a new log group is created if app logging is enabled\n')
    audit_log_enabled: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Specify if Elasticsearch audit logging should be set up. Requires Elasticsearch version 6.7 or later and fine grained access control to be enabled. Default: - false\n')
    audit_log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='(deprecated) Log Elasticsearch audit logs to this log group. Default: - a new log group is created if audit logging is enabled\n')
    slow_index_log_enabled: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Specify if slow index logging should be set up. Requires Elasticsearch version 5.1 or later. Default: - false\n')
    slow_index_log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='(deprecated) Log slow indices to this log group. Default: - a new log group is created if slow index logging is enabled\n')
    slow_search_log_enabled: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Specify if slow search logging should be set up. Requires Elasticsearch version 5.1 or later. Default: - false\n')
    slow_search_log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='(deprecated) Log slow searches to this log group. Default: - a new log group is created if slow search logging is enabled\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: infused\n\nExample::\n\n    prod_domain = es.Domain(self, "Domain",\n        version=es.ElasticsearchVersion.V7_1,\n        capacity=es.CapacityConfig(\n            master_nodes=5,\n            data_nodes=20\n        ),\n        ebs=es.EbsOptions(\n            volume_size=20\n        ),\n        zone_awareness=es.ZoneAwarenessConfig(\n            availability_zone_count=3\n        ),\n        logging=es.LoggingOptions(\n            slow_search_log_enabled=True,\n            app_log_enabled=True,\n            slow_index_log_enabled=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['app_log_enabled', 'app_log_group', 'audit_log_enabled', 'audit_log_group', 'slow_index_log_enabled', 'slow_index_log_group', 'slow_search_log_enabled', 'slow_search_log_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.LoggingOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.ZoneAwarenessConfig
class ZoneAwarenessConfigDef(BaseStruct):
    availability_zone_count: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) If you enabled multiple Availability Zones (AZs), the number of AZs that you want the domain to use. Valid values are 2 and 3. Default: - 2 if zone awareness is enabled.\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Indicates whether to enable zone awareness for the Amazon ES domain. When you enable zone awareness, Amazon ES allocates the nodes and replica index shards that belong to a cluster across two Availability Zones (AZs) in the same region to prevent data loss and minimize downtime in the event of node or data center failure. Don\'t enable zone awareness if your cluster has no replica index shards or is a single-node cluster. For more information, see [Configuring a Multi-AZ Domain] (https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-managedomains-multiaz) in the Amazon Elasticsearch Service Developer Guide. Default: - false\n\n:deprecated: use opensearchservice module instead\n\n:stability: deprecated\n:exampleMetadata: infused\n\nExample::\n\n    prod_domain = es.Domain(self, "Domain",\n        version=es.ElasticsearchVersion.V7_1,\n        capacity=es.CapacityConfig(\n            master_nodes=5,\n            data_nodes=20\n        ),\n        ebs=es.EbsOptions(\n            volume_size=20\n        ),\n        zone_awareness=es.ZoneAwarenessConfig(\n            availability_zone_count=3\n        ),\n        logging=es.LoggingOptions(\n            slow_search_log_enabled=True,\n            app_log_enabled=True,\n            slow_index_log_enabled=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone_count', 'enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.ZoneAwarenessConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticsearch.TLSSecurityPolicy
# skipping emum

#  autogenerated from aws_cdk.aws_elasticsearch.IDomain
#  skipping Interface

#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomain
class CfnDomainDef(BaseCfnResource):
    access_policies: typing.Any = pydantic.Field(None, description='An AWS Identity and Access Management ( IAM ) policy document that specifies who can access the OpenSearch Service domain and their permissions. For more information, see `Configuring access policies <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ac.html#ac-creating>`_ in the *Amazon OpenSearch Service Developer Guid* e.\n')
    advanced_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Additional options to specify for the OpenSearch Service domain. For more information, see `Advanced cluster parameters <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    advanced_security_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_AdvancedSecurityOptionsInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies options for fine-grained access control.\n')
    cognito_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_CognitoOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures OpenSearch Service to use Amazon Cognito authentication for OpenSearch Dashboards.\n')
    domain_endpoint_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_DomainEndpointOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies additional options for the domain endpoint, such as whether to require HTTPS for all traffic or whether to use a custom endpoint rather than the default endpoint.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description="A name for the OpenSearch Service domain. For valid values, see the `DomainName <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/configuration-api.html#configuration-api-datatypes-domainname>`_ data type in the *Amazon OpenSearch Service Developer Guide* . If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the domain name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    ebs_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_EBSOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configurations of Amazon Elastic Block Store (Amazon EBS) volumes that are attached to data nodes in the OpenSearch Service domain. For more information, see `EBS volume size limits <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/limits.html#ebsresource>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    elasticsearch_cluster_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_ElasticsearchClusterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='ElasticsearchClusterConfig is a property of the AWS::Elasticsearch::Domain resource that configures the cluster of an Amazon OpenSearch Service domain.\n')
    elasticsearch_version: typing.Optional[str] = pydantic.Field(None, description='The version of Elasticsearch to use, such as 2.3. If not specified, 1.5 is used as the default. For information about the versions that OpenSearch Service supports, see `Supported versions of OpenSearch and Elasticsearch <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/what-is.html#choosing-version>`_ in the *Amazon OpenSearch Service Developer Guide* . If you set the `EnableVersionUpgrade <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html#cfn-attributes-updatepolicy-upgradeopensearchdomain>`_ update policy to ``true`` , you can update ``ElasticsearchVersion`` without interruption. When ``EnableVersionUpgrade`` is set to ``false`` , or is not specified, updating ``ElasticsearchVersion`` results in `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    encryption_at_rest_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_EncryptionAtRestOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether the domain should encrypt data at rest, and if so, the AWS Key Management Service key to use. See `Encryption of data at rest for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/encryption-at-rest.html>`_ .\n')
    log_publishing_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_LogPublishingOptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An object with one or more of the following keys: ``SEARCH_SLOW_LOGS`` , ``ES_APPLICATION_LOGS`` , ``INDEX_SLOW_LOGS`` , ``AUDIT_LOGS`` , depending on the types of logs you want to publish. Each key needs a valid ``LogPublishingOption`` value.\n')
    node_to_node_encryption_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_NodeToNodeEncryptionOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies whether node-to-node encryption is enabled. See `Node-to-node encryption for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ntn.html>`_ .\n')
    snapshot_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_SnapshotOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='*DEPRECATED* . The automated snapshot configuration for the OpenSearch Service domain indices.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An arbitrary set of tags (keyvalue pairs) to associate with the OpenSearch Service domain.\n')
    vpc_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_VPCOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The virtual private cloud (VPC) configuration for the OpenSearch Service domain. For more information, see `Launching your Amazon OpenSearch Service domains within a VPC <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html>`_ in the *Amazon OpenSearch Service Developer Guide* .')
    _init_params: typing.ClassVar[list[str]] = ['access_policies', 'advanced_options', 'advanced_security_options', 'cognito_options', 'domain_endpoint_options', 'domain_name', 'ebs_options', 'elasticsearch_cluster_config', 'elasticsearch_version', 'encryption_at_rest_options', 'log_publishing_options', 'node_to_node_encryption_options', 'snapshot_options', 'tags', 'vpc_options']
    _method_names: typing.ClassVar[list[str]] = ['AdvancedSecurityOptionsInputProperty', 'CognitoOptionsProperty', 'ColdStorageOptionsProperty', 'DomainEndpointOptionsProperty', 'EBSOptionsProperty', 'ElasticsearchClusterConfigProperty', 'EncryptionAtRestOptionsProperty', 'LogPublishingOptionProperty', 'MasterUserOptionsProperty', 'NodeToNodeEncryptionOptionsProperty', 'SnapshotOptionsProperty', 'VPCOptionsProperty', 'ZoneAwarenessConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomain'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDomainDefConfig] = pydantic.Field(None)


class CfnDomainDefConfig(pydantic.BaseModel):
    AdvancedSecurityOptionsInputProperty: typing.Optional[list[CfnDomainDefAdvancedsecurityoptionsinputpropertyParams]] = pydantic.Field(None, description='')
    CognitoOptionsProperty: typing.Optional[list[CfnDomainDefCognitooptionspropertyParams]] = pydantic.Field(None, description='')
    ColdStorageOptionsProperty: typing.Optional[list[CfnDomainDefColdstorageoptionspropertyParams]] = pydantic.Field(None, description='')
    DomainEndpointOptionsProperty: typing.Optional[list[CfnDomainDefDomainendpointoptionspropertyParams]] = pydantic.Field(None, description='')
    EBSOptionsProperty: typing.Optional[list[CfnDomainDefEbsoptionspropertyParams]] = pydantic.Field(None, description='')
    ElasticsearchClusterConfigProperty: typing.Optional[list[CfnDomainDefElasticsearchclusterconfigpropertyParams]] = pydantic.Field(None, description='')
    EncryptionAtRestOptionsProperty: typing.Optional[list[CfnDomainDefEncryptionatrestoptionspropertyParams]] = pydantic.Field(None, description='')
    LogPublishingOptionProperty: typing.Optional[list[CfnDomainDefLogpublishingoptionpropertyParams]] = pydantic.Field(None, description='')
    MasterUserOptionsProperty: typing.Optional[list[CfnDomainDefMasteruseroptionspropertyParams]] = pydantic.Field(None, description='')
    NodeToNodeEncryptionOptionsProperty: typing.Optional[list[CfnDomainDefNodetonodeencryptionoptionspropertyParams]] = pydantic.Field(None, description='')
    SnapshotOptionsProperty: typing.Optional[list[CfnDomainDefSnapshotoptionspropertyParams]] = pydantic.Field(None, description='')
    VPCOptionsProperty: typing.Optional[list[CfnDomainDefVpcoptionspropertyParams]] = pydantic.Field(None, description='')
    ZoneAwarenessConfigProperty: typing.Optional[list[CfnDomainDefZoneawarenessconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDomainDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDomainDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDomainDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDomainDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDomainDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDomainDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDomainDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDomainDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDomainDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDomainDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDomainDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDomainDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDomainDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDomainDefAdvancedsecurityoptionsinputpropertyParams(pydantic.BaseModel):
    anonymous_auth_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    internal_user_database_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    master_user_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_MasterUserOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefCognitooptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    identity_pool_id: typing.Optional[str] = pydantic.Field(None, description='')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    user_pool_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefColdstorageoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefDomainendpointoptionspropertyParams(pydantic.BaseModel):
    custom_endpoint: typing.Optional[str] = pydantic.Field(None, description='')
    custom_endpoint_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='')
    custom_endpoint_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    enforce_https: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    tls_security_policy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefEbsoptionspropertyParams(pydantic.BaseModel):
    ebs_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefElasticsearchclusterconfigpropertyParams(pydantic.BaseModel):
    cold_storage_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_ColdStorageOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    dedicated_master_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    dedicated_master_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    dedicated_master_type: typing.Optional[str] = pydantic.Field(None, description='')
    instance_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='')
    warm_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    warm_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    warm_type: typing.Optional[str] = pydantic.Field(None, description='')
    zone_awareness_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_ZoneAwarenessConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    zone_awareness_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefEncryptionatrestoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefLogpublishingoptionpropertyParams(pydantic.BaseModel):
    cloud_watch_logs_log_group_arn: typing.Optional[str] = pydantic.Field(None, description='')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefMasteruseroptionspropertyParams(pydantic.BaseModel):
    master_user_arn: typing.Optional[str] = pydantic.Field(None, description='')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description='')
    master_user_password: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefNodetonodeencryptionoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefSnapshotoptionspropertyParams(pydantic.BaseModel):
    automated_snapshot_start_hour: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefVpcoptionspropertyParams(pydantic.BaseModel):
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDomainDefZoneawarenessconfigpropertyParams(pydantic.BaseModel):
    availability_zone_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDomainDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDomainDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDomainDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDomainDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDomainDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDomainDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDomainDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDomainDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDomainDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_elasticsearch.CfnDomainProps
class CfnDomainPropsDef(BaseCfnProperty):
    access_policies: typing.Any = pydantic.Field(None, description='An AWS Identity and Access Management ( IAM ) policy document that specifies who can access the OpenSearch Service domain and their permissions. For more information, see `Configuring access policies <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ac.html#ac-creating>`_ in the *Amazon OpenSearch Service Developer Guid* e.\n')
    advanced_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Additional options to specify for the OpenSearch Service domain. For more information, see `Advanced cluster parameters <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    advanced_security_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_AdvancedSecurityOptionsInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies options for fine-grained access control.\n')
    cognito_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_CognitoOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures OpenSearch Service to use Amazon Cognito authentication for OpenSearch Dashboards.\n')
    domain_endpoint_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_DomainEndpointOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies additional options for the domain endpoint, such as whether to require HTTPS for all traffic or whether to use a custom endpoint rather than the default endpoint.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description="A name for the OpenSearch Service domain. For valid values, see the `DomainName <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/configuration-api.html#configuration-api-datatypes-domainname>`_ data type in the *Amazon OpenSearch Service Developer Guide* . If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the domain name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    ebs_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_EBSOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configurations of Amazon Elastic Block Store (Amazon EBS) volumes that are attached to data nodes in the OpenSearch Service domain. For more information, see `EBS volume size limits <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/limits.html#ebsresource>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    elasticsearch_cluster_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_ElasticsearchClusterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='ElasticsearchClusterConfig is a property of the AWS::Elasticsearch::Domain resource that configures the cluster of an Amazon OpenSearch Service domain.\n')
    elasticsearch_version: typing.Optional[str] = pydantic.Field(None, description='The version of Elasticsearch to use, such as 2.3. If not specified, 1.5 is used as the default. For information about the versions that OpenSearch Service supports, see `Supported versions of OpenSearch and Elasticsearch <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/what-is.html#choosing-version>`_ in the *Amazon OpenSearch Service Developer Guide* . If you set the `EnableVersionUpgrade <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html#cfn-attributes-updatepolicy-upgradeopensearchdomain>`_ update policy to ``true`` , you can update ``ElasticsearchVersion`` without interruption. When ``EnableVersionUpgrade`` is set to ``false`` , or is not specified, updating ``ElasticsearchVersion`` results in `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    encryption_at_rest_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_EncryptionAtRestOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether the domain should encrypt data at rest, and if so, the AWS Key Management Service key to use. See `Encryption of data at rest for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/encryption-at-rest.html>`_ .\n')
    log_publishing_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_LogPublishingOptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An object with one or more of the following keys: ``SEARCH_SLOW_LOGS`` , ``ES_APPLICATION_LOGS`` , ``INDEX_SLOW_LOGS`` , ``AUDIT_LOGS`` , depending on the types of logs you want to publish. Each key needs a valid ``LogPublishingOption`` value.\n')
    node_to_node_encryption_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_NodeToNodeEncryptionOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies whether node-to-node encryption is enabled. See `Node-to-node encryption for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ntn.html>`_ .\n')
    snapshot_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_SnapshotOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='*DEPRECATED* . The automated snapshot configuration for the OpenSearch Service domain indices.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An arbitrary set of tags (keyvalue pairs) to associate with the OpenSearch Service domain.\n')
    vpc_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_elasticsearch.CfnDomain_VPCOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The virtual private cloud (VPC) configuration for the OpenSearch Service domain. For more information, see `Launching your Amazon OpenSearch Service domains within a VPC <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html>`_ in the *Amazon OpenSearch Service Developer Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticsearch-domain.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticsearch as elasticsearch\n\n    # access_policies: Any\n\n    cfn_domain_props = elasticsearch.CfnDomainProps(\n        access_policies=access_policies,\n        advanced_options={\n            "advanced_options_key": "advancedOptions"\n        },\n        advanced_security_options=elasticsearch.CfnDomain.AdvancedSecurityOptionsInputProperty(\n            anonymous_auth_enabled=False,\n            enabled=False,\n            internal_user_database_enabled=False,\n            master_user_options=elasticsearch.CfnDomain.MasterUserOptionsProperty(\n                master_user_arn="masterUserArn",\n                master_user_name="masterUserName",\n                master_user_password="masterUserPassword"\n            )\n        ),\n        cognito_options=elasticsearch.CfnDomain.CognitoOptionsProperty(\n            enabled=False,\n            identity_pool_id="identityPoolId",\n            role_arn="roleArn",\n            user_pool_id="userPoolId"\n        ),\n        domain_endpoint_options=elasticsearch.CfnDomain.DomainEndpointOptionsProperty(\n            custom_endpoint="customEndpoint",\n            custom_endpoint_certificate_arn="customEndpointCertificateArn",\n            custom_endpoint_enabled=False,\n            enforce_https=False,\n            tls_security_policy="tlsSecurityPolicy"\n        ),\n        domain_name="domainName",\n        ebs_options=elasticsearch.CfnDomain.EBSOptionsProperty(\n            ebs_enabled=False,\n            iops=123,\n            volume_size=123,\n            volume_type="volumeType"\n        ),\n        elasticsearch_cluster_config=elasticsearch.CfnDomain.ElasticsearchClusterConfigProperty(\n            cold_storage_options=elasticsearch.CfnDomain.ColdStorageOptionsProperty(\n                enabled=False\n            ),\n            dedicated_master_count=123,\n            dedicated_master_enabled=False,\n            dedicated_master_type="dedicatedMasterType",\n            instance_count=123,\n            instance_type="instanceType",\n            warm_count=123,\n            warm_enabled=False,\n            warm_type="warmType",\n            zone_awareness_config=elasticsearch.CfnDomain.ZoneAwarenessConfigProperty(\n                availability_zone_count=123\n            ),\n            zone_awareness_enabled=False\n        ),\n        elasticsearch_version="elasticsearchVersion",\n        encryption_at_rest_options=elasticsearch.CfnDomain.EncryptionAtRestOptionsProperty(\n            enabled=False,\n            kms_key_id="kmsKeyId"\n        ),\n        log_publishing_options={\n            "log_publishing_options_key": elasticsearch.CfnDomain.LogPublishingOptionProperty(\n                cloud_watch_logs_log_group_arn="cloudWatchLogsLogGroupArn",\n                enabled=False\n            )\n        },\n        node_to_node_encryption_options=elasticsearch.CfnDomain.NodeToNodeEncryptionOptionsProperty(\n            enabled=False\n        ),\n        snapshot_options=elasticsearch.CfnDomain.SnapshotOptionsProperty(\n            automated_snapshot_start_hour=123\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        vpc_options=elasticsearch.CfnDomain.VPCOptionsProperty(\n            security_group_ids=["securityGroupIds"],\n            subnet_ids=["subnetIds"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_policies', 'advanced_options', 'advanced_security_options', 'cognito_options', 'domain_endpoint_options', 'domain_name', 'ebs_options', 'elasticsearch_cluster_config', 'elasticsearch_version', 'encryption_at_rest_options', 'log_publishing_options', 'node_to_node_encryption_options', 'snapshot_options', 'tags', 'vpc_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticsearch.CfnDomainProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    ElasticsearchVersion: typing.Optional[dict[str, ElasticsearchVersionDef]] = pydantic.Field(None)
    Domain: typing.Optional[dict[str, DomainDef]] = pydantic.Field(None)
    AdvancedSecurityOptions: typing.Optional[dict[str, AdvancedSecurityOptionsDef]] = pydantic.Field(None)
    CapacityConfig: typing.Optional[dict[str, CapacityConfigDef]] = pydantic.Field(None)
    CfnDomain_AdvancedSecurityOptionsInputProperty: typing.Optional[dict[str, CfnDomain_AdvancedSecurityOptionsInputPropertyDef]] = pydantic.Field(None)
    CfnDomain_CognitoOptionsProperty: typing.Optional[dict[str, CfnDomain_CognitoOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_ColdStorageOptionsProperty: typing.Optional[dict[str, CfnDomain_ColdStorageOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_DomainEndpointOptionsProperty: typing.Optional[dict[str, CfnDomain_DomainEndpointOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_EBSOptionsProperty: typing.Optional[dict[str, CfnDomain_EBSOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_ElasticsearchClusterConfigProperty: typing.Optional[dict[str, CfnDomain_ElasticsearchClusterConfigPropertyDef]] = pydantic.Field(None)
    CfnDomain_EncryptionAtRestOptionsProperty: typing.Optional[dict[str, CfnDomain_EncryptionAtRestOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_LogPublishingOptionProperty: typing.Optional[dict[str, CfnDomain_LogPublishingOptionPropertyDef]] = pydantic.Field(None)
    CfnDomain_MasterUserOptionsProperty: typing.Optional[dict[str, CfnDomain_MasterUserOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_NodeToNodeEncryptionOptionsProperty: typing.Optional[dict[str, CfnDomain_NodeToNodeEncryptionOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_SnapshotOptionsProperty: typing.Optional[dict[str, CfnDomain_SnapshotOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_VPCOptionsProperty: typing.Optional[dict[str, CfnDomain_VPCOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_ZoneAwarenessConfigProperty: typing.Optional[dict[str, CfnDomain_ZoneAwarenessConfigPropertyDef]] = pydantic.Field(None)
    CognitoOptions: typing.Optional[dict[str, CognitoOptionsDef]] = pydantic.Field(None)
    CustomEndpointOptions: typing.Optional[dict[str, CustomEndpointOptionsDef]] = pydantic.Field(None)
    DomainAttributes: typing.Optional[dict[str, DomainAttributesDef]] = pydantic.Field(None)
    DomainProps: typing.Optional[dict[str, DomainPropsDef]] = pydantic.Field(None)
    EbsOptions: typing.Optional[dict[str, EbsOptionsDef]] = pydantic.Field(None)
    EncryptionAtRestOptions: typing.Optional[dict[str, EncryptionAtRestOptionsDef]] = pydantic.Field(None)
    LoggingOptions: typing.Optional[dict[str, LoggingOptionsDef]] = pydantic.Field(None)
    ZoneAwarenessConfig: typing.Optional[dict[str, ZoneAwarenessConfigDef]] = pydantic.Field(None)
    CfnDomain: typing.Optional[dict[str, CfnDomainDef]] = pydantic.Field(None)
    CfnDomainProps: typing.Optional[dict[str, CfnDomainPropsDef]] = pydantic.Field(None)
    ...
