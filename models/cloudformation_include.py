from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.cloudformation_include.IncludedNestedStack
class IncludedNestedStackDef(BaseStruct):
    included_template: typing.Union[models.cloudformation_include.CfnIncludeDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The CfnInclude that represents the template, which can be used to access Resources and other template elements.\n')
    stack: typing.Union[models.NestedStackDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The NestedStack object which represents the scope of the template.\n\n:exampleMetadata: infused\n\nExample::\n\n    # parent_template: cfn_inc.CfnInclude\n\n\n    included_child_stack = parent_template.get_nested_stack("ChildStack")\n    child_stack = included_child_stack.stack\n    child_template = included_child_stack.included_template\n')
    _init_params: typing.ClassVar[list[str]] = ['included_template', 'stack']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloudformation_include.IncludedNestedStack'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.cloudformation_include.IncludedNestedStackDefConfig] = pydantic.Field(None)


class IncludedNestedStackDefConfig(pydantic.BaseModel):
    included_template_config: typing.Optional[models.cloudformation_include.CfnIncludeDefConfig] = pydantic.Field(None)
    stack_config: typing.Optional[models.core.NestedStackDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.cloudformation_include.CfnInclude
class CfnIncludeDef(BaseCfnResource):
    template_file: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Path to the template file. Both JSON and YAML template formats are supported.\n')
    allow_cyclical_references: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to allow cyclical references, effectively disregarding safeguards meant to avoid undeployable templates. This should only be set to true in the case of templates utilizing cloud transforms (e.g. SAM) that after processing the transform will no longer contain any circular references. Default: - will throw an error on detecting any cyclical references\n')
    load_nested_stacks: typing.Optional[typing.Mapping[str, typing.Union[models.cloudformation_include.CfnIncludePropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Specifies the template files that define nested stacks that should be included. If your template specifies a stack that isn't included here, it won't be created as a NestedStack resource, and it won't be accessible from the ``CfnInclude.getNestedStack`` method (but will still be accessible from the ``CfnInclude.getResource`` method). If you include a stack here with an ID that isn't in the template, or is in the template but is not a nested stack, template creation will fail and an error will be thrown. Default: - no nested stacks will be included\n")
    parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description="Specifies parameters to be replaced by the values in this mapping. Any parameters in the template that aren't specified here will be left unmodified. If you include a parameter here with an ID that isn't in the template, template creation will fail and an error will be thrown. If you are importing a parameter from a live stack, we cannot know the value of that parameter. You will need to supply a value for your parameters, else the default value will be used. Default: - parameters will retain their original definitions\n")
    preserve_logical_ids: typing.Optional[bool] = pydantic.Field(None, description="Whether the resources should have the same logical IDs in the resulting CDK template as they did in the original CloudFormation template file. If you're vending a Construct using an existing CloudFormation template, make sure to pass this as ``false``. **Note**: regardless of whether this option is true or false, the ``CfnInclude.getResource`` and related methods always uses the original logical ID of the resource/element, as specified in the template file. Default: true")
    _init_params: typing.ClassVar[list[str]] = ['template_file', 'allow_cyclical_references', 'load_nested_stacks', 'parameters', 'preserve_logical_ids']
    _method_names: typing.ClassVar[list[str]] = ['get_condition', 'get_hook', 'get_mapping', 'get_nested_stack', 'get_output', 'get_parameter', 'get_resource', 'get_rule', 'load_nested_stack', 'override_logical_id']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloudformation_include.CfnInclude'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.cloudformation_include.CfnIncludeDefConfig] = pydantic.Field(None)


class CfnIncludeDefConfig(pydantic.BaseModel):
    get_condition: typing.Optional[list[models.cloudformation_include.CfnIncludeDefGetConditionParams]] = pydantic.Field(None, description="Returns the CfnCondition object from the 'Conditions' section of the CloudFormation template with the given name.\nAny modifications performed on that object will be reflected in the resulting CDK template.\n\nIf a Condition with the given name is not present in the template,\nthrows an exception.")
    get_hook: typing.Optional[list[models.cloudformation_include.CfnIncludeDefGetHookParams]] = pydantic.Field(None, description="Returns the CfnHook object from the 'Hooks' section of the included CloudFormation template with the given logical ID.\nAny modifications performed on the returned object will be reflected in the resulting CDK template.\n\nIf a Hook with the given logical ID is not present in the template,\nan exception will be thrown.")
    get_mapping: typing.Optional[list[models.cloudformation_include.CfnIncludeDefGetMappingParams]] = pydantic.Field(None, description="Returns the CfnMapping object from the 'Mappings' section of the included template.\nAny modifications performed on that object will be reflected in the resulting CDK template.\n\nIf a Mapping with the given name is not present in the template,\nan exception will be thrown.")
    get_nested_stack: typing.Optional[list[models.cloudformation_include.CfnIncludeDefGetNestedStackParams]] = pydantic.Field(None, description='Returns a loaded NestedStack with name logicalId.\nFor a nested stack to be returned by this method,\nit must be specified either in the ``CfnIncludeProps.loadNestedStacks`` property,\nor through the ``loadNestedStack`` method.')
    get_output: typing.Optional[list[models.cloudformation_include.CfnIncludeDefGetOutputParams]] = pydantic.Field(None, description="Returns the CfnOutput object from the 'Outputs' section of the included template.\nAny modifications performed on that object will be reflected in the resulting CDK template.\n\nIf an Output with the given name is not present in the template,\nthrows an exception.")
    get_parameter: typing.Optional[list[models.cloudformation_include.CfnIncludeDefGetParameterParams]] = pydantic.Field(None, description="Returns the CfnParameter object from the 'Parameters' section of the included template.\nAny modifications performed on that object will be reflected in the resulting CDK template.\n\nIf a Parameter with the given name is not present in the template,\nthrows an exception.")
    get_resource: typing.Optional[list[models.cloudformation_include.CfnIncludeDefGetResourceParams]] = pydantic.Field(None, description="Returns the low-level CfnResource from the template with the given logical ID.\nAny modifications performed on that resource will be reflected in the resulting CDK template.\n\nThe returned object will be of the proper underlying class;\nyou can always cast it to the correct type in your code::\n\n   // assume the template contains an AWS::S3::Bucket with logical ID 'Bucket'\n   const cfnBucket = cfnTemplate.getResource('Bucket') as s3.CfnBucket;\n   // cfnBucket is of type s3.CfnBucket\n\nIf the template does not contain a resource with the given logical ID,\nan exception will be thrown.")
    get_rule: typing.Optional[list[models.cloudformation_include.CfnIncludeDefGetRuleParams]] = pydantic.Field(None, description="Returns the CfnRule object from the 'Rules' section of the CloudFormation template with the given name.\nAny modifications performed on that object will be reflected in the resulting CDK template.\n\nIf a Rule with the given name is not present in the template,\nan exception will be thrown.")
    load_nested_stack: typing.Optional[list[models.cloudformation_include.CfnIncludeDefLoadNestedStackParams]] = pydantic.Field(None, description='Includes a template for a child stack inside of this parent template.\nA child with this logical ID must exist in the template,\nand be of type AWS::CloudFormation::Stack.\nThis is equivalent to specifying the value in the ``CfnIncludeProps.loadNestedStacks``\nproperty on object construction.')
    override_logical_id: typing.Optional[list[models.cloudformation_include.CfnIncludeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')

class CfnIncludeDefGetConditionParams(pydantic.BaseModel):
    condition_name: str = pydantic.Field(..., description='the name of the Condition in the CloudFormation template file.')
    return_config: typing.Optional[list[models.core.CfnConditionDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefGetHookParams(pydantic.BaseModel):
    hook_logical_id: str = pydantic.Field(..., description="the logical ID of the Hook in the included CloudFormation template's 'Hooks' section.")
    return_config: typing.Optional[list[models.core.CfnHookDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefGetMappingParams(pydantic.BaseModel):
    mapping_name: str = pydantic.Field(..., description='the name of the Mapping in the template to retrieve.')
    return_config: typing.Optional[list[models.core.CfnMappingDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefGetNestedStackParams(pydantic.BaseModel):
    logical_id: str = pydantic.Field(..., description='the ID of the stack to retrieve, as it appears in the template.')
    return_config: typing.Optional[list[models.cloudformation_include.IncludedNestedStackDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefGetOutputParams(pydantic.BaseModel):
    logical_id: str = pydantic.Field(..., description='the name of the output to retrieve.')
    return_config: typing.Optional[list[models.core.CfnOutputDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefGetParameterParams(pydantic.BaseModel):
    parameter_name: str = pydantic.Field(..., description='the name of the parameter to retrieve.')
    return_config: typing.Optional[list[models.core.CfnParameterDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefGetResourceParams(pydantic.BaseModel):
    logical_id: str = pydantic.Field(..., description='the logical ID of the resource in the CloudFormation template file.')
    return_config: typing.Optional[list[models.core.CfnResourceDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefGetRuleParams(pydantic.BaseModel):
    rule_name: str = pydantic.Field(..., description='the name of the Rule in the CloudFormation template.')
    return_config: typing.Optional[list[models.core.CfnRuleDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefLoadNestedStackParams(pydantic.BaseModel):
    logical_id: str = pydantic.Field(..., description='the ID of the stack to retrieve, as it appears in the template.\n')
    template_file: str = pydantic.Field(..., description='Path to the template file. Both JSON and YAML template formats are supported.\n')
    allow_cyclical_references: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to allow cyclical references, effectively disregarding safeguards meant to avoid undeployable templates. This should only be set to true in the case of templates utilizing cloud transforms (e.g. SAM) that after processing the transform will no longer contain any circular references. Default: - will throw an error on detecting any cyclical references\n')
    load_nested_stacks: typing.Optional[typing.Mapping[str, typing.Union[models.cloudformation_include.CfnIncludePropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Specifies the template files that define nested stacks that should be included. If your template specifies a stack that isn't included here, it won't be created as a NestedStack resource, and it won't be accessible from the ``CfnInclude.getNestedStack`` method (but will still be accessible from the ``CfnInclude.getResource`` method). If you include a stack here with an ID that isn't in the template, or is in the template but is not a nested stack, template creation will fail and an error will be thrown. Default: - no nested stacks will be included\n")
    parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description="Specifies parameters to be replaced by the values in this mapping. Any parameters in the template that aren't specified here will be left unmodified. If you include a parameter here with an ID that isn't in the template, template creation will fail and an error will be thrown. If you are importing a parameter from a live stack, we cannot know the value of that parameter. You will need to supply a value for your parameters, else the default value will be used. Default: - parameters will retain their original definitions\n")
    preserve_logical_ids: typing.Optional[bool] = pydantic.Field(None, description="Whether the resources should have the same logical IDs in the resulting CDK template as they did in the original CloudFormation template file. If you're vending a Construct using an existing CloudFormation template, make sure to pass this as ``false``. **Note**: regardless of whether this option is true or false, the ``CfnInclude.getResource`` and related methods always uses the original logical ID of the resource/element, as specified in the template file. Default: true\n")
    return_config: typing.Optional[list[models.cloudformation_include.IncludedNestedStackDefConfig]] = pydantic.Field(None)
    ...

class CfnIncludeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...


#  autogenerated from aws_cdk.cloudformation_include.CfnIncludeProps
class CfnIncludePropsDef(BaseCfnProperty):
    template_file: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Path to the template file. Both JSON and YAML template formats are supported.\n')
    allow_cyclical_references: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to allow cyclical references, effectively disregarding safeguards meant to avoid undeployable templates. This should only be set to true in the case of templates utilizing cloud transforms (e.g. SAM) that after processing the transform will no longer contain any circular references. Default: - will throw an error on detecting any cyclical references\n')
    load_nested_stacks: typing.Optional[typing.Mapping[str, typing.Union[models.cloudformation_include.CfnIncludePropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Specifies the template files that define nested stacks that should be included. If your template specifies a stack that isn't included here, it won't be created as a NestedStack resource, and it won't be accessible from the ``CfnInclude.getNestedStack`` method (but will still be accessible from the ``CfnInclude.getResource`` method). If you include a stack here with an ID that isn't in the template, or is in the template but is not a nested stack, template creation will fail and an error will be thrown. Default: - no nested stacks will be included\n")
    parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description="Specifies parameters to be replaced by the values in this mapping. Any parameters in the template that aren't specified here will be left unmodified. If you include a parameter here with an ID that isn't in the template, template creation will fail and an error will be thrown. If you are importing a parameter from a live stack, we cannot know the value of that parameter. You will need to supply a value for your parameters, else the default value will be used. Default: - parameters will retain their original definitions\n")
    preserve_logical_ids: typing.Optional[bool] = pydantic.Field(None, description='Whether the resources should have the same logical IDs in the resulting CDK template as they did in the original CloudFormation template file. If you\'re vending a Construct using an existing CloudFormation template, make sure to pass this as ``false``. **Note**: regardless of whether this option is true or false, the ``CfnInclude.getResource`` and related methods always uses the original logical ID of the resource/element, as specified in the template file. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    parent_template = cfn_inc.CfnInclude(self, "ParentStack",\n        template_file="path/to/my-parent-template.json",\n        load_nested_stacks={\n            "ChildStack": cfn_inc.CfnIncludeProps(\n                template_file="path/to/my-nested-template.json"\n            )\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['template_file', 'allow_cyclical_references', 'load_nested_stacks', 'parameters', 'preserve_logical_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloudformation_include.CfnIncludeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    IncludedNestedStack: typing.Optional[dict[str, models.cloudformation_include.IncludedNestedStackDef]] = pydantic.Field(None)
    CfnInclude: typing.Optional[dict[str, models.cloudformation_include.CfnIncludeDef]] = pydantic.Field(None)
    CfnIncludeProps: typing.Optional[dict[str, models.cloudformation_include.CfnIncludePropsDef]] = pydantic.Field(None)
    ...

import models
