from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_lightsail.CfnBucket.AccessRulesProperty
class CfnBucket_AccessRulesPropertyDef(BaseStruct):
    allow_public_overrides: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the access control list (ACL) permissions that are applied to individual objects override the ``GetObject`` option that is currently specified. When this is true, you can use the `PutObjectAcl <https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObjectAcl.html>`_ Amazon S3 API operation to set individual objects to public (read-only) or private, using either the ``public-read`` ACL or the ``private`` ACL.\n')
    object_access: typing.Optional[str] = pydantic.Field(None, description='Specifies the anonymous access to all objects in a bucket. The following options can be specified: - ``public`` - Sets all objects in the bucket to public (read-only), making them readable by everyone on the internet. If the ``GetObject`` value is set to ``public`` , then all objects in the bucket default to public regardless of the ``allowPublicOverrides`` value. - ``private`` - Sets all objects in the bucket to private, making them readable only by you and anyone that you grant access to. If the ``GetObject`` value is set to ``private`` , and the ``allowPublicOverrides`` value is set to ``true`` , then all objects in the bucket default to private unless they are configured with a ``public-read`` ACL. Individual objects with a ``public-read`` ACL are readable by everyone on the internet.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-bucket-accessrules.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    access_rules_property = lightsail.CfnBucket.AccessRulesProperty(\n        allow_public_overrides=False,\n        object_access="objectAccess"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_public_overrides', 'object_access']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnBucket.AccessRulesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnContainer.ContainerProperty
class CfnContainer_ContainerPropertyDef(BaseStruct):
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The launch command for the container.\n')
    container_name: typing.Optional[str] = pydantic.Field(None, description='The name of the container.\n')
    environment: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_EnvironmentVariablePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The environment variables of the container.\n')
    image: typing.Optional[str] = pydantic.Field(None, description='The name of the image used for the container. Container images that are sourced from (registered and stored on) your container service start with a colon ( ``:`` ). For example, if your container service name is ``container-service-1`` , the container image label is ``mystaticsite`` , and you want to use the third version ( ``3`` ) of the registered container image, then you should specify ``:container-service-1.mystaticsite.3`` . To use the latest version of a container image, specify ``latest`` instead of a version number (for example, ``:container-service-1.mystaticsite.latest`` ). Your container service will automatically use the highest numbered version of the registered container image. Container images that are sourced from a public registry like Docker Hub don’t start with a colon. For example, ``nginx:latest`` or ``nginx`` .\n')
    ports: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_PortInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An object that describes the open firewall ports and protocols of the container.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-container-container.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    container_property = lightsail.CfnContainer.ContainerProperty(\n        command=["command"],\n        container_name="containerName",\n        environment=[lightsail.CfnContainer.EnvironmentVariableProperty(\n            value="value",\n            variable="variable"\n        )],\n        image="image",\n        ports=[lightsail.CfnContainer.PortInfoProperty(\n            port="port",\n            protocol="protocol"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['command', 'container_name', 'environment', 'image', 'ports']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainer.ContainerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnContainer.ContainerServiceDeploymentProperty
class CfnContainer_ContainerServiceDeploymentPropertyDef(BaseStruct):
    containers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_ContainerPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An object that describes the configuration for the containers of the deployment.\n')
    public_endpoint: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_PublicEndpointPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the endpoint of the deployment.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-container-containerservicedeployment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    container_service_deployment_property = lightsail.CfnContainer.ContainerServiceDeploymentProperty(\n        containers=[lightsail.CfnContainer.ContainerProperty(\n            command=["command"],\n            container_name="containerName",\n            environment=[lightsail.CfnContainer.EnvironmentVariableProperty(\n                value="value",\n                variable="variable"\n            )],\n            image="image",\n            ports=[lightsail.CfnContainer.PortInfoProperty(\n                port="port",\n                protocol="protocol"\n            )]\n        )],\n        public_endpoint=lightsail.CfnContainer.PublicEndpointProperty(\n            container_name="containerName",\n            container_port=123,\n            health_check_config=lightsail.CfnContainer.HealthCheckConfigProperty(\n                healthy_threshold=123,\n                interval_seconds=123,\n                path="path",\n                success_codes="successCodes",\n                timeout_seconds=123,\n                unhealthy_threshold=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['containers', 'public_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainer.ContainerServiceDeploymentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnContainer.EnvironmentVariableProperty
class CfnContainer_EnvironmentVariablePropertyDef(BaseStruct):
    value: typing.Optional[str] = pydantic.Field(None, description='The environment variable value.\n')
    variable: typing.Optional[str] = pydantic.Field(None, description='The environment variable key.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-container-environmentvariable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    environment_variable_property = lightsail.CfnContainer.EnvironmentVariableProperty(\n        value="value",\n        variable="variable"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['value', 'variable']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainer.EnvironmentVariableProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnContainer.HealthCheckConfigProperty
class CfnContainer_HealthCheckConfigPropertyDef(BaseStruct):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive health check successes required before moving the container to the ``Healthy`` state. The default value is ``2`` .\n')
    interval_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The approximate interval, in seconds, between health checks of an individual container. You can specify between ``5`` and ``300`` seconds. The default value is ``5`` .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path on the container on which to perform the health check. The default value is ``/`` .\n')
    success_codes: typing.Optional[str] = pydantic.Field(None, description='The HTTP codes to use when checking for a successful response from a container. You can specify values between ``200`` and ``499`` . You can specify multiple values (for example, ``200,202`` ) or a range of values (for example, ``200-299`` ).\n')
    timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of time, in seconds, during which no response means a failed health check. You can specify between ``2`` and ``60`` seconds. The default value is ``2`` .\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive health check failures required before moving the container to the ``Unhealthy`` state. The default value is ``2`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-container-healthcheckconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    health_check_config_property = lightsail.CfnContainer.HealthCheckConfigProperty(\n        healthy_threshold=123,\n        interval_seconds=123,\n        path="path",\n        success_codes="successCodes",\n        timeout_seconds=123,\n        unhealthy_threshold=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['healthy_threshold', 'interval_seconds', 'path', 'success_codes', 'timeout_seconds', 'unhealthy_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainer.HealthCheckConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnContainer.PortInfoProperty
class CfnContainer_PortInfoPropertyDef(BaseStruct):
    port: typing.Optional[str] = pydantic.Field(None, description='The open firewall ports of the container.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The protocol name for the open ports. *Allowed values* : ``HTTP`` | ``HTTPS`` | ``TCP`` | ``UDP``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-container-portinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    port_info_property = lightsail.CfnContainer.PortInfoProperty(\n        port="port",\n        protocol="protocol"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port', 'protocol']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainer.PortInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnContainer.PublicDomainNameProperty
class CfnContainer_PublicDomainNamePropertyDef(BaseStruct):
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='The name of the certificate for the public domains.\n')
    domain_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The public domain names to use with the container service.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-container-publicdomainname.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    public_domain_name_property = lightsail.CfnContainer.PublicDomainNameProperty(\n        certificate_name="certificateName",\n        domain_names=["domainNames"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_name', 'domain_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainer.PublicDomainNameProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnContainer.PublicEndpointProperty
class CfnContainer_PublicEndpointPropertyDef(BaseStruct):
    container_name: typing.Optional[str] = pydantic.Field(None, description='The name of the container entry of the deployment that the endpoint configuration applies to.\n')
    container_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port of the specified container to which traffic is forwarded to.\n')
    health_check_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_HealthCheckConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the health check configuration of the container.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-container-publicendpoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    public_endpoint_property = lightsail.CfnContainer.PublicEndpointProperty(\n        container_name="containerName",\n        container_port=123,\n        health_check_config=lightsail.CfnContainer.HealthCheckConfigProperty(\n            healthy_threshold=123,\n            interval_seconds=123,\n            path="path",\n            success_codes="successCodes",\n            timeout_seconds=123,\n            unhealthy_threshold=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_name', 'container_port', 'health_check_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainer.PublicEndpointProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDatabase.RelationalDatabaseParameterProperty
class CfnDatabase_RelationalDatabaseParameterPropertyDef(BaseStruct):
    allowed_values: typing.Optional[str] = pydantic.Field(None, description='The valid range of values for the parameter.\n')
    apply_method: typing.Optional[str] = pydantic.Field(None, description='Indicates when parameter updates are applied. Can be ``immediate`` or ``pending-reboot`` .\n')
    apply_type: typing.Optional[str] = pydantic.Field(None, description='Specifies the engine-specific parameter type.\n')
    data_type: typing.Optional[str] = pydantic.Field(None, description='The valid data type of the parameter.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the parameter.\n')
    is_modifiable: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the parameter can be modified.\n')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='The name of the parameter.\n')
    parameter_value: typing.Optional[str] = pydantic.Field(None, description='The value for the parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-database-relationaldatabaseparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    relational_database_parameter_property = lightsail.CfnDatabase.RelationalDatabaseParameterProperty(\n        allowed_values="allowedValues",\n        apply_method="applyMethod",\n        apply_type="applyType",\n        data_type="dataType",\n        description="description",\n        is_modifiable=False,\n        parameter_name="parameterName",\n        parameter_value="parameterValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_values', 'apply_method', 'apply_type', 'data_type', 'description', 'is_modifiable', 'parameter_name', 'parameter_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDatabase.RelationalDatabaseParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDisk.AddOnProperty
class CfnDisk_AddOnPropertyDef(BaseStruct):
    add_on_type: str = pydantic.Field(..., description='The add-on type (for example, ``AutoSnapshot`` ). .. epigraph:: ``AutoSnapshot`` is the only add-on that can be enabled for a disk.\n')
    auto_snapshot_add_on_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDisk_AutoSnapshotAddOnPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters for the automatic snapshot add-on, such as the daily time when an automatic snapshot will be created.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the add-on. Valid Values: ``Enabled`` | ``Disabled``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-disk-addon.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    add_on_property = lightsail.CfnDisk.AddOnProperty(\n        add_on_type="addOnType",\n\n        # the properties below are optional\n        auto_snapshot_add_on_request=lightsail.CfnDisk.AutoSnapshotAddOnProperty(\n            snapshot_time_of_day="snapshotTimeOfDay"\n        ),\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['add_on_type', 'auto_snapshot_add_on_request', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDisk.AddOnProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDisk.AutoSnapshotAddOnProperty
class CfnDisk_AutoSnapshotAddOnPropertyDef(BaseStruct):
    snapshot_time_of_day: typing.Optional[str] = pydantic.Field(None, description='The daily time when an automatic snapshot will be created. Constraints: - Must be in ``HH:00`` format, and in an hourly increment. - Specified in Coordinated Universal Time (UTC). - The snapshot will be automatically created between the time specified and up to 45 minutes after.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-disk-autosnapshotaddon.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    auto_snapshot_add_on_property = lightsail.CfnDisk.AutoSnapshotAddOnProperty(\n        snapshot_time_of_day="snapshotTimeOfDay"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['snapshot_time_of_day']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDisk.AutoSnapshotAddOnProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDisk.LocationProperty
class CfnDisk_LocationPropertyDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='``CfnDisk.LocationProperty.AvailabilityZone``.')
    region_name: typing.Optional[str] = pydantic.Field(None, description='``CfnDisk.LocationProperty.RegionName``.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-disk-location.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    location_property = lightsail.CfnDisk.LocationProperty(\n        availability_zone="availabilityZone",\n        region_name="regionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'region_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDisk.LocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDistribution.CacheBehaviorPerPathProperty
class CfnDistribution_CacheBehaviorPerPathPropertyDef(BaseStruct):
    behavior: typing.Optional[str] = pydantic.Field(None, description="The cache behavior for the specified path. You can specify one of the following per-path cache behaviors: - *``cache``* - This behavior caches the specified path. - *``dont-cache``* - This behavior doesn't cache the specified path.\n")
    path: typing.Optional[str] = pydantic.Field(None, description='The path to a directory or file to cache, or not cache. Use an asterisk symbol to specify wildcard directories ( ``path/to/assets/*`` ), and file types ( ``*.html`` , ``*jpg`` , ``*js`` ). Directories and file paths are case-sensitive. Examples: - Specify the following to cache all files in the document root of an Apache web server running on a instance. ``var/www/html/`` - Specify the following file to cache only the index page in the document root of an Apache web server. ``var/www/html/index.html`` - Specify the following to cache only the .html files in the document root of an Apache web server. ``var/www/html/*.html`` - Specify the following to cache only the .jpg, .png, and .gif files in the images sub-directory of the document root of an Apache web server. ``var/www/html/images/*.jpg`` ``var/www/html/images/*.png`` ``var/www/html/images/*.gif`` Specify the following to cache all files in the images subdirectory of the document root of an Apache web server. ``var/www/html/images/``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-distribution-cachebehaviorperpath.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cache_behavior_per_path_property = lightsail.CfnDistribution.CacheBehaviorPerPathProperty(\n        behavior="behavior",\n        path="path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['behavior', 'path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistribution.CacheBehaviorPerPathProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDistribution.CacheBehaviorProperty
class CfnDistribution_CacheBehaviorPropertyDef(BaseStruct):
    behavior: typing.Optional[str] = pydantic.Field(None, description='The cache behavior of the distribution. The following cache behaviors can be specified: - *``cache``* - This option is best for static sites. When specified, your distribution caches and serves your entire website as static content. This behavior is ideal for websites with static content that doesn\'t change depending on who views it, or for websites that don\'t use cookies, headers, or query strings to personalize content. - *``dont-cache``* - This option is best for sites that serve a mix of static and dynamic content. When specified, your distribution caches and serves only the content that is specified in the distribution’s ``CacheBehaviorPerPath`` parameter. This behavior is ideal for websites or web applications that use cookies, headers, and query strings to personalize content for individual users.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-distribution-cachebehavior.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cache_behavior_property = lightsail.CfnDistribution.CacheBehaviorProperty(\n        behavior="behavior"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['behavior']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistribution.CacheBehaviorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDistribution.CacheSettingsProperty
class CfnDistribution_CacheSettingsPropertyDef(BaseStruct):
    allowed_http_methods: typing.Optional[str] = pydantic.Field(None, description="The HTTP methods that are processed and forwarded to the distribution's origin. You can specify the following options: - ``GET,HEAD`` - The distribution forwards the ``GET`` and ``HEAD`` methods. - ``GET,HEAD,OPTIONS`` - The distribution forwards the ``GET`` , ``HEAD`` , and ``OPTIONS`` methods. - ``GET,HEAD,OPTIONS,PUT,PATCH,POST,DELETE`` - The distribution forwards the ``GET`` , ``HEAD`` , ``OPTIONS`` , ``PUT`` , ``PATCH`` , ``POST`` , and ``DELETE`` methods. If you specify ``GET,HEAD,OPTIONS,PUT,PATCH,POST,DELETE`` , you might need to restrict access to your distribution's origin so users can't perform operations that you don't want them to. For example, you might not want users to have permission to delete objects from your origin.\n")
    cached_http_methods: typing.Optional[str] = pydantic.Field(None, description='The HTTP method responses that are cached by your distribution. You can specify the following options: - ``GET,HEAD`` - The distribution caches responses to the ``GET`` and ``HEAD`` methods. - ``GET,HEAD,OPTIONS`` - The distribution caches responses to the ``GET`` , ``HEAD`` , and ``OPTIONS`` methods.\n')
    default_ttl: typing.Union[int, float, None] = pydantic.Field(None, description="The default amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the content has been updated. .. epigraph:: The value specified applies only when the origin does not add HTTP headers such as ``Cache-Control max-age`` , ``Cache-Control s-maxage`` , and ``Expires`` to objects.\n")
    forwarded_cookies: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_CookieObjectPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the cookies that are forwarded to the origin. Your content is cached based on the cookies that are forwarded.\n')
    forwarded_headers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_HeaderObjectPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the headers that are forwarded to the origin. Your content is cached based on the headers that are forwarded.\n')
    forwarded_query_strings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_QueryStringObjectPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the query strings that are forwarded to the origin. Your content is cached based on the query strings that are forwarded.\n')
    maximum_ttl: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated. The value specified applies only when the origin adds HTTP headers such as ``Cache-Control max-age`` , ``Cache-Control s-maxage`` , and ``Expires`` to objects.\n")
    minimum_ttl: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of time that objects stay in the distribution\'s cache before the distribution forwards another request to the origin to determine whether the object has been updated. A value of ``0`` must be specified for ``minimumTTL`` if the distribution is configured to forward all headers to the origin.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-distribution-cachesettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cache_settings_property = lightsail.CfnDistribution.CacheSettingsProperty(\n        allowed_http_methods="allowedHttpMethods",\n        cached_http_methods="cachedHttpMethods",\n        default_ttl=123,\n        forwarded_cookies=lightsail.CfnDistribution.CookieObjectProperty(\n            cookies_allow_list=["cookiesAllowList"],\n            option="option"\n        ),\n        forwarded_headers=lightsail.CfnDistribution.HeaderObjectProperty(\n            headers_allow_list=["headersAllowList"],\n            option="option"\n        ),\n        forwarded_query_strings=lightsail.CfnDistribution.QueryStringObjectProperty(\n            option=False,\n            query_strings_allow_list=["queryStringsAllowList"]\n        ),\n        maximum_ttl=123,\n        minimum_ttl=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_http_methods', 'cached_http_methods', 'default_ttl', 'forwarded_cookies', 'forwarded_headers', 'forwarded_query_strings', 'maximum_ttl', 'minimum_ttl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistribution.CacheSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDistribution.CookieObjectProperty
class CfnDistribution_CookieObjectPropertyDef(BaseStruct):
    cookies_allow_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The specific cookies to forward to your distribution's origin.\n")
    option: typing.Optional[str] = pydantic.Field(None, description='Specifies which cookies to forward to the distribution\'s origin for a cache behavior. Use one of the following configurations for your distribution: - *``all``* - Forwards all cookies to your origin. - *``none``* - Doesn’t forward cookies to your origin. - *``allow-list``* - Forwards only the cookies that you specify using the ``CookiesAllowList`` parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-distribution-cookieobject.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cookie_object_property = lightsail.CfnDistribution.CookieObjectProperty(\n        cookies_allow_list=["cookiesAllowList"],\n        option="option"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cookies_allow_list', 'option']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistribution.CookieObjectProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDistribution.HeaderObjectProperty
class CfnDistribution_HeaderObjectPropertyDef(BaseStruct):
    headers_allow_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The specific headers to forward to your distribution's origin.\n")
    option: typing.Optional[str] = pydantic.Field(None, description='The headers that you want your distribution to forward to your origin. Your distribution caches your content based on these headers. Use one of the following configurations for your distribution: - *``all``* - Forwards all headers to your origin.. - *``none``* - Forwards only the default headers. - *``allow-list``* - Forwards only the headers that you specify using the ``HeadersAllowList`` parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-distribution-headerobject.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    header_object_property = lightsail.CfnDistribution.HeaderObjectProperty(\n        headers_allow_list=["headersAllowList"],\n        option="option"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['headers_allow_list', 'option']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistribution.HeaderObjectProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDistribution.InputOriginProperty
class CfnDistribution_InputOriginPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the origin resource.\n')
    protocol_policy: typing.Optional[str] = pydantic.Field(None, description='The protocol that your Amazon Lightsail distribution uses when establishing a connection with your origin to pull content.\n')
    region_name: typing.Optional[str] = pydantic.Field(None, description='The AWS Region name of the origin resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-distribution-inputorigin.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    input_origin_property = lightsail.CfnDistribution.InputOriginProperty(\n        name="name",\n        protocol_policy="protocolPolicy",\n        region_name="regionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'protocol_policy', 'region_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistribution.InputOriginProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDistribution.QueryStringObjectProperty
class CfnDistribution_QueryStringObjectPropertyDef(BaseStruct):
    option: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the distribution forwards and caches based on query strings.\n')
    query_strings_allow_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The specific query strings that the distribution forwards to the origin. Your distribution caches content based on the specified query strings. If the ``option`` parameter is true, then your distribution forwards all query strings, regardless of what you specify using the ``QueryStringsAllowList`` parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-distribution-querystringobject.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    query_string_object_property = lightsail.CfnDistribution.QueryStringObjectProperty(\n        option=False,\n        query_strings_allow_list=["queryStringsAllowList"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['option', 'query_strings_allow_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistribution.QueryStringObjectProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.AddOnProperty
class CfnInstance_AddOnPropertyDef(BaseStruct):
    add_on_type: str = pydantic.Field(..., description='The add-on type (for example, ``AutoSnapshot`` ). .. epigraph:: ``AutoSnapshot`` is the only add-on that can be enabled for an instance.\n')
    auto_snapshot_add_on_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_AutoSnapshotAddOnPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters for the automatic snapshot add-on, such as the daily time when an automatic snapshot will be created.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the add-on. Valid Values: ``Enabled`` | ``Disabled``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-addon.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    add_on_property = lightsail.CfnInstance.AddOnProperty(\n        add_on_type="addOnType",\n\n        # the properties below are optional\n        auto_snapshot_add_on_request=lightsail.CfnInstance.AutoSnapshotAddOnProperty(\n            snapshot_time_of_day="snapshotTimeOfDay"\n        ),\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['add_on_type', 'auto_snapshot_add_on_request', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.AddOnProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.AutoSnapshotAddOnProperty
class CfnInstance_AutoSnapshotAddOnPropertyDef(BaseStruct):
    snapshot_time_of_day: typing.Optional[str] = pydantic.Field(None, description='The daily time when an automatic snapshot will be created. Constraints: - Must be in ``HH:00`` format, and in an hourly increment. - Specified in Coordinated Universal Time (UTC). - The snapshot will be automatically created between the time specified and up to 45 minutes after.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-autosnapshotaddon.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    auto_snapshot_add_on_property = lightsail.CfnInstance.AutoSnapshotAddOnProperty(\n        snapshot_time_of_day="snapshotTimeOfDay"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['snapshot_time_of_day']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.AutoSnapshotAddOnProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.DiskProperty
class CfnInstance_DiskPropertyDef(BaseStruct):
    disk_name: str = pydantic.Field(..., description='The unique name of the disk.\n')
    path: str = pydantic.Field(..., description='The disk path.\n')
    attached_to: typing.Optional[str] = pydantic.Field(None, description='The resources to which the disk is attached.\n')
    attachment_state: typing.Optional[str] = pydantic.Field(None, description='(Deprecated) The attachment state of the disk. .. epigraph:: In releases prior to November 14, 2017, this parameter returned ``attached`` for system disks in the API response. It is now deprecated, but still included in the response. Use ``isAttached`` instead.\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The input/output operations per second (IOPS) of the disk.\n')
    is_system_disk: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether this disk is a system disk (has an operating system loaded on it).\n')
    size_in_gb: typing.Optional[str] = pydantic.Field(None, description='The size of the disk in GB.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-disk.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    disk_property = lightsail.CfnInstance.DiskProperty(\n        disk_name="diskName",\n        path="path",\n\n        # the properties below are optional\n        attached_to="attachedTo",\n        attachment_state="attachmentState",\n        iops=123,\n        is_system_disk=False,\n        size_in_gb="sizeInGb"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['disk_name', 'path', 'attached_to', 'attachment_state', 'iops', 'is_system_disk', 'size_in_gb']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.DiskProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.HardwareProperty
class CfnInstance_HardwarePropertyDef(BaseStruct):
    cpu_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of vCPUs the instance has. .. epigraph:: The ``CpuCount`` property is read-only and should not be specified in a create instance or update instance request.\n')
    disks: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_DiskPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The disks attached to the instance. The instance restarts when performing an attach disk or detach disk request. This resets the public IP address of your instance if a static IP isn't attached to it.\n")
    ram_size_in_gb: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of RAM in GB on the instance (for example, ``1.0`` ). .. epigraph:: The ``RamSizeInGb`` property is read-only and should not be specified in a create instance or update instance request.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-hardware.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    hardware_property = lightsail.CfnInstance.HardwareProperty(\n        cpu_count=123,\n        disks=[lightsail.CfnInstance.DiskProperty(\n            disk_name="diskName",\n            path="path",\n\n            # the properties below are optional\n            attached_to="attachedTo",\n            attachment_state="attachmentState",\n            iops=123,\n            is_system_disk=False,\n            size_in_gb="sizeInGb"\n        )],\n        ram_size_in_gb=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cpu_count', 'disks', 'ram_size_in_gb']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.HardwareProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.LocationProperty
class CfnInstance_LocationPropertyDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone for the instance.\n')
    region_name: typing.Optional[str] = pydantic.Field(None, description='The name of the AWS Region for the instance.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-location.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    location_property = lightsail.CfnInstance.LocationProperty(\n        availability_zone="availabilityZone",\n        region_name="regionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'region_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.LocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.MonthlyTransferProperty
class CfnInstance_MonthlyTransferPropertyDef(BaseStruct):
    gb_per_month_allocated: typing.Optional[str] = pydantic.Field(None, description='The amount of allocated monthly data transfer (in GB) for an instance.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-monthlytransfer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    monthly_transfer_property = lightsail.CfnInstance.MonthlyTransferProperty(\n        gb_per_month_allocated="gbPerMonthAllocated"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['gb_per_month_allocated']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.MonthlyTransferProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.NetworkingProperty
class CfnInstance_NetworkingPropertyDef(BaseStruct):
    ports: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_PortPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='An array of ports to open on the instance.\n')
    monthly_transfer: typing.Union[int, float, None] = pydantic.Field(None, description='The monthly amount of data transfer, in GB, allocated for the instance.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-networking.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    networking_property = lightsail.CfnInstance.NetworkingProperty(\n        ports=[lightsail.CfnInstance.PortProperty(\n            access_direction="accessDirection",\n            access_from="accessFrom",\n            access_type="accessType",\n            cidr_list_aliases=["cidrListAliases"],\n            cidrs=["cidrs"],\n            common_name="commonName",\n            from_port=123,\n            ipv6_cidrs=["ipv6Cidrs"],\n            protocol="protocol",\n            to_port=123\n        )],\n\n        # the properties below are optional\n        monthly_transfer=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ports', 'monthly_transfer']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.NetworkingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.PortProperty
class CfnInstance_PortPropertyDef(BaseStruct):
    access_direction: typing.Optional[str] = pydantic.Field(None, description='The access direction ( ``inbound`` or ``outbound`` ). .. epigraph:: Lightsail currently supports only ``inbound`` access direction.\n')
    access_from: typing.Optional[str] = pydantic.Field(None, description='The location from which access is allowed. For example, ``Anywhere (0.0.0.0/0)`` , or ``Custom`` if a specific IP address or range of IP addresses is allowed.\n')
    access_type: typing.Optional[str] = pydantic.Field(None, description='The type of access ( ``Public`` or ``Private`` ).\n')
    cidr_list_aliases: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An alias that defines access for a preconfigured range of IP addresses. The only alias currently supported is ``lightsail-connect`` , which allows IP addresses of the browser-based RDP/SSH client in the Lightsail console to connect to your instance.\n')
    cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv4 address, or range of IPv4 addresses (in CIDR notation) that are allowed to connect to an instance through the ports, and the protocol. .. epigraph:: The ``ipv6Cidrs`` parameter lists the IPv6 addresses that are allowed to connect to an instance. Examples: - To allow the IP address ``192.0.2.44`` , specify ``192.0.2.44`` or ``192.0.2.44/32`` . - To allow the IP addresses ``192.0.2.0`` to ``192.0.2.255`` , specify ``192.0.2.0/24`` .\n')
    common_name: typing.Optional[str] = pydantic.Field(None, description='The common name of the port information.\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='The first port in a range of open ports on an instance. Allowed ports: - TCP and UDP - ``0`` to ``65535`` - ICMP - The ICMP type for IPv4 addresses. For example, specify ``8`` as the ``fromPort`` (ICMP type), and ``-1`` as the ``toPort`` (ICMP code), to enable ICMP Ping. - ICMPv6 - The ICMP type for IPv6 addresses. For example, specify ``128`` as the ``fromPort`` (ICMPv6 type), and ``0`` as ``toPort`` (ICMPv6 code).\n')
    ipv6_cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv6 address, or range of IPv6 addresses (in CIDR notation) that are allowed to connect to an instance through the ports, and the protocol. Only devices with an IPv6 address can connect to an instance through IPv6; otherwise, IPv4 should be used. .. epigraph:: The ``cidrs`` parameter lists the IPv4 addresses that are allowed to connect to an instance.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description="The IP protocol name. The name can be one of the following: - ``tcp`` - Transmission Control Protocol (TCP) provides reliable, ordered, and error-checked delivery of streamed data between applications running on hosts communicating by an IP network. If you have an application that doesn't require reliable data stream service, use UDP instead. - ``all`` - All transport layer protocol types. - ``udp`` - With User Datagram Protocol (UDP), computer applications can send messages (or datagrams) to other hosts on an Internet Protocol (IP) network. Prior communications are not required to set up transmission channels or data paths. Applications that don't require reliable data stream service can use UDP, which provides a connectionless datagram service that emphasizes reduced latency over reliability. If you do require reliable data stream service, use TCP instead. - ``icmp`` - Internet Control Message Protocol (ICMP) is used to send error messages and operational information indicating success or failure when communicating with an instance. For example, an error is indicated when an instance could not be reached. When you specify ``icmp`` as the ``protocol`` , you must specify the ICMP type using the ``fromPort`` parameter, and ICMP code using the ``toPort`` parameter.\n")
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='The last port in a range of open ports on an instance. Allowed ports: - TCP and UDP - ``0`` to ``65535`` - ICMP - The ICMP code for IPv4 addresses. For example, specify ``8`` as the ``fromPort`` (ICMP type), and ``-1`` as the ``toPort`` (ICMP code), to enable ICMP Ping. - ICMPv6 - The ICMP code for IPv6 addresses. For example, specify ``128`` as the ``fromPort`` (ICMPv6 type), and ``0`` as ``toPort`` (ICMPv6 code).\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-port.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    port_property = lightsail.CfnInstance.PortProperty(\n        access_direction="accessDirection",\n        access_from="accessFrom",\n        access_type="accessType",\n        cidr_list_aliases=["cidrListAliases"],\n        cidrs=["cidrs"],\n        common_name="commonName",\n        from_port=123,\n        ipv6_cidrs=["ipv6Cidrs"],\n        protocol="protocol",\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_direction', 'access_from', 'access_type', 'cidr_list_aliases', 'cidrs', 'common_name', 'from_port', 'ipv6_cidrs', 'protocol', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.PortProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstance.StateProperty
class CfnInstance_StatePropertyDef(BaseStruct):
    code: typing.Union[int, float, None] = pydantic.Field(None, description='The status code of the instance.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The state of the instance (for example, ``running`` or ``pending`` ).\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lightsail-instance-state.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    state_property = lightsail.CfnInstance.StateProperty(\n        code=123,\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['code', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance.StateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnAlarm
class CfnAlarmDef(BaseCfnResource):
    alarm_name: str = pydantic.Field(..., description='The name of the alarm.\n')
    comparison_operator: str = pydantic.Field(..., description='The arithmetic operation to use when comparing the specified statistic and threshold.\n')
    evaluation_periods: typing.Union[int, float] = pydantic.Field(..., description='The number of periods over which data is compared to the specified threshold.\n')
    metric_name: str = pydantic.Field(..., description='The name of the metric associated with the alarm.\n')
    monitored_resource_name: str = pydantic.Field(..., description='The name of the Lightsail resource that the alarm monitors.\n')
    threshold: typing.Union[int, float] = pydantic.Field(..., description='The value against which the specified statistic is compared.\n')
    contact_protocols: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The contact protocols for the alarm, such as ``Email`` , ``SMS`` (text messaging), or both. *Allowed Values* : ``Email`` | ``SMS``\n')
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of data points within the evaluation periods that must be breaching to cause the alarm to go to the ``ALARM`` state.\n')
    notification_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the alarm is enabled.\n')
    notification_triggers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The alarm states that trigger a notification. .. epigraph:: To specify the ``OK`` and ``INSUFFICIENT_DATA`` values, you must also specify ``ContactProtocols`` values. Otherwise, the ``OK`` and ``INSUFFICIENT_DATA`` values will not take effect and the stack will drift. *Allowed Values* : ``OK`` | ``ALARM`` | ``INSUFFICIENT_DATA``\n')
    treat_missing_data: typing.Optional[str] = pydantic.Field(None, description='Specifies how the alarm handles missing data points. An alarm can treat missing data in the following ways: - ``breaching`` - Assumes the missing data is not within the threshold. Missing data counts towards the number of times that the metric is not within the threshold. - ``notBreaching`` - Assumes the missing data is within the threshold. Missing data does not count towards the number of times that the metric is not within the threshold. - ``ignore`` - Ignores the missing data. Maintains the current alarm state. - ``missing`` - Missing data is treated as missing.')
    _init_params: typing.ClassVar[list[str]] = ['alarm_name', 'comparison_operator', 'evaluation_periods', 'metric_name', 'monitored_resource_name', 'threshold', 'contact_protocols', 'datapoints_to_alarm', 'notification_enabled', 'notification_triggers', 'treat_missing_data']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnAlarm'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnAlarmDefConfig] = pydantic.Field(None)


class CfnAlarmDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnAlarmDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnAlarmDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnAlarmDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnAlarmDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnAlarmDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnAlarmDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnAlarmDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnAlarmDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnAlarmDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnAlarmDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnAlarmDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnAlarmDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnAlarmDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAlarmDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAlarmDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAlarmDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAlarmDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAlarmDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAlarmDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAlarmDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAlarmDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAlarmDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAlarmDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAlarmDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnAlarmDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAlarmDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAlarmDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnBucket
class CfnBucketDef(BaseCfnResource):
    bucket_name: str = pydantic.Field(..., description='The name of the bucket.\n')
    bundle_id: str = pydantic.Field(..., description='The bundle ID for the bucket (for example, ``small_1_0`` ). A bucket bundle specifies the monthly cost, storage space, and data transfer quota for a bucket.\n')
    access_rules: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnBucket_AccessRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the access rules for the bucket.\n')
    object_versioning: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether object versioning is enabled for the bucket. The following options can be configured: - ``Enabled`` - Object versioning is enabled. - ``Suspended`` - Object versioning was previously enabled but is currently suspended. Existing object versions are retained. - ``NeverEnabled`` - Object versioning has never been enabled.\n')
    read_only_access_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of AWS account IDs that have read-only access to the bucket.\n')
    resources_receiving_access: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of Lightsail instances that have access to the bucket.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'bundle_id', 'access_rules', 'object_versioning', 'read_only_access_accounts', 'resources_receiving_access', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AccessRulesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnBucket'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnBucketDefConfig] = pydantic.Field(None)


class CfnBucketDefConfig(pydantic.BaseModel):
    AccessRulesProperty: typing.Optional[list[CfnBucketDefAccessrulespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnBucketDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnBucketDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnBucketDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnBucketDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnBucketDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnBucketDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnBucketDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnBucketDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnBucketDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnBucketDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnBucketDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnBucketDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnBucketDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_able_to_update_bundle_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnBucketDefAccessrulespropertyParams(pydantic.BaseModel):
    allow_public_overrides: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    object_access: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnBucketDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnBucketDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBucketDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnBucketDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBucketDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnBucketDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnBucketDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnBucketDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnBucketDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnBucketDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBucketDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnBucketDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnBucketDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBucketDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnCertificate
class CfnCertificateDef(BaseCfnResource):
    certificate_name: str = pydantic.Field(..., description='The name of the certificate.\n')
    domain_name: str = pydantic.Field(..., description='The domain name of the certificate.\n')
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of strings that specify the alternate domains (such as ``example.org`` ) and subdomains (such as ``blog.example.com`` ) of the certificate.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.')
    _init_params: typing.ClassVar[list[str]] = ['certificate_name', 'domain_name', 'subject_alternative_names', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCertificateDefConfig] = pydantic.Field(None)


class CfnCertificateDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnCertificateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCertificateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCertificateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCertificateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCertificateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCertificateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCertificateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCertificateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCertificateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCertificateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCertificateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCertificateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCertificateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCertificateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCertificateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCertificateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCertificateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCertificateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCertificateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCertificateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCertificateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCertificateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCertificateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnCertificateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCertificateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCertificateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnContainer
class CfnContainerDef(BaseCfnResource):
    power: str = pydantic.Field(..., description='The power specification of the container service. The power specifies the amount of RAM, the number of vCPUs, and the base price of the container service.\n')
    scale: typing.Union[int, float] = pydantic.Field(..., description='The scale specification of the container service. The scale specifies the allocated compute nodes of the container service.\n')
    service_name: str = pydantic.Field(..., description='The name of the container service.\n')
    container_service_deployment: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_ContainerServiceDeploymentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the current container deployment of the container service.\n')
    is_disabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the container service is disabled.\n')
    public_domain_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_PublicDomainNamePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The public domain name of the container service, such as ``example.com`` and ``www.example.com`` . You can specify up to four public domain names for a container service. The domain names that you specify are used when you create a deployment with a container that is configured as the public endpoint of your container service. If you don't specify public domain names, then you can use the default domain of the container service. .. epigraph:: You must create and validate an SSL/TLS certificate before you can use public domain names with your container service. Use the `AWS::Lightsail::Certificate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-certificate.html>`_ resource to create a certificate for the public domain names that you want to use with your container service.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.')
    _init_params: typing.ClassVar[list[str]] = ['power', 'scale', 'service_name', 'container_service_deployment', 'is_disabled', 'public_domain_names', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ContainerProperty', 'ContainerServiceDeploymentProperty', 'EnvironmentVariableProperty', 'HealthCheckConfigProperty', 'PortInfoProperty', 'PublicDomainNameProperty', 'PublicEndpointProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnContainerDefConfig] = pydantic.Field(None)


class CfnContainerDefConfig(pydantic.BaseModel):
    ContainerProperty: typing.Optional[list[CfnContainerDefContainerpropertyParams]] = pydantic.Field(None, description='')
    ContainerServiceDeploymentProperty: typing.Optional[list[CfnContainerDefContainerservicedeploymentpropertyParams]] = pydantic.Field(None, description='')
    EnvironmentVariableProperty: typing.Optional[list[CfnContainerDefEnvironmentvariablepropertyParams]] = pydantic.Field(None, description='')
    HealthCheckConfigProperty: typing.Optional[list[CfnContainerDefHealthcheckconfigpropertyParams]] = pydantic.Field(None, description='')
    PortInfoProperty: typing.Optional[list[CfnContainerDefPortinfopropertyParams]] = pydantic.Field(None, description='')
    PublicDomainNameProperty: typing.Optional[list[CfnContainerDefPublicdomainnamepropertyParams]] = pydantic.Field(None, description='')
    PublicEndpointProperty: typing.Optional[list[CfnContainerDefPublicendpointpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnContainerDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnContainerDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnContainerDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnContainerDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnContainerDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnContainerDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnContainerDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnContainerDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnContainerDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnContainerDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnContainerDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnContainerDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnContainerDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnContainerDefContainerpropertyParams(pydantic.BaseModel):
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    container_name: typing.Optional[str] = pydantic.Field(None, description='')
    environment: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_EnvironmentVariablePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    image: typing.Optional[str] = pydantic.Field(None, description='')
    ports: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_PortInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnContainerDefContainerservicedeploymentpropertyParams(pydantic.BaseModel):
    containers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_ContainerPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    public_endpoint: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_PublicEndpointPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnContainerDefEnvironmentvariablepropertyParams(pydantic.BaseModel):
    value: typing.Optional[str] = pydantic.Field(None, description='')
    variable: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnContainerDefHealthcheckconfigpropertyParams(pydantic.BaseModel):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='')
    interval_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    success_codes: typing.Optional[str] = pydantic.Field(None, description='')
    timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnContainerDefPortinfopropertyParams(pydantic.BaseModel):
    port: typing.Optional[str] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnContainerDefPublicdomainnamepropertyParams(pydantic.BaseModel):
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='')
    domain_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnContainerDefPublicendpointpropertyParams(pydantic.BaseModel):
    container_name: typing.Optional[str] = pydantic.Field(None, description='')
    container_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    health_check_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_HealthCheckConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnContainerDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnContainerDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContainerDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnContainerDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContainerDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnContainerDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnContainerDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnContainerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnContainerDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnContainerDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContainerDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnContainerDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnContainerDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContainerDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnDatabase
class CfnDatabaseDef(BaseCfnResource):
    master_database_name: str = pydantic.Field(..., description="The meaning of this parameter differs according to the database engine you use. *MySQL* The name of the database to create when the Lightsail database resource is created. If this parameter isn't specified, no database is created in the database resource. Constraints: - Must contain 1-64 letters or numbers. - Must begin with a letter. Subsequent characters can be letters, underscores, or numbers (0-9). - Can't be a word reserved by the specified database engine. For more information about reserved words in MySQL, see the Keywords and Reserved Words articles for `MySQL 5.6 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/5.6/en/keywords.html>`_ , `MySQL 5.7 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/5.7/en/keywords.html>`_ , and `MySQL 8.0 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/8.0/en/keywords.html>`_ . *PostgreSQL* The name of the database to create when the Lightsail database resource is created. If this parameter isn't specified, a database named ``postgres`` is created in the database resource. Constraints: - Must contain 1-63 letters or numbers. - Must begin with a letter. Subsequent characters can be letters, underscores, or numbers (0-9). - Can't be a word reserved by the specified database engine. For more information about reserved words in PostgreSQL, see the SQL Key Words articles for `PostgreSQL 9.6 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html>`_ , `PostgreSQL 10 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/10/sql-keywords-appendix.html>`_ , `PostgreSQL 11 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/11/sql-keywords-appendix.html>`_ , and `PostgreSQL 12 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/12/sql-keywords-appendix.html>`_ .\n")
    master_username: str = pydantic.Field(..., description="The name for the primary user. *MySQL* Constraints: - Required for MySQL. - Must be 1-16 letters or numbers. Can contain underscores. - First character must be a letter. - Can't be a reserved word for the chosen database engine. For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and Reserved Words articles for `MySQL 5.6 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/5.6/en/keywords.html>`_ , `MySQL 5.7 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/5.7/en/keywords.html>`_ , or `MySQL 8.0 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/8.0/en/keywords.html>`_ . *PostgreSQL* Constraints: - Required for PostgreSQL. - Must be 1-63 letters or numbers. Can contain underscores. - First character must be a letter. - Can't be a reserved word for the chosen database engine. For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and Reserved Words articles for `PostgreSQL 9.6 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html>`_ , `PostgreSQL 10 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/10/sql-keywords-appendix.html>`_ , `PostgreSQL 11 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/11/sql-keywords-appendix.html>`_ , and `PostgreSQL 12 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/12/sql-keywords-appendix.html>`_ .\n")
    relational_database_blueprint_id: str = pydantic.Field(..., description='The blueprint ID for the database (for example, ``mysql_8_0`` ).\n')
    relational_database_bundle_id: str = pydantic.Field(..., description='The bundle ID for the database (for example, ``medium_1_0`` ).\n')
    relational_database_name: str = pydantic.Field(..., description='The name of the instance.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone for the database.\n')
    backup_retention: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether automated backup retention is enabled for the database.\n')
    ca_certificate_identifier: typing.Optional[str] = pydantic.Field(None, description='The certificate associated with the database.\n')
    master_user_password: typing.Optional[str] = pydantic.Field(None, description='The password for the primary user of the database. The password can include any printable ASCII character except the following: /, ", or @. It cannot contain spaces. .. epigraph:: The ``MasterUserPassword`` and ``RotateMasterUserPassword`` parameters cannot be used together in the same template. *MySQL* Constraints: Must contain 8-41 characters. *PostgreSQL* Constraints: Must contain 8-128 characters.\n')
    preferred_backup_window: typing.Optional[str] = pydantic.Field(None, description='The daily time range during which automated backups are created for the database (for example, ``16:00-16:30`` ).\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description='The weekly time range during which system maintenance can occur for the database, formatted as follows: ``ddd:hh24:mi-ddd:hh24:mi`` . For example, ``Tue:17:00-Tue:17:30`` .\n')
    publicly_accessible: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the database is accessible to anyone on the internet.\n')
    relational_database_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDatabase_RelationalDatabaseParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of parameters for the database.\n')
    rotate_master_user_password: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether to change the primary user password to a new, strong password generated by Lightsail . .. epigraph:: The ``RotateMasterUserPassword`` and ``MasterUserPassword`` parameters cannot be used together in the same template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.')
    _init_params: typing.ClassVar[list[str]] = ['master_database_name', 'master_username', 'relational_database_blueprint_id', 'relational_database_bundle_id', 'relational_database_name', 'availability_zone', 'backup_retention', 'ca_certificate_identifier', 'master_user_password', 'preferred_backup_window', 'preferred_maintenance_window', 'publicly_accessible', 'relational_database_parameters', 'rotate_master_user_password', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['RelationalDatabaseParameterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDatabase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDatabaseDefConfig] = pydantic.Field(None)


class CfnDatabaseDefConfig(pydantic.BaseModel):
    RelationalDatabaseParameterProperty: typing.Optional[list[CfnDatabaseDefRelationaldatabaseparameterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDatabaseDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDatabaseDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDatabaseDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDatabaseDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDatabaseDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDatabaseDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDatabaseDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDatabaseDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDatabaseDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDatabaseDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDatabaseDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDatabaseDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDatabaseDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDatabaseDefRelationaldatabaseparameterpropertyParams(pydantic.BaseModel):
    allowed_values: typing.Optional[str] = pydantic.Field(None, description='')
    apply_method: typing.Optional[str] = pydantic.Field(None, description='')
    apply_type: typing.Optional[str] = pydantic.Field(None, description='')
    data_type: typing.Optional[str] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    is_modifiable: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='')
    parameter_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDatabaseDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDatabaseDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDatabaseDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDatabaseDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDatabaseDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDatabaseDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDatabaseDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDatabaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDatabaseDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDatabaseDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDatabaseDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDatabaseDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDatabaseDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDatabaseDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnDisk
class CfnDiskDef(BaseCfnResource):
    disk_name: str = pydantic.Field(..., description='The name of the disk.\n')
    size_in_gb: typing.Union[int, float] = pydantic.Field(..., description='The size of the disk in GB.\n')
    add_ons: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDisk_AddOnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of add-ons for the disk. .. epigraph:: If the disk has an add-on enabled when performing a delete disk request, the add-on is automatically disabled before the disk is deleted.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The AWS Region and Availability Zone location for the disk (for example, ``us-east-1a`` ).\n')
    location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDisk_LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='``AWS::Lightsail::Disk.Location``.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.')
    _init_params: typing.ClassVar[list[str]] = ['disk_name', 'size_in_gb', 'add_ons', 'availability_zone', 'location', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AddOnProperty', 'AutoSnapshotAddOnProperty', 'LocationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDisk'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDiskDefConfig] = pydantic.Field(None)


class CfnDiskDefConfig(pydantic.BaseModel):
    AddOnProperty: typing.Optional[list[CfnDiskDefAddonpropertyParams]] = pydantic.Field(None, description='')
    AutoSnapshotAddOnProperty: typing.Optional[list[CfnDiskDefAutosnapshotaddonpropertyParams]] = pydantic.Field(None, description='')
    LocationProperty: typing.Optional[list[CfnDiskDefLocationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDiskDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDiskDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDiskDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDiskDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDiskDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDiskDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDiskDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDiskDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDiskDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDiskDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDiskDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDiskDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDiskDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_is_attached_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDiskDefAddonpropertyParams(pydantic.BaseModel):
    add_on_type: str = pydantic.Field(..., description='')
    auto_snapshot_add_on_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDisk_AutoSnapshotAddOnPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    status: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDiskDefAutosnapshotaddonpropertyParams(pydantic.BaseModel):
    snapshot_time_of_day: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDiskDefLocationpropertyParams(pydantic.BaseModel):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    region_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDiskDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDiskDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDiskDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDiskDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDiskDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDiskDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDiskDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDiskDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDiskDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDiskDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDiskDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDiskDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDiskDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDiskDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnDistribution
class CfnDistributionDef(BaseCfnResource):
    bundle_id: str = pydantic.Field(..., description='The ID of the bundle applied to the distribution.\n')
    default_cache_behavior: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_CacheBehaviorPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that describes the default cache behavior of the distribution.\n')
    distribution_name: str = pydantic.Field(..., description='The name of the distribution.\n')
    origin: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_InputOriginPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that describes the origin resource of the distribution, such as a Lightsail instance, bucket, or load balancer. The distribution pulls, caches, and serves content from the origin.\n')
    cache_behaviors: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_CacheBehaviorPerPathPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of objects that describe the per-path cache behavior of the distribution.\n')
    cache_behavior_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_CacheSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the cache behavior settings of the distribution.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='The name of the SSL/TLS certificate attached to the distribution.\n')
    ip_address_type: typing.Optional[str] = pydantic.Field(None, description='The IP address type of the distribution. The possible values are ``ipv4`` for IPv4 only, and ``dualstack`` for IPv4 and IPv6.\n')
    is_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the distribution is enabled.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.')
    _init_params: typing.ClassVar[list[str]] = ['bundle_id', 'default_cache_behavior', 'distribution_name', 'origin', 'cache_behaviors', 'cache_behavior_settings', 'certificate_name', 'ip_address_type', 'is_enabled', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['CacheBehaviorPerPathProperty', 'CacheBehaviorProperty', 'CacheSettingsProperty', 'CookieObjectProperty', 'HeaderObjectProperty', 'InputOriginProperty', 'QueryStringObjectProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistribution'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDistributionDefConfig] = pydantic.Field(None)


class CfnDistributionDefConfig(pydantic.BaseModel):
    CacheBehaviorPerPathProperty: typing.Optional[list[CfnDistributionDefCachebehaviorperpathpropertyParams]] = pydantic.Field(None, description='')
    CacheBehaviorProperty: typing.Optional[list[CfnDistributionDefCachebehaviorpropertyParams]] = pydantic.Field(None, description='')
    CacheSettingsProperty: typing.Optional[list[CfnDistributionDefCachesettingspropertyParams]] = pydantic.Field(None, description='')
    CookieObjectProperty: typing.Optional[list[CfnDistributionDefCookieobjectpropertyParams]] = pydantic.Field(None, description='')
    HeaderObjectProperty: typing.Optional[list[CfnDistributionDefHeaderobjectpropertyParams]] = pydantic.Field(None, description='')
    InputOriginProperty: typing.Optional[list[CfnDistributionDefInputoriginpropertyParams]] = pydantic.Field(None, description='')
    QueryStringObjectProperty: typing.Optional[list[CfnDistributionDefQuerystringobjectpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDistributionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDistributionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDistributionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDistributionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDistributionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDistributionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDistributionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDistributionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDistributionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDistributionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDistributionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDistributionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDistributionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_able_to_update_bundle_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDistributionDefCachebehaviorperpathpropertyParams(pydantic.BaseModel):
    behavior: typing.Optional[str] = pydantic.Field(None, description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDistributionDefCachebehaviorpropertyParams(pydantic.BaseModel):
    behavior: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDistributionDefCachesettingspropertyParams(pydantic.BaseModel):
    allowed_http_methods: typing.Optional[str] = pydantic.Field(None, description='')
    cached_http_methods: typing.Optional[str] = pydantic.Field(None, description='')
    default_ttl: typing.Union[int, float, None] = pydantic.Field(None, description='')
    forwarded_cookies: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_CookieObjectPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    forwarded_headers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_HeaderObjectPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    forwarded_query_strings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_QueryStringObjectPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    maximum_ttl: typing.Union[int, float, None] = pydantic.Field(None, description='')
    minimum_ttl: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDistributionDefCookieobjectpropertyParams(pydantic.BaseModel):
    cookies_allow_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    option: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDistributionDefHeaderobjectpropertyParams(pydantic.BaseModel):
    headers_allow_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    option: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDistributionDefInputoriginpropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    protocol_policy: typing.Optional[str] = pydantic.Field(None, description='')
    region_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDistributionDefQuerystringobjectpropertyParams(pydantic.BaseModel):
    option: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    query_strings_allow_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDistributionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDistributionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDistributionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDistributionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDistributionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDistributionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDistributionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDistributionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDistributionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDistributionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDistributionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDistributionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDistributionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDistributionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnInstance
class CfnInstanceDef(BaseCfnResource):
    blueprint_id: str = pydantic.Field(..., description='The blueprint ID for the instance (for example, ``os_amlinux_2016_03`` ).\n')
    bundle_id: str = pydantic.Field(..., description='The bundle ID for the instance (for example, ``micro_1_0`` ).\n')
    instance_name: str = pydantic.Field(..., description='The name of the instance.\n')
    add_ons: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_AddOnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of add-ons for the instance. .. epigraph:: If the instance has an add-on enabled when performing a delete instance request, the add-on is automatically disabled before the instance is deleted.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone for the instance.\n')
    hardware: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_HardwarePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The hardware properties for the instance, such as the vCPU count, attached disks, and amount of RAM. .. epigraph:: The instance restarts when performing an attach disk or detach disk request. This resets the public IP address of your instance if a static IP isn't attached to it.\n")
    key_pair_name: typing.Optional[str] = pydantic.Field(None, description='The name of the key pair to use for the instance. If no key pair name is specified, the Regional Lightsail default key pair is used.\n')
    location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The location for the instance, such as the AWS Region and Availability Zone. .. epigraph:: The ``Location`` property is read-only and should not be specified in a create instance or update instance request.\n')
    networking: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_NetworkingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The public ports and the monthly amount of data transfer allocated for the instance.\n')
    state: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_StatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The status code and the state (for example, ``running`` ) of the instance. .. epigraph:: The ``State`` property is read-only and should not be specified in a create instance or update instance request.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n')
    user_data: typing.Optional[str] = pydantic.Field(None, description='The optional launch script for the instance. Specify a launch script to configure an instance with additional user data. For example, you might want to specify ``apt-get -y update`` as a launch script. .. epigraph:: Depending on the blueprint of your instance, the command to get software on your instance varies. Amazon Linux and CentOS use ``yum`` , Debian and Ubuntu use ``apt-get`` , and FreeBSD uses ``pkg`` .')
    _init_params: typing.ClassVar[list[str]] = ['blueprint_id', 'bundle_id', 'instance_name', 'add_ons', 'availability_zone', 'hardware', 'key_pair_name', 'location', 'networking', 'state', 'tags', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['AddOnProperty', 'AutoSnapshotAddOnProperty', 'DiskProperty', 'HardwareProperty', 'LocationProperty', 'MonthlyTransferProperty', 'NetworkingProperty', 'PortProperty', 'StateProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnInstanceDefConfig] = pydantic.Field(None)


class CfnInstanceDefConfig(pydantic.BaseModel):
    AddOnProperty: typing.Optional[list[CfnInstanceDefAddonpropertyParams]] = pydantic.Field(None, description='')
    AutoSnapshotAddOnProperty: typing.Optional[list[CfnInstanceDefAutosnapshotaddonpropertyParams]] = pydantic.Field(None, description='')
    DiskProperty: typing.Optional[list[CfnInstanceDefDiskpropertyParams]] = pydantic.Field(None, description='')
    HardwareProperty: typing.Optional[list[CfnInstanceDefHardwarepropertyParams]] = pydantic.Field(None, description='')
    LocationProperty: typing.Optional[list[CfnInstanceDefLocationpropertyParams]] = pydantic.Field(None, description='')
    MonthlyTransferProperty: typing.Optional[list[CfnInstanceDefMonthlytransferpropertyParams]] = pydantic.Field(None, description='')
    NetworkingProperty: typing.Optional[list[CfnInstanceDefNetworkingpropertyParams]] = pydantic.Field(None, description='')
    PortProperty: typing.Optional[list[CfnInstanceDefPortpropertyParams]] = pydantic.Field(None, description='')
    StateProperty: typing.Optional[list[CfnInstanceDefStatepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnInstanceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnInstanceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnInstanceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnInstanceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnInstanceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnInstanceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnInstanceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnInstanceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnInstanceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnInstanceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnInstanceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnInstanceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnInstanceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_is_static_ip_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnInstanceDefAddonpropertyParams(pydantic.BaseModel):
    add_on_type: str = pydantic.Field(..., description='')
    auto_snapshot_add_on_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_AutoSnapshotAddOnPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    status: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefAutosnapshotaddonpropertyParams(pydantic.BaseModel):
    snapshot_time_of_day: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefDiskpropertyParams(pydantic.BaseModel):
    disk_name: str = pydantic.Field(..., description='')
    path: str = pydantic.Field(..., description='')
    attached_to: typing.Optional[str] = pydantic.Field(None, description='')
    attachment_state: typing.Optional[str] = pydantic.Field(None, description='')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='')
    is_system_disk: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    size_in_gb: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefHardwarepropertyParams(pydantic.BaseModel):
    cpu_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    disks: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_DiskPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ram_size_in_gb: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefLocationpropertyParams(pydantic.BaseModel):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    region_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefMonthlytransferpropertyParams(pydantic.BaseModel):
    gb_per_month_allocated: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefNetworkingpropertyParams(pydantic.BaseModel):
    ports: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_PortPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    monthly_transfer: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefPortpropertyParams(pydantic.BaseModel):
    access_direction: typing.Optional[str] = pydantic.Field(None, description='')
    access_from: typing.Optional[str] = pydantic.Field(None, description='')
    access_type: typing.Optional[str] = pydantic.Field(None, description='')
    cidr_list_aliases: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    common_name: typing.Optional[str] = pydantic.Field(None, description='')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ipv6_cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefStatepropertyParams(pydantic.BaseModel):
    code: typing.Union[int, float, None] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInstanceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInstanceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInstanceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInstanceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInstanceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInstanceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnInstanceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInstanceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnLoadBalancer
class CfnLoadBalancerDef(BaseCfnResource):
    instance_port: typing.Union[int, float] = pydantic.Field(..., description='The port that the load balancer uses to direct traffic to your Lightsail instances. For HTTP traffic, specify port ``80`` . For HTTPS traffic, specify port ``443`` .\n')
    load_balancer_name: str = pydantic.Field(..., description='The name of the load balancer.\n')
    attached_instances: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Lightsail instances to attach to the load balancer.\n')
    health_check_path: typing.Optional[str] = pydantic.Field(None, description='The path on the attached instance where the health check will be performed. If no path is specified, the load balancer tries to make a request to the default (root) page ( ``/index.html`` ).\n')
    ip_address_type: typing.Optional[str] = pydantic.Field(None, description='The IP address type of the load balancer. The possible values are ``ipv4`` for IPv4 only, and ``dualstack`` for both IPv4 and IPv6.\n')
    session_stickiness_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="A Boolean value indicating whether session stickiness is enabled. Enable session stickiness (also known as *session affinity* ) to bind a user's session to a specific instance. This ensures that all requests from the user during the session are sent to the same instance.\n")
    session_stickiness_lb_cookie_duration_seconds: typing.Optional[str] = pydantic.Field(None, description='The time period, in seconds, after which the load balancer session stickiness cookie should be considered stale. If you do not specify this parameter, the default value is 0, which indicates that the sticky session should last for the duration of the browser session.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n')
    tls_policy_name: typing.Optional[str] = pydantic.Field(None, description='The name of the TLS security policy for the load balancer.')
    _init_params: typing.ClassVar[list[str]] = ['instance_port', 'load_balancer_name', 'attached_instances', 'health_check_path', 'ip_address_type', 'session_stickiness_enabled', 'session_stickiness_lb_cookie_duration_seconds', 'tags', 'tls_policy_name']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnLoadBalancer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLoadBalancerDefConfig] = pydantic.Field(None)


class CfnLoadBalancerDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnLoadBalancerDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLoadBalancerDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLoadBalancerDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLoadBalancerDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLoadBalancerDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLoadBalancerDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLoadBalancerDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLoadBalancerDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLoadBalancerDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLoadBalancerDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLoadBalancerDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLoadBalancerDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLoadBalancerDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnLoadBalancerDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLoadBalancerDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoadBalancerDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLoadBalancerDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoadBalancerDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLoadBalancerDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLoadBalancerDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLoadBalancerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLoadBalancerDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLoadBalancerDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoadBalancerDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnLoadBalancerDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLoadBalancerDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoadBalancerDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnLoadBalancerTlsCertificate
class CfnLoadBalancerTlsCertificateDef(BaseCfnResource):
    certificate_domain_name: str = pydantic.Field(..., description='The domain name for the SSL/TLS certificate. For example, ``example.com`` or ``www.example.com`` .\n')
    certificate_name: str = pydantic.Field(..., description='The name of the SSL/TLS certificate.\n')
    load_balancer_name: str = pydantic.Field(..., description='The name of the load balancer that the SSL/TLS certificate is attached to.\n')
    certificate_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of alternative domain names and subdomain names for your SSL/TLS certificate. In addition to the primary domain name, you can have up to nine alternative domain names. Wildcards (such as ``*.example.com`` ) are not supported.\n')
    https_redirection_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether HTTPS redirection is enabled for the load balancer that the TLS certificate is attached to.\n')
    is_attached: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the SSL/TLS certificate is attached to a Lightsail load balancer.')
    _init_params: typing.ClassVar[list[str]] = ['certificate_domain_name', 'certificate_name', 'load_balancer_name', 'certificate_alternative_names', 'https_redirection_enabled', 'is_attached']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnLoadBalancerTlsCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLoadBalancerTlsCertificateDefConfig] = pydantic.Field(None)


class CfnLoadBalancerTlsCertificateDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnLoadBalancerTlsCertificateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLoadBalancerTlsCertificateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLoadBalancerTlsCertificateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLoadBalancerTlsCertificateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLoadBalancerTlsCertificateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLoadBalancerTlsCertificateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLoadBalancerTlsCertificateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLoadBalancerTlsCertificateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLoadBalancerTlsCertificateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLoadBalancerTlsCertificateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLoadBalancerTlsCertificateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLoadBalancerTlsCertificateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLoadBalancerTlsCertificateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLoadBalancerTlsCertificateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLoadBalancerTlsCertificateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoadBalancerTlsCertificateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLoadBalancerTlsCertificateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoadBalancerTlsCertificateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLoadBalancerTlsCertificateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLoadBalancerTlsCertificateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLoadBalancerTlsCertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLoadBalancerTlsCertificateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLoadBalancerTlsCertificateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoadBalancerTlsCertificateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnLoadBalancerTlsCertificateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLoadBalancerTlsCertificateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoadBalancerTlsCertificateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnStaticIp
class CfnStaticIpDef(BaseCfnResource):
    static_ip_name: str = pydantic.Field(..., description='The name of the static IP.\n')
    attached_to: typing.Optional[str] = pydantic.Field(None, description='The instance that the static IP is attached to.')
    _init_params: typing.ClassVar[list[str]] = ['static_ip_name', 'attached_to']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnStaticIp'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnStaticIpDefConfig] = pydantic.Field(None)


class CfnStaticIpDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnStaticIpDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnStaticIpDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnStaticIpDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnStaticIpDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnStaticIpDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnStaticIpDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnStaticIpDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnStaticIpDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnStaticIpDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnStaticIpDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnStaticIpDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnStaticIpDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnStaticIpDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_is_attached_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnStaticIpDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnStaticIpDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStaticIpDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnStaticIpDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStaticIpDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnStaticIpDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnStaticIpDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnStaticIpDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnStaticIpDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnStaticIpDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStaticIpDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnStaticIpDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnStaticIpDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStaticIpDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lightsail.CfnAlarmProps
class CfnAlarmPropsDef(BaseCfnProperty):
    alarm_name: str = pydantic.Field(..., description='The name of the alarm.\n')
    comparison_operator: str = pydantic.Field(..., description='The arithmetic operation to use when comparing the specified statistic and threshold.\n')
    evaluation_periods: typing.Union[int, float] = pydantic.Field(..., description='The number of periods over which data is compared to the specified threshold.\n')
    metric_name: str = pydantic.Field(..., description='The name of the metric associated with the alarm.\n')
    monitored_resource_name: str = pydantic.Field(..., description='The name of the Lightsail resource that the alarm monitors.\n')
    threshold: typing.Union[int, float] = pydantic.Field(..., description='The value against which the specified statistic is compared.\n')
    contact_protocols: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The contact protocols for the alarm, such as ``Email`` , ``SMS`` (text messaging), or both. *Allowed Values* : ``Email`` | ``SMS``\n')
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of data points within the evaluation periods that must be breaching to cause the alarm to go to the ``ALARM`` state.\n')
    notification_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the alarm is enabled.\n')
    notification_triggers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The alarm states that trigger a notification. .. epigraph:: To specify the ``OK`` and ``INSUFFICIENT_DATA`` values, you must also specify ``ContactProtocols`` values. Otherwise, the ``OK`` and ``INSUFFICIENT_DATA`` values will not take effect and the stack will drift. *Allowed Values* : ``OK`` | ``ALARM`` | ``INSUFFICIENT_DATA``\n')
    treat_missing_data: typing.Optional[str] = pydantic.Field(None, description='Specifies how the alarm handles missing data points. An alarm can treat missing data in the following ways: - ``breaching`` - Assumes the missing data is not within the threshold. Missing data counts towards the number of times that the metric is not within the threshold. - ``notBreaching`` - Assumes the missing data is within the threshold. Missing data does not count towards the number of times that the metric is not within the threshold. - ``ignore`` - Ignores the missing data. Maintains the current alarm state. - ``missing`` - Missing data is treated as missing.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-alarm.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_alarm_props = lightsail.CfnAlarmProps(\n        alarm_name="alarmName",\n        comparison_operator="comparisonOperator",\n        evaluation_periods=123,\n        metric_name="metricName",\n        monitored_resource_name="monitoredResourceName",\n        threshold=123,\n\n        # the properties below are optional\n        contact_protocols=["contactProtocols"],\n        datapoints_to_alarm=123,\n        notification_enabled=False,\n        notification_triggers=["notificationTriggers"],\n        treat_missing_data="treatMissingData"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alarm_name', 'comparison_operator', 'evaluation_periods', 'metric_name', 'monitored_resource_name', 'threshold', 'contact_protocols', 'datapoints_to_alarm', 'notification_enabled', 'notification_triggers', 'treat_missing_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnAlarmProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnBucketProps
class CfnBucketPropsDef(BaseCfnProperty):
    bucket_name: str = pydantic.Field(..., description='The name of the bucket.\n')
    bundle_id: str = pydantic.Field(..., description='The bundle ID for the bucket (for example, ``small_1_0`` ). A bucket bundle specifies the monthly cost, storage space, and data transfer quota for a bucket.\n')
    access_rules: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnBucket_AccessRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the access rules for the bucket.\n')
    object_versioning: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether object versioning is enabled for the bucket. The following options can be configured: - ``Enabled`` - Object versioning is enabled. - ``Suspended`` - Object versioning was previously enabled but is currently suspended. Existing object versions are retained. - ``NeverEnabled`` - Object versioning has never been enabled.\n')
    read_only_access_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of AWS account IDs that have read-only access to the bucket.\n')
    resources_receiving_access: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of Lightsail instances that have access to the bucket.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-bucket.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_bucket_props = lightsail.CfnBucketProps(\n        bucket_name="bucketName",\n        bundle_id="bundleId",\n\n        # the properties below are optional\n        access_rules=lightsail.CfnBucket.AccessRulesProperty(\n            allow_public_overrides=False,\n            object_access="objectAccess"\n        ),\n        object_versioning=False,\n        read_only_access_accounts=["readOnlyAccessAccounts"],\n        resources_receiving_access=["resourcesReceivingAccess"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'bundle_id', 'access_rules', 'object_versioning', 'read_only_access_accounts', 'resources_receiving_access', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnBucketProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnCertificateProps
class CfnCertificatePropsDef(BaseCfnProperty):
    certificate_name: str = pydantic.Field(..., description='The name of the certificate.\n')
    domain_name: str = pydantic.Field(..., description='The domain name of the certificate.\n')
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of strings that specify the alternate domains (such as ``example.org`` ) and subdomains (such as ``blog.example.com`` ) of the certificate.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-certificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_certificate_props = lightsail.CfnCertificateProps(\n        certificate_name="certificateName",\n        domain_name="domainName",\n\n        # the properties below are optional\n        subject_alternative_names=["subjectAlternativeNames"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_name', 'domain_name', 'subject_alternative_names', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnCertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnContainerProps
class CfnContainerPropsDef(BaseCfnProperty):
    power: str = pydantic.Field(..., description='The power specification of the container service. The power specifies the amount of RAM, the number of vCPUs, and the base price of the container service.\n')
    scale: typing.Union[int, float] = pydantic.Field(..., description='The scale specification of the container service. The scale specifies the allocated compute nodes of the container service.\n')
    service_name: str = pydantic.Field(..., description='The name of the container service.\n')
    container_service_deployment: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_ContainerServiceDeploymentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the current container deployment of the container service.\n')
    is_disabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the container service is disabled.\n')
    public_domain_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnContainer_PublicDomainNamePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The public domain name of the container service, such as ``example.com`` and ``www.example.com`` . You can specify up to four public domain names for a container service. The domain names that you specify are used when you create a deployment with a container that is configured as the public endpoint of your container service. If you don't specify public domain names, then you can use the default domain of the container service. .. epigraph:: You must create and validate an SSL/TLS certificate before you can use public domain names with your container service. Use the `AWS::Lightsail::Certificate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-certificate.html>`_ resource to create a certificate for the public domain names that you want to use with your container service.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-container.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_container_props = lightsail.CfnContainerProps(\n        power="power",\n        scale=123,\n        service_name="serviceName",\n\n        # the properties below are optional\n        container_service_deployment=lightsail.CfnContainer.ContainerServiceDeploymentProperty(\n            containers=[lightsail.CfnContainer.ContainerProperty(\n                command=["command"],\n                container_name="containerName",\n                environment=[lightsail.CfnContainer.EnvironmentVariableProperty(\n                    value="value",\n                    variable="variable"\n                )],\n                image="image",\n                ports=[lightsail.CfnContainer.PortInfoProperty(\n                    port="port",\n                    protocol="protocol"\n                )]\n            )],\n            public_endpoint=lightsail.CfnContainer.PublicEndpointProperty(\n                container_name="containerName",\n                container_port=123,\n                health_check_config=lightsail.CfnContainer.HealthCheckConfigProperty(\n                    healthy_threshold=123,\n                    interval_seconds=123,\n                    path="path",\n                    success_codes="successCodes",\n                    timeout_seconds=123,\n                    unhealthy_threshold=123\n                )\n            )\n        ),\n        is_disabled=False,\n        public_domain_names=[lightsail.CfnContainer.PublicDomainNameProperty(\n            certificate_name="certificateName",\n            domain_names=["domainNames"]\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['power', 'scale', 'service_name', 'container_service_deployment', 'is_disabled', 'public_domain_names', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnContainerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDatabaseProps
class CfnDatabasePropsDef(BaseCfnProperty):
    master_database_name: str = pydantic.Field(..., description="The meaning of this parameter differs according to the database engine you use. *MySQL* The name of the database to create when the Lightsail database resource is created. If this parameter isn't specified, no database is created in the database resource. Constraints: - Must contain 1-64 letters or numbers. - Must begin with a letter. Subsequent characters can be letters, underscores, or numbers (0-9). - Can't be a word reserved by the specified database engine. For more information about reserved words in MySQL, see the Keywords and Reserved Words articles for `MySQL 5.6 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/5.6/en/keywords.html>`_ , `MySQL 5.7 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/5.7/en/keywords.html>`_ , and `MySQL 8.0 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/8.0/en/keywords.html>`_ . *PostgreSQL* The name of the database to create when the Lightsail database resource is created. If this parameter isn't specified, a database named ``postgres`` is created in the database resource. Constraints: - Must contain 1-63 letters or numbers. - Must begin with a letter. Subsequent characters can be letters, underscores, or numbers (0-9). - Can't be a word reserved by the specified database engine. For more information about reserved words in PostgreSQL, see the SQL Key Words articles for `PostgreSQL 9.6 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html>`_ , `PostgreSQL 10 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/10/sql-keywords-appendix.html>`_ , `PostgreSQL 11 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/11/sql-keywords-appendix.html>`_ , and `PostgreSQL 12 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/12/sql-keywords-appendix.html>`_ .\n")
    master_username: str = pydantic.Field(..., description="The name for the primary user. *MySQL* Constraints: - Required for MySQL. - Must be 1-16 letters or numbers. Can contain underscores. - First character must be a letter. - Can't be a reserved word for the chosen database engine. For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and Reserved Words articles for `MySQL 5.6 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/5.6/en/keywords.html>`_ , `MySQL 5.7 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/5.7/en/keywords.html>`_ , or `MySQL 8.0 <https://docs.aws.amazon.com/https://dev.mysql.com/doc/refman/8.0/en/keywords.html>`_ . *PostgreSQL* Constraints: - Required for PostgreSQL. - Must be 1-63 letters or numbers. Can contain underscores. - First character must be a letter. - Can't be a reserved word for the chosen database engine. For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and Reserved Words articles for `PostgreSQL 9.6 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html>`_ , `PostgreSQL 10 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/10/sql-keywords-appendix.html>`_ , `PostgreSQL 11 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/11/sql-keywords-appendix.html>`_ , and `PostgreSQL 12 <https://docs.aws.amazon.com/https://www.postgresql.org/docs/12/sql-keywords-appendix.html>`_ .\n")
    relational_database_blueprint_id: str = pydantic.Field(..., description='The blueprint ID for the database (for example, ``mysql_8_0`` ).\n')
    relational_database_bundle_id: str = pydantic.Field(..., description='The bundle ID for the database (for example, ``medium_1_0`` ).\n')
    relational_database_name: str = pydantic.Field(..., description='The name of the instance.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone for the database.\n')
    backup_retention: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether automated backup retention is enabled for the database.\n')
    ca_certificate_identifier: typing.Optional[str] = pydantic.Field(None, description='The certificate associated with the database.\n')
    master_user_password: typing.Optional[str] = pydantic.Field(None, description='The password for the primary user of the database. The password can include any printable ASCII character except the following: /, ", or @. It cannot contain spaces. .. epigraph:: The ``MasterUserPassword`` and ``RotateMasterUserPassword`` parameters cannot be used together in the same template. *MySQL* Constraints: Must contain 8-41 characters. *PostgreSQL* Constraints: Must contain 8-128 characters.\n')
    preferred_backup_window: typing.Optional[str] = pydantic.Field(None, description='The daily time range during which automated backups are created for the database (for example, ``16:00-16:30`` ).\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description='The weekly time range during which system maintenance can occur for the database, formatted as follows: ``ddd:hh24:mi-ddd:hh24:mi`` . For example, ``Tue:17:00-Tue:17:30`` .\n')
    publicly_accessible: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the database is accessible to anyone on the internet.\n')
    relational_database_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDatabase_RelationalDatabaseParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of parameters for the database.\n')
    rotate_master_user_password: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether to change the primary user password to a new, strong password generated by Lightsail . .. epigraph:: The ``RotateMasterUserPassword`` and ``MasterUserPassword`` parameters cannot be used together in the same template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-database.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_database_props = lightsail.CfnDatabaseProps(\n        master_database_name="masterDatabaseName",\n        master_username="masterUsername",\n        relational_database_blueprint_id="relationalDatabaseBlueprintId",\n        relational_database_bundle_id="relationalDatabaseBundleId",\n        relational_database_name="relationalDatabaseName",\n\n        # the properties below are optional\n        availability_zone="availabilityZone",\n        backup_retention=False,\n        ca_certificate_identifier="caCertificateIdentifier",\n        master_user_password="masterUserPassword",\n        preferred_backup_window="preferredBackupWindow",\n        preferred_maintenance_window="preferredMaintenanceWindow",\n        publicly_accessible=False,\n        relational_database_parameters=[lightsail.CfnDatabase.RelationalDatabaseParameterProperty(\n            allowed_values="allowedValues",\n            apply_method="applyMethod",\n            apply_type="applyType",\n            data_type="dataType",\n            description="description",\n            is_modifiable=False,\n            parameter_name="parameterName",\n            parameter_value="parameterValue"\n        )],\n        rotate_master_user_password=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['master_database_name', 'master_username', 'relational_database_blueprint_id', 'relational_database_bundle_id', 'relational_database_name', 'availability_zone', 'backup_retention', 'ca_certificate_identifier', 'master_user_password', 'preferred_backup_window', 'preferred_maintenance_window', 'publicly_accessible', 'relational_database_parameters', 'rotate_master_user_password', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDatabaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDiskProps
class CfnDiskPropsDef(BaseCfnProperty):
    disk_name: str = pydantic.Field(..., description='The name of the disk.\n')
    size_in_gb: typing.Union[int, float] = pydantic.Field(..., description='The size of the disk in GB.\n')
    add_ons: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDisk_AddOnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of add-ons for the disk. .. epigraph:: If the disk has an add-on enabled when performing a delete disk request, the add-on is automatically disabled before the disk is deleted.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The AWS Region and Availability Zone location for the disk (for example, ``us-east-1a`` ).\n')
    location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDisk_LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='``AWS::Lightsail::Disk.Location``.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-disk.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_disk_props = lightsail.CfnDiskProps(\n        disk_name="diskName",\n        size_in_gb=123,\n\n        # the properties below are optional\n        add_ons=[lightsail.CfnDisk.AddOnProperty(\n            add_on_type="addOnType",\n\n            # the properties below are optional\n            auto_snapshot_add_on_request=lightsail.CfnDisk.AutoSnapshotAddOnProperty(\n                snapshot_time_of_day="snapshotTimeOfDay"\n            ),\n            status="status"\n        )],\n        availability_zone="availabilityZone",\n        location=lightsail.CfnDisk.LocationProperty(\n            availability_zone="availabilityZone",\n            region_name="regionName"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['disk_name', 'size_in_gb', 'add_ons', 'availability_zone', 'location', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDiskProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnDistributionProps
class CfnDistributionPropsDef(BaseCfnProperty):
    bundle_id: str = pydantic.Field(..., description='The ID of the bundle applied to the distribution.\n')
    default_cache_behavior: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_CacheBehaviorPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that describes the default cache behavior of the distribution.\n')
    distribution_name: str = pydantic.Field(..., description='The name of the distribution.\n')
    origin: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_InputOriginPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that describes the origin resource of the distribution, such as a Lightsail instance, bucket, or load balancer. The distribution pulls, caches, and serves content from the origin.\n')
    cache_behaviors: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_CacheBehaviorPerPathPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of objects that describe the per-path cache behavior of the distribution.\n')
    cache_behavior_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnDistribution_CacheSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that describes the cache behavior settings of the distribution.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='The name of the SSL/TLS certificate attached to the distribution.\n')
    ip_address_type: typing.Optional[str] = pydantic.Field(None, description='The IP address type of the distribution. The possible values are ``ipv4`` for IPv4 only, and ``dualstack`` for IPv4 and IPv6.\n')
    is_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the distribution is enabled.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-distribution.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_distribution_props = lightsail.CfnDistributionProps(\n        bundle_id="bundleId",\n        default_cache_behavior=lightsail.CfnDistribution.CacheBehaviorProperty(\n            behavior="behavior"\n        ),\n        distribution_name="distributionName",\n        origin=lightsail.CfnDistribution.InputOriginProperty(\n            name="name",\n            protocol_policy="protocolPolicy",\n            region_name="regionName"\n        ),\n\n        # the properties below are optional\n        cache_behaviors=[lightsail.CfnDistribution.CacheBehaviorPerPathProperty(\n            behavior="behavior",\n            path="path"\n        )],\n        cache_behavior_settings=lightsail.CfnDistribution.CacheSettingsProperty(\n            allowed_http_methods="allowedHttpMethods",\n            cached_http_methods="cachedHttpMethods",\n            default_ttl=123,\n            forwarded_cookies=lightsail.CfnDistribution.CookieObjectProperty(\n                cookies_allow_list=["cookiesAllowList"],\n                option="option"\n            ),\n            forwarded_headers=lightsail.CfnDistribution.HeaderObjectProperty(\n                headers_allow_list=["headersAllowList"],\n                option="option"\n            ),\n            forwarded_query_strings=lightsail.CfnDistribution.QueryStringObjectProperty(\n                option=False,\n                query_strings_allow_list=["queryStringsAllowList"]\n            ),\n            maximum_ttl=123,\n            minimum_ttl=123\n        ),\n        certificate_name="certificateName",\n        ip_address_type="ipAddressType",\n        is_enabled=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bundle_id', 'default_cache_behavior', 'distribution_name', 'origin', 'cache_behaviors', 'cache_behavior_settings', 'certificate_name', 'ip_address_type', 'is_enabled', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnDistributionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnInstanceProps
class CfnInstancePropsDef(BaseCfnProperty):
    blueprint_id: str = pydantic.Field(..., description='The blueprint ID for the instance (for example, ``os_amlinux_2016_03`` ).\n')
    bundle_id: str = pydantic.Field(..., description='The bundle ID for the instance (for example, ``micro_1_0`` ).\n')
    instance_name: str = pydantic.Field(..., description='The name of the instance.\n')
    add_ons: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_AddOnPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of add-ons for the instance. .. epigraph:: If the instance has an add-on enabled when performing a delete instance request, the add-on is automatically disabled before the instance is deleted.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone for the instance.\n')
    hardware: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_HardwarePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The hardware properties for the instance, such as the vCPU count, attached disks, and amount of RAM. .. epigraph:: The instance restarts when performing an attach disk or detach disk request. This resets the public IP address of your instance if a static IP isn't attached to it.\n")
    key_pair_name: typing.Optional[str] = pydantic.Field(None, description='The name of the key pair to use for the instance. If no key pair name is specified, the Regional Lightsail default key pair is used.\n')
    location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The location for the instance, such as the AWS Region and Availability Zone. .. epigraph:: The ``Location`` property is read-only and should not be specified in a create instance or update instance request.\n')
    networking: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_NetworkingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The public ports and the monthly amount of data transfer allocated for the instance.\n')
    state: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_lightsail.CfnInstance_StatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The status code and the state (for example, ``running`` ) of the instance. .. epigraph:: The ``State`` property is read-only and should not be specified in a create instance or update instance request.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n')
    user_data: typing.Optional[str] = pydantic.Field(None, description='The optional launch script for the instance. Specify a launch script to configure an instance with additional user data. For example, you might want to specify ``apt-get -y update`` as a launch script. .. epigraph:: Depending on the blueprint of your instance, the command to get software on your instance varies. Amazon Linux and CentOS use ``yum`` , Debian and Ubuntu use ``apt-get`` , and FreeBSD uses ``pkg`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-instance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_instance_props = lightsail.CfnInstanceProps(\n        blueprint_id="blueprintId",\n        bundle_id="bundleId",\n        instance_name="instanceName",\n\n        # the properties below are optional\n        add_ons=[lightsail.CfnInstance.AddOnProperty(\n            add_on_type="addOnType",\n\n            # the properties below are optional\n            auto_snapshot_add_on_request=lightsail.CfnInstance.AutoSnapshotAddOnProperty(\n                snapshot_time_of_day="snapshotTimeOfDay"\n            ),\n            status="status"\n        )],\n        availability_zone="availabilityZone",\n        hardware=lightsail.CfnInstance.HardwareProperty(\n            cpu_count=123,\n            disks=[lightsail.CfnInstance.DiskProperty(\n                disk_name="diskName",\n                path="path",\n\n                # the properties below are optional\n                attached_to="attachedTo",\n                attachment_state="attachmentState",\n                iops=123,\n                is_system_disk=False,\n                size_in_gb="sizeInGb"\n            )],\n            ram_size_in_gb=123\n        ),\n        key_pair_name="keyPairName",\n        location=lightsail.CfnInstance.LocationProperty(\n            availability_zone="availabilityZone",\n            region_name="regionName"\n        ),\n        networking=lightsail.CfnInstance.NetworkingProperty(\n            ports=[lightsail.CfnInstance.PortProperty(\n                access_direction="accessDirection",\n                access_from="accessFrom",\n                access_type="accessType",\n                cidr_list_aliases=["cidrListAliases"],\n                cidrs=["cidrs"],\n                common_name="commonName",\n                from_port=123,\n                ipv6_cidrs=["ipv6Cidrs"],\n                protocol="protocol",\n                to_port=123\n            )],\n\n            # the properties below are optional\n            monthly_transfer=123\n        ),\n        state=lightsail.CfnInstance.StateProperty(\n            code=123,\n            name="name"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        user_data="userData"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['blueprint_id', 'bundle_id', 'instance_name', 'add_ons', 'availability_zone', 'hardware', 'key_pair_name', 'location', 'networking', 'state', 'tags', 'user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnLoadBalancerProps
class CfnLoadBalancerPropsDef(BaseCfnProperty):
    instance_port: typing.Union[int, float] = pydantic.Field(..., description='The port that the load balancer uses to direct traffic to your Lightsail instances. For HTTP traffic, specify port ``80`` . For HTTPS traffic, specify port ``443`` .\n')
    load_balancer_name: str = pydantic.Field(..., description='The name of the load balancer.\n')
    attached_instances: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Lightsail instances to attach to the load balancer.\n')
    health_check_path: typing.Optional[str] = pydantic.Field(None, description='The path on the attached instance where the health check will be performed. If no path is specified, the load balancer tries to make a request to the default (root) page ( ``/index.html`` ).\n')
    ip_address_type: typing.Optional[str] = pydantic.Field(None, description='The IP address type of the load balancer. The possible values are ``ipv4`` for IPv4 only, and ``dualstack`` for both IPv4 and IPv6.\n')
    session_stickiness_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="A Boolean value indicating whether session stickiness is enabled. Enable session stickiness (also known as *session affinity* ) to bind a user's session to a specific instance. This ensures that all requests from the user during the session are sent to the same instance.\n")
    session_stickiness_lb_cookie_duration_seconds: typing.Optional[str] = pydantic.Field(None, description='The time period, in seconds, after which the load balancer session stickiness cookie should be considered stale. If you do not specify this parameter, the default value is 0, which indicates that the sticky session should last for the duration of the browser session.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ in the *AWS CloudFormation User Guide* . .. epigraph:: The ``Value`` of ``Tags`` is optional for Lightsail resources.\n')
    tls_policy_name: typing.Optional[str] = pydantic.Field(None, description='The name of the TLS security policy for the load balancer.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-loadbalancer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_load_balancer_props = lightsail.CfnLoadBalancerProps(\n        instance_port=123,\n        load_balancer_name="loadBalancerName",\n\n        # the properties below are optional\n        attached_instances=["attachedInstances"],\n        health_check_path="healthCheckPath",\n        ip_address_type="ipAddressType",\n        session_stickiness_enabled=False,\n        session_stickiness_lb_cookie_duration_seconds="sessionStickinessLbCookieDurationSeconds",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        tls_policy_name="tlsPolicyName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_port', 'load_balancer_name', 'attached_instances', 'health_check_path', 'ip_address_type', 'session_stickiness_enabled', 'session_stickiness_lb_cookie_duration_seconds', 'tags', 'tls_policy_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnLoadBalancerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnLoadBalancerTlsCertificateProps
class CfnLoadBalancerTlsCertificatePropsDef(BaseCfnProperty):
    certificate_domain_name: str = pydantic.Field(..., description='The domain name for the SSL/TLS certificate. For example, ``example.com`` or ``www.example.com`` .\n')
    certificate_name: str = pydantic.Field(..., description='The name of the SSL/TLS certificate.\n')
    load_balancer_name: str = pydantic.Field(..., description='The name of the load balancer that the SSL/TLS certificate is attached to.\n')
    certificate_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of alternative domain names and subdomain names for your SSL/TLS certificate. In addition to the primary domain name, you can have up to nine alternative domain names. Wildcards (such as ``*.example.com`` ) are not supported.\n')
    https_redirection_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether HTTPS redirection is enabled for the load balancer that the TLS certificate is attached to.\n')
    is_attached: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean value indicating whether the SSL/TLS certificate is attached to a Lightsail load balancer.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-loadbalancertlscertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_load_balancer_tls_certificate_props = lightsail.CfnLoadBalancerTlsCertificateProps(\n        certificate_domain_name="certificateDomainName",\n        certificate_name="certificateName",\n        load_balancer_name="loadBalancerName",\n\n        # the properties below are optional\n        certificate_alternative_names=["certificateAlternativeNames"],\n        https_redirection_enabled=False,\n        is_attached=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_domain_name', 'certificate_name', 'load_balancer_name', 'certificate_alternative_names', 'https_redirection_enabled', 'is_attached']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnLoadBalancerTlsCertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lightsail.CfnStaticIpProps
class CfnStaticIpPropsDef(BaseCfnProperty):
    static_ip_name: str = pydantic.Field(..., description='The name of the static IP.\n')
    attached_to: typing.Optional[str] = pydantic.Field(None, description='The instance that the static IP is attached to.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lightsail-staticip.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lightsail as lightsail\n\n    cfn_static_ip_props = lightsail.CfnStaticIpProps(\n        static_ip_name="staticIpName",\n\n        # the properties below are optional\n        attached_to="attachedTo"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['static_ip_name', 'attached_to']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lightsail.CfnStaticIpProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnBucket_AccessRulesProperty: typing.Optional[dict[str, CfnBucket_AccessRulesPropertyDef]] = pydantic.Field(None)
    CfnContainer_ContainerProperty: typing.Optional[dict[str, CfnContainer_ContainerPropertyDef]] = pydantic.Field(None)
    CfnContainer_ContainerServiceDeploymentProperty: typing.Optional[dict[str, CfnContainer_ContainerServiceDeploymentPropertyDef]] = pydantic.Field(None)
    CfnContainer_EnvironmentVariableProperty: typing.Optional[dict[str, CfnContainer_EnvironmentVariablePropertyDef]] = pydantic.Field(None)
    CfnContainer_HealthCheckConfigProperty: typing.Optional[dict[str, CfnContainer_HealthCheckConfigPropertyDef]] = pydantic.Field(None)
    CfnContainer_PortInfoProperty: typing.Optional[dict[str, CfnContainer_PortInfoPropertyDef]] = pydantic.Field(None)
    CfnContainer_PublicDomainNameProperty: typing.Optional[dict[str, CfnContainer_PublicDomainNamePropertyDef]] = pydantic.Field(None)
    CfnContainer_PublicEndpointProperty: typing.Optional[dict[str, CfnContainer_PublicEndpointPropertyDef]] = pydantic.Field(None)
    CfnDatabase_RelationalDatabaseParameterProperty: typing.Optional[dict[str, CfnDatabase_RelationalDatabaseParameterPropertyDef]] = pydantic.Field(None)
    CfnDisk_AddOnProperty: typing.Optional[dict[str, CfnDisk_AddOnPropertyDef]] = pydantic.Field(None)
    CfnDisk_AutoSnapshotAddOnProperty: typing.Optional[dict[str, CfnDisk_AutoSnapshotAddOnPropertyDef]] = pydantic.Field(None)
    CfnDisk_LocationProperty: typing.Optional[dict[str, CfnDisk_LocationPropertyDef]] = pydantic.Field(None)
    CfnDistribution_CacheBehaviorPerPathProperty: typing.Optional[dict[str, CfnDistribution_CacheBehaviorPerPathPropertyDef]] = pydantic.Field(None)
    CfnDistribution_CacheBehaviorProperty: typing.Optional[dict[str, CfnDistribution_CacheBehaviorPropertyDef]] = pydantic.Field(None)
    CfnDistribution_CacheSettingsProperty: typing.Optional[dict[str, CfnDistribution_CacheSettingsPropertyDef]] = pydantic.Field(None)
    CfnDistribution_CookieObjectProperty: typing.Optional[dict[str, CfnDistribution_CookieObjectPropertyDef]] = pydantic.Field(None)
    CfnDistribution_HeaderObjectProperty: typing.Optional[dict[str, CfnDistribution_HeaderObjectPropertyDef]] = pydantic.Field(None)
    CfnDistribution_InputOriginProperty: typing.Optional[dict[str, CfnDistribution_InputOriginPropertyDef]] = pydantic.Field(None)
    CfnDistribution_QueryStringObjectProperty: typing.Optional[dict[str, CfnDistribution_QueryStringObjectPropertyDef]] = pydantic.Field(None)
    CfnInstance_AddOnProperty: typing.Optional[dict[str, CfnInstance_AddOnPropertyDef]] = pydantic.Field(None)
    CfnInstance_AutoSnapshotAddOnProperty: typing.Optional[dict[str, CfnInstance_AutoSnapshotAddOnPropertyDef]] = pydantic.Field(None)
    CfnInstance_DiskProperty: typing.Optional[dict[str, CfnInstance_DiskPropertyDef]] = pydantic.Field(None)
    CfnInstance_HardwareProperty: typing.Optional[dict[str, CfnInstance_HardwarePropertyDef]] = pydantic.Field(None)
    CfnInstance_LocationProperty: typing.Optional[dict[str, CfnInstance_LocationPropertyDef]] = pydantic.Field(None)
    CfnInstance_MonthlyTransferProperty: typing.Optional[dict[str, CfnInstance_MonthlyTransferPropertyDef]] = pydantic.Field(None)
    CfnInstance_NetworkingProperty: typing.Optional[dict[str, CfnInstance_NetworkingPropertyDef]] = pydantic.Field(None)
    CfnInstance_PortProperty: typing.Optional[dict[str, CfnInstance_PortPropertyDef]] = pydantic.Field(None)
    CfnInstance_StateProperty: typing.Optional[dict[str, CfnInstance_StatePropertyDef]] = pydantic.Field(None)
    CfnAlarm: typing.Optional[dict[str, CfnAlarmDef]] = pydantic.Field(None)
    CfnBucket: typing.Optional[dict[str, CfnBucketDef]] = pydantic.Field(None)
    CfnCertificate: typing.Optional[dict[str, CfnCertificateDef]] = pydantic.Field(None)
    CfnContainer: typing.Optional[dict[str, CfnContainerDef]] = pydantic.Field(None)
    CfnDatabase: typing.Optional[dict[str, CfnDatabaseDef]] = pydantic.Field(None)
    CfnDisk: typing.Optional[dict[str, CfnDiskDef]] = pydantic.Field(None)
    CfnDistribution: typing.Optional[dict[str, CfnDistributionDef]] = pydantic.Field(None)
    CfnInstance: typing.Optional[dict[str, CfnInstanceDef]] = pydantic.Field(None)
    CfnLoadBalancer: typing.Optional[dict[str, CfnLoadBalancerDef]] = pydantic.Field(None)
    CfnLoadBalancerTlsCertificate: typing.Optional[dict[str, CfnLoadBalancerTlsCertificateDef]] = pydantic.Field(None)
    CfnStaticIp: typing.Optional[dict[str, CfnStaticIpDef]] = pydantic.Field(None)
    CfnAlarmProps: typing.Optional[dict[str, CfnAlarmPropsDef]] = pydantic.Field(None)
    CfnBucketProps: typing.Optional[dict[str, CfnBucketPropsDef]] = pydantic.Field(None)
    CfnCertificateProps: typing.Optional[dict[str, CfnCertificatePropsDef]] = pydantic.Field(None)
    CfnContainerProps: typing.Optional[dict[str, CfnContainerPropsDef]] = pydantic.Field(None)
    CfnDatabaseProps: typing.Optional[dict[str, CfnDatabasePropsDef]] = pydantic.Field(None)
    CfnDiskProps: typing.Optional[dict[str, CfnDiskPropsDef]] = pydantic.Field(None)
    CfnDistributionProps: typing.Optional[dict[str, CfnDistributionPropsDef]] = pydantic.Field(None)
    CfnInstanceProps: typing.Optional[dict[str, CfnInstancePropsDef]] = pydantic.Field(None)
    CfnLoadBalancerProps: typing.Optional[dict[str, CfnLoadBalancerPropsDef]] = pydantic.Field(None)
    CfnLoadBalancerTlsCertificateProps: typing.Optional[dict[str, CfnLoadBalancerTlsCertificatePropsDef]] = pydantic.Field(None)
    CfnStaticIpProps: typing.Optional[dict[str, CfnStaticIpPropsDef]] = pydantic.Field(None)
    ...
