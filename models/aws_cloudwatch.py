from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_cloudwatch.AlarmBase
class AlarmBaseDef(BaseClass):
    account: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to\n')
    environment_from_arn: typing.Optional[str] = pydantic.Field(None, description='ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.\n')
    physical_name: typing.Optional[str] = pydantic.Field(None, description='The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to')
    _init_params: typing.ClassVar[list[str]] = ['account', 'environment_from_arn', 'physical_name', 'region']
    _method_names: typing.ClassVar[list[str]] = ['add_alarm_action', 'add_insufficient_data_action', 'add_ok_action', 'apply_removal_policy', 'render_alarm_rule']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.AlarmBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.AlarmBaseDefConfig] = pydantic.Field(None)


class AlarmBaseDefConfig(pydantic.BaseModel):
    add_alarm_action: typing.Optional[list[models.aws_cloudwatch.AlarmBaseDefAddAlarmActionParams]] = pydantic.Field(None, description='Trigger this action if the alarm fires.\nTypically SnsAction or AutoScalingAction.')
    add_insufficient_data_action: typing.Optional[list[models.aws_cloudwatch.AlarmBaseDefAddInsufficientDataActionParams]] = pydantic.Field(None, description='Trigger this action if there is insufficient data to evaluate the alarm.\nTypically SnsAction or AutoScalingAction.')
    add_ok_action: typing.Optional[list[models.aws_cloudwatch.AlarmBaseDefAddOkActionParams]] = pydantic.Field(None, description='Trigger this action if the alarm returns from breaching state into ok state.\nTypically SnsAction or AutoScalingAction.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    render_alarm_rule: typing.Optional[bool] = pydantic.Field(None, description='AlarmRule indicating ALARM state for Alarm.')

class AlarmBaseDefAddAlarmActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class AlarmBaseDefAddInsufficientDataActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class AlarmBaseDefAddOkActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class AlarmBaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.AlarmRule
class AlarmRuleDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['all_of', 'any_of', 'from_alarm', 'from_boolean', 'from_string', 'not_']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.AlarmRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['all_of', 'any_of', 'from_alarm', 'from_boolean', 'from_string', 'not_']
    ...


    all_of: typing.Optional[models.aws_cloudwatch.AlarmRuleDefAllOfParams] = pydantic.Field(None, description='function to join all provided AlarmRules with AND operator.')
    any_of: typing.Optional[models.aws_cloudwatch.AlarmRuleDefAnyOfParams] = pydantic.Field(None, description='function to join all provided AlarmRules with OR operator.')
    from_alarm: typing.Optional[models.aws_cloudwatch.AlarmRuleDefFromAlarmParams] = pydantic.Field(None, description='function to build Rule Expression for given IAlarm and AlarmState.')
    from_boolean: typing.Optional[models.aws_cloudwatch.AlarmRuleDefFromBooleanParams] = pydantic.Field(None, description='function to build TRUE/FALSE intent for Rule Expression.')
    from_string: typing.Optional[models.aws_cloudwatch.AlarmRuleDefFromStringParams] = pydantic.Field(None, description='function to build Rule Expression for given Alarm Rule string.')
    not_: typing.Optional[models.aws_cloudwatch.AlarmRuleDefNotParams] = pydantic.Field(None, description='function to wrap provided AlarmRule in NOT operator.')

class AlarmRuleDefAllOfParams(pydantic.BaseModel):
    operands: list[models.UnsupportedResource] = pydantic.Field(...)
    ...

class AlarmRuleDefAnyOfParams(pydantic.BaseModel):
    operands: list[models.UnsupportedResource] = pydantic.Field(...)
    ...

class AlarmRuleDefFromAlarmParams(pydantic.BaseModel):
    alarm: typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef] = pydantic.Field(..., description='IAlarm to be used in Rule Expression.\n')
    alarm_state: aws_cdk.aws_cloudwatch.AlarmState = pydantic.Field(..., description='AlarmState to be used in Rule Expression.')
    ...

class AlarmRuleDefFromBooleanParams(pydantic.BaseModel):
    value: bool = pydantic.Field(..., description='boolean value to be used in rule expression.')
    ...

class AlarmRuleDefFromStringParams(pydantic.BaseModel):
    alarm_rule: str = pydantic.Field(..., description='string to be used in Rule Expression.')
    ...

class AlarmRuleDefNotParams(pydantic.BaseModel):
    operand: models.UnsupportedResource = pydantic.Field(..., description='IAlarmRule to be wrapped in NOT operator.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.AlarmStatusWidget
class AlarmStatusWidgetDef(BaseClass):
    alarms: typing.Union[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='CloudWatch Alarms to show in widget.')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: 3\n')
    sort_by: typing.Optional[aws_cdk.aws_cloudwatch.AlarmStatusWidgetSortBy] = pydantic.Field(None, description='Specifies how to sort the alarms in the widget. Default: - alphabetical order\n')
    states: typing.Optional[typing.Sequence[aws_cdk.aws_cloudwatch.AlarmState]] = pydantic.Field(None, description='Use this field to filter the list of alarms displayed in the widget to only those alarms currently in the specified states. You can specify one or more alarm states in the value for this field. The alarm states that you can specify are ALARM, INSUFFICIENT_DATA, and OK. If you omit this field or specify an empty array, all the alarms specifed in alarms are displayed. Default: - all the alarms specified in alarms are displayed.\n')
    title: typing.Optional[str] = pydantic.Field(None, description="The title of the widget. Default: 'Alarm Status'\n")
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6')
    _init_params: typing.ClassVar[list[str]] = ['alarms', 'height', 'sort_by', 'states', 'title', 'width']
    _method_names: typing.ClassVar[list[str]] = ['position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.AlarmStatusWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.AlarmStatusWidgetDefConfig] = pydantic.Field(None)


class AlarmStatusWidgetDefConfig(pydantic.BaseModel):
    position: typing.Optional[list[models.aws_cloudwatch.AlarmStatusWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class AlarmStatusWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.AlarmWidget
class AlarmWidgetDef(BaseClass):
    alarm: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The alarm to show.')
    left_y_axis: typing.Union[models.aws_cloudwatch.YAxisPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Left Y axis. Default: - No minimum or maximum values for the left Y-axis\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6')
    _init_params: typing.ClassVar[list[str]] = ['alarm', 'left_y_axis', 'height', 'region', 'title', 'width']
    _method_names: typing.ClassVar[list[str]] = ['position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.AlarmWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.AlarmWidgetDefConfig] = pydantic.Field(None)


class AlarmWidgetDefConfig(pydantic.BaseModel):
    position: typing.Optional[list[models.aws_cloudwatch.AlarmWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class AlarmWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.Color
class ColorDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Color'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.Column
class ColumnDef(BaseClass):
    widgets: list[typing.Union[models.aws_cloudwatch.AlarmStatusWidgetDef, models.aws_cloudwatch.AlarmWidgetDef, models.aws_cloudwatch.ColumnDef, models.aws_cloudwatch.ConcreteWidgetDef, models.aws_cloudwatch.CustomWidgetDef, models.aws_cloudwatch.GaugeWidgetDef, models.aws_cloudwatch.GraphWidgetDef, models.aws_cloudwatch.LogQueryWidgetDef, models.aws_cloudwatch.RowDef, models.aws_cloudwatch.SingleValueWidgetDef, models.aws_cloudwatch.SpacerDef, models.aws_cloudwatch.TextWidgetDef]] = pydantic.Field(REQUIRED_INIT_PARAM)
    _init_params: typing.ClassVar[list[str]] = ['widgets']
    _method_names: typing.ClassVar[list[str]] = ['add_widget', 'position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Column'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.ColumnDefConfig] = pydantic.Field(None)


class ColumnDefConfig(pydantic.BaseModel):
    add_widget: typing.Optional[list[models.aws_cloudwatch.ColumnDefAddWidgetParams]] = pydantic.Field(None, description='Add the widget to this container.')
    position: typing.Optional[list[models.aws_cloudwatch.ColumnDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class ColumnDefAddWidgetParams(pydantic.BaseModel):
    w: typing.Union[models.aws_cloudwatch.AlarmStatusWidgetDef, models.aws_cloudwatch.AlarmWidgetDef, models.aws_cloudwatch.ColumnDef, models.aws_cloudwatch.ConcreteWidgetDef, models.aws_cloudwatch.CustomWidgetDef, models.aws_cloudwatch.GaugeWidgetDef, models.aws_cloudwatch.GraphWidgetDef, models.aws_cloudwatch.LogQueryWidgetDef, models.aws_cloudwatch.RowDef, models.aws_cloudwatch.SingleValueWidgetDef, models.aws_cloudwatch.SpacerDef, models.aws_cloudwatch.TextWidgetDef] = pydantic.Field(..., description='-')
    ...

class ColumnDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.ConcreteWidget
class ConcreteWidgetDef(BaseClass):
    width: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of horizontal grid units the widget will take up.')
    height: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of vertical grid units the widget will take up.')
    _init_params: typing.ClassVar[list[str]] = ['width', 'height']
    _method_names: typing.ClassVar[list[str]] = ['position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.ConcreteWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.ConcreteWidgetDefConfig] = pydantic.Field(None)


class ConcreteWidgetDefConfig(pydantic.BaseModel):
    position: typing.Optional[list[models.aws_cloudwatch.ConcreteWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class ConcreteWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.CustomWidget
class CustomWidgetDef(BaseClass):
    function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Arn of the AWS Lambda function that returns HTML or JSON that will be displayed in the widget.')
    title: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The title of the widget.\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    params: typing.Any = pydantic.Field(None, description='Parameters passed to the lambda function. Default: - no parameters are passed to the lambda function\n')
    update_on_refresh: typing.Optional[bool] = pydantic.Field(None, description='Update the widget on refresh. Default: true\n')
    update_on_resize: typing.Optional[bool] = pydantic.Field(None, description='Update the widget on resize. Default: true\n')
    update_on_time_range_change: typing.Optional[bool] = pydantic.Field(None, description='Update the widget on time range change. Default: true\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6')
    _init_params: typing.ClassVar[list[str]] = ['function_arn', 'title', 'height', 'params', 'update_on_refresh', 'update_on_resize', 'update_on_time_range_change', 'width']
    _method_names: typing.ClassVar[list[str]] = ['position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CustomWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.CustomWidgetDefConfig] = pydantic.Field(None)


class CustomWidgetDefConfig(pydantic.BaseModel):
    position: typing.Optional[list[models.aws_cloudwatch.CustomWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class CustomWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.DashboardVariable
class DashboardVariableDef(BaseClass):
    input_type: typing.Union[aws_cdk.aws_cloudwatch.VariableInputType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The way the variable value is selected.\n')
    type: typing.Union[aws_cdk.aws_cloudwatch.VariableType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Type of the variable.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Pattern or property value to replace.\n')
    default_value: typing.Optional[models.aws_cloudwatch.DefaultValueDef] = pydantic.Field(None, description='Optional default value. Default: - no default value is set\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Optional label in the toolbar. Default: - the variable's value\n")
    values: typing.Optional[models.aws_cloudwatch.ValuesDef] = pydantic.Field(None, description='Optional values (required for {@link VariableInputType.RADIO} and {@link VariableInputType.SELECT} dashboard variables). Default: - no values\n')
    visible: typing.Optional[bool] = pydantic.Field(None, description='Whether the variable is visible. Default: - true')
    _init_params: typing.ClassVar[list[str]] = ['input_type', 'type', 'value', 'default_value', 'label', 'values', 'visible']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.DashboardVariable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.DefaultValue
class DefaultValueDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['value']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.DefaultValue'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.DefaultValueDefConfig] = pydantic.Field(None)


class DefaultValueDefConfig(pydantic.BaseModel):
    value: typing.Optional[list[models.aws_cloudwatch.DefaultValueDefValueParams]] = pydantic.Field(None, description='Create a default value.')

class DefaultValueDefValueParams(pydantic.BaseModel):
    value: typing.Any = pydantic.Field(..., description='the value to be used as default.')
    return_config: typing.Optional[list[models.aws_cloudwatch.DefaultValueDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.GaugeWidget
class GaugeWidgetDef(BaseClass):
    annotations: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.HorizontalAnnotationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Annotations for the left Y axis. Default: - No annotations')
    end: typing.Optional[str] = pydantic.Field(None, description='The end of the time range to use for each widget independently from those of the dashboard. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.\n')
    left_y_axis: typing.Union[models.aws_cloudwatch.YAxisPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Left Y axis. Default: - None\n')
    legend_position: typing.Optional[aws_cdk.aws_cloudwatch.LegendPosition] = pydantic.Field(None, description='Position of the legend. Default: - bottom\n')
    live_data: typing.Optional[bool] = pydantic.Field(None, description='Whether the graph should show live data. Default: false\n')
    metrics: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]]] = pydantic.Field(None, description='Metrics to display on left Y axis. Default: - No metrics\n')
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The default period for all metrics in this widget. The period is the length of time represented by one data point on the graph. This default can be overridden within each metric definition. Default: cdk.Duration.seconds(300)\n')
    set_period_to_time_range: typing.Optional[bool] = pydantic.Field(None, description='Whether to show the value from the entire time range. Only applicable for Bar and Pie charts. If false, values will be from the most recent period of your chosen time range; if true, shows the value from the entire time range. Default: false\n')
    start: typing.Optional[str] = pydantic.Field(None, description='The start of the time range to use for each widget independently from those of the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='The default statistic to be displayed for each metric. This default can be overridden within the definition of each individual metric Default: - The statistic for each metric is used\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6')
    _init_params: typing.ClassVar[list[str]] = ['annotations', 'end', 'left_y_axis', 'legend_position', 'live_data', 'metrics', 'period', 'set_period_to_time_range', 'start', 'statistic', 'height', 'region', 'title', 'width']
    _method_names: typing.ClassVar[list[str]] = ['add_metric', 'position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.GaugeWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.GaugeWidgetDefConfig] = pydantic.Field(None)


class GaugeWidgetDefConfig(pydantic.BaseModel):
    add_metric: typing.Optional[list[models.aws_cloudwatch.GaugeWidgetDefAddMetricParams]] = pydantic.Field(None, description='Add another metric to the left Y axis of the GaugeWidget.')
    position: typing.Optional[list[models.aws_cloudwatch.GaugeWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class GaugeWidgetDefAddMetricParams(pydantic.BaseModel):
    metric: typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef] = pydantic.Field(..., description='the metric to add.')
    ...

class GaugeWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.GraphWidget
class GraphWidgetDef(BaseClass):
    end: typing.Optional[str] = pydantic.Field(None, description='The end of the time range to use for each widget independently from those of the dashboard. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.')
    left: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]]] = pydantic.Field(None, description='Metrics to display on left Y axis. Default: - No metrics\n')
    left_annotations: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.HorizontalAnnotationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Annotations for the left Y axis. Default: - No annotations\n')
    left_y_axis: typing.Union[models.aws_cloudwatch.YAxisPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Left Y axis. Default: - None\n')
    legend_position: typing.Optional[aws_cdk.aws_cloudwatch.LegendPosition] = pydantic.Field(None, description='Position of the legend. Default: - bottom\n')
    live_data: typing.Optional[bool] = pydantic.Field(None, description='Whether the graph should show live data. Default: false\n')
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The default period for all metrics in this widget. The period is the length of time represented by one data point on the graph. This default can be overridden within each metric definition. Default: cdk.Duration.seconds(300)\n')
    right: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]]] = pydantic.Field(None, description='Metrics to display on right Y axis. Default: - No metrics\n')
    right_annotations: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.HorizontalAnnotationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Annotations for the right Y axis. Default: - No annotations\n')
    right_y_axis: typing.Union[models.aws_cloudwatch.YAxisPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Right Y axis. Default: - None\n')
    set_period_to_time_range: typing.Optional[bool] = pydantic.Field(None, description='Whether to show the value from the entire time range. Only applicable for Bar and Pie charts. If false, values will be from the most recent period of your chosen time range; if true, shows the value from the entire time range. Default: false\n')
    stacked: typing.Optional[bool] = pydantic.Field(None, description='Whether the graph should be shown as stacked lines. Default: false\n')
    start: typing.Optional[str] = pydantic.Field(None, description='The start of the time range to use for each widget independently from those of the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='The default statistic to be displayed for each metric. This default can be overridden within the definition of each individual metric Default: - The statistic for each metric is used\n')
    vertical_annotations: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.VerticalAnnotationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Annotations for the X axis. Default: - No annotations\n')
    view: typing.Optional[aws_cdk.aws_cloudwatch.GraphWidgetView] = pydantic.Field(None, description='Display this metric. Default: TimeSeries\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6')
    _init_params: typing.ClassVar[list[str]] = ['end', 'left', 'left_annotations', 'left_y_axis', 'legend_position', 'live_data', 'period', 'right', 'right_annotations', 'right_y_axis', 'set_period_to_time_range', 'stacked', 'start', 'statistic', 'vertical_annotations', 'view', 'height', 'region', 'title', 'width']
    _method_names: typing.ClassVar[list[str]] = ['add_left_metric', 'add_right_metric', 'position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.GraphWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.GraphWidgetDefConfig] = pydantic.Field(None)


class GraphWidgetDefConfig(pydantic.BaseModel):
    add_left_metric: typing.Optional[list[models.aws_cloudwatch.GraphWidgetDefAddLeftMetricParams]] = pydantic.Field(None, description='Add another metric to the left Y axis of the GraphWidget.')
    add_right_metric: typing.Optional[list[models.aws_cloudwatch.GraphWidgetDefAddRightMetricParams]] = pydantic.Field(None, description='Add another metric to the right Y axis of the GraphWidget.')
    position: typing.Optional[list[models.aws_cloudwatch.GraphWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class GraphWidgetDefAddLeftMetricParams(pydantic.BaseModel):
    metric: typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef] = pydantic.Field(..., description='the metric to add.')
    ...

class GraphWidgetDefAddRightMetricParams(pydantic.BaseModel):
    metric: typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef] = pydantic.Field(..., description='the metric to add.')
    ...

class GraphWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.LogQueryWidget
class LogQueryWidgetDef(BaseClass):
    log_group_names: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Names of log groups to query.')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: 6\n')
    query_lines: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A sequence of lines to use to build the query. The query will be built by joining the lines together using ``\\n|``. Default: - Exactly one of ``queryString``, ``queryLines`` is required.\n')
    query_string: typing.Optional[str] = pydantic.Field(None, description='Full query string for log insights. Be sure to prepend every new line with a newline and pipe character (``\\n|``). Default: - Exactly one of ``queryString``, ``queryLines`` is required.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this widget should be taken from. Default: Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the widget. Default: No title\n')
    view: typing.Optional[aws_cdk.aws_cloudwatch.LogQueryVisualizationType] = pydantic.Field(None, description='The type of view to use. Default: LogQueryVisualizationType.TABLE\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6')
    _init_params: typing.ClassVar[list[str]] = ['log_group_names', 'height', 'query_lines', 'query_string', 'region', 'title', 'view', 'width']
    _method_names: typing.ClassVar[list[str]] = ['position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.LogQueryWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.LogQueryWidgetDefConfig] = pydantic.Field(None)


class LogQueryWidgetDefConfig(pydantic.BaseModel):
    position: typing.Optional[list[models.aws_cloudwatch.LogQueryWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class LogQueryWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.MathExpression
class MathExpressionDef(BaseClass):
    expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The expression defining the metric. When an expression contains a SEARCH function, it cannot be used within an Alarm.')
    using_metrics: typing.Optional[typing.Mapping[str, typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]]] = pydantic.Field(None, description='The metrics used in the expression, in a map. The key is the identifier that represents the given metric in the expression, and the value is the actual Metric object. Default: - Empty map.\n')
    color: typing.Optional[str] = pydantic.Field(None, description='Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this expression when added to a Graph in a Dashboard. If this expression evaluates to more than one time series (for example, through the use of ``METRICS()`` or ``SEARCH()`` expressions), each time series will appear in the graph using a combination of the expression label and the individual metric label. Specify the empty string (``''``) to suppress the expression label and only keep the metric label. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. If the math expression produces more than one time series, the maximum will be shown for each individual time series produce by this math expression. Default: - Expression value is used as label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)\n")
    search_account: typing.Optional[str] = pydantic.Field(None, description='Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.\n')
    search_region: typing.Optional[str] = pydantic.Field(None, description='Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.')
    _init_params: typing.ClassVar[list[str]] = ['expression', 'using_metrics', 'color', 'label', 'period', 'search_account', 'search_region']
    _method_names: typing.ClassVar[list[str]] = ['create_alarm', 'with_']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MathExpression'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.MathExpressionDefConfig] = pydantic.Field(None)


class MathExpressionDefConfig(pydantic.BaseModel):
    create_alarm: typing.Optional[list[models.aws_cloudwatch.MathExpressionDefCreateAlarmParams]] = pydantic.Field(None, description='Make a new Alarm for this metric.\nCombines both properties that may adjust the metric (aggregation) as well\nas alarm properties.')
    with_: typing.Optional[list[models.aws_cloudwatch.MathExpressionDefWithParams]] = pydantic.Field(None, description='Return a copy of Metric with properties changed.\nAll properties except namespace and metricName can be changed.')
    period_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)

class MathExpressionDefCreateAlarmParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    evaluation_periods: typing.Union[int, float] = pydantic.Field(..., description='The number of periods over which data is compared to the specified threshold.\n')
    threshold: typing.Union[int, float] = pydantic.Field(..., description='The value against which the specified statistic is compared.\n')
    actions_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether the actions for this alarm are enabled. Default: true\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='Description for the alarm. Default: No description\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description='Name of the alarm. Default: Automatically generated name\n')
    comparison_operator: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = pydantic.Field(None, description='Comparison to use to check if metric is breaching. Default: GreaterThanOrEqualToThreshold\n')
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M out of N" alarm. In that case, this value is the M. For more information, see Evaluating an Alarm in the Amazon CloudWatch User Guide. Default: ``evaluationPeriods``\n')
    evaluate_low_sample_count_percentile: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to evaluate the data and potentially change the alarm state if there are too few data points to be statistically significant. Used only for alarms that are based on percentiles. Default: - Not configured.\n')
    treat_missing_data: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = pydantic.Field(None, description='Sets how this alarm is to handle missing data points. Default: TreatMissingData.Missing')
    return_config: typing.Optional[list[models.aws_cloudwatch.AlarmDefConfig]] = pydantic.Field(None)
    ...

class MathExpressionDefWithParams(pydantic.BaseModel):
    color: typing.Optional[str] = pydantic.Field(None, description='Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this expression when added to a Graph in a Dashboard. If this expression evaluates to more than one time series (for example, through the use of ``METRICS()`` or ``SEARCH()`` expressions), each time series will appear in the graph using a combination of the expression label and the individual metric label. Specify the empty string (``''``) to suppress the expression label and only keep the metric label. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. If the math expression produces more than one time series, the maximum will be shown for each individual time series produce by this math expression. Default: - Expression value is used as label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)\n")
    search_account: typing.Optional[str] = pydantic.Field(None, description='Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.\n')
    search_region: typing.Optional[str] = pydantic.Field(None, description='Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.')
    return_config: typing.Optional[list[models.aws_cloudwatch.MathExpressionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.Metric
class MetricDef(BaseClass):
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the metric.')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Namespace of the metric.\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    _init_params: typing.ClassVar[list[str]] = ['metric_name', 'namespace', 'account', 'color', 'dimensions_map', 'label', 'period', 'region', 'statistic', 'unit']
    _method_names: typing.ClassVar[list[str]] = ['attach_to', 'create_alarm', 'with_']
    _classmethod_names: typing.ClassVar[list[str]] = ['grant_put_metric_data']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Metric'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['grant_put_metric_data']
    ...


    grant_put_metric_data: typing.Optional[models.aws_cloudwatch.MetricDefGrantPutMetricDataParams] = pydantic.Field(None, description='Grant permissions to the given identity to write metrics.')
    resource_config: typing.Optional[models.aws_cloudwatch.MetricDefConfig] = pydantic.Field(None)


class MetricDefConfig(pydantic.BaseModel):
    attach_to: typing.Optional[list[models.aws_cloudwatch.MetricDefAttachToParams]] = pydantic.Field(None, description="Attach the metric object to the given construct scope.\nReturns a Metric object that uses the account and region from the Stack\nthe given construct is defined in. If the metric is subsequently used\nin a Dashboard or Alarm in a different Stack defined in a different\naccount or region, the appropriate 'region' and 'account' fields\nwill be added to it.\n\nIf the scope we attach to is in an environment-agnostic stack,\nnothing is done and the same Metric object is returned.")
    create_alarm: typing.Optional[list[models.aws_cloudwatch.MetricDefCreateAlarmParams]] = pydantic.Field(None, description='Make a new Alarm for this metric.\nCombines both properties that may adjust the metric (aggregation) as well\nas alarm properties.')
    with_: typing.Optional[list[models.aws_cloudwatch.MetricDefWithParams]] = pydantic.Field(None, description='Return a copy of Metric ``with`` properties changed.\nAll properties except namespace and metricName can be changed.')
    period_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)

class MetricDefAttachToParams(pydantic.BaseModel):
    scope: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class MetricDefCreateAlarmParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    evaluation_periods: typing.Union[int, float] = pydantic.Field(..., description='The number of periods over which data is compared to the specified threshold.\n')
    threshold: typing.Union[int, float] = pydantic.Field(..., description='The value against which the specified statistic is compared.\n')
    actions_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether the actions for this alarm are enabled. Default: true\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='Description for the alarm. Default: No description\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description='Name of the alarm. Default: Automatically generated name\n')
    comparison_operator: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = pydantic.Field(None, description='Comparison to use to check if metric is breaching. Default: GreaterThanOrEqualToThreshold\n')
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M out of N" alarm. In that case, this value is the M. For more information, see Evaluating an Alarm in the Amazon CloudWatch User Guide. Default: ``evaluationPeriods``\n')
    evaluate_low_sample_count_percentile: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to evaluate the data and potentially change the alarm state if there are too few data points to be statistically significant. Used only for alarms that are based on percentiles. Default: - Not configured.\n')
    treat_missing_data: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = pydantic.Field(None, description='Sets how this alarm is to handle missing data points. Default: TreatMissingData.Missing')
    return_config: typing.Optional[list[models.aws_cloudwatch.AlarmDefConfig]] = pydantic.Field(None)
    ...

class MetricDefGrantPutMetricDataParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='The IAM identity to give permissions to.')
    ...

class MetricDefWithParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.Row
class RowDef(BaseClass):
    widgets: list[typing.Union[models.aws_cloudwatch.AlarmStatusWidgetDef, models.aws_cloudwatch.AlarmWidgetDef, models.aws_cloudwatch.ColumnDef, models.aws_cloudwatch.ConcreteWidgetDef, models.aws_cloudwatch.CustomWidgetDef, models.aws_cloudwatch.GaugeWidgetDef, models.aws_cloudwatch.GraphWidgetDef, models.aws_cloudwatch.LogQueryWidgetDef, models.aws_cloudwatch.RowDef, models.aws_cloudwatch.SingleValueWidgetDef, models.aws_cloudwatch.SpacerDef, models.aws_cloudwatch.TextWidgetDef]] = pydantic.Field(REQUIRED_INIT_PARAM)
    _init_params: typing.ClassVar[list[str]] = ['widgets']
    _method_names: typing.ClassVar[list[str]] = ['add_widget', 'position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Row'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.RowDefConfig] = pydantic.Field(None)


class RowDefConfig(pydantic.BaseModel):
    add_widget: typing.Optional[list[models.aws_cloudwatch.RowDefAddWidgetParams]] = pydantic.Field(None, description='Add the widget to this container.')
    position: typing.Optional[list[models.aws_cloudwatch.RowDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class RowDefAddWidgetParams(pydantic.BaseModel):
    w: typing.Union[models.aws_cloudwatch.AlarmStatusWidgetDef, models.aws_cloudwatch.AlarmWidgetDef, models.aws_cloudwatch.ColumnDef, models.aws_cloudwatch.ConcreteWidgetDef, models.aws_cloudwatch.CustomWidgetDef, models.aws_cloudwatch.GaugeWidgetDef, models.aws_cloudwatch.GraphWidgetDef, models.aws_cloudwatch.LogQueryWidgetDef, models.aws_cloudwatch.RowDef, models.aws_cloudwatch.SingleValueWidgetDef, models.aws_cloudwatch.SpacerDef, models.aws_cloudwatch.TextWidgetDef] = pydantic.Field(..., description='-')
    ...

class RowDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.SingleValueWidget
class SingleValueWidgetDef(BaseClass):
    metrics: typing.Union[typing.Sequence[typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Metrics to display.')
    end: typing.Optional[str] = pydantic.Field(None, description='The end of the time range to use for each widget independently from those of the dashboard. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.\n')
    full_precision: typing.Optional[bool] = pydantic.Field(None, description='Whether to show as many digits as can fit, before rounding. Default: false\n')
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The default period for all metrics in this widget. The period is the length of time represented by one data point on the graph. This default can be overridden within each metric definition. Default: cdk.Duration.seconds(300)\n')
    set_period_to_time_range: typing.Optional[bool] = pydantic.Field(None, description='Whether to show the value from the entire time range. Default: false\n')
    sparkline: typing.Optional[bool] = pydantic.Field(None, description='Whether to show a graph below the value illustrating the value for the whole time range. Cannot be used in combination with ``setPeriodToTimeRange`` Default: false\n')
    start: typing.Optional[str] = pydantic.Field(None, description='The start of the time range to use for each widget independently from those of the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6')
    _init_params: typing.ClassVar[list[str]] = ['metrics', 'end', 'full_precision', 'period', 'set_period_to_time_range', 'sparkline', 'start', 'height', 'region', 'title', 'width']
    _method_names: typing.ClassVar[list[str]] = ['position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.SingleValueWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.SingleValueWidgetDefConfig] = pydantic.Field(None)


class SingleValueWidgetDefConfig(pydantic.BaseModel):
    position: typing.Optional[list[models.aws_cloudwatch.SingleValueWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class SingleValueWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.Spacer
class SpacerDef(BaseClass):
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the spacer. Default: : 1')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the spacer. Default: 1')
    _init_params: typing.ClassVar[list[str]] = ['height', 'width']
    _method_names: typing.ClassVar[list[str]] = ['position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Spacer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.SpacerDefConfig] = pydantic.Field(None)


class SpacerDefConfig(pydantic.BaseModel):
    position: typing.Optional[bool] = pydantic.Field(None, description='Place the widget at a given position.')


#  autogenerated from aws_cdk.aws_cloudwatch.Stats
class StatsDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['p', 'percentile', 'percentile_rank', 'pr', 'tc', 'tm', 'trimmed_count', 'trimmed_mean', 'trimmed_sum', 'ts', 'winsorized_mean', 'wm']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Stats'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.StatsDefConfig] = pydantic.Field(None)


class StatsDefConfig(pydantic.BaseModel):
    p: typing.Optional[list[models.aws_cloudwatch.StatsDefPParams]] = pydantic.Field(None, description='A shorter alias for ``percentile()``.')
    percentile: typing.Optional[list[models.aws_cloudwatch.StatsDefPercentileParams]] = pydantic.Field(None, description='Percentile indicates the relative standing of a value in a dataset.\nPercentiles help you get a better understanding of the distribution of your metric data.\n\nFor example, ``p(90)`` is the 90th percentile and means that 90% of the data\nwithin the period is lower than this value and 10% of the data is higher\nthan this value.')
    percentile_rank: typing.Optional[list[models.aws_cloudwatch.StatsDefPercentileRankParams]] = pydantic.Field(None, description='Percentile rank (PR) is the percentage of values that meet a fixed threshold.\n- If two numbers are given, they define the lower and upper bounds in absolute values,\n  respectively.\n- If one number is given, it defines the upper bound (the lower bound is assumed to\n  be 0).\n\nFor example, ``percentileRank(300)`` returns the percentage of data points that have a value of 300 or less.\n``percentileRank(100, 2000)`` returns the percentage of data points that have a value between 100 and 2000.')
    pr: typing.Optional[list[models.aws_cloudwatch.StatsDefPrParams]] = pydantic.Field(None, description='Shorter alias for ``percentileRank()``.')
    tc: typing.Optional[list[models.aws_cloudwatch.StatsDefTcParams]] = pydantic.Field(None, description='Shorter alias for ``trimmedCount()``.')
    tm: typing.Optional[list[models.aws_cloudwatch.StatsDefTmParams]] = pydantic.Field(None, description='A shorter alias for ``trimmedMean()``.')
    trimmed_count: typing.Optional[list[models.aws_cloudwatch.StatsDefTrimmedCountParams]] = pydantic.Field(None, description='Trimmed count (TC) is the number of data points in the chosen range for a trimmed mean statistic.\n- If two numbers are given, they define the lower and upper bounds in percentages,\n  respectively.\n- If one number is given, it defines the upper bound (the lower bound is assumed to\n  be 0).\n\nFor example, ``tc(90)`` returns the number of data points not including any\ndata points that fall in the highest 10% of the values. ``tc(10, 90)``\nreturns the number of data points not including any data points that fall\nin the lowest 10% of the values and the highest 90% of the values.')
    trimmed_mean: typing.Optional[list[models.aws_cloudwatch.StatsDefTrimmedMeanParams]] = pydantic.Field(None, description='Trimmed mean (TM) is the mean of all values that are between two specified boundaries.\nValues outside of the boundaries are ignored when the mean is calculated.\nYou define the boundaries as one or two numbers between 0 and 100, up to 10\ndecimal places. The numbers are percentages.\n\n- If two numbers are given, they define the lower and upper bounds in percentages,\n  respectively.\n- If one number is given, it defines the upper bound (the lower bound is assumed to\n  be 0).\n\nFor example, ``tm(90)`` calculates the average after removing the 10% of data\npoints with the highest values; ``tm(10, 90)`` calculates the average after removing the\n10% with the lowest and 10% with the highest values.')
    trimmed_sum: typing.Optional[list[models.aws_cloudwatch.StatsDefTrimmedSumParams]] = pydantic.Field(None, description='Trimmed sum (TS) is the sum of the values of data points in a chosen range for a trimmed mean statistic.\nIt is equivalent to ``(Trimmed Mean) * (Trimmed count)``.\n\n- If two numbers are given, they define the lower and upper bounds in percentages,\n  respectively.\n- If one number is given, it defines the upper bound (the lower bound is assumed to\n  be 0).\n\nFor example, ``ts(90)`` returns the sum of the data points not including any\ndata points that fall in the highest 10% of the values.  ``ts(10, 90)``\nreturns the sum of the data points not including any data points that fall\nin the lowest 10% of the values and the highest 90% of the values.')
    ts: typing.Optional[list[models.aws_cloudwatch.StatsDefTsParams]] = pydantic.Field(None, description='Shorter alias for ``trimmedSum()``.')
    winsorized_mean: typing.Optional[list[models.aws_cloudwatch.StatsDefWinsorizedMeanParams]] = pydantic.Field(None, description='Winsorized mean (WM) is similar to trimmed mean.\nHowever, with winsorized mean, the values that are outside the boundary are\nnot ignored, but instead are considered to be equal to the value at the\nedge of the appropriate boundary.  After this normalization, the average is\ncalculated. You define the boundaries as one or two numbers between 0 and\n100, up to 10 decimal places.\n\n- If two numbers are given, they define the lower and upper bounds in percentages,\n  respectively.\n- If one number is given, it defines the upper bound (the lower bound is assumed to\n  be 0).\n\nFor example, ``tm(90)`` calculates the average after removing the 10% of data\npoints with the highest values; ``tm(10, 90)`` calculates the average after removing the\n10% with the lowest and 10% with the highest values.\n\nFor example, ``wm(90)`` calculates the average while treating the 10% of the\nhighest values to be equal to the value at the 90th percentile.\n``wm(10, 90)`` calculates the average while treaing the bottom 10% and the\ntop 10% of values to be equal to the boundary values.')
    wm: typing.Optional[list[models.aws_cloudwatch.StatsDefWmParams]] = pydantic.Field(None, description='A shorter alias for ``winsorizedMean()``.')

class StatsDefPParams(pydantic.BaseModel):
    percentile: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...

class StatsDefPercentileParams(pydantic.BaseModel):
    percentile: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...

class StatsDefPercentileRankParams(pydantic.BaseModel):
    v1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    v2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefPrParams(pydantic.BaseModel):
    v1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    v2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefTcParams(pydantic.BaseModel):
    p1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    p2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefTmParams(pydantic.BaseModel):
    p1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    p2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefTrimmedCountParams(pydantic.BaseModel):
    p1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    p2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefTrimmedMeanParams(pydantic.BaseModel):
    p1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    p2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefTrimmedSumParams(pydantic.BaseModel):
    p1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    p2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefTsParams(pydantic.BaseModel):
    p1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    p2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefWinsorizedMeanParams(pydantic.BaseModel):
    p1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    p2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...

class StatsDefWmParams(pydantic.BaseModel):
    p1: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    p2: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.TextWidget
class TextWidgetDef(BaseClass):
    markdown: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The text to display, in MarkDown format.')
    background: typing.Optional[aws_cdk.aws_cloudwatch.TextWidgetBackground] = pydantic.Field(None, description='Background for the widget. Default: solid\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: 2\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6')
    _init_params: typing.ClassVar[list[str]] = ['markdown', 'background', 'height', 'width']
    _method_names: typing.ClassVar[list[str]] = ['position']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.TextWidget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.TextWidgetDefConfig] = pydantic.Field(None)


class TextWidgetDefConfig(pydantic.BaseModel):
    position: typing.Optional[list[models.aws_cloudwatch.TextWidgetDefPositionParams]] = pydantic.Field(None, description='Place the widget at a given position.')

class TextWidgetDefPositionParams(pydantic.BaseModel):
    x: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    y: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.Values
class ValuesDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_search', 'from_search_components', 'from_values']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Values'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_search', 'from_search_components', 'from_values']
    ...


    from_search: typing.Optional[models.aws_cloudwatch.ValuesDefFromSearchParams] = pydantic.Field(None, description='Create values from a search expression.')
    from_search_components: typing.Optional[models.aws_cloudwatch.ValuesDefFromSearchComponentsParams] = pydantic.Field(None, description='Create values from the components of search expression.')
    from_values: typing.Optional[models.aws_cloudwatch.ValuesDefFromValuesParams] = pydantic.Field(None, description='Create values from an array of possible variable values.')

class ValuesDefFromSearchParams(pydantic.BaseModel):
    expression: str = pydantic.Field(..., description='search expression that specifies a namespace, dimension name(s) and a metric name. For example ``{AWS/EC2,InstanceId} MetricName=\\"CPUUtilization\\"``\n')
    populate_from: str = pydantic.Field(..., description='dimension the dimension name, that the search expression retrieves, whose values will be used to populate the values to choose from. For example ``InstanceId``')
    ...

class ValuesDefFromSearchComponentsParams(pydantic.BaseModel):
    dimensions: typing.Sequence[str] = pydantic.Field(..., description='The list of dimensions to be used in the search expression.\n')
    metric_name: str = pydantic.Field(..., description='The metric name to be used in the search expression.\n')
    namespace: str = pydantic.Field(..., description='The namespace to be used in the search expression.\n')
    populate_from: str = pydantic.Field(..., description='The dimension name, that the search expression retrieves, whose values will be used to populate the values to choose from.')
    ...

class ValuesDefFromValuesParams(pydantic.BaseModel):
    values: list[models.aws_cloudwatch.VariableValueDef] = pydantic.Field(...)
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.Alarm
class AlarmDef(BaseConstruct):
    metric: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metric to add the alarm on. Metric objects can be obtained from most resources, or you can construct custom Metric objects by instantiating one.\n')
    evaluation_periods: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of periods over which data is compared to the specified threshold.\n')
    threshold: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value against which the specified statistic is compared.\n')
    actions_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether the actions for this alarm are enabled. Default: true\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='Description for the alarm. Default: No description\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description='Name of the alarm. Default: Automatically generated name\n')
    comparison_operator: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = pydantic.Field(None, description='Comparison to use to check if metric is breaching. Default: GreaterThanOrEqualToThreshold\n')
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M out of N" alarm. In that case, this value is the M. For more information, see Evaluating an Alarm in the Amazon CloudWatch User Guide. Default: ``evaluationPeriods``\n')
    evaluate_low_sample_count_percentile: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to evaluate the data and potentially change the alarm state if there are too few data points to be statistically significant. Used only for alarms that are based on percentiles. Default: - Not configured.\n')
    treat_missing_data: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = pydantic.Field(None, description='Sets how this alarm is to handle missing data points. Default: TreatMissingData.Missing')
    _init_params: typing.ClassVar[list[str]] = ['metric', 'evaluation_periods', 'threshold', 'actions_enabled', 'alarm_description', 'alarm_name', 'comparison_operator', 'datapoints_to_alarm', 'evaluate_low_sample_count_percentile', 'treat_missing_data']
    _method_names: typing.ClassVar[list[str]] = ['add_alarm_action', 'add_insufficient_data_action', 'add_ok_action', 'apply_removal_policy', 'render_alarm_rule']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_alarm_arn', 'from_alarm_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Alarm'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_alarm_arn', 'from_alarm_name']
    ...


    from_alarm_arn: typing.Optional[models.aws_cloudwatch.AlarmDefFromAlarmArnParams] = pydantic.Field(None, description='Import an existing CloudWatch alarm provided an ARN.')
    from_alarm_name: typing.Optional[models.aws_cloudwatch.AlarmDefFromAlarmNameParams] = pydantic.Field(None, description='Import an existing CloudWatch alarm provided an Name.')
    resource_config: typing.Optional[models.aws_cloudwatch.AlarmDefConfig] = pydantic.Field(None)


class AlarmDefConfig(pydantic.BaseModel):
    add_alarm_action: typing.Optional[list[models.aws_cloudwatch.AlarmDefAddAlarmActionParams]] = pydantic.Field(None, description='Trigger this action if the alarm fires.\nTypically SnsAcion or AutoScalingAction.')
    add_insufficient_data_action: typing.Optional[list[models.aws_cloudwatch.AlarmDefAddInsufficientDataActionParams]] = pydantic.Field(None, description='Trigger this action if there is insufficient data to evaluate the alarm.\nTypically SnsAction or AutoScalingAction.')
    add_ok_action: typing.Optional[list[models.aws_cloudwatch.AlarmDefAddOkActionParams]] = pydantic.Field(None, description='Trigger this action if the alarm returns from breaching state into ok state.\nTypically SnsAction or AutoScalingAction.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    render_alarm_rule: typing.Optional[bool] = pydantic.Field(None, description='AlarmRule indicating ALARM state for Alarm.')

class AlarmDefAddAlarmActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class AlarmDefAddInsufficientDataActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class AlarmDefAddOkActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class AlarmDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class AlarmDefFromAlarmArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    alarm_arn: str = pydantic.Field(..., description='Alarm ARN (i.e. arn:aws:cloudwatch:::alarm:Foo).')
    ...

class AlarmDefFromAlarmNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    alarm_name: str = pydantic.Field(..., description='Alarm Name.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.CompositeAlarm
class CompositeAlarmDef(BaseConstruct):
    alarm_rule: typing.Union[models.UnsupportedResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="Expression that specifies which other alarms are to be evaluated to determine this composite alarm's state.\n")
    actions_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether the actions for this alarm are enabled. Default: true\n')
    actions_suppressor: typing.Optional[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]] = pydantic.Field(None, description='Actions will be suppressed if the suppressor alarm is in the ALARM state. Default: - alarm will not be suppressed.\n')
    actions_suppressor_extension_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum duration that the composite alarm waits after suppressor alarm goes out of the ALARM state. After this time, the composite alarm performs its actions. Default: - 1 minute extension period will be set.\n')
    actions_suppressor_wait_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum duration that the composite alarm waits for the suppressor alarm to go into the ALARM state. After this time, the composite alarm performs its actions. Default: - 1 minute wait period will be set.\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='Description for the alarm. Default: - No description.\n')
    composite_alarm_name: typing.Optional[str] = pydantic.Field(None, description='Name of the alarm. Default: - Automatically generated name.')
    _init_params: typing.ClassVar[list[str]] = ['alarm_rule', 'actions_enabled', 'actions_suppressor', 'actions_suppressor_extension_period', 'actions_suppressor_wait_period', 'alarm_description', 'composite_alarm_name']
    _method_names: typing.ClassVar[list[str]] = ['add_alarm_action', 'add_insufficient_data_action', 'add_ok_action', 'apply_removal_policy', 'render_alarm_rule']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_composite_alarm_arn', 'from_composite_alarm_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CompositeAlarm'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_composite_alarm_arn', 'from_composite_alarm_name']
    ...


    from_composite_alarm_arn: typing.Optional[models.aws_cloudwatch.CompositeAlarmDefFromCompositeAlarmArnParams] = pydantic.Field(None, description='Import an existing CloudWatch composite alarm provided an ARN.')
    from_composite_alarm_name: typing.Optional[models.aws_cloudwatch.CompositeAlarmDefFromCompositeAlarmNameParams] = pydantic.Field(None, description='Import an existing CloudWatch composite alarm provided an Name.')
    resource_config: typing.Optional[models.aws_cloudwatch.CompositeAlarmDefConfig] = pydantic.Field(None)


class CompositeAlarmDefConfig(pydantic.BaseModel):
    add_alarm_action: typing.Optional[list[models.aws_cloudwatch.CompositeAlarmDefAddAlarmActionParams]] = pydantic.Field(None, description='Trigger this action if the alarm fires.\nTypically SnsAction or AutoScalingAction.')
    add_insufficient_data_action: typing.Optional[list[models.aws_cloudwatch.CompositeAlarmDefAddInsufficientDataActionParams]] = pydantic.Field(None, description='Trigger this action if there is insufficient data to evaluate the alarm.\nTypically SnsAction or AutoScalingAction.')
    add_ok_action: typing.Optional[list[models.aws_cloudwatch.CompositeAlarmDefAddOkActionParams]] = pydantic.Field(None, description='Trigger this action if the alarm returns from breaching state into ok state.\nTypically SnsAction or AutoScalingAction.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    render_alarm_rule: typing.Optional[bool] = pydantic.Field(None, description='AlarmRule indicating ALARM state for Alarm.')

class CompositeAlarmDefAddAlarmActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class CompositeAlarmDefAddInsufficientDataActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class CompositeAlarmDefAddOkActionParams(pydantic.BaseModel):
    actions: list[typing.Union[models.aws_cloudwatch_actions.ApplicationScalingActionDef, models.aws_cloudwatch_actions.AutoScalingActionDef, models.aws_cloudwatch_actions.Ec2ActionDef, models.aws_cloudwatch_actions.SnsActionDef, models.aws_cloudwatch_actions.SsmActionDef, models.aws_cloudwatch_actions.SsmIncidentActionDef]] = pydantic.Field(...)
    ...

class CompositeAlarmDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class CompositeAlarmDefFromCompositeAlarmArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    composite_alarm_arn: str = pydantic.Field(..., description='Composite Alarm ARN (i.e. arn:aws:cloudwatch:::alarm:CompositeAlarmName).')
    ...

class CompositeAlarmDefFromCompositeAlarmNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    composite_alarm_name: str = pydantic.Field(..., description='Composite Alarm Name.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.Dashboard
class DashboardDef(BaseConstruct):
    dashboard_name: typing.Optional[str] = pydantic.Field(None, description='Name of the dashboard. If set, must only contain alphanumerics, dash (-) and underscore (_) Default: - automatically generated name\n')
    default_interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Interval duration for metrics. You can specify defaultInterval with the relative time(eg. cdk.Duration.days(7)). Both properties ``defaultInterval`` and ``start`` cannot be set at once. Default: When the dashboard loads, the defaultInterval time will be the default time range.\n')
    end: typing.Optional[str] = pydantic.Field(None, description='The end of the time range to use for each widget on the dashboard when the dashboard loads. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.\n')
    period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = pydantic.Field(None, description='Use this field to specify the period for the graphs when the dashboard loads. Specifying ``Auto`` causes the period of all graphs on the dashboard to automatically adapt to the time range of the dashboard. Specifying ``Inherit`` ensures that the period set for each graph is always obeyed. Default: Auto\n')
    start: typing.Optional[str] = pydantic.Field(None, description='The start of the time range to use for each widget on the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Both properties ``defaultInterval`` and ``start`` cannot be set at once. Default: When the dashboard loads, the start time will be the default time range.\n')
    variables: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.DashboardVariableDef]]] = pydantic.Field(None, description='A list of dashboard variables. Default: - No variables\n')
    widgets: typing.Optional[typing.Sequence[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmStatusWidgetDef, models.aws_cloudwatch.AlarmWidgetDef, models.aws_cloudwatch.ColumnDef, models.aws_cloudwatch.ConcreteWidgetDef, models.aws_cloudwatch.CustomWidgetDef, models.aws_cloudwatch.GaugeWidgetDef, models.aws_cloudwatch.GraphWidgetDef, models.aws_cloudwatch.LogQueryWidgetDef, models.aws_cloudwatch.RowDef, models.aws_cloudwatch.SingleValueWidgetDef, models.aws_cloudwatch.SpacerDef, models.aws_cloudwatch.TextWidgetDef]]]] = pydantic.Field(None, description='Initial set of widgets on the dashboard. One array represents a row of widgets. Default: - No widgets')
    _init_params: typing.ClassVar[list[str]] = ['dashboard_name', 'default_interval', 'end', 'period_override', 'start', 'variables', 'widgets']
    _method_names: typing.ClassVar[list[str]] = ['add_variable', 'add_widgets', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Dashboard'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.DashboardDefConfig] = pydantic.Field(None)


class DashboardDefConfig(pydantic.BaseModel):
    add_variable: typing.Optional[list[models.aws_cloudwatch.DashboardDefAddVariableParams]] = pydantic.Field(None, description='Add a variable to the dashboard.')
    add_widgets: typing.Optional[list[models.aws_cloudwatch.DashboardDefAddWidgetsParams]] = pydantic.Field(None, description='Add a widget to the dashboard.\nWidgets given in multiple calls to add() will be laid out stacked on\ntop of each other.\n\nMultiple widgets added in the same call to add() will be laid out next\nto each other.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class DashboardDefAddVariableParams(pydantic.BaseModel):
    variable: typing.Union[models.aws_cloudwatch.DashboardVariableDef] = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_dashboard_variables.html\n')
    ...

class DashboardDefAddWidgetsParams(pydantic.BaseModel):
    widgets: list[typing.Union[models.aws_cloudwatch.AlarmStatusWidgetDef, models.aws_cloudwatch.AlarmWidgetDef, models.aws_cloudwatch.ColumnDef, models.aws_cloudwatch.ConcreteWidgetDef, models.aws_cloudwatch.CustomWidgetDef, models.aws_cloudwatch.GaugeWidgetDef, models.aws_cloudwatch.GraphWidgetDef, models.aws_cloudwatch.LogQueryWidgetDef, models.aws_cloudwatch.RowDef, models.aws_cloudwatch.SingleValueWidgetDef, models.aws_cloudwatch.SpacerDef, models.aws_cloudwatch.TextWidgetDef]] = pydantic.Field(...)
    ...

class DashboardDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.AlarmActionConfig
class AlarmActionConfigDef(BaseStruct):
    alarm_action_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Return the ARN that should be used for a CloudWatch Alarm action.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    alarm_action_config = cloudwatch.AlarmActionConfig(\n        alarm_action_arn="alarmActionArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alarm_action_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.AlarmActionConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.AlarmProps
class AlarmPropsDef(BaseStruct):
    evaluation_periods: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of periods over which data is compared to the specified threshold.\n')
    threshold: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value against which the specified statistic is compared.\n')
    actions_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether the actions for this alarm are enabled. Default: true\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='Description for the alarm. Default: No description\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description='Name of the alarm. Default: Automatically generated name\n')
    comparison_operator: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = pydantic.Field(None, description='Comparison to use to check if metric is breaching. Default: GreaterThanOrEqualToThreshold\n')
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M out of N" alarm. In that case, this value is the M. For more information, see Evaluating an Alarm in the Amazon CloudWatch User Guide. Default: ``evaluationPeriods``\n')
    evaluate_low_sample_count_percentile: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to evaluate the data and potentially change the alarm state if there are too few data points to be statistically significant. Used only for alarms that are based on percentiles. Default: - Not configured.\n')
    treat_missing_data: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = pydantic.Field(None, description='Sets how this alarm is to handle missing data points. Default: TreatMissingData.Missing\n')
    metric: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metric to add the alarm on. Metric objects can be obtained from most resources, or you can construct custom Metric objects by instantiating one.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_cloudwatch as cloudwatch\n\n    # alias: lambda.Alias\n\n    # or add alarms to an existing group\n    # blue_green_alias: lambda.Alias\n\n    alarm = cloudwatch.Alarm(self, "Errors",\n        comparison_operator=cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,\n        threshold=1,\n        evaluation_periods=1,\n        metric=alias.metric_errors()\n    )\n    deployment_group = codedeploy.LambdaDeploymentGroup(self, "BlueGreenDeployment",\n        alias=alias,\n        deployment_config=codedeploy.LambdaDeploymentConfig.LINEAR_10PERCENT_EVERY_1MINUTE,\n        alarms=[alarm\n        ]\n    )\n    deployment_group.add_alarm(cloudwatch.Alarm(self, "BlueGreenErrors",\n        comparison_operator=cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,\n        threshold=1,\n        evaluation_periods=1,\n        metric=blue_green_alias.metric_errors()\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['evaluation_periods', 'threshold', 'actions_enabled', 'alarm_description', 'alarm_name', 'comparison_operator', 'datapoints_to_alarm', 'evaluate_low_sample_count_percentile', 'treat_missing_data', 'metric']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.AlarmProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.AlarmStatusWidgetProps
class AlarmStatusWidgetPropsDef(BaseStruct):
    alarms: typing.Union[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='CloudWatch Alarms to show in widget.\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: 3\n')
    sort_by: typing.Optional[aws_cdk.aws_cloudwatch.AlarmStatusWidgetSortBy] = pydantic.Field(None, description='Specifies how to sort the alarms in the widget. Default: - alphabetical order\n')
    states: typing.Optional[typing.Sequence[aws_cdk.aws_cloudwatch.AlarmState]] = pydantic.Field(None, description='Use this field to filter the list of alarms displayed in the widget to only those alarms currently in the specified states. You can specify one or more alarm states in the value for this field. The alarm states that you can specify are ALARM, INSUFFICIENT_DATA, and OK. If you omit this field or specify an empty array, all the alarms specifed in alarms are displayed. Default: - all the alarms specified in alarms are displayed.\n')
    title: typing.Optional[str] = pydantic.Field(None, description="The title of the widget. Default: 'Alarm Status'\n")
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n\n:exampleMetadata: infused\n\nExample::\n\n    # dashboard: cloudwatch.Dashboard\n    # error_alarm: cloudwatch.Alarm\n\n\n    dashboard.add_widgets(\n        cloudwatch.AlarmStatusWidget(\n            alarms=[error_alarm]\n        ))\n')
    _init_params: typing.ClassVar[list[str]] = ['alarms', 'height', 'sort_by', 'states', 'title', 'width']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.AlarmStatusWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.AlarmWidgetProps
class AlarmWidgetPropsDef(BaseStruct):
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n')
    alarm: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The alarm to show.\n')
    left_y_axis: typing.Union[models.aws_cloudwatch.YAxisPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Left Y axis. Default: - No minimum or maximum values for the left Y-axis\n\n:exampleMetadata: infused\n\nExample::\n\n    # dashboard: cloudwatch.Dashboard\n    # error_alarm: cloudwatch.Alarm\n\n\n    dashboard.add_widgets(cloudwatch.AlarmWidget(\n        title="Errors",\n        alarm=error_alarm\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['height', 'region', 'title', 'width', 'alarm', 'left_y_axis']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.AlarmWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAlarm.DimensionProperty
class CfnAlarm_DimensionPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the dimension, from 1–255 characters in length. This dimension name must have been included when the metric was published.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value for the dimension, from 1–255 characters in length.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-alarm-dimension.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    dimension_property = cloudwatch.CfnAlarm.DimensionProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAlarm.DimensionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAlarm.MetricDataQueryProperty
class CfnAlarm_MetricDataQueryPropertyDef(BaseStruct):
    account_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the account where the metrics are located, if this is a cross-account alarm.\n')
    expression: typing.Optional[str] = pydantic.Field(None, description='The math expression to be performed on the returned data, if this object is performing a math expression. This expression can use the ``Id`` of the other metrics to refer to those metrics, and can also use the ``Id`` of other expressions to use the result of those expressions. For more information about metric math expressions, see `Metric Math Syntax and Functions <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax>`_ in the *Amazon CloudWatch User Guide* . Within each MetricDataQuery object, you must specify either ``Expression`` or ``MetricStat`` but not both.\n')
    label: typing.Optional[str] = pydantic.Field(None, description='A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents. If the metric or expression is shown in a CloudWatch dashboard widget, the label is shown. If ``Label`` is omitted, CloudWatch generates a default.\n')
    metric_stat: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_MetricStatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data. Within one MetricDataQuery object, you must specify either ``Expression`` or ``MetricStat`` but not both.\n')
    period: typing.Union[int, float, None] = pydantic.Field(None, description='The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a ``PutMetricData`` operation that includes a ``StorageResolution of 1 second`` .\n')
    return_data: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='This option indicates whether to return the timestamps and raw data values of this metric. When you create an alarm based on a metric math expression, specify ``True`` for this value for only the one math expression that the alarm is based on. You must specify ``False`` for ``ReturnData`` for all the other metrics and expressions used in the alarm. This field is required.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-alarm-metricdataquery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_data_query_property = cloudwatch.CfnAlarm.MetricDataQueryProperty(\n        id="id",\n\n        # the properties below are optional\n        account_id="accountId",\n        expression="expression",\n        label="label",\n        metric_stat=cloudwatch.CfnAlarm.MetricStatProperty(\n            metric=cloudwatch.CfnAlarm.MetricProperty(\n                dimensions=[cloudwatch.CfnAlarm.DimensionProperty(\n                    name="name",\n                    value="value"\n                )],\n                metric_name="metricName",\n                namespace="namespace"\n            ),\n            period=123,\n            stat="stat",\n\n            # the properties below are optional\n            unit="unit"\n        ),\n        period=123,\n        return_data=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'expression', 'label', 'metric_stat', 'period', 'return_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAlarm.MetricDataQueryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAlarm.MetricProperty
class CfnAlarm_MetricPropertyDef(BaseStruct):
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The metric dimensions that you want to be used for the metric that the alarm will watch.\n')
    metric_name: typing.Optional[str] = pydantic.Field(None, description='The name of the metric that you want the alarm to watch. This is a required field.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the metric that the alarm will watch.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-alarm-metric.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_property = cloudwatch.CfnAlarm.MetricProperty(\n        dimensions=[cloudwatch.CfnAlarm.DimensionProperty(\n            name="name",\n            value="value"\n        )],\n        metric_name="metricName",\n        namespace="namespace"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dimensions', 'metric_name', 'namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAlarm.MetricProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAlarm.MetricStatProperty
class CfnAlarm_MetricStatPropertyDef(BaseStruct):
    metric: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_MetricPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metric to return, including the metric name, namespace, and dimensions.\n')
    period: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a ``PutMetricData`` call that includes a ``StorageResolution`` of 1 second. If the ``StartTime`` parameter specifies a time stamp that is greater than 3 hours ago, you must specify the period as follows or no data points in that time range is returned: - Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute). - Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes). - Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).\n')
    stat: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The statistic to return. It can include any CloudWatch statistic or extended statistic. For a list of valid values, see the table in `Statistics <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Statistic>`_ in the *Amazon CloudWatch User Guide* .\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='The unit to use for the returned data points. Valid values are: Seconds, Microseconds, Milliseconds, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Bits, Kilobits, Megabits, Gigabits, Terabits, Percent, Count, Bytes/Second, Kilobytes/Second, Megabytes/Second, Gigabytes/Second, Terabytes/Second, Bits/Second, Kilobits/Second, Megabits/Second, Gigabits/Second, Terabits/Second, Count/Second, or None.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-alarm-metricstat.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_stat_property = cloudwatch.CfnAlarm.MetricStatProperty(\n        metric=cloudwatch.CfnAlarm.MetricProperty(\n            dimensions=[cloudwatch.CfnAlarm.DimensionProperty(\n                name="name",\n                value="value"\n            )],\n            metric_name="metricName",\n            namespace="namespace"\n        ),\n        period=123,\n        stat="stat",\n\n        # the properties below are optional\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric', 'period', 'stat', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAlarm.MetricStatProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector.ConfigurationProperty
class CfnAnomalyDetector_ConfigurationPropertyDef(BaseStruct):
    excluded_time_ranges: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_RangePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Specifies an array of time ranges to exclude from use when the anomaly detection model is trained and updated. Use this to make sure that events that could cause unusual values for the metric, such as deployments, aren't used when CloudWatch creates or updates the model.\n")
    metric_time_zone: typing.Optional[str] = pydantic.Field(None, description='The time zone to use for the metric. This is useful to enable the model to automatically account for daylight savings time changes if the metric is sensitive to such time changes. To specify a time zone, use the name of the time zone as specified in the standard tz database. For more information, see `tz database <https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Tz_database>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-anomalydetector-configuration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    configuration_property = cloudwatch.CfnAnomalyDetector.ConfigurationProperty(\n        excluded_time_ranges=[cloudwatch.CfnAnomalyDetector.RangeProperty(\n            end_time="endTime",\n            start_time="startTime"\n        )],\n        metric_time_zone="metricTimeZone"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['excluded_time_ranges', 'metric_time_zone']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector.ConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector.DimensionProperty
class CfnAnomalyDetector_DimensionPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the dimension.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the dimension. Dimension values must contain only ASCII characters and must include at least one non-whitespace character. ASCII control characters are not supported as part of dimension values.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-anomalydetector-dimension.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    dimension_property = cloudwatch.CfnAnomalyDetector.DimensionProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector.DimensionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector.MetricDataQueryProperty
class CfnAnomalyDetector_MetricDataQueryPropertyDef(BaseStruct):
    account_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the account where the metrics are located. If you are performing a ``GetMetricData`` operation in a monitoring account, use this to specify which account to retrieve this metric from. If you are performing a ``PutMetricAlarm`` operation, use this to specify which account contains the metric that the alarm is watching.\n')
    expression: typing.Optional[str] = pydantic.Field(None, description='This field can contain either a Metrics Insights query, or a metric math expression to be performed on the returned data. For more information about Metrics Insights queries, see `Metrics Insights query components and syntax <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch-metrics-insights-querylanguage>`_ in the *Amazon CloudWatch User Guide* . A math expression can use the ``Id`` of the other metrics or queries to refer to those metrics, and can also use the ``Id`` of other expressions to use the result of those expressions. For more information about metric math expressions, see `Metric Math Syntax and Functions <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax>`_ in the *Amazon CloudWatch User Guide* . Within each MetricDataQuery object, you must specify either ``Expression`` or ``MetricStat`` but not both.\n')
    label: typing.Optional[str] = pydantic.Field(None, description='A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents. If the metric or expression is shown in a CloudWatch dashboard widget, the label is shown. If Label is omitted, CloudWatch generates a default. You can put dynamic expressions into a label, so that it is more descriptive. For more information, see `Using Dynamic Labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ .\n')
    metric_stat: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_MetricStatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data. Within one MetricDataQuery object, you must specify either ``Expression`` or ``MetricStat`` but not both.\n')
    period: typing.Union[int, float, None] = pydantic.Field(None, description='The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a ``PutMetricData`` operation that includes a ``StorageResolution of 1 second`` .\n')
    return_data: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='When used in ``GetMetricData`` , this option indicates whether to return the timestamps and raw data values of this metric. If you are performing this call just to do math expressions and do not also need the raw data returned, you can specify ``false`` . If you omit this, the default of ``true`` is used. When used in ``PutMetricAlarm`` , specify ``true`` for the one expression result to use as the alarm. For all other metrics and expressions in the same ``PutMetricAlarm`` operation, specify ``ReturnData`` as False.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-anomalydetector-metricdataquery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_data_query_property = cloudwatch.CfnAnomalyDetector.MetricDataQueryProperty(\n        id="id",\n\n        # the properties below are optional\n        account_id="accountId",\n        expression="expression",\n        label="label",\n        metric_stat=cloudwatch.CfnAnomalyDetector.MetricStatProperty(\n            metric=cloudwatch.CfnAnomalyDetector.MetricProperty(\n                metric_name="metricName",\n                namespace="namespace",\n\n                # the properties below are optional\n                dimensions=[cloudwatch.CfnAnomalyDetector.DimensionProperty(\n                    name="name",\n                    value="value"\n                )]\n            ),\n            period=123,\n            stat="stat",\n\n            # the properties below are optional\n            unit="unit"\n        ),\n        period=123,\n        return_data=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'expression', 'label', 'metric_stat', 'period', 'return_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector.MetricDataQueryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector.MetricMathAnomalyDetectorProperty
class CfnAnomalyDetector_MetricMathAnomalyDetectorPropertyDef(BaseStruct):
    metric_data_queries: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_MetricDataQueryPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of metric data query structures that enables you to create an anomaly detector based on the result of a metric math expression. Each item in ``MetricDataQueries`` gets a metric or performs a math expression. One item in ``MetricDataQueries`` is the expression that provides the time series that the anomaly detector uses as input. Designate the expression by setting ``ReturnData`` to ``true`` for this object in the array. For all other expressions and metrics, set ``ReturnData`` to ``false`` . The designated expression must return a single time series.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-anomalydetector-metricmathanomalydetector.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_math_anomaly_detector_property = cloudwatch.CfnAnomalyDetector.MetricMathAnomalyDetectorProperty(\n        metric_data_queries=[cloudwatch.CfnAnomalyDetector.MetricDataQueryProperty(\n            id="id",\n\n            # the properties below are optional\n            account_id="accountId",\n            expression="expression",\n            label="label",\n            metric_stat=cloudwatch.CfnAnomalyDetector.MetricStatProperty(\n                metric=cloudwatch.CfnAnomalyDetector.MetricProperty(\n                    metric_name="metricName",\n                    namespace="namespace",\n\n                    # the properties below are optional\n                    dimensions=[cloudwatch.CfnAnomalyDetector.DimensionProperty(\n                        name="name",\n                        value="value"\n                    )]\n                ),\n                period=123,\n                stat="stat",\n\n                # the properties below are optional\n                unit="unit"\n            ),\n            period=123,\n            return_data=False\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric_data_queries']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector.MetricMathAnomalyDetectorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector.MetricProperty
class CfnAnomalyDetector_MetricPropertyDef(BaseStruct):
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the metric. This is a required field.\n')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The namespace of the metric.\n')
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The dimensions for the metric.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-anomalydetector-metric.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_property = cloudwatch.CfnAnomalyDetector.MetricProperty(\n        metric_name="metricName",\n        namespace="namespace",\n\n        # the properties below are optional\n        dimensions=[cloudwatch.CfnAnomalyDetector.DimensionProperty(\n            name="name",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric_name', 'namespace', 'dimensions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector.MetricProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector.MetricStatProperty
class CfnAnomalyDetector_MetricStatPropertyDef(BaseStruct):
    metric: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_MetricPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metric to return, including the metric name, namespace, and dimensions.\n')
    period: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a ``PutMetricData`` call that includes a ``StorageResolution`` of 1 second. If the ``StartTime`` parameter specifies a time stamp that is greater than 3 hours ago, you must specify the period as follows or no data points in that time range is returned: - Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute). - Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes). - Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).\n')
    stat: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The statistic to return. It can include any CloudWatch statistic or extended statistic.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='When you are using a ``Put`` operation, this defines what unit you want to use when storing the metric. In a ``Get`` operation, if you omit ``Unit`` then all data that was collected with any unit is returned, along with the corresponding units that were specified when the data was reported to CloudWatch. If you specify a unit, the operation returns only data that was collected with that unit specified. If you specify a unit that does not match the data collected, the results of the operation are null. CloudWatch does not perform unit conversions.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-anomalydetector-metricstat.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_stat_property = cloudwatch.CfnAnomalyDetector.MetricStatProperty(\n        metric=cloudwatch.CfnAnomalyDetector.MetricProperty(\n            metric_name="metricName",\n            namespace="namespace",\n\n            # the properties below are optional\n            dimensions=[cloudwatch.CfnAnomalyDetector.DimensionProperty(\n                name="name",\n                value="value"\n            )]\n        ),\n        period=123,\n        stat="stat",\n\n        # the properties below are optional\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric', 'period', 'stat', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector.MetricStatProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector.RangeProperty
class CfnAnomalyDetector_RangePropertyDef(BaseStruct):
    end_time: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The end time of the range to exclude. The format is ``yyyy-MM-dd'T'HH:mm:ss`` . For example, ``2019-07-01T23:59:59`` .\n")
    start_time: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The start time of the range to exclude. The format is ``yyyy-MM-dd\'T\'HH:mm:ss`` . For example, ``2019-07-01T23:59:59`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-anomalydetector-range.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    range_property = cloudwatch.CfnAnomalyDetector.RangeProperty(\n        end_time="endTime",\n        start_time="startTime"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['end_time', 'start_time']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector.RangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector.SingleMetricAnomalyDetectorProperty
class CfnAnomalyDetector_SingleMetricAnomalyDetectorPropertyDef(BaseStruct):
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The metric dimensions to create the anomaly detection model for.\n')
    metric_name: typing.Optional[str] = pydantic.Field(None, description='The name of the metric to create the anomaly detection model for.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the metric to create the anomaly detection model for.\n')
    stat: typing.Optional[str] = pydantic.Field(None, description='The statistic to use for the metric and anomaly detection model.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-anomalydetector-singlemetricanomalydetector.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    single_metric_anomaly_detector_property = cloudwatch.CfnAnomalyDetector.SingleMetricAnomalyDetectorProperty(\n        dimensions=[cloudwatch.CfnAnomalyDetector.DimensionProperty(\n            name="name",\n            value="value"\n        )],\n        metric_name="metricName",\n        namespace="namespace",\n        stat="stat"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dimensions', 'metric_name', 'namespace', 'stat']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector.SingleMetricAnomalyDetectorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnMetricStream.MetricStreamFilterProperty
class CfnMetricStream_MetricStreamFilterPropertyDef(BaseStruct):
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the metric namespace in the filter. The namespace can contain only ASCII printable characters (ASCII range 32 through 126). It must contain at least one non-whitespace character.\n')
    metric_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The names of the metrics to either include or exclude from the metric stream. If you omit this parameter, all metrics in the namespace are included or excluded, depending on whether this filter is specified as an exclude filter or an include filter. Each metric name can contain only ASCII printable characters (ASCII range 32 through 126). Each metric name must contain at least one non-whitespace character.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-metricstream-metricstreamfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_stream_filter_property = cloudwatch.CfnMetricStream.MetricStreamFilterProperty(\n        namespace="namespace",\n\n        # the properties below are optional\n        metric_names=["metricNames"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace', 'metric_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnMetricStream.MetricStreamFilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnMetricStream.MetricStreamStatisticsConfigurationProperty
class CfnMetricStream_MetricStreamStatisticsConfigurationPropertyDef(BaseStruct):
    additional_statistics: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The additional statistics to stream for the metrics listed in ``IncludeMetrics`` .\n')
    include_metrics: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnMetricStream_MetricStreamStatisticsMetricPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='An array that defines the metrics that are to have additional statistics streamed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-metricstream-metricstreamstatisticsconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_stream_statistics_configuration_property = cloudwatch.CfnMetricStream.MetricStreamStatisticsConfigurationProperty(\n        additional_statistics=["additionalStatistics"],\n        include_metrics=[cloudwatch.CfnMetricStream.MetricStreamStatisticsMetricProperty(\n            metric_name="metricName",\n            namespace="namespace"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['additional_statistics', 'include_metrics']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnMetricStream.MetricStreamStatisticsConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnMetricStream.MetricStreamStatisticsMetricProperty
class CfnMetricStream_MetricStreamStatisticsMetricPropertyDef(BaseStruct):
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the metric.\n')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The namespace of the metric.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-metricstream-metricstreamstatisticsmetric.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_stream_statistics_metric_property = cloudwatch.CfnMetricStream.MetricStreamStatisticsMetricProperty(\n        metric_name="metricName",\n        namespace="namespace"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric_name', 'namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnMetricStream.MetricStreamStatisticsMetricProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CommonMetricOptions
class CommonMetricOptionsDef(BaseStruct):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    common_metric_options = cloudwatch.CommonMetricOptions(\n        account="account",\n        color="color",\n        dimensions_map={\n            "dimensions_map_key": "dimensionsMap"\n        },\n        label="label",\n        period=cdk.Duration.minutes(30),\n        region="region",\n        statistic="statistic",\n        unit=cloudwatch.Unit.SECONDS\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'color', 'dimensions_map', 'label', 'period', 'region', 'statistic', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CommonMetricOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CompositeAlarmProps
class CompositeAlarmPropsDef(BaseStruct):
    alarm_rule: typing.Union[models.UnsupportedResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="Expression that specifies which other alarms are to be evaluated to determine this composite alarm's state.\n")
    actions_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether the actions for this alarm are enabled. Default: true\n')
    actions_suppressor: typing.Optional[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]] = pydantic.Field(None, description='Actions will be suppressed if the suppressor alarm is in the ALARM state. Default: - alarm will not be suppressed.\n')
    actions_suppressor_extension_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum duration that the composite alarm waits after suppressor alarm goes out of the ALARM state. After this time, the composite alarm performs its actions. Default: - 1 minute extension period will be set.\n')
    actions_suppressor_wait_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum duration that the composite alarm waits for the suppressor alarm to go into the ALARM state. After this time, the composite alarm performs its actions. Default: - 1 minute wait period will be set.\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='Description for the alarm. Default: - No description.\n')
    composite_alarm_name: typing.Optional[str] = pydantic.Field(None, description='Name of the alarm. Default: - Automatically generated name.\n\n:exampleMetadata: infused\n\nExample::\n\n    # alarm1: cloudwatch.Alarm\n    # alarm2: cloudwatch.Alarm\n    # alarm3: cloudwatch.Alarm\n    # alarm4: cloudwatch.Alarm\n\n\n    alarm_rule = cloudwatch.AlarmRule.any_of(\n        cloudwatch.AlarmRule.all_of(\n            cloudwatch.AlarmRule.any_of(alarm1,\n                cloudwatch.AlarmRule.from_alarm(alarm2, cloudwatch.AlarmState.OK), alarm3),\n            cloudwatch.AlarmRule.not(cloudwatch.AlarmRule.from_alarm(alarm4, cloudwatch.AlarmState.INSUFFICIENT_DATA))),\n        cloudwatch.AlarmRule.from_boolean(False))\n\n    cloudwatch.CompositeAlarm(self, "MyAwesomeCompositeAlarm",\n        alarm_rule=alarm_rule\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alarm_rule', 'actions_enabled', 'actions_suppressor', 'actions_suppressor_extension_period', 'actions_suppressor_wait_period', 'alarm_description', 'composite_alarm_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CompositeAlarmProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CreateAlarmOptions
class CreateAlarmOptionsDef(BaseStruct):
    evaluation_periods: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of periods over which data is compared to the specified threshold.\n')
    threshold: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value against which the specified statistic is compared.\n')
    actions_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether the actions for this alarm are enabled. Default: true\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='Description for the alarm. Default: No description\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description='Name of the alarm. Default: Automatically generated name\n')
    comparison_operator: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = pydantic.Field(None, description='Comparison to use to check if metric is breaching. Default: GreaterThanOrEqualToThreshold\n')
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M out of N" alarm. In that case, this value is the M. For more information, see Evaluating an Alarm in the Amazon CloudWatch User Guide. Default: ``evaluationPeriods``\n')
    evaluate_low_sample_count_percentile: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to evaluate the data and potentially change the alarm state if there are too few data points to be statistically significant. Used only for alarms that are based on percentiles. Default: - Not configured.\n')
    treat_missing_data: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = pydantic.Field(None, description='Sets how this alarm is to handle missing data points. Default: TreatMissingData.Missing\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_cloudwatch as cloudwatch\n\n    # my_hosted_zone: route53.HostedZone\n\n    certificate = acm.Certificate(self, "Certificate",\n        domain_name="hello.example.com",\n        validation=acm.CertificateValidation.from_dns(my_hosted_zone)\n    )\n    certificate.metric_days_to_expiry().create_alarm(self, "Alarm",\n        comparison_operator=cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,\n        evaluation_periods=1,\n        threshold=45\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['evaluation_periods', 'threshold', 'actions_enabled', 'alarm_description', 'alarm_name', 'comparison_operator', 'datapoints_to_alarm', 'evaluate_low_sample_count_percentile', 'treat_missing_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CreateAlarmOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CustomWidgetProps
class CustomWidgetPropsDef(BaseStruct):
    function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Arn of the AWS Lambda function that returns HTML or JSON that will be displayed in the widget.\n')
    title: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The title of the widget.\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    params: typing.Any = pydantic.Field(None, description='Parameters passed to the lambda function. Default: - no parameters are passed to the lambda function\n')
    update_on_refresh: typing.Optional[bool] = pydantic.Field(None, description='Update the widget on refresh. Default: true\n')
    update_on_resize: typing.Optional[bool] = pydantic.Field(None, description='Update the widget on resize. Default: true\n')
    update_on_time_range_change: typing.Optional[bool] = pydantic.Field(None, description='Update the widget on time range change. Default: true\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n\n:exampleMetadata: infused\n\nExample::\n\n    # dashboard: cloudwatch.Dashboard\n\n\n    # Import or create a lambda function\n    fn = lambda_.Function.from_function_arn(dashboard, "Function", "arn:aws:lambda:us-east-1:123456789012:function:MyFn")\n\n    dashboard.add_widgets(cloudwatch.CustomWidget(\n        function_arn=fn.function_arn,\n        title="My lambda baked widget"\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['function_arn', 'title', 'height', 'params', 'update_on_refresh', 'update_on_resize', 'update_on_time_range_change', 'width']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CustomWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.DashboardProps
class DashboardPropsDef(BaseStruct):
    dashboard_name: typing.Optional[str] = pydantic.Field(None, description='Name of the dashboard. If set, must only contain alphanumerics, dash (-) and underscore (_) Default: - automatically generated name\n')
    default_interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Interval duration for metrics. You can specify defaultInterval with the relative time(eg. cdk.Duration.days(7)). Both properties ``defaultInterval`` and ``start`` cannot be set at once. Default: When the dashboard loads, the defaultInterval time will be the default time range.\n')
    end: typing.Optional[str] = pydantic.Field(None, description='The end of the time range to use for each widget on the dashboard when the dashboard loads. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.\n')
    period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = pydantic.Field(None, description='Use this field to specify the period for the graphs when the dashboard loads. Specifying ``Auto`` causes the period of all graphs on the dashboard to automatically adapt to the time range of the dashboard. Specifying ``Inherit`` ensures that the period set for each graph is always obeyed. Default: Auto\n')
    start: typing.Optional[str] = pydantic.Field(None, description='The start of the time range to use for each widget on the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Both properties ``defaultInterval`` and ``start`` cannot be set at once. Default: When the dashboard loads, the start time will be the default time range.\n')
    variables: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.DashboardVariableDef]]] = pydantic.Field(None, description='A list of dashboard variables. Default: - No variables\n')
    widgets: typing.Optional[typing.Sequence[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmStatusWidgetDef, models.aws_cloudwatch.AlarmWidgetDef, models.aws_cloudwatch.ColumnDef, models.aws_cloudwatch.ConcreteWidgetDef, models.aws_cloudwatch.CustomWidgetDef, models.aws_cloudwatch.GaugeWidgetDef, models.aws_cloudwatch.GraphWidgetDef, models.aws_cloudwatch.LogQueryWidgetDef, models.aws_cloudwatch.RowDef, models.aws_cloudwatch.SingleValueWidgetDef, models.aws_cloudwatch.SpacerDef, models.aws_cloudwatch.TextWidgetDef]]]] = pydantic.Field(None, description='Initial set of widgets on the dashboard. One array represents a row of widgets. Default: - No widgets\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_cloudwatch as cw\n\n\n    dashboard = cw.Dashboard(self, "Dash",\n        default_interval=Duration.days(7),\n        variables=[cw.DashboardVariable(\n            id="region2",\n            type=cw.VariableType.PATTERN,\n            label="RegionPattern",\n            input_type=cw.VariableInputType.INPUT,\n            value="us-east-1",\n            default_value=cw.DefaultValue.value("us-east-1"),\n            visible=True\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dashboard_name', 'default_interval', 'end', 'period_override', 'start', 'variables', 'widgets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.DashboardProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.DashboardVariableOptions
class DashboardVariableOptionsDef(BaseStruct):
    input_type: typing.Union[aws_cdk.aws_cloudwatch.VariableInputType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The way the variable value is selected.\n')
    type: typing.Union[aws_cdk.aws_cloudwatch.VariableType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Type of the variable.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Pattern or property value to replace.\n')
    default_value: typing.Optional[models.aws_cloudwatch.DefaultValueDef] = pydantic.Field(None, description='Optional default value. Default: - no default value is set\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Optional label in the toolbar. Default: - the variable's value\n")
    values: typing.Optional[models.aws_cloudwatch.ValuesDef] = pydantic.Field(None, description='Optional values (required for {@link VariableInputType.RADIO} and {@link VariableInputType.SELECT} dashboard variables). Default: - no values\n')
    visible: typing.Optional[bool] = pydantic.Field(None, description='Whether the variable is visible. Default: - true\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_cloudwatch as cw\n\n\n    dashboard = cw.Dashboard(self, "Dash",\n        default_interval=Duration.days(7),\n        variables=[cw.DashboardVariable(\n            id="functionName",\n            type=cw.VariableType.PATTERN,\n            label="Function",\n            input_type=cw.VariableInputType.RADIO,\n            value="originalFuncNameInDashboard",\n            # equivalent to cw.Values.fromSearch(\'{AWS/Lambda,FunctionName} MetricName="Duration"\', \'FunctionName\')\n            values=cw.Values.from_search_components(\n                namespace="AWS/Lambda",\n                dimensions=["FunctionName"],\n                metric_name="Duration",\n                populate_from="FunctionName"\n            ),\n            default_value=cw.DefaultValue.FIRST,\n            visible=True\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input_type', 'type', 'value', 'default_value', 'label', 'values', 'visible']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.DashboardVariableOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.Dimension
class DimensionDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the dimension.\n')
    value: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Value of the dimension.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cw-dimension.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    # value: Any\n\n    dimension = cloudwatch.Dimension(\n        name="name",\n        value=value\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.Dimension'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.GaugeWidgetProps
class GaugeWidgetPropsDef(BaseStruct):
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n')
    annotations: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.HorizontalAnnotationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Annotations for the left Y axis. Default: - No annotations\n')
    end: typing.Optional[str] = pydantic.Field(None, description='The end of the time range to use for each widget independently from those of the dashboard. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.\n')
    left_y_axis: typing.Union[models.aws_cloudwatch.YAxisPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Left Y axis. Default: - None\n')
    legend_position: typing.Optional[aws_cdk.aws_cloudwatch.LegendPosition] = pydantic.Field(None, description='Position of the legend. Default: - bottom\n')
    live_data: typing.Optional[bool] = pydantic.Field(None, description='Whether the graph should show live data. Default: false\n')
    metrics: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]]] = pydantic.Field(None, description='Metrics to display on left Y axis. Default: - No metrics\n')
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The default period for all metrics in this widget. The period is the length of time represented by one data point on the graph. This default can be overridden within each metric definition. Default: cdk.Duration.seconds(300)\n')
    set_period_to_time_range: typing.Optional[bool] = pydantic.Field(None, description='Whether to show the value from the entire time range. Only applicable for Bar and Pie charts. If false, values will be from the most recent period of your chosen time range; if true, shows the value from the entire time range. Default: false\n')
    start: typing.Optional[str] = pydantic.Field(None, description='The start of the time range to use for each widget independently from those of the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='The default statistic to be displayed for each metric. This default can be overridden within the definition of each individual metric Default: - The statistic for each metric is used\n\n:exampleMetadata: infused\n\nExample::\n\n    # dashboard: cloudwatch.Dashboard\n    # error_alarm: cloudwatch.Alarm\n    # gauge_metric: cloudwatch.Metric\n\n\n    dashboard.add_widgets(cloudwatch.GaugeWidget(\n        metrics=[gauge_metric],\n        left_yAxis=cloudwatch.YAxisProps(\n            min=0,\n            max=1000\n        )\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['height', 'region', 'title', 'width', 'annotations', 'end', 'left_y_axis', 'legend_position', 'live_data', 'metrics', 'period', 'set_period_to_time_range', 'start', 'statistic']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.GaugeWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.GraphWidgetProps
class GraphWidgetPropsDef(BaseStruct):
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n')
    end: typing.Optional[str] = pydantic.Field(None, description='The end of the time range to use for each widget independently from those of the dashboard. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.\n')
    left: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]]] = pydantic.Field(None, description='Metrics to display on left Y axis. Default: - No metrics\n')
    left_annotations: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.HorizontalAnnotationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Annotations for the left Y axis. Default: - No annotations\n')
    left_y_axis: typing.Union[models.aws_cloudwatch.YAxisPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Left Y axis. Default: - None\n')
    legend_position: typing.Optional[aws_cdk.aws_cloudwatch.LegendPosition] = pydantic.Field(None, description='Position of the legend. Default: - bottom\n')
    live_data: typing.Optional[bool] = pydantic.Field(None, description='Whether the graph should show live data. Default: false\n')
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The default period for all metrics in this widget. The period is the length of time represented by one data point on the graph. This default can be overridden within each metric definition. Default: cdk.Duration.seconds(300)\n')
    right: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]]] = pydantic.Field(None, description='Metrics to display on right Y axis. Default: - No metrics\n')
    right_annotations: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.HorizontalAnnotationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Annotations for the right Y axis. Default: - No annotations\n')
    right_y_axis: typing.Union[models.aws_cloudwatch.YAxisPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Right Y axis. Default: - None\n')
    set_period_to_time_range: typing.Optional[bool] = pydantic.Field(None, description='Whether to show the value from the entire time range. Only applicable for Bar and Pie charts. If false, values will be from the most recent period of your chosen time range; if true, shows the value from the entire time range. Default: false\n')
    stacked: typing.Optional[bool] = pydantic.Field(None, description='Whether the graph should be shown as stacked lines. Default: false\n')
    start: typing.Optional[str] = pydantic.Field(None, description='The start of the time range to use for each widget independently from those of the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='The default statistic to be displayed for each metric. This default can be overridden within the definition of each individual metric Default: - The statistic for each metric is used\n')
    vertical_annotations: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.VerticalAnnotationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Annotations for the X axis. Default: - No annotations\n')
    view: typing.Optional[aws_cdk.aws_cloudwatch.GraphWidgetView] = pydantic.Field(None, description='Display this metric. Default: TimeSeries\n\n:exampleMetadata: infused\n\nExample::\n\n    # dashboard: cloudwatch.Dashboard\n\n\n    dashboard.add_widgets(cloudwatch.GraphWidget(\n        # ...\n\n        legend_position=cloudwatch.LegendPosition.RIGHT\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['height', 'region', 'title', 'width', 'end', 'left', 'left_annotations', 'left_y_axis', 'legend_position', 'live_data', 'period', 'right', 'right_annotations', 'right_y_axis', 'set_period_to_time_range', 'stacked', 'start', 'statistic', 'vertical_annotations', 'view']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.GraphWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.HorizontalAnnotation
class HorizontalAnnotationDef(BaseStruct):
    value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the annotation.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to be used for the annotation. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    fill: typing.Optional[aws_cdk.aws_cloudwatch.Shading] = pydantic.Field(None, description='Add shading above or below the annotation. Default: No shading\n')
    label: typing.Optional[str] = pydantic.Field(None, description='Label for the annotation. Default: - No label\n')
    visible: typing.Optional[bool] = pydantic.Field(None, description='Whether the annotation is visible. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    horizontal_annotation = cloudwatch.HorizontalAnnotation(\n        value=123,\n\n        # the properties below are optional\n        color="color",\n        fill=cloudwatch.Shading.NONE,\n        label="label",\n        visible=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['value', 'color', 'fill', 'label', 'visible']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.HorizontalAnnotation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.LogQueryWidgetProps
class LogQueryWidgetPropsDef(BaseStruct):
    log_group_names: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Names of log groups to query.\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: 6\n')
    query_lines: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A sequence of lines to use to build the query. The query will be built by joining the lines together using ``\\n|``. Default: - Exactly one of ``queryString``, ``queryLines`` is required.\n')
    query_string: typing.Optional[str] = pydantic.Field(None, description='Full query string for log insights. Be sure to prepend every new line with a newline and pipe character (``\\n|``). Default: - Exactly one of ``queryString``, ``queryLines`` is required.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this widget should be taken from. Default: Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the widget. Default: No title\n')
    view: typing.Optional[aws_cdk.aws_cloudwatch.LogQueryVisualizationType] = pydantic.Field(None, description='The type of view to use. Default: LogQueryVisualizationType.TABLE\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n\n        :exampleMetadata: infused\n\n        Example::\n\n            # dashboard: cloudwatch.Dashboard\n\n\n            dashboard.add_widgets(cloudwatch.LogQueryWidget(\n                log_group_names=["my-log-group"],\n                view=cloudwatch.LogQueryVisualizationType.TABLE,\n                # The lines will be automatically combined using \'\n|\'.\n                query_lines=["fields @message", "filter @message like /Error/"\n                ]\n            ))\n')
    _init_params: typing.ClassVar[list[str]] = ['log_group_names', 'height', 'query_lines', 'query_string', 'region', 'title', 'view', 'width']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.LogQueryWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.MathExpressionOptions
class MathExpressionOptionsDef(BaseStruct):
    color: typing.Optional[str] = pydantic.Field(None, description='Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this expression when added to a Graph in a Dashboard. If this expression evaluates to more than one time series (for example, through the use of ``METRICS()`` or ``SEARCH()`` expressions), each time series will appear in the graph using a combination of the expression label and the individual metric label. Specify the empty string (``''``) to suppress the expression label and only keep the metric label. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. If the math expression produces more than one time series, the maximum will be shown for each individual time series produce by this math expression. Default: - Expression value is used as label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)\n")
    search_account: typing.Optional[str] = pydantic.Field(None, description='Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.\n')
    search_region: typing.Optional[str] = pydantic.Field(None, description='Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    math_expression_options = cloudwatch.MathExpressionOptions(\n        color="color",\n        label="label",\n        period=cdk.Duration.minutes(30),\n        search_account="searchAccount",\n        search_region="searchRegion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['color', 'label', 'period', 'search_account', 'search_region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MathExpressionOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.MathExpressionProps
class MathExpressionPropsDef(BaseStruct):
    color: typing.Optional[str] = pydantic.Field(None, description='Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this expression when added to a Graph in a Dashboard. If this expression evaluates to more than one time series (for example, through the use of ``METRICS()`` or ``SEARCH()`` expressions), each time series will appear in the graph using a combination of the expression label and the individual metric label. Specify the empty string (``''``) to suppress the expression label and only keep the metric label. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. If the math expression produces more than one time series, the maximum will be shown for each individual time series produce by this math expression. Default: - Expression value is used as label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)\n")
    search_account: typing.Optional[str] = pydantic.Field(None, description='Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.\n')
    search_region: typing.Optional[str] = pydantic.Field(None, description='Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.\n')
    expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The expression defining the metric. When an expression contains a SEARCH function, it cannot be used within an Alarm.\n')
    using_metrics: typing.Optional[typing.Mapping[str, typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]]] = pydantic.Field(None, description='The metrics used in the expression, in a map. The key is the identifier that represents the given metric in the expression, and the value is the actual Metric object. Default: - Empty map.\n\n:exampleMetadata: infused\n\nExample::\n\n    # fn: lambda.Function\n\n\n    all_problems = cloudwatch.MathExpression(\n        expression="errors + throttles",\n        using_metrics={\n            "errors": fn.metric_errors(),\n            "throttles": fn.metric_throttles()\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['color', 'label', 'period', 'search_account', 'search_region', 'expression', 'using_metrics']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MathExpressionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.MetricConfig
class MetricConfigDef(BaseStruct):
    math_expression: typing.Union[models.aws_cloudwatch.MetricExpressionConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='In case the metric is a math expression, the details of the math expression. Default: - None\n')
    metric_stat: typing.Union[models.aws_cloudwatch.MetricStatConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='In case the metric represents a query, the details of the query. Default: - None\n')
    rendering_properties: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Additional properties which will be rendered if the metric is used in a dashboard. Examples are \'label\' and \'color\', but any key in here will be added to dashboard graphs. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    # metric: cloudwatch.Metric\n    # rendering_properties: Any\n    # value: Any\n\n    metric_config = cloudwatch.MetricConfig(\n        math_expression=cloudwatch.MetricExpressionConfig(\n            expression="expression",\n            period=123,\n            using_metrics={\n                "using_metrics_key": metric\n            },\n\n            # the properties below are optional\n            search_account="searchAccount",\n            search_region="searchRegion"\n        ),\n        metric_stat=cloudwatch.MetricStatConfig(\n            metric_name="metricName",\n            namespace="namespace",\n            period=cdk.Duration.minutes(30),\n            statistic="statistic",\n\n            # the properties below are optional\n            account="account",\n            dimensions=[cloudwatch.Dimension(\n                name="name",\n                value=value\n            )],\n            region="region",\n            unit_filter=cloudwatch.Unit.SECONDS\n        ),\n        rendering_properties={\n            "rendering_properties_key": rendering_properties\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['math_expression', 'metric_stat', 'rendering_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MetricConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.MetricExpressionConfig
class MetricExpressionConfigDef(BaseStruct):
    expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Math expression for the metric.\n')
    period: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='How many seconds to aggregate over.\n')
    using_metrics: typing.Union[typing.Mapping[str, typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Metrics used in the math expression.\n')
    search_account: typing.Optional[str] = pydantic.Field(None, description='Account to evaluate search expressions within. Default: - Deployment account.\n')
    search_region: typing.Optional[str] = pydantic.Field(None, description='Region to evaluate search expressions within. Default: - Deployment region.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    # metric: cloudwatch.Metric\n\n    metric_expression_config = cloudwatch.MetricExpressionConfig(\n        expression="expression",\n        period=123,\n        using_metrics={\n            "using_metrics_key": metric\n        },\n\n        # the properties below are optional\n        search_account="searchAccount",\n        search_region="searchRegion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['expression', 'period', 'using_metrics', 'search_account', 'search_region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MetricExpressionConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.MetricOptions
class MetricOptionsDef(BaseStruct):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_cloudwatch as cloudwatch\n\n    # delivery_stream: firehose.DeliveryStream\n\n\n    # Alarm that triggers when the per-second average of incoming bytes exceeds 90% of the current service limit\n    incoming_bytes_percent_of_limit = cloudwatch.MathExpression(\n        expression="incomingBytes / 300 / bytePerSecLimit",\n        using_metrics={\n            "incoming_bytes": delivery_stream.metric_incoming_bytes(statistic=cloudwatch.Statistic.SUM),\n            "byte_per_sec_limit": delivery_stream.metric("BytesPerSecondLimit")\n        }\n    )\n\n    cloudwatch.Alarm(self, "Alarm",\n        metric=incoming_bytes_percent_of_limit,\n        threshold=0.9,\n        evaluation_periods=3\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'color', 'dimensions_map', 'label', 'period', 'region', 'statistic', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MetricOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.MetricProps
class MetricPropsDef(BaseStruct):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n')
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the metric.\n')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Namespace of the metric.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_cloudwatch as cloudwatch\n\n\n    metric = cloudwatch.Metric(\n        namespace="MyNamespace",\n        metric_name="MyMetric",\n        dimensions_map={"MyDimension": "MyDimensionValue"}\n    )\n    alarm = cloudwatch.Alarm(self, "MyAlarm",\n        metric=metric,\n        threshold=100,\n        evaluation_periods=3,\n        datapoints_to_alarm=2\n    )\n\n    topic_rule = iot.TopicRule(self, "TopicRule",\n        sql=iot.IotSql.from_string_as_ver20160323("SELECT topic(2) as device_id FROM \'device/+/data\'"),\n        actions=[\n            actions.CloudWatchSetAlarmStateAction(alarm,\n                reason="AWS Iot Rule action is triggered",\n                alarm_state_to_set=cloudwatch.AlarmState.ALARM\n            )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'color', 'dimensions_map', 'label', 'period', 'region', 'statistic', 'unit', 'metric_name', 'namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MetricProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.MetricStatConfig
class MetricStatConfigDef(BaseStruct):
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the metric.\n')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Namespace of the metric.\n')
    period: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='How many seconds to aggregate over.\n')
    statistic: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Aggregation function to use (can be either simple or a percentile).\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: Deployment account.\n')
    dimensions: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.DimensionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The dimensions to apply to the alarm. Default: []\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: Deployment region.\n')
    unit_filter: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. This field has been renamed from plain ``unit`` to clearly communicate its purpose. Default: - Refer to all metric datums\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    # value: Any\n\n    metric_stat_config = cloudwatch.MetricStatConfig(\n        metric_name="metricName",\n        namespace="namespace",\n        period=cdk.Duration.minutes(30),\n        statistic="statistic",\n\n        # the properties below are optional\n        account="account",\n        dimensions=[cloudwatch.Dimension(\n            name="name",\n            value=value\n        )],\n        region="region",\n        unit_filter=cloudwatch.Unit.SECONDS\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric_name', 'namespace', 'period', 'statistic', 'account', 'dimensions', 'region', 'unit_filter']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MetricStatConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.MetricStatConfigDefConfig] = pydantic.Field(None)


class MetricStatConfigDefConfig(pydantic.BaseModel):
    period_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_cloudwatch.MetricWidgetProps
class MetricWidgetPropsDef(BaseStruct):
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    metric_widget_props = cloudwatch.MetricWidgetProps(\n        height=123,\n        region="region",\n        title="title",\n        width=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['height', 'region', 'title', 'width']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.MetricWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.SearchComponents
class SearchComponentsDef(BaseStruct):
    dimensions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The list of dimensions to be used in the search expression.\n')
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metric name to be used in the search expression.\n')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The namespace to be used in the search expression.\n')
    populate_from: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The dimension name, that the search expression retrieves, whose values will be used to populate the values to choose from.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_cloudwatch as cw\n\n\n    dashboard = cw.Dashboard(self, "Dash",\n        default_interval=Duration.days(7),\n        variables=[cw.DashboardVariable(\n            id="functionName",\n            type=cw.VariableType.PATTERN,\n            label="Function",\n            input_type=cw.VariableInputType.RADIO,\n            value="originalFuncNameInDashboard",\n            # equivalent to cw.Values.fromSearch(\'{AWS/Lambda,FunctionName} MetricName="Duration"\', \'FunctionName\')\n            values=cw.Values.from_search_components(\n                namespace="AWS/Lambda",\n                dimensions=["FunctionName"],\n                metric_name="Duration",\n                populate_from="FunctionName"\n            ),\n            default_value=cw.DefaultValue.FIRST,\n            visible=True\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dimensions', 'metric_name', 'namespace', 'populate_from']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.SearchComponents'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.SingleValueWidgetProps
class SingleValueWidgetPropsDef(BaseStruct):
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the metrics of this graph should be taken from. Default: - Current region\n')
    title: typing.Optional[str] = pydantic.Field(None, description='Title for the graph. Default: - None\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n')
    metrics: typing.Union[typing.Sequence[typing.Union[models.aws_cloudwatch.MathExpressionDef, models.aws_cloudwatch.MetricDef]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Metrics to display.\n')
    end: typing.Optional[str] = pydantic.Field(None, description='The end of the time range to use for each widget independently from those of the dashboard. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.\n')
    full_precision: typing.Optional[bool] = pydantic.Field(None, description='Whether to show as many digits as can fit, before rounding. Default: false\n')
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The default period for all metrics in this widget. The period is the length of time represented by one data point on the graph. This default can be overridden within each metric definition. Default: cdk.Duration.seconds(300)\n')
    set_period_to_time_range: typing.Optional[bool] = pydantic.Field(None, description='Whether to show the value from the entire time range. Default: false\n')
    sparkline: typing.Optional[bool] = pydantic.Field(None, description='Whether to show a graph below the value illustrating the value for the whole time range. Cannot be used in combination with ``setPeriodToTimeRange`` Default: false\n')
    start: typing.Optional[str] = pydantic.Field(None, description='The start of the time range to use for each widget independently from those of the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.\n\n:exampleMetadata: infused\n\nExample::\n\n    # dashboard: cloudwatch.Dashboard\n\n\n    dashboard.add_widgets(cloudwatch.SingleValueWidget(\n        metrics=[],\n\n        period=Duration.minutes(15)\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['height', 'region', 'title', 'width', 'metrics', 'end', 'full_precision', 'period', 'set_period_to_time_range', 'sparkline', 'start']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.SingleValueWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.SpacerProps
class SpacerPropsDef(BaseStruct):
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the spacer. Default: : 1\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the spacer. Default: 1\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    spacer_props = cloudwatch.SpacerProps(\n        height=123,\n        width=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['height', 'width']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.SpacerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.TextWidgetProps
class TextWidgetPropsDef(BaseStruct):
    markdown: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The text to display, in MarkDown format.\n')
    background: typing.Optional[aws_cdk.aws_cloudwatch.TextWidgetBackground] = pydantic.Field(None, description='Background for the widget. Default: solid\n')
    height: typing.Union[int, float, None] = pydantic.Field(None, description='Height of the widget. Default: 2\n')
    width: typing.Union[int, float, None] = pydantic.Field(None, description='Width of the widget, in a grid of 24 units wide. Default: 6\n\n:exampleMetadata: infused\n\nExample::\n\n    # dashboard: cloudwatch.Dashboard\n\n\n    dashboard.add_widgets(cloudwatch.TextWidget(\n        markdown="# Key Performance Indicators"\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['markdown', 'background', 'height', 'width']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.TextWidgetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.VariableValue
class VariableValueDef(BaseStruct):
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Value of the selected item.')
    label: typing.Optional[str] = pydantic.Field(None, description='Optional label for the selected item. Default: - the variable\'s value\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_cloudwatch as cw\n\n\n    dashboard = cw.Dashboard(self, "Dash",\n        default_interval=Duration.days(7),\n        variables=[cw.DashboardVariable(\n            id="region",\n            type=cw.VariableType.PROPERTY,\n            label="Region",\n            input_type=cw.VariableInputType.RADIO,\n            value="region",\n            values=cw.Values.from_values(cw.VariableValue(label="IAD", value="us-east-1"), label="DUB", value="us-west-2"),\n            default_value=cw.DefaultValue.value("us-east-1"),\n            visible=True\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['value', 'label']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.VariableValue'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.VerticalAnnotation
class VerticalAnnotationDef(BaseStruct):
    date: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The date and time (in ISO 8601 format) in the graph where the vertical annotation line is to appear.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to be used for the annotation. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    fill: typing.Optional[aws_cdk.aws_cloudwatch.VerticalShading] = pydantic.Field(None, description='Add shading before or after the annotation. Default: No shading\n')
    label: typing.Optional[str] = pydantic.Field(None, description='Label for the annotation. Default: - No label\n')
    visible: typing.Optional[bool] = pydantic.Field(None, description='Whether the annotation is visible. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    vertical_annotation = cloudwatch.VerticalAnnotation(\n        date="date",\n\n        # the properties below are optional\n        color="color",\n        fill=cloudwatch.VerticalShading.NONE,\n        label="label",\n        visible=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['date', 'color', 'fill', 'label', 'visible']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.VerticalAnnotation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.YAxisProps
class YAxisPropsDef(BaseStruct):
    label: typing.Optional[str] = pydantic.Field(None, description='The label. Default: - No label\n')
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The max value. Default: - No maximum value\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The min value. Default: 0\n')
    show_units: typing.Optional[bool] = pydantic.Field(None, description='Whether to show units. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # dashboard: cloudwatch.Dashboard\n    # error_alarm: cloudwatch.Alarm\n    # gauge_metric: cloudwatch.Metric\n\n\n    dashboard.add_widgets(cloudwatch.GaugeWidget(\n        metrics=[gauge_metric],\n        left_yAxis=cloudwatch.YAxisProps(\n            min=0,\n            max=1000\n        )\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['label', 'max', 'min', 'show_units']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.YAxisProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.AlarmState
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.AlarmStatusWidgetSortBy
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.ComparisonOperator
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.GraphWidgetView
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.LegendPosition
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.LogQueryVisualizationType
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.PeriodOverride
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.Shading
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.Statistic
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.TextWidgetBackground
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.TreatMissingData
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.Unit
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.VariableInputType
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.VariableType
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.VerticalShading
# skipping emum

#  autogenerated from aws_cdk.aws_cloudwatch.IAlarm
#  skipping Interface

#  autogenerated from aws_cdk.aws_cloudwatch.IAlarmAction
#  skipping Interface

#  autogenerated from aws_cdk.aws_cloudwatch.IAlarmRule
#  skipping Interface

#  autogenerated from aws_cdk.aws_cloudwatch.IMetric
#  skipping Interface

#  autogenerated from aws_cdk.aws_cloudwatch.IVariable
#  skipping Interface

#  autogenerated from aws_cdk.aws_cloudwatch.IWidget
#  skipping Interface

#  autogenerated from aws_cdk.aws_cloudwatch.CfnAlarm
class CfnAlarmDef(BaseCfnResource):
    comparison_operator: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. You can specify the following values: ``GreaterThanThreshold`` , ``GreaterThanOrEqualToThreshold`` , ``LessThanThreshold`` , or ``LessThanOrEqualToThreshold`` .\n')
    evaluation_periods: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of periods over which data is compared to the specified threshold. If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies that number. If you are setting an "M out of N" alarm, this value is the N, and ``DatapointsToAlarm`` is the M. For more information, see `Evaluating an Alarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation>`_ in the *Amazon CloudWatch User Guide* .\n')
    actions_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether actions should be executed during any changes to the alarm state. The default is TRUE. Default: - true\n')
    alarm_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of actions to execute when this alarm transitions into an ALARM state from any other state. Specify each action as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see `PutMetricAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutMetricAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='The description of the alarm.\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description="The name of the alarm. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the alarm name. .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M out of N" alarm. In that case, this value is the M, and the value that you set for ``EvaluationPeriods`` is the N value. For more information, see `Evaluating an Alarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation>`_ in the *Amazon CloudWatch User Guide* . If you omit this parameter, CloudWatch uses the same value here that you set for ``EvaluationPeriods`` , and the alarm goes to alarm state if that many consecutive periods are breaching.\n')
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The dimensions for the metric associated with the alarm. For an alarm based on a math expression, you can't specify ``Dimensions`` . Instead, you use ``Metrics`` .\n")
    evaluate_low_sample_count_percentile: typing.Optional[str] = pydantic.Field(None, description='Used only for alarms based on percentiles. If ``ignore`` , the alarm state does not change during periods with too few data points to be statistically significant. If ``evaluate`` or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available.\n')
    extended_statistic: typing.Optional[str] = pydantic.Field(None, description="The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100. For an alarm based on a metric, you must specify either ``Statistic`` or ``ExtendedStatistic`` but not both. For an alarm based on a math expression, you can't specify ``ExtendedStatistic`` . Instead, you use ``Metrics`` .\n")
    insufficient_data_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the ``INSUFFICIENT_DATA`` state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n')
    metric_name: typing.Optional[str] = pydantic.Field(None, description="The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use ``Metrics`` instead and you can't specify ``MetricName`` .\n")
    metrics: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_MetricDataQueryPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array that enables you to create an alarm based on the result of a metric math expression. Each item in the array either retrieves a metric or performs a math expression. If you specify the ``Metrics`` parameter, you cannot specify ``MetricName`` , ``Dimensions`` , ``Period`` , ``Namespace`` , ``Statistic`` , ``ExtendedStatistic`` , or ``Unit`` .\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify ``Namespace`` and you use ``Metrics`` instead. For a list of namespaces for metrics from AWS services, see `AWS Services That Publish CloudWatch Metrics. <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/aws-services-cloudwatch-metrics.html>`_\n")
    ok_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the ``OK`` state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n')
    period: typing.Union[int, float, None] = pydantic.Field(None, description="The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. Valid values are 10, 30, 60, and any multiple of 60. For an alarm based on a math expression, you can't specify ``Period`` , and instead you use the ``Metrics`` parameter. *Minimum:* 10\n")
    statistic: typing.Optional[str] = pydantic.Field(None, description="The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ``ExtendedStatistic`` . For an alarm based on a metric, you must specify either ``Statistic`` or ``ExtendedStatistic`` but not both. For an alarm based on a math expression, you can't specify ``Statistic`` . Instead, you use ``Metrics`` .\n")
    threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The value to compare with the specified statistic.\n')
    threshold_metric_id: typing.Optional[str] = pydantic.Field(None, description='In an alarm based on an anomaly detection model, this is the ID of the ``ANOMALY_DETECTION_BAND`` function used as the threshold for the alarm.\n')
    treat_missing_data: typing.Optional[str] = pydantic.Field(None, description='Sets how this alarm is to handle missing data points. Valid values are ``breaching`` , ``notBreaching`` , ``ignore`` , and ``missing`` . For more information, see `Configuring How CloudWatch Alarms Treat Missing Data <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-and-missing-data>`_ in the *Amazon CloudWatch User Guide* . If you omit this parameter, the default behavior of ``missing`` is used.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='The unit of the metric associated with the alarm. Specify this only if you are creating an alarm based on a single metric. Do not specify this if you are specifying a ``Metrics`` array. You can specify the following values: Seconds, Microseconds, Milliseconds, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Bits, Kilobits, Megabits, Gigabits, Terabits, Percent, Count, Bytes/Second, Kilobytes/Second, Megabytes/Second, Gigabytes/Second, Terabytes/Second, Bits/Second, Kilobits/Second, Megabits/Second, Gigabits/Second, Terabits/Second, Count/Second, or None.')
    _init_params: typing.ClassVar[list[str]] = ['comparison_operator', 'evaluation_periods', 'actions_enabled', 'alarm_actions', 'alarm_description', 'alarm_name', 'datapoints_to_alarm', 'dimensions', 'evaluate_low_sample_count_percentile', 'extended_statistic', 'insufficient_data_actions', 'metric_name', 'metrics', 'namespace', 'ok_actions', 'period', 'statistic', 'threshold', 'threshold_metric_id', 'treat_missing_data', 'unit']
    _method_names: typing.ClassVar[list[str]] = ['DimensionProperty', 'MetricDataQueryProperty', 'MetricProperty', 'MetricStatProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAlarm'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.CfnAlarmDefConfig] = pydantic.Field(None)


class CfnAlarmDefConfig(pydantic.BaseModel):
    DimensionProperty: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefDimensionpropertyParams]] = pydantic.Field(None, description='')
    MetricDataQueryProperty: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefMetricdataquerypropertyParams]] = pydantic.Field(None, description='')
    MetricProperty: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefMetricpropertyParams]] = pydantic.Field(None, description='')
    MetricStatProperty: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefMetricstatpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cloudwatch.CfnAlarmDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAlarmDefDimensionpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnAlarmDefMetricdataquerypropertyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='')
    account_id: typing.Optional[str] = pydantic.Field(None, description='')
    expression: typing.Optional[str] = pydantic.Field(None, description='')
    label: typing.Optional[str] = pydantic.Field(None, description='')
    metric_stat: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_MetricStatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    period: typing.Union[int, float, None] = pydantic.Field(None, description='')
    return_data: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnAlarmDefMetricpropertyParams(pydantic.BaseModel):
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    metric_name: typing.Optional[str] = pydantic.Field(None, description='')
    namespace: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAlarmDefMetricstatpropertyParams(pydantic.BaseModel):
    metric: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_MetricPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    period: typing.Union[int, float] = pydantic.Field(..., description='')
    stat: str = pydantic.Field(..., description='')
    unit: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAlarmDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAlarmDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAlarmDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAlarmDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAlarmDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAlarmDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAlarmDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAlarmDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAlarmDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAlarmDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAlarmDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAlarmDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAlarmDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAlarmDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetector
class CfnAnomalyDetectorDef(BaseCfnResource):
    configuration: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_ConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies details about how the anomaly detection model is to be trained, including time ranges to exclude when training and updating the model. The configuration can also include the time zone to use for the metric.\n')
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The dimensions of the metric associated with the anomaly detection band.\n')
    metric_math_anomaly_detector: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_MetricMathAnomalyDetectorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The CloudWatch metric math expression for this anomaly detector.\n')
    metric_name: typing.Optional[str] = pydantic.Field(None, description='The name of the metric associated with the anomaly detection band.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the metric associated with the anomaly detection band.\n')
    single_metric_anomaly_detector: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_SingleMetricAnomalyDetectorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The CloudWatch metric and statistic for this anomaly detector.\n')
    stat: typing.Optional[str] = pydantic.Field(None, description='The statistic of the metric associated with the anomaly detection band.')
    _init_params: typing.ClassVar[list[str]] = ['configuration', 'dimensions', 'metric_math_anomaly_detector', 'metric_name', 'namespace', 'single_metric_anomaly_detector', 'stat']
    _method_names: typing.ClassVar[list[str]] = ['ConfigurationProperty', 'DimensionProperty', 'MetricDataQueryProperty', 'MetricMathAnomalyDetectorProperty', 'MetricProperty', 'MetricStatProperty', 'RangeProperty', 'SingleMetricAnomalyDetectorProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetector'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.CfnAnomalyDetectorDefConfig] = pydantic.Field(None)


class CfnAnomalyDetectorDefConfig(pydantic.BaseModel):
    ConfigurationProperty: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefConfigurationpropertyParams]] = pydantic.Field(None, description='')
    DimensionProperty: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefDimensionpropertyParams]] = pydantic.Field(None, description='')
    MetricDataQueryProperty: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefMetricdataquerypropertyParams]] = pydantic.Field(None, description='')
    MetricMathAnomalyDetectorProperty: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefMetricmathanomalydetectorpropertyParams]] = pydantic.Field(None, description='')
    MetricProperty: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefMetricpropertyParams]] = pydantic.Field(None, description='')
    MetricStatProperty: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefMetricstatpropertyParams]] = pydantic.Field(None, description='')
    RangeProperty: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefRangepropertyParams]] = pydantic.Field(None, description='')
    SingleMetricAnomalyDetectorProperty: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefSinglemetricanomalydetectorpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cloudwatch.CfnAnomalyDetectorDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAnomalyDetectorDefConfigurationpropertyParams(pydantic.BaseModel):
    excluded_time_ranges: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_RangePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    metric_time_zone: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAnomalyDetectorDefDimensionpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnAnomalyDetectorDefMetricdataquerypropertyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='')
    account_id: typing.Optional[str] = pydantic.Field(None, description='')
    expression: typing.Optional[str] = pydantic.Field(None, description='')
    label: typing.Optional[str] = pydantic.Field(None, description='')
    metric_stat: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_MetricStatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    period: typing.Union[int, float, None] = pydantic.Field(None, description='')
    return_data: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnAnomalyDetectorDefMetricmathanomalydetectorpropertyParams(pydantic.BaseModel):
    metric_data_queries: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_MetricDataQueryPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnAnomalyDetectorDefMetricpropertyParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='')
    namespace: str = pydantic.Field(..., description='')
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnAnomalyDetectorDefMetricstatpropertyParams(pydantic.BaseModel):
    metric: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_MetricPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    period: typing.Union[int, float] = pydantic.Field(..., description='')
    stat: str = pydantic.Field(..., description='')
    unit: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAnomalyDetectorDefRangepropertyParams(pydantic.BaseModel):
    end_time: str = pydantic.Field(..., description='')
    start_time: str = pydantic.Field(..., description='')
    ...

class CfnAnomalyDetectorDefSinglemetricanomalydetectorpropertyParams(pydantic.BaseModel):
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    metric_name: typing.Optional[str] = pydantic.Field(None, description='')
    namespace: typing.Optional[str] = pydantic.Field(None, description='')
    stat: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAnomalyDetectorDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAnomalyDetectorDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAnomalyDetectorDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAnomalyDetectorDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAnomalyDetectorDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAnomalyDetectorDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAnomalyDetectorDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAnomalyDetectorDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAnomalyDetectorDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAnomalyDetectorDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAnomalyDetectorDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAnomalyDetectorDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAnomalyDetectorDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAnomalyDetectorDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.CfnCompositeAlarm
class CfnCompositeAlarmDef(BaseCfnResource):
    alarm_rule: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An expression that specifies which other alarms are to be evaluated to determine this composite alarm\'s state. For each alarm that you reference, you designate a function that specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the functions in your expression. You can use either alarm names or ARNs to reference the other alarms that are to be evaluated. Functions can include the following: - ALARM("alarm-name or alarm-ARN") is TRUE if the named alarm is in ALARM state. - OK("alarm-name or alarm-ARN") is TRUE if the named alarm is in OK state. - INSUFFICIENT_DATA("alarm-name or alarm-ARN") is TRUE if the named alarm is in INSUFFICIENT_DATA state. - TRUE always evaluates to TRUE. - FALSE always evaluates to FALSE. TRUE and FALSE are useful for testing a complex AlarmRule structure, and for testing your alarm actions. For more information about ``AlarmRule`` syntax, see `PutCompositeAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutCompositeAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n')
    actions_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is TRUE.\n')
    actions_suppressor: typing.Optional[str] = pydantic.Field(None, description='Actions will be suppressed if the suppressor alarm is in the ``ALARM`` state. ``ActionsSuppressor`` can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm.\n')
    actions_suppressor_extension_period: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the ``ALARM`` state. After this time, the composite alarm performs its actions. .. epigraph:: ``ExtensionPeriod`` is required only when ``ActionsSuppressor`` is specified.\n')
    actions_suppressor_wait_period: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the ``ALARM`` state. After this time, the composite alarm performs its actions. .. epigraph:: ``WaitPeriod`` is required only when ``ActionsSuppressor`` is specified.\n')
    alarm_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see `PutCompositeAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutCompositeAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='The description for the composite alarm.\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description='The name for the composite alarm. This name must be unique within your AWS account.\n')
    insufficient_data_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see `PutCompositeAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutCompositeAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n')
    ok_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see `PutCompositeAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutCompositeAlarm.html>`_ in the *Amazon CloudWatch API Reference* .')
    _init_params: typing.ClassVar[list[str]] = ['alarm_rule', 'actions_enabled', 'actions_suppressor', 'actions_suppressor_extension_period', 'actions_suppressor_wait_period', 'alarm_actions', 'alarm_description', 'alarm_name', 'insufficient_data_actions', 'ok_actions']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnCompositeAlarm'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.CfnCompositeAlarmDefConfig] = pydantic.Field(None)


class CfnCompositeAlarmDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cloudwatch.CfnCompositeAlarmDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnCompositeAlarmDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCompositeAlarmDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCompositeAlarmDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCompositeAlarmDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCompositeAlarmDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCompositeAlarmDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCompositeAlarmDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCompositeAlarmDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCompositeAlarmDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCompositeAlarmDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCompositeAlarmDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCompositeAlarmDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCompositeAlarmDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCompositeAlarmDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.CfnDashboard
class CfnDashboardDef(BaseCfnResource):
    dashboard_body: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The detailed information about the dashboard in JSON format, including the widgets to include and their location on the dashboard. This parameter is required. For more information about the syntax, see `Dashboard Body Structure and Syntax <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Dashboard-Body-Structure.html>`_ .\n')
    dashboard_name: typing.Optional[str] = pydantic.Field(None, description='The name of the dashboard. The name must be between 1 and 255 characters. If you do not specify a name, one will be generated automatically.')
    _init_params: typing.ClassVar[list[str]] = ['dashboard_body', 'dashboard_name']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnDashboard'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.CfnDashboardDefConfig] = pydantic.Field(None)


class CfnDashboardDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cloudwatch.CfnDashboardDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDashboardDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDashboardDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDashboardDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDashboardDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDashboardDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDashboardDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDashboardDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDashboardDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDashboardDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDashboardDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDashboardDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDashboardDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDashboardDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDashboardDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.CfnInsightRule
class CfnInsightRuleDef(BaseCfnResource):
    rule_body: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The definition of the rule, as a JSON object. For details about the syntax, see `Contributor Insights Rule Syntax <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContributorInsights-RuleSyntax.html>`_ in the *Amazon CloudWatch User Guide* .\n')
    rule_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the rule.\n')
    rule_state: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The current state of the rule. Valid values are ``ENABLED`` and ``DISABLED`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of key-value pairs to associate with the Contributor Insights rule. You can associate as many as 50 tags with a rule. Tags can help you organize and categorize your resources. For more information, see `Tagging Your Amazon CloudWatch Resources <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Tagging.html>`_ . To be able to associate tags with a rule, you must have the ``cloudwatch:TagResource`` permission in addition to the ``cloudwatch:PutInsightRule`` permission.')
    _init_params: typing.ClassVar[list[str]] = ['rule_body', 'rule_name', 'rule_state', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnInsightRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.CfnInsightRuleDefConfig] = pydantic.Field(None)


class CfnInsightRuleDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cloudwatch.CfnInsightRuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnInsightRuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInsightRuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInsightRuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInsightRuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInsightRuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInsightRuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInsightRuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInsightRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInsightRuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInsightRuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInsightRuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnInsightRuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInsightRuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInsightRuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.CfnMetricStream
class CfnMetricStreamDef(BaseCfnResource):
    firehose_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the Amazon Kinesis Firehose delivery stream to use for this metric stream. This Amazon Kinesis Firehose delivery stream must already exist and must be in the same account as the metric stream.\n')
    output_format: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The output format for the stream. Valid values are ``json`` and ``opentelemetry0.7`` For more information about metric stream output formats, see `Metric streams output formats <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-metric-streams-formats.html>`_ . This parameter is required.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of an IAM role that this metric stream will use to access Amazon Kinesis Firehose resources. This IAM role must already exist and must be in the same account as the metric stream. This IAM role must include the ``firehose:PutRecord`` and ``firehose:PutRecordBatch`` permissions.\n')
    exclude_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnMetricStream_MetricStreamFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='If you specify this parameter, the stream sends metrics from all metric namespaces except for the namespaces that you specify here. You cannot specify both ``IncludeFilters`` and ``ExcludeFilters`` in the same metric stream. When you modify the ``IncludeFilters`` or ``ExcludeFilters`` of an existing metric stream in any way, the metric stream is effectively restarted, so after such a change you will get only the datapoints that have a timestamp after the time of the update.\n')
    include_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnMetricStream_MetricStreamFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='If you specify this parameter, the stream sends only the metrics from the metric namespaces that you specify here. You cannot specify both ``IncludeFilters`` and ``ExcludeFilters`` in the same metric stream. When you modify the ``IncludeFilters`` or ``ExcludeFilters`` of an existing metric stream in any way, the metric stream is effectively restarted, so after such a change you will get only the datapoints that have a timestamp after the time of the update.\n')
    include_linked_accounts_metrics: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If you are creating a metric stream in a monitoring account, specify ``true`` to include metrics from source accounts that are linked to this monitoring account, in the metric stream. The default is ``false`` . For more information about linking accounts, see `CloudWatch cross-account observability <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Unified-Cross-Account.html>`_\n')
    name: typing.Optional[str] = pydantic.Field(None, description='If you are creating a new metric stream, this is the name for the new stream. The name must be different than the names of other metric streams in this account and Region. If you are updating a metric stream, specify the name of that stream here.\n')
    statistics_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnMetricStream_MetricStreamStatisticsConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="By default, a metric stream always sends the MAX, MIN, SUM, and SAMPLECOUNT statistics for each metric that is streamed. You can use this parameter to have the metric stream also send additional statistics in the stream. This array can have up to 100 members. For each entry in this array, you specify one or more metrics and the list of additional statistics to stream for those metrics. The additional statistics that you can stream depend on the stream's ``OutputFormat`` . If the ``OutputFormat`` is ``json`` , you can stream any additional statistic that is supported by CloudWatch , listed in `CloudWatch statistics definitions <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html>`_ . If the ``OutputFormat`` is ``opentelemetry0`` .7, you can stream percentile statistics *(p??)* .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to the metric stream. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['firehose_arn', 'output_format', 'role_arn', 'exclude_filters', 'include_filters', 'include_linked_accounts_metrics', 'name', 'statistics_configurations', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['MetricStreamFilterProperty', 'MetricStreamStatisticsConfigurationProperty', 'MetricStreamStatisticsMetricProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnMetricStream'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cloudwatch.CfnMetricStreamDefConfig] = pydantic.Field(None)


class CfnMetricStreamDefConfig(pydantic.BaseModel):
    MetricStreamFilterProperty: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefMetricstreamfilterpropertyParams]] = pydantic.Field(None, description='')
    MetricStreamStatisticsConfigurationProperty: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefMetricstreamstatisticsconfigurationpropertyParams]] = pydantic.Field(None, description='')
    MetricStreamStatisticsMetricProperty: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefMetricstreamstatisticsmetricpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cloudwatch.CfnMetricStreamDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnMetricStreamDefMetricstreamfilterpropertyParams(pydantic.BaseModel):
    namespace: str = pydantic.Field(..., description='')
    metric_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnMetricStreamDefMetricstreamstatisticsconfigurationpropertyParams(pydantic.BaseModel):
    additional_statistics: typing.Sequence[str] = pydantic.Field(..., description='')
    include_metrics: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnMetricStream_MetricStreamStatisticsMetricPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnMetricStreamDefMetricstreamstatisticsmetricpropertyParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='')
    namespace: str = pydantic.Field(..., description='')
    ...

class CfnMetricStreamDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMetricStreamDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMetricStreamDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMetricStreamDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMetricStreamDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMetricStreamDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMetricStreamDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMetricStreamDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMetricStreamDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMetricStreamDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMetricStreamDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMetricStreamDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMetricStreamDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMetricStreamDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cloudwatch.CfnAlarmProps
class CfnAlarmPropsDef(BaseCfnProperty):
    comparison_operator: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand. You can specify the following values: ``GreaterThanThreshold`` , ``GreaterThanOrEqualToThreshold`` , ``LessThanThreshold`` , or ``LessThanOrEqualToThreshold`` .\n')
    evaluation_periods: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of periods over which data is compared to the specified threshold. If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies that number. If you are setting an "M out of N" alarm, this value is the N, and ``DatapointsToAlarm`` is the M. For more information, see `Evaluating an Alarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation>`_ in the *Amazon CloudWatch User Guide* .\n')
    actions_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether actions should be executed during any changes to the alarm state. The default is TRUE. Default: - true\n')
    alarm_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of actions to execute when this alarm transitions into an ALARM state from any other state. Specify each action as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see `PutMetricAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutMetricAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='The description of the alarm.\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description="The name of the alarm. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the alarm name. .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M out of N" alarm. In that case, this value is the M, and the value that you set for ``EvaluationPeriods`` is the N value. For more information, see `Evaluating an Alarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation>`_ in the *Amazon CloudWatch User Guide* . If you omit this parameter, CloudWatch uses the same value here that you set for ``EvaluationPeriods`` , and the alarm goes to alarm state if that many consecutive periods are breaching.\n')
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The dimensions for the metric associated with the alarm. For an alarm based on a math expression, you can't specify ``Dimensions`` . Instead, you use ``Metrics`` .\n")
    evaluate_low_sample_count_percentile: typing.Optional[str] = pydantic.Field(None, description='Used only for alarms based on percentiles. If ``ignore`` , the alarm state does not change during periods with too few data points to be statistically significant. If ``evaluate`` or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available.\n')
    extended_statistic: typing.Optional[str] = pydantic.Field(None, description="The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100. For an alarm based on a metric, you must specify either ``Statistic`` or ``ExtendedStatistic`` but not both. For an alarm based on a math expression, you can't specify ``ExtendedStatistic`` . Instead, you use ``Metrics`` .\n")
    insufficient_data_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the ``INSUFFICIENT_DATA`` state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n')
    metric_name: typing.Optional[str] = pydantic.Field(None, description="The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use ``Metrics`` instead and you can't specify ``MetricName`` .\n")
    metrics: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAlarm_MetricDataQueryPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array that enables you to create an alarm based on the result of a metric math expression. Each item in the array either retrieves a metric or performs a math expression. If you specify the ``Metrics`` parameter, you cannot specify ``MetricName`` , ``Dimensions`` , ``Period`` , ``Namespace`` , ``Statistic`` , ``ExtendedStatistic`` , or ``Unit`` .\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify ``Namespace`` and you use ``Metrics`` instead. For a list of namespaces for metrics from AWS services, see `AWS Services That Publish CloudWatch Metrics. <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/aws-services-cloudwatch-metrics.html>`_\n")
    ok_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the ``OK`` state from any other state. Each action is specified as an Amazon Resource Name (ARN).\n')
    period: typing.Union[int, float, None] = pydantic.Field(None, description="The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. Valid values are 10, 30, 60, and any multiple of 60. For an alarm based on a math expression, you can't specify ``Period`` , and instead you use the ``Metrics`` parameter. *Minimum:* 10\n")
    statistic: typing.Optional[str] = pydantic.Field(None, description="The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ``ExtendedStatistic`` . For an alarm based on a metric, you must specify either ``Statistic`` or ``ExtendedStatistic`` but not both. For an alarm based on a math expression, you can't specify ``Statistic`` . Instead, you use ``Metrics`` .\n")
    threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The value to compare with the specified statistic.\n')
    threshold_metric_id: typing.Optional[str] = pydantic.Field(None, description='In an alarm based on an anomaly detection model, this is the ID of the ``ANOMALY_DETECTION_BAND`` function used as the threshold for the alarm.\n')
    treat_missing_data: typing.Optional[str] = pydantic.Field(None, description='Sets how this alarm is to handle missing data points. Valid values are ``breaching`` , ``notBreaching`` , ``ignore`` , and ``missing`` . For more information, see `Configuring How CloudWatch Alarms Treat Missing Data <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-and-missing-data>`_ in the *Amazon CloudWatch User Guide* . If you omit this parameter, the default behavior of ``missing`` is used.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='The unit of the metric associated with the alarm. Specify this only if you are creating an alarm based on a single metric. Do not specify this if you are specifying a ``Metrics`` array. You can specify the following values: Seconds, Microseconds, Milliseconds, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Bits, Kilobits, Megabits, Gigabits, Terabits, Percent, Count, Bytes/Second, Kilobytes/Second, Megabytes/Second, Gigabytes/Second, Terabytes/Second, Bits/Second, Kilobits/Second, Megabits/Second, Gigabits/Second, Terabits/Second, Count/Second, or None.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloudwatch-alarm.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    cfn_alarm_props = cloudwatch.CfnAlarmProps(\n        comparison_operator="comparisonOperator",\n        evaluation_periods=123,\n\n        # the properties below are optional\n        actions_enabled=False,\n        alarm_actions=["alarmActions"],\n        alarm_description="alarmDescription",\n        alarm_name="alarmName",\n        datapoints_to_alarm=123,\n        dimensions=[cloudwatch.CfnAlarm.DimensionProperty(\n            name="name",\n            value="value"\n        )],\n        evaluate_low_sample_count_percentile="evaluateLowSampleCountPercentile",\n        extended_statistic="extendedStatistic",\n        insufficient_data_actions=["insufficientDataActions"],\n        metric_name="metricName",\n        metrics=[cloudwatch.CfnAlarm.MetricDataQueryProperty(\n            id="id",\n\n            # the properties below are optional\n            account_id="accountId",\n            expression="expression",\n            label="label",\n            metric_stat=cloudwatch.CfnAlarm.MetricStatProperty(\n                metric=cloudwatch.CfnAlarm.MetricProperty(\n                    dimensions=[cloudwatch.CfnAlarm.DimensionProperty(\n                        name="name",\n                        value="value"\n                    )],\n                    metric_name="metricName",\n                    namespace="namespace"\n                ),\n                period=123,\n                stat="stat",\n\n                # the properties below are optional\n                unit="unit"\n            ),\n            period=123,\n            return_data=False\n        )],\n        namespace="namespace",\n        ok_actions=["okActions"],\n        period=123,\n        statistic="statistic",\n        threshold=123,\n        threshold_metric_id="thresholdMetricId",\n        treat_missing_data="treatMissingData",\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['comparison_operator', 'evaluation_periods', 'actions_enabled', 'alarm_actions', 'alarm_description', 'alarm_name', 'datapoints_to_alarm', 'dimensions', 'evaluate_low_sample_count_percentile', 'extended_statistic', 'insufficient_data_actions', 'metric_name', 'metrics', 'namespace', 'ok_actions', 'period', 'statistic', 'threshold', 'threshold_metric_id', 'treat_missing_data', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAlarmProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnAnomalyDetectorProps
class CfnAnomalyDetectorPropsDef(BaseCfnProperty):
    configuration: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_ConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies details about how the anomaly detection model is to be trained, including time ranges to exclude when training and updating the model. The configuration can also include the time zone to use for the metric.\n')
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_DimensionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The dimensions of the metric associated with the anomaly detection band.\n')
    metric_math_anomaly_detector: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_MetricMathAnomalyDetectorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The CloudWatch metric math expression for this anomaly detector.\n')
    metric_name: typing.Optional[str] = pydantic.Field(None, description='The name of the metric associated with the anomaly detection band.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the metric associated with the anomaly detection band.\n')
    single_metric_anomaly_detector: typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnAnomalyDetector_SingleMetricAnomalyDetectorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The CloudWatch metric and statistic for this anomaly detector.\n')
    stat: typing.Optional[str] = pydantic.Field(None, description='The statistic of the metric associated with the anomaly detection band.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloudwatch-anomalydetector.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    cfn_anomaly_detector_props = cloudwatch.CfnAnomalyDetectorProps(\n        configuration=cloudwatch.CfnAnomalyDetector.ConfigurationProperty(\n            excluded_time_ranges=[cloudwatch.CfnAnomalyDetector.RangeProperty(\n                end_time="endTime",\n                start_time="startTime"\n            )],\n            metric_time_zone="metricTimeZone"\n        ),\n        dimensions=[cloudwatch.CfnAnomalyDetector.DimensionProperty(\n            name="name",\n            value="value"\n        )],\n        metric_math_anomaly_detector=cloudwatch.CfnAnomalyDetector.MetricMathAnomalyDetectorProperty(\n            metric_data_queries=[cloudwatch.CfnAnomalyDetector.MetricDataQueryProperty(\n                id="id",\n\n                # the properties below are optional\n                account_id="accountId",\n                expression="expression",\n                label="label",\n                metric_stat=cloudwatch.CfnAnomalyDetector.MetricStatProperty(\n                    metric=cloudwatch.CfnAnomalyDetector.MetricProperty(\n                        metric_name="metricName",\n                        namespace="namespace",\n\n                        # the properties below are optional\n                        dimensions=[cloudwatch.CfnAnomalyDetector.DimensionProperty(\n                            name="name",\n                            value="value"\n                        )]\n                    ),\n                    period=123,\n                    stat="stat",\n\n                    # the properties below are optional\n                    unit="unit"\n                ),\n                period=123,\n                return_data=False\n            )]\n        ),\n        metric_name="metricName",\n        namespace="namespace",\n        single_metric_anomaly_detector=cloudwatch.CfnAnomalyDetector.SingleMetricAnomalyDetectorProperty(\n            dimensions=[cloudwatch.CfnAnomalyDetector.DimensionProperty(\n                name="name",\n                value="value"\n            )],\n            metric_name="metricName",\n            namespace="namespace",\n            stat="stat"\n        ),\n        stat="stat"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['configuration', 'dimensions', 'metric_math_anomaly_detector', 'metric_name', 'namespace', 'single_metric_anomaly_detector', 'stat']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnAnomalyDetectorProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnCompositeAlarmProps
class CfnCompositeAlarmPropsDef(BaseCfnProperty):
    alarm_rule: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An expression that specifies which other alarms are to be evaluated to determine this composite alarm\'s state. For each alarm that you reference, you designate a function that specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the functions in your expression. You can use either alarm names or ARNs to reference the other alarms that are to be evaluated. Functions can include the following: - ALARM("alarm-name or alarm-ARN") is TRUE if the named alarm is in ALARM state. - OK("alarm-name or alarm-ARN") is TRUE if the named alarm is in OK state. - INSUFFICIENT_DATA("alarm-name or alarm-ARN") is TRUE if the named alarm is in INSUFFICIENT_DATA state. - TRUE always evaluates to TRUE. - FALSE always evaluates to FALSE. TRUE and FALSE are useful for testing a complex AlarmRule structure, and for testing your alarm actions. For more information about ``AlarmRule`` syntax, see `PutCompositeAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutCompositeAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n')
    actions_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is TRUE.\n')
    actions_suppressor: typing.Optional[str] = pydantic.Field(None, description='Actions will be suppressed if the suppressor alarm is in the ``ALARM`` state. ``ActionsSuppressor`` can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm.\n')
    actions_suppressor_extension_period: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the ``ALARM`` state. After this time, the composite alarm performs its actions. .. epigraph:: ``ExtensionPeriod`` is required only when ``ActionsSuppressor`` is specified.\n')
    actions_suppressor_wait_period: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the ``ALARM`` state. After this time, the composite alarm performs its actions. .. epigraph:: ``WaitPeriod`` is required only when ``ActionsSuppressor`` is specified.\n')
    alarm_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see `PutCompositeAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutCompositeAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n')
    alarm_description: typing.Optional[str] = pydantic.Field(None, description='The description for the composite alarm.\n')
    alarm_name: typing.Optional[str] = pydantic.Field(None, description='The name for the composite alarm. This name must be unique within your AWS account.\n')
    insufficient_data_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see `PutCompositeAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutCompositeAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n')
    ok_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see `PutCompositeAlarm <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutCompositeAlarm.html>`_ in the *Amazon CloudWatch API Reference* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloudwatch-compositealarm.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    cfn_composite_alarm_props = cloudwatch.CfnCompositeAlarmProps(\n        alarm_rule="alarmRule",\n\n        # the properties below are optional\n        actions_enabled=False,\n        actions_suppressor="actionsSuppressor",\n        actions_suppressor_extension_period=123,\n        actions_suppressor_wait_period=123,\n        alarm_actions=["alarmActions"],\n        alarm_description="alarmDescription",\n        alarm_name="alarmName",\n        insufficient_data_actions=["insufficientDataActions"],\n        ok_actions=["okActions"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alarm_rule', 'actions_enabled', 'actions_suppressor', 'actions_suppressor_extension_period', 'actions_suppressor_wait_period', 'alarm_actions', 'alarm_description', 'alarm_name', 'insufficient_data_actions', 'ok_actions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnCompositeAlarmProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnDashboardProps
class CfnDashboardPropsDef(BaseCfnProperty):
    dashboard_body: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The detailed information about the dashboard in JSON format, including the widgets to include and their location on the dashboard. This parameter is required. For more information about the syntax, see `Dashboard Body Structure and Syntax <https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Dashboard-Body-Structure.html>`_ .\n')
    dashboard_name: typing.Optional[str] = pydantic.Field(None, description='The name of the dashboard. The name must be between 1 and 255 characters. If you do not specify a name, one will be generated automatically.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloudwatch-dashboard.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    cfn_dashboard_props = cloudwatch.CfnDashboardProps(\n        dashboard_body="dashboardBody",\n\n        # the properties below are optional\n        dashboard_name="dashboardName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dashboard_body', 'dashboard_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnDashboardProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnInsightRuleProps
class CfnInsightRulePropsDef(BaseCfnProperty):
    rule_body: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The definition of the rule, as a JSON object. For details about the syntax, see `Contributor Insights Rule Syntax <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContributorInsights-RuleSyntax.html>`_ in the *Amazon CloudWatch User Guide* .\n')
    rule_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the rule.\n')
    rule_state: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The current state of the rule. Valid values are ``ENABLED`` and ``DISABLED`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of key-value pairs to associate with the Contributor Insights rule. You can associate as many as 50 tags with a rule. Tags can help you organize and categorize your resources. For more information, see `Tagging Your Amazon CloudWatch Resources <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Tagging.html>`_ . To be able to associate tags with a rule, you must have the ``cloudwatch:TagResource`` permission in addition to the ``cloudwatch:PutInsightRule`` permission.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloudwatch-insightrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    cfn_insight_rule_props = cloudwatch.CfnInsightRuleProps(\n        rule_body="ruleBody",\n        rule_name="ruleName",\n        rule_state="ruleState",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rule_body', 'rule_name', 'rule_state', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnInsightRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cloudwatch.CfnMetricStreamProps
class CfnMetricStreamPropsDef(BaseCfnProperty):
    firehose_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the Amazon Kinesis Firehose delivery stream to use for this metric stream. This Amazon Kinesis Firehose delivery stream must already exist and must be in the same account as the metric stream.\n')
    output_format: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The output format for the stream. Valid values are ``json`` and ``opentelemetry0.7`` For more information about metric stream output formats, see `Metric streams output formats <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-metric-streams-formats.html>`_ . This parameter is required.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of an IAM role that this metric stream will use to access Amazon Kinesis Firehose resources. This IAM role must already exist and must be in the same account as the metric stream. This IAM role must include the ``firehose:PutRecord`` and ``firehose:PutRecordBatch`` permissions.\n')
    exclude_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnMetricStream_MetricStreamFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='If you specify this parameter, the stream sends metrics from all metric namespaces except for the namespaces that you specify here. You cannot specify both ``IncludeFilters`` and ``ExcludeFilters`` in the same metric stream. When you modify the ``IncludeFilters`` or ``ExcludeFilters`` of an existing metric stream in any way, the metric stream is effectively restarted, so after such a change you will get only the datapoints that have a timestamp after the time of the update.\n')
    include_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnMetricStream_MetricStreamFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='If you specify this parameter, the stream sends only the metrics from the metric namespaces that you specify here. You cannot specify both ``IncludeFilters`` and ``ExcludeFilters`` in the same metric stream. When you modify the ``IncludeFilters`` or ``ExcludeFilters`` of an existing metric stream in any way, the metric stream is effectively restarted, so after such a change you will get only the datapoints that have a timestamp after the time of the update.\n')
    include_linked_accounts_metrics: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If you are creating a metric stream in a monitoring account, specify ``true`` to include metrics from source accounts that are linked to this monitoring account, in the metric stream. The default is ``false`` . For more information about linking accounts, see `CloudWatch cross-account observability <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Unified-Cross-Account.html>`_\n')
    name: typing.Optional[str] = pydantic.Field(None, description='If you are creating a new metric stream, this is the name for the new stream. The name must be different than the names of other metric streams in this account and Region. If you are updating a metric stream, specify the name of that stream here.\n')
    statistics_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cloudwatch.CfnMetricStream_MetricStreamStatisticsConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="By default, a metric stream always sends the MAX, MIN, SUM, and SAMPLECOUNT statistics for each metric that is streamed. You can use this parameter to have the metric stream also send additional statistics in the stream. This array can have up to 100 members. For each entry in this array, you specify one or more metrics and the list of additional statistics to stream for those metrics. The additional statistics that you can stream depend on the stream's ``OutputFormat`` . If the ``OutputFormat`` is ``json`` , you can stream any additional statistic that is supported by CloudWatch , listed in `CloudWatch statistics definitions <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html>`_ . If the ``OutputFormat`` is ``opentelemetry0`` .7, you can stream percentile statistics *(p??)* .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to the metric stream. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloudwatch-metricstream.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cloudwatch as cloudwatch\n\n    cfn_metric_stream_props = cloudwatch.CfnMetricStreamProps(\n        firehose_arn="firehoseArn",\n        output_format="outputFormat",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        exclude_filters=[cloudwatch.CfnMetricStream.MetricStreamFilterProperty(\n            namespace="namespace",\n\n            # the properties below are optional\n            metric_names=["metricNames"]\n        )],\n        include_filters=[cloudwatch.CfnMetricStream.MetricStreamFilterProperty(\n            namespace="namespace",\n\n            # the properties below are optional\n            metric_names=["metricNames"]\n        )],\n        include_linked_accounts_metrics=False,\n        name="name",\n        statistics_configurations=[cloudwatch.CfnMetricStream.MetricStreamStatisticsConfigurationProperty(\n            additional_statistics=["additionalStatistics"],\n            include_metrics=[cloudwatch.CfnMetricStream.MetricStreamStatisticsMetricProperty(\n                metric_name="metricName",\n                namespace="namespace"\n            )]\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['firehose_arn', 'output_format', 'role_arn', 'exclude_filters', 'include_filters', 'include_linked_accounts_metrics', 'name', 'statistics_configurations', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cloudwatch.CfnMetricStreamProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    AlarmBase: typing.Optional[dict[str, models.aws_cloudwatch.AlarmBaseDef]] = pydantic.Field(None)
    AlarmRule: typing.Optional[dict[str, models.aws_cloudwatch.AlarmRuleDef]] = pydantic.Field(None)
    AlarmStatusWidget: typing.Optional[dict[str, models.aws_cloudwatch.AlarmStatusWidgetDef]] = pydantic.Field(None)
    AlarmWidget: typing.Optional[dict[str, models.aws_cloudwatch.AlarmWidgetDef]] = pydantic.Field(None)
    Color: typing.Optional[dict[str, models.aws_cloudwatch.ColorDef]] = pydantic.Field(None)
    Column: typing.Optional[dict[str, models.aws_cloudwatch.ColumnDef]] = pydantic.Field(None)
    ConcreteWidget: typing.Optional[dict[str, models.aws_cloudwatch.ConcreteWidgetDef]] = pydantic.Field(None)
    CustomWidget: typing.Optional[dict[str, models.aws_cloudwatch.CustomWidgetDef]] = pydantic.Field(None)
    DashboardVariable: typing.Optional[dict[str, models.aws_cloudwatch.DashboardVariableDef]] = pydantic.Field(None)
    DefaultValue: typing.Optional[dict[str, models.aws_cloudwatch.DefaultValueDef]] = pydantic.Field(None)
    GaugeWidget: typing.Optional[dict[str, models.aws_cloudwatch.GaugeWidgetDef]] = pydantic.Field(None)
    GraphWidget: typing.Optional[dict[str, models.aws_cloudwatch.GraphWidgetDef]] = pydantic.Field(None)
    LogQueryWidget: typing.Optional[dict[str, models.aws_cloudwatch.LogQueryWidgetDef]] = pydantic.Field(None)
    MathExpression: typing.Optional[dict[str, models.aws_cloudwatch.MathExpressionDef]] = pydantic.Field(None)
    Metric: typing.Optional[dict[str, models.aws_cloudwatch.MetricDef]] = pydantic.Field(None)
    Row: typing.Optional[dict[str, models.aws_cloudwatch.RowDef]] = pydantic.Field(None)
    SingleValueWidget: typing.Optional[dict[str, models.aws_cloudwatch.SingleValueWidgetDef]] = pydantic.Field(None)
    Spacer: typing.Optional[dict[str, models.aws_cloudwatch.SpacerDef]] = pydantic.Field(None)
    Stats: typing.Optional[dict[str, models.aws_cloudwatch.StatsDef]] = pydantic.Field(None)
    TextWidget: typing.Optional[dict[str, models.aws_cloudwatch.TextWidgetDef]] = pydantic.Field(None)
    Values: typing.Optional[dict[str, models.aws_cloudwatch.ValuesDef]] = pydantic.Field(None)
    Alarm: typing.Optional[dict[str, models.aws_cloudwatch.AlarmDef]] = pydantic.Field(None)
    CompositeAlarm: typing.Optional[dict[str, models.aws_cloudwatch.CompositeAlarmDef]] = pydantic.Field(None)
    Dashboard: typing.Optional[dict[str, models.aws_cloudwatch.DashboardDef]] = pydantic.Field(None)
    AlarmActionConfig: typing.Optional[dict[str, models.aws_cloudwatch.AlarmActionConfigDef]] = pydantic.Field(None)
    AlarmProps: typing.Optional[dict[str, models.aws_cloudwatch.AlarmPropsDef]] = pydantic.Field(None)
    AlarmStatusWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.AlarmStatusWidgetPropsDef]] = pydantic.Field(None)
    AlarmWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.AlarmWidgetPropsDef]] = pydantic.Field(None)
    CfnAlarm_DimensionProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAlarm_DimensionPropertyDef]] = pydantic.Field(None)
    CfnAlarm_MetricDataQueryProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAlarm_MetricDataQueryPropertyDef]] = pydantic.Field(None)
    CfnAlarm_MetricProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAlarm_MetricPropertyDef]] = pydantic.Field(None)
    CfnAlarm_MetricStatProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAlarm_MetricStatPropertyDef]] = pydantic.Field(None)
    CfnAnomalyDetector_ConfigurationProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetector_ConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAnomalyDetector_DimensionProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetector_DimensionPropertyDef]] = pydantic.Field(None)
    CfnAnomalyDetector_MetricDataQueryProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetector_MetricDataQueryPropertyDef]] = pydantic.Field(None)
    CfnAnomalyDetector_MetricMathAnomalyDetectorProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetector_MetricMathAnomalyDetectorPropertyDef]] = pydantic.Field(None)
    CfnAnomalyDetector_MetricProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetector_MetricPropertyDef]] = pydantic.Field(None)
    CfnAnomalyDetector_MetricStatProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetector_MetricStatPropertyDef]] = pydantic.Field(None)
    CfnAnomalyDetector_RangeProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetector_RangePropertyDef]] = pydantic.Field(None)
    CfnAnomalyDetector_SingleMetricAnomalyDetectorProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetector_SingleMetricAnomalyDetectorPropertyDef]] = pydantic.Field(None)
    CfnMetricStream_MetricStreamFilterProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnMetricStream_MetricStreamFilterPropertyDef]] = pydantic.Field(None)
    CfnMetricStream_MetricStreamStatisticsConfigurationProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnMetricStream_MetricStreamStatisticsConfigurationPropertyDef]] = pydantic.Field(None)
    CfnMetricStream_MetricStreamStatisticsMetricProperty: typing.Optional[dict[str, models.aws_cloudwatch.CfnMetricStream_MetricStreamStatisticsMetricPropertyDef]] = pydantic.Field(None)
    CommonMetricOptions: typing.Optional[dict[str, models.aws_cloudwatch.CommonMetricOptionsDef]] = pydantic.Field(None)
    CompositeAlarmProps: typing.Optional[dict[str, models.aws_cloudwatch.CompositeAlarmPropsDef]] = pydantic.Field(None)
    CreateAlarmOptions: typing.Optional[dict[str, models.aws_cloudwatch.CreateAlarmOptionsDef]] = pydantic.Field(None)
    CustomWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.CustomWidgetPropsDef]] = pydantic.Field(None)
    DashboardProps: typing.Optional[dict[str, models.aws_cloudwatch.DashboardPropsDef]] = pydantic.Field(None)
    DashboardVariableOptions: typing.Optional[dict[str, models.aws_cloudwatch.DashboardVariableOptionsDef]] = pydantic.Field(None)
    Dimension: typing.Optional[dict[str, models.aws_cloudwatch.DimensionDef]] = pydantic.Field(None)
    GaugeWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.GaugeWidgetPropsDef]] = pydantic.Field(None)
    GraphWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.GraphWidgetPropsDef]] = pydantic.Field(None)
    HorizontalAnnotation: typing.Optional[dict[str, models.aws_cloudwatch.HorizontalAnnotationDef]] = pydantic.Field(None)
    LogQueryWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.LogQueryWidgetPropsDef]] = pydantic.Field(None)
    MathExpressionOptions: typing.Optional[dict[str, models.aws_cloudwatch.MathExpressionOptionsDef]] = pydantic.Field(None)
    MathExpressionProps: typing.Optional[dict[str, models.aws_cloudwatch.MathExpressionPropsDef]] = pydantic.Field(None)
    MetricConfig: typing.Optional[dict[str, models.aws_cloudwatch.MetricConfigDef]] = pydantic.Field(None)
    MetricExpressionConfig: typing.Optional[dict[str, models.aws_cloudwatch.MetricExpressionConfigDef]] = pydantic.Field(None)
    MetricOptions: typing.Optional[dict[str, models.aws_cloudwatch.MetricOptionsDef]] = pydantic.Field(None)
    MetricProps: typing.Optional[dict[str, models.aws_cloudwatch.MetricPropsDef]] = pydantic.Field(None)
    MetricStatConfig: typing.Optional[dict[str, models.aws_cloudwatch.MetricStatConfigDef]] = pydantic.Field(None)
    MetricWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.MetricWidgetPropsDef]] = pydantic.Field(None)
    SearchComponents: typing.Optional[dict[str, models.aws_cloudwatch.SearchComponentsDef]] = pydantic.Field(None)
    SingleValueWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.SingleValueWidgetPropsDef]] = pydantic.Field(None)
    SpacerProps: typing.Optional[dict[str, models.aws_cloudwatch.SpacerPropsDef]] = pydantic.Field(None)
    TextWidgetProps: typing.Optional[dict[str, models.aws_cloudwatch.TextWidgetPropsDef]] = pydantic.Field(None)
    VariableValue: typing.Optional[dict[str, models.aws_cloudwatch.VariableValueDef]] = pydantic.Field(None)
    VerticalAnnotation: typing.Optional[dict[str, models.aws_cloudwatch.VerticalAnnotationDef]] = pydantic.Field(None)
    YAxisProps: typing.Optional[dict[str, models.aws_cloudwatch.YAxisPropsDef]] = pydantic.Field(None)
    CfnAlarm: typing.Optional[dict[str, models.aws_cloudwatch.CfnAlarmDef]] = pydantic.Field(None)
    CfnAnomalyDetector: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetectorDef]] = pydantic.Field(None)
    CfnCompositeAlarm: typing.Optional[dict[str, models.aws_cloudwatch.CfnCompositeAlarmDef]] = pydantic.Field(None)
    CfnDashboard: typing.Optional[dict[str, models.aws_cloudwatch.CfnDashboardDef]] = pydantic.Field(None)
    CfnInsightRule: typing.Optional[dict[str, models.aws_cloudwatch.CfnInsightRuleDef]] = pydantic.Field(None)
    CfnMetricStream: typing.Optional[dict[str, models.aws_cloudwatch.CfnMetricStreamDef]] = pydantic.Field(None)
    CfnAlarmProps: typing.Optional[dict[str, models.aws_cloudwatch.CfnAlarmPropsDef]] = pydantic.Field(None)
    CfnAnomalyDetectorProps: typing.Optional[dict[str, models.aws_cloudwatch.CfnAnomalyDetectorPropsDef]] = pydantic.Field(None)
    CfnCompositeAlarmProps: typing.Optional[dict[str, models.aws_cloudwatch.CfnCompositeAlarmPropsDef]] = pydantic.Field(None)
    CfnDashboardProps: typing.Optional[dict[str, models.aws_cloudwatch.CfnDashboardPropsDef]] = pydantic.Field(None)
    CfnInsightRuleProps: typing.Optional[dict[str, models.aws_cloudwatch.CfnInsightRulePropsDef]] = pydantic.Field(None)
    CfnMetricStreamProps: typing.Optional[dict[str, models.aws_cloudwatch.CfnMetricStreamPropsDef]] = pydantic.Field(None)
    ...

import models
