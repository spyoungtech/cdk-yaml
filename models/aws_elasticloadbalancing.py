from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_elasticloadbalancing.InstanceTarget
class InstanceTargetDef(BaseClass):
    instance: typing.Union[models.aws_ec2.InstanceDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Instance to register to.')
    _init_params: typing.ClassVar[list[str]] = ['instance']
    _method_names: typing.ClassVar[list[str]] = ['attach_to_classic_lb']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.InstanceTarget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InstanceTargetDefConfig] = pydantic.Field(None)


class InstanceTargetDefConfig(pydantic.BaseModel):
    attach_to_classic_lb: typing.Optional[list[InstanceTargetDefAttachToClassicLbParams]] = pydantic.Field(None, description='Attach load-balanced target to a classic ELB.')
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)
    instance_config: typing.Optional[models.aws_ec2.InstanceDefConfig] = pydantic.Field(None)

class InstanceTargetDefAttachToClassicLbParams(pydantic.BaseModel):
    load_balancer: models.aws_elasticloadbalancing.LoadBalancerDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_elasticloadbalancing.ListenerPort
class ListenerPortDef(BaseClass, ConnectableMixin):
    security_group: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.SecurityGroupDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    default_port: typing.Union[models.aws_ec2.PortDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    _init_params: typing.ClassVar[list[str]] = ['security_group', 'default_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.ListenerPort'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ListenerPortDefConfig] = pydantic.Field(None)


class ListenerPortDefConfig(pydantic.BaseModel):
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_elasticloadbalancing.LoadBalancer
class LoadBalancerDef(BaseConstruct, ConnectableMixin):
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='VPC network of the fleet instances.\n')
    access_logging_policy: typing.Union[models.aws_elasticloadbalancing.CfnLoadBalancer_AccessLoggingPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Enable Loadbalancer access logs Can be used to avoid manual work as aws console Required S3 bucket name , enabled flag Can add interval for pushing log Can set bucket prefix in order to provide folder name inside bucket. Default: - disabled\n')
    cross_zone: typing.Optional[bool] = pydantic.Field(None, description='Whether cross zone load balancing is enabled. This controls whether the load balancer evenly distributes requests across each availability zone Default: true\n')
    health_check: typing.Union[models.aws_elasticloadbalancing.HealthCheckDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Health check settings for the load balancing targets. Not required but recommended. Default: - None.\n')
    internet_facing: typing.Optional[bool] = pydantic.Field(None, description="Whether this is an internet-facing Load Balancer. This controls whether the LB has a public IP address assigned. It does not open up the Load Balancer's security groups to public internet access. Default: false\n")
    listeners: typing.Optional[typing.Sequence[typing.Union[models.aws_elasticloadbalancing.LoadBalancerListenerDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='What listeners to set up for the load balancer. Can also be added by .addListener() Default: -\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which subnets to deploy the load balancer. Can be used to define a specific set of subnets to deploy the load balancer to. Useful multiple public or private subnets are covering the same availability zone. Default: - Public subnets if internetFacing, Private subnets otherwise\n')
    targets: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ecs.BaseServiceDef, models.aws_ecs.Ec2ServiceDef, models.aws_ecs.ExternalServiceDef, models.aws_ecs.FargateServiceDef, models.aws_elasticloadbalancing.InstanceTargetDef]]] = pydantic.Field(None, description='What targets to load balance to. Can also be added by .addTarget() Default: - None.')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'access_logging_policy', 'cross_zone', 'health_check', 'internet_facing', 'listeners', 'subnet_selection', 'targets']
    _method_names: typing.ClassVar[list[str]] = ['add_listener', 'add_target', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.LoadBalancer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LoadBalancerDefConfig] = pydantic.Field(None)


class LoadBalancerDefConfig(pydantic.BaseModel):
    add_listener: typing.Optional[list[LoadBalancerDefAddListenerParams]] = pydantic.Field(None, description='Add a backend to the load balancer.')
    add_target: typing.Optional[list[LoadBalancerDefAddTargetParams]] = pydantic.Field(None, description='')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)

class LoadBalancerDefAddListenerParams(pydantic.BaseModel):
    external_port: typing.Union[int, float] = pydantic.Field(..., description='External listening port.\n')
    allow_connections_from: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.aws_synthetics.CanaryDef]]] = pydantic.Field(None, description='Allow connections to the load balancer from the given set of connection peers. By default, connections will be allowed from anywhere. Set this to an empty list to deny connections, or supply a custom list of peers to allow connections from (IP ranges or security groups). Default: Anywhere\n')
    external_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancing.LoadBalancingProtocol] = pydantic.Field(None, description="What public protocol to use for load balancing. Either 'tcp', 'ssl', 'http' or 'https'. May be omitted if the external port is either 80 or 443.\n")
    internal_port: typing.Union[int, float, None] = pydantic.Field(None, description='Instance listening port. Same as the externalPort if not specified. Default: externalPort\n')
    internal_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancing.LoadBalancingProtocol] = pydantic.Field(None, description="What public protocol to use for load balancing. Either 'tcp', 'ssl', 'http' or 'https'. May be omitted if the internal port is either 80 or 443. The instance protocol is 'tcp' if the front-end protocol is 'tcp' or 'ssl', the instance protocol is 'http' if the front-end protocol is 'https'.\n")
    policy_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='SSL policy names.\n')
    ssl_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='the ARN of the SSL certificate. Default: - none\n')
    return_config: typing.Optional[list[models.aws_elasticloadbalancing.ListenerPortDefConfig]] = pydantic.Field(None)
    ...

class LoadBalancerDefAddTargetParams(pydantic.BaseModel):
    target: typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ecs.BaseServiceDef, models.aws_ecs.Ec2ServiceDef, models.aws_ecs.ExternalServiceDef, models.aws_ecs.FargateServiceDef, models.aws_elasticloadbalancing.InstanceTargetDef] = pydantic.Field(..., description='-')
    ...

class LoadBalancerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.AccessLoggingPolicyProperty
class CfnLoadBalancer_AccessLoggingPolicyPropertyDef(BaseStruct):
    enabled: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies whether access logs are enabled for the load balancer.\n')
    s3_bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Amazon S3 bucket where the access logs are stored.\n')
    emit_interval: typing.Union[int, float, None] = pydantic.Field(None, description='The interval for publishing the access logs. You can specify an interval of either 5 minutes or 60 minutes. Default: 60 minutes\n')
    s3_bucket_prefix: typing.Optional[str] = pydantic.Field(None, description='The logical hierarchy you created for your Amazon S3 bucket, for example ``my-bucket-prefix/prod`` . If the prefix is not provided, the log is placed at the root level of the bucket.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancing-loadbalancer-accessloggingpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    access_logging_policy_property = elb.CfnLoadBalancer.AccessLoggingPolicyProperty(\n        enabled=False,\n        s3_bucket_name="s3BucketName",\n\n        # the properties below are optional\n        emit_interval=123,\n        s3_bucket_prefix="s3BucketPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 's3_bucket_name', 'emit_interval', 's3_bucket_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.AccessLoggingPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.AppCookieStickinessPolicyProperty
class CfnLoadBalancer_AppCookieStickinessPolicyPropertyDef(BaseStruct):
    cookie_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the application cookie used for stickiness.\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancing-loadbalancer-appcookiestickinesspolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    app_cookie_stickiness_policy_property = elb.CfnLoadBalancer.AppCookieStickinessPolicyProperty(\n        cookie_name="cookieName",\n        policy_name="policyName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cookie_name', 'policy_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.AppCookieStickinessPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.ConnectionDrainingPolicyProperty
class CfnLoadBalancer_ConnectionDrainingPolicyPropertyDef(BaseStruct):
    enabled: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies whether connection draining is enabled for the load balancer.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time, in seconds, to keep the existing connections open before deregistering the instances.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancing-loadbalancer-connectiondrainingpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    connection_draining_policy_property = elb.CfnLoadBalancer.ConnectionDrainingPolicyProperty(\n        enabled=False,\n\n        # the properties below are optional\n        timeout=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.ConnectionDrainingPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.ConnectionSettingsProperty
class CfnLoadBalancer_ConnectionSettingsPropertyDef(BaseStruct):
    idle_timeout: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancing-loadbalancer-connectionsettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    connection_settings_property = elb.CfnLoadBalancer.ConnectionSettingsProperty(\n        idle_timeout=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle_timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.ConnectionSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.HealthCheckProperty
class CfnLoadBalancer_HealthCheckPropertyDef(BaseStruct):
    healthy_threshold: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of consecutive health checks successes required before moving the instance to the ``Healthy`` state.\n')
    interval: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The approximate interval, in seconds, between health checks of an individual instance.\n')
    target: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535. TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy. SSL is also specified as SSL: port pair, for example, SSL:5000. For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy. The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.\n')
    timeout: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of time, in seconds, during which no response means a failed health check. This value must be less than the ``Interval`` value.\n')
    unhealthy_threshold: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of consecutive health check failures required before moving the instance to the ``Unhealthy`` state.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancing-loadbalancer-healthcheck.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    health_check_property = elb.CfnLoadBalancer.HealthCheckProperty(\n        healthy_threshold="healthyThreshold",\n        interval="interval",\n        target="target",\n        timeout="timeout",\n        unhealthy_threshold="unhealthyThreshold"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['healthy_threshold', 'interval', 'target', 'timeout', 'unhealthy_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.HealthCheckProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.LBCookieStickinessPolicyProperty
class CfnLoadBalancer_LBCookieStickinessPolicyPropertyDef(BaseStruct):
    cookie_expiration_period: typing.Optional[str] = pydantic.Field(None, description='The time period, in seconds, after which the cookie should be considered stale. If this parameter is not specified, the stickiness session lasts for the duration of the browser session.\n')
    policy_name: typing.Optional[str] = pydantic.Field(None, description='The name of the policy. This name must be unique within the set of policies for this load balancer.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancing-loadbalancer-lbcookiestickinesspolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    l_bCookie_stickiness_policy_property = elb.CfnLoadBalancer.LBCookieStickinessPolicyProperty(\n        cookie_expiration_period="cookieExpirationPeriod",\n        policy_name="policyName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cookie_expiration_period', 'policy_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.LBCookieStickinessPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.ListenersProperty
class CfnLoadBalancer_ListenersPropertyDef(BaseStruct):
    instance_port: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The port on which the instance is listening.\n')
    load_balancer_port: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.\n')
    protocol: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The load balancer transport protocol to use for routing: HTTP, HTTPS, TCP, or SSL.\n')
    instance_protocol: typing.Optional[str] = pydantic.Field(None, description="The protocol to use for routing traffic to instances: HTTP, HTTPS, TCP, or SSL. If the front-end protocol is TCP or SSL, the back-end protocol must be TCP or SSL. If the front-end protocol is HTTP or HTTPS, the back-end protocol must be HTTP or HTTPS. If there is another listener with the same ``InstancePort`` whose ``InstanceProtocol`` is secure, (HTTPS or SSL), the listener's ``InstanceProtocol`` must also be secure. If there is another listener with the same ``InstancePort`` whose ``InstanceProtocol`` is HTTP or TCP, the listener's ``InstanceProtocol`` must be HTTP or TCP.\n")
    policy_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The names of the policies to associate with the listener.\n')
    ssl_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the server certificate.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancing-loadbalancer-listeners.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    listeners_property = elb.CfnLoadBalancer.ListenersProperty(\n        instance_port="instancePort",\n        load_balancer_port="loadBalancerPort",\n        protocol="protocol",\n\n        # the properties below are optional\n        instance_protocol="instanceProtocol",\n        policy_names=["policyNames"],\n        ssl_certificate_id="sslCertificateId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_port', 'load_balancer_port', 'protocol', 'instance_protocol', 'policy_names', 'ssl_certificate_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.ListenersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.PoliciesProperty
class CfnLoadBalancer_PoliciesPropertyDef(BaseStruct):
    attributes: typing.Union[_REQUIRED_INIT_PARAM, typing.Sequence[typing.Any], models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='The policy attributes.\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy.\n')
    policy_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy type.\n')
    instance_ports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The instance ports for the policy. Required only for some policy types.\n')
    load_balancer_ports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The load balancer ports for the policy. Required only for some policy types.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancing-loadbalancer-policies.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    # attributes: Any\n\n    policies_property = elb.CfnLoadBalancer.PoliciesProperty(\n        attributes=[attributes],\n        policy_name="policyName",\n        policy_type="policyType",\n\n        # the properties below are optional\n        instance_ports=["instancePorts"],\n        load_balancer_ports=["loadBalancerPorts"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attributes', 'policy_name', 'policy_type', 'instance_ports', 'load_balancer_ports']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer.PoliciesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.HealthCheck
class HealthCheckDef(BaseStruct):
    port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='What port number to health check on.\n')
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='After how many successful checks is an instance considered healthy. Default: 2\n')
    interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Number of seconds between health checks. Default: Duration.seconds(30)\n')
    path: typing.Optional[str] = pydantic.Field(None, description='What path to use for HTTP or HTTPS health check (must return 200). For SSL and TCP health checks, accepting connections is enough to be considered healthy. Default: "/"\n')
    protocol: typing.Optional[aws_cdk.aws_elasticloadbalancing.LoadBalancingProtocol] = pydantic.Field(None, description="What protocol to use for health checking. The protocol is automatically determined from the port if it's not supplied. Default: Automatic\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Health check timeout. Default: Duration.seconds(5)\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='After how many unsuccessful checks is an instance considered unhealthy. Default: 5\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.IVpc\n\n    # my_auto_scaling_group: autoscaling.AutoScalingGroup\n\n    lb = elb.LoadBalancer(self, "LB",\n        vpc=vpc,\n        internet_facing=True,\n        health_check=elb.HealthCheck(\n            port=80\n        )\n    )\n    lb.add_target(my_auto_scaling_group)\n    lb.add_listener(\n        external_port=80\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port', 'healthy_threshold', 'interval', 'path', 'protocol', 'timeout', 'unhealthy_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.HealthCheck'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.LoadBalancerListener
class LoadBalancerListenerDef(BaseStruct):
    external_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='External listening port.\n')
    allow_connections_from: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.aws_synthetics.CanaryDef]]] = pydantic.Field(None, description='Allow connections to the load balancer from the given set of connection peers. By default, connections will be allowed from anywhere. Set this to an empty list to deny connections, or supply a custom list of peers to allow connections from (IP ranges or security groups). Default: Anywhere\n')
    external_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancing.LoadBalancingProtocol] = pydantic.Field(None, description="What public protocol to use for load balancing. Either 'tcp', 'ssl', 'http' or 'https'. May be omitted if the external port is either 80 or 443.\n")
    internal_port: typing.Union[int, float, None] = pydantic.Field(None, description='Instance listening port. Same as the externalPort if not specified. Default: externalPort\n')
    internal_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancing.LoadBalancingProtocol] = pydantic.Field(None, description="What public protocol to use for load balancing. Either 'tcp', 'ssl', 'http' or 'https'. May be omitted if the internal port is either 80 or 443. The instance protocol is 'tcp' if the front-end protocol is 'tcp' or 'ssl', the instance protocol is 'http' if the front-end protocol is 'https'.\n")
    policy_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='SSL policy names.\n')
    ssl_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='the ARN of the SSL certificate. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.IVpc\n\n    # my_auto_scaling_group: autoscaling.AutoScalingGroup\n\n    lb = elb.LoadBalancer(self, "LB",\n        vpc=vpc,\n        internet_facing=True,\n        health_check=elb.HealthCheck(\n            port=80\n        )\n    )\n    lb.add_target(my_auto_scaling_group)\n    lb.add_listener(\n        external_port=80\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['external_port', 'allow_connections_from', 'external_protocol', 'internal_port', 'internal_protocol', 'policy_names', 'ssl_certificate_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.LoadBalancerListener'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_elasticloadbalancing.LoadBalancerProps
class LoadBalancerPropsDef(BaseStruct):
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='VPC network of the fleet instances.\n')
    access_logging_policy: typing.Union[models.aws_elasticloadbalancing.CfnLoadBalancer_AccessLoggingPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Enable Loadbalancer access logs Can be used to avoid manual work as aws console Required S3 bucket name , enabled flag Can add interval for pushing log Can set bucket prefix in order to provide folder name inside bucket. Default: - disabled\n')
    cross_zone: typing.Optional[bool] = pydantic.Field(None, description='Whether cross zone load balancing is enabled. This controls whether the load balancer evenly distributes requests across each availability zone Default: true\n')
    health_check: typing.Union[models.aws_elasticloadbalancing.HealthCheckDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Health check settings for the load balancing targets. Not required but recommended. Default: - None.\n')
    internet_facing: typing.Optional[bool] = pydantic.Field(None, description="Whether this is an internet-facing Load Balancer. This controls whether the LB has a public IP address assigned. It does not open up the Load Balancer's security groups to public internet access. Default: false\n")
    listeners: typing.Optional[typing.Sequence[typing.Union[models.aws_elasticloadbalancing.LoadBalancerListenerDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='What listeners to set up for the load balancer. Can also be added by .addListener() Default: -\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which subnets to deploy the load balancer. Can be used to define a specific set of subnets to deploy the load balancer to. Useful multiple public or private subnets are covering the same availability zone. Default: - Public subnets if internetFacing, Private subnets otherwise\n')
    targets: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ecs.BaseServiceDef, models.aws_ecs.Ec2ServiceDef, models.aws_ecs.ExternalServiceDef, models.aws_ecs.FargateServiceDef, models.aws_elasticloadbalancing.InstanceTargetDef]]] = pydantic.Field(None, description='What targets to load balance to. Can also be added by .addTarget() Default: - None.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n    # task_definition: ecs.TaskDefinition\n    # vpc: ec2.Vpc\n\n    service = ecs.Ec2Service(self, "Service", cluster=cluster, task_definition=task_definition)\n\n    lb = elb.LoadBalancer(self, "LB", vpc=vpc)\n    lb.add_listener(external_port=80)\n    lb.add_target(service.load_balancer_target(\n        container_name="MyContainer",\n        container_port=80\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'access_logging_policy', 'cross_zone', 'health_check', 'internet_facing', 'listeners', 'subnet_selection', 'targets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.LoadBalancerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LoadBalancerPropsDefConfig] = pydantic.Field(None)


class LoadBalancerPropsDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_elasticloadbalancing.LoadBalancingProtocol
# skipping emum

#  autogenerated from aws_cdk.aws_elasticloadbalancing.ILoadBalancerTarget
#  skipping Interface

#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer
class CfnLoadBalancerDef(BaseCfnResource):
    listeners: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_ListenersPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The listeners for the load balancer. You can specify at most one listener per port. If you update the properties for a listener, AWS CloudFormation deletes the existing listener and creates a new one with the specified properties. While the new listener is being created, clients cannot connect to the load balancer.\n')
    access_logging_policy: typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_AccessLoggingPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about where and how access logs are stored for the load balancer.\n')
    app_cookie_stickiness_policy: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_AppCookieStickinessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about a policy for application-controlled session stickiness.\n')
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Availability Zones for the load balancer. For load balancers in a VPC, specify ``Subnets`` instead. Update requires replacement if you did not previously specify an Availability Zone or if you are removing all Availability Zones. Otherwise, update requires no interruption.\n')
    connection_draining_policy: typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_ConnectionDrainingPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='If enabled, the load balancer allows existing requests to complete before the load balancer shifts traffic away from a deregistered or unhealthy instance. For more information, see `Configure connection draining <https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-conn-drain.html>`_ in the *User Guide for Classic Load Balancers* .\n')
    connection_settings: typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_ConnectionSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='If enabled, the load balancer allows the connections to remain idle (no data is sent over the connection) for the specified duration. By default, Elastic Load Balancing maintains a 60-second idle connection timeout for both front-end and back-end connections of your load balancer. For more information, see `Configure idle connection timeout <https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-idle-timeout.html>`_ in the *User Guide for Classic Load Balancers* .\n')
    cross_zone: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones. For more information, see `Configure cross-zone load balancing <https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-disable-crosszone-lb.html>`_ in the *User Guide for Classic Load Balancers* .\n')
    health_check: typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_HealthCheckPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The health check settings to use when evaluating the health of your EC2 instances. Update requires replacement if you did not previously specify health check settings or if you are removing the health check settings. Otherwise, update requires no interruption.\n')
    instances: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the instances for the load balancer.\n')
    lb_cookie_stickiness_policy: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_LBCookieStickinessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about a policy for duration-based session stickiness.\n')
    load_balancer_name: typing.Optional[str] = pydantic.Field(None, description="The name of the load balancer. This name must be unique within your set of load balancers for the region. If you don't specify a name, AWS CloudFormation generates a unique physical ID for the load balancer. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . If you specify a name, you cannot perform updates that require replacement of this resource, but you can perform other updates. To replace the resource, specify a new name.\n")
    policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_PoliciesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The policies defined for your Classic Load Balancer. Specify only back-end server policies.\n')
    scheme: typing.Optional[str] = pydantic.Field(None, description='The type of load balancer. Valid only for load balancers in a VPC. If ``Scheme`` is ``internet-facing`` , the load balancer has a public DNS name that resolves to a public IP address. If ``Scheme`` is ``internal`` , the load balancer has a public DNS name that resolves to a private IP address.\n')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security groups for the load balancer. Valid only for load balancers in a VPC.\n')
    subnets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the subnets for the load balancer. You can specify at most one subnet per Availability Zone. Update requires replacement if you did not previously specify a subnet or if you are removing all subnets. Otherwise, update requires no interruption. To update to a different subnet in the current Availability Zone, you must first update to a subnet in a different Availability Zone, then update to the new subnet in the original Availability Zone.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags associated with a load balancer.')
    _init_params: typing.ClassVar[list[str]] = ['listeners', 'access_logging_policy', 'app_cookie_stickiness_policy', 'availability_zones', 'connection_draining_policy', 'connection_settings', 'cross_zone', 'health_check', 'instances', 'lb_cookie_stickiness_policy', 'load_balancer_name', 'policies', 'scheme', 'security_groups', 'subnets', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AccessLoggingPolicyProperty', 'AppCookieStickinessPolicyProperty', 'ConnectionDrainingPolicyProperty', 'ConnectionSettingsProperty', 'HealthCheckProperty', 'LBCookieStickinessPolicyProperty', 'ListenersProperty', 'PoliciesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLoadBalancerDefConfig] = pydantic.Field(None)


class CfnLoadBalancerDefConfig(pydantic.BaseModel):
    AccessLoggingPolicyProperty: typing.Optional[list[CfnLoadBalancerDefAccessloggingpolicypropertyParams]] = pydantic.Field(None, description='')
    AppCookieStickinessPolicyProperty: typing.Optional[list[CfnLoadBalancerDefAppcookiestickinesspolicypropertyParams]] = pydantic.Field(None, description='')
    ConnectionDrainingPolicyProperty: typing.Optional[list[CfnLoadBalancerDefConnectiondrainingpolicypropertyParams]] = pydantic.Field(None, description='')
    ConnectionSettingsProperty: typing.Optional[list[CfnLoadBalancerDefConnectionsettingspropertyParams]] = pydantic.Field(None, description='')
    HealthCheckProperty: typing.Optional[list[CfnLoadBalancerDefHealthcheckpropertyParams]] = pydantic.Field(None, description='')
    LBCookieStickinessPolicyProperty: typing.Optional[list[CfnLoadBalancerDefLbcookiestickinesspolicypropertyParams]] = pydantic.Field(None, description='')
    ListenersProperty: typing.Optional[list[CfnLoadBalancerDefListenerspropertyParams]] = pydantic.Field(None, description='')
    PoliciesProperty: typing.Optional[list[CfnLoadBalancerDefPoliciespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnLoadBalancerDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLoadBalancerDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLoadBalancerDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLoadBalancerDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLoadBalancerDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLoadBalancerDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLoadBalancerDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLoadBalancerDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLoadBalancerDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLoadBalancerDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLoadBalancerDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLoadBalancerDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLoadBalancerDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnLoadBalancerDefAccessloggingpolicypropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    s3_bucket_name: str = pydantic.Field(..., description='')
    emit_interval: typing.Union[int, float, None] = pydantic.Field(None, description='')
    s3_bucket_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLoadBalancerDefAppcookiestickinesspolicypropertyParams(pydantic.BaseModel):
    cookie_name: str = pydantic.Field(..., description='')
    policy_name: str = pydantic.Field(..., description='')
    ...

class CfnLoadBalancerDefConnectiondrainingpolicypropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLoadBalancerDefConnectionsettingspropertyParams(pydantic.BaseModel):
    idle_timeout: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnLoadBalancerDefHealthcheckpropertyParams(pydantic.BaseModel):
    healthy_threshold: str = pydantic.Field(..., description='')
    interval: str = pydantic.Field(..., description='')
    target: str = pydantic.Field(..., description='')
    timeout: str = pydantic.Field(..., description='')
    unhealthy_threshold: str = pydantic.Field(..., description='')
    ...

class CfnLoadBalancerDefLbcookiestickinesspolicypropertyParams(pydantic.BaseModel):
    cookie_expiration_period: typing.Optional[str] = pydantic.Field(None, description='')
    policy_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLoadBalancerDefListenerspropertyParams(pydantic.BaseModel):
    instance_port: str = pydantic.Field(..., description='')
    load_balancer_port: str = pydantic.Field(..., description='')
    protocol: str = pydantic.Field(..., description='')
    instance_protocol: typing.Optional[str] = pydantic.Field(None, description='')
    policy_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ssl_certificate_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLoadBalancerDefPoliciespropertyParams(pydantic.BaseModel):
    attributes: typing.Union[typing.Sequence[typing.Any], models.UnsupportedResource] = pydantic.Field(..., description='')
    policy_name: str = pydantic.Field(..., description='')
    policy_type: str = pydantic.Field(..., description='')
    instance_ports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    load_balancer_ports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnLoadBalancerDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLoadBalancerDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoadBalancerDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLoadBalancerDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoadBalancerDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLoadBalancerDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLoadBalancerDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLoadBalancerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLoadBalancerDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLoadBalancerDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoadBalancerDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLoadBalancerDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLoadBalancerDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoadBalancerDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_elasticloadbalancing.CfnLoadBalancerProps
class CfnLoadBalancerPropsDef(BaseCfnProperty):
    listeners: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_ListenersPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The listeners for the load balancer. You can specify at most one listener per port. If you update the properties for a listener, AWS CloudFormation deletes the existing listener and creates a new one with the specified properties. While the new listener is being created, clients cannot connect to the load balancer.\n')
    access_logging_policy: typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_AccessLoggingPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about where and how access logs are stored for the load balancer.\n')
    app_cookie_stickiness_policy: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_AppCookieStickinessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about a policy for application-controlled session stickiness.\n')
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Availability Zones for the load balancer. For load balancers in a VPC, specify ``Subnets`` instead. Update requires replacement if you did not previously specify an Availability Zone or if you are removing all Availability Zones. Otherwise, update requires no interruption.\n')
    connection_draining_policy: typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_ConnectionDrainingPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='If enabled, the load balancer allows existing requests to complete before the load balancer shifts traffic away from a deregistered or unhealthy instance. For more information, see `Configure connection draining <https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-conn-drain.html>`_ in the *User Guide for Classic Load Balancers* .\n')
    connection_settings: typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_ConnectionSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='If enabled, the load balancer allows the connections to remain idle (no data is sent over the connection) for the specified duration. By default, Elastic Load Balancing maintains a 60-second idle connection timeout for both front-end and back-end connections of your load balancer. For more information, see `Configure idle connection timeout <https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-idle-timeout.html>`_ in the *User Guide for Classic Load Balancers* .\n')
    cross_zone: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones. For more information, see `Configure cross-zone load balancing <https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-disable-crosszone-lb.html>`_ in the *User Guide for Classic Load Balancers* .\n')
    health_check: typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_HealthCheckPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The health check settings to use when evaluating the health of your EC2 instances. Update requires replacement if you did not previously specify health check settings or if you are removing the health check settings. Otherwise, update requires no interruption.\n')
    instances: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the instances for the load balancer.\n')
    lb_cookie_stickiness_policy: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_LBCookieStickinessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about a policy for duration-based session stickiness.\n')
    load_balancer_name: typing.Optional[str] = pydantic.Field(None, description="The name of the load balancer. This name must be unique within your set of load balancers for the region. If you don't specify a name, AWS CloudFormation generates a unique physical ID for the load balancer. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . If you specify a name, you cannot perform updates that require replacement of this resource, but you can perform other updates. To replace the resource, specify a new name.\n")
    policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_elasticloadbalancing.CfnLoadBalancer_PoliciesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The policies defined for your Classic Load Balancer. Specify only back-end server policies.\n')
    scheme: typing.Optional[str] = pydantic.Field(None, description='The type of load balancer. Valid only for load balancers in a VPC. If ``Scheme`` is ``internet-facing`` , the load balancer has a public DNS name that resolves to a public IP address. If ``Scheme`` is ``internal`` , the load balancer has a public DNS name that resolves to a private IP address.\n')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security groups for the load balancer. Valid only for load balancers in a VPC.\n')
    subnets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the subnets for the load balancer. You can specify at most one subnet per Availability Zone. Update requires replacement if you did not previously specify a subnet or if you are removing all subnets. Otherwise, update requires no interruption. To update to a different subnet in the current Availability Zone, you must first update to a subnet in a different Availability Zone, then update to the new subnet in the original Availability Zone.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags associated with a load balancer.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancing-loadbalancer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_elasticloadbalancing as elb\n\n    # attributes: Any\n\n    cfn_load_balancer_props = elb.CfnLoadBalancerProps(\n        listeners=[elb.CfnLoadBalancer.ListenersProperty(\n            instance_port="instancePort",\n            load_balancer_port="loadBalancerPort",\n            protocol="protocol",\n\n            # the properties below are optional\n            instance_protocol="instanceProtocol",\n            policy_names=["policyNames"],\n            ssl_certificate_id="sslCertificateId"\n        )],\n\n        # the properties below are optional\n        access_logging_policy=elb.CfnLoadBalancer.AccessLoggingPolicyProperty(\n            enabled=False,\n            s3_bucket_name="s3BucketName",\n\n            # the properties below are optional\n            emit_interval=123,\n            s3_bucket_prefix="s3BucketPrefix"\n        ),\n        app_cookie_stickiness_policy=[elb.CfnLoadBalancer.AppCookieStickinessPolicyProperty(\n            cookie_name="cookieName",\n            policy_name="policyName"\n        )],\n        availability_zones=["availabilityZones"],\n        connection_draining_policy=elb.CfnLoadBalancer.ConnectionDrainingPolicyProperty(\n            enabled=False,\n\n            # the properties below are optional\n            timeout=123\n        ),\n        connection_settings=elb.CfnLoadBalancer.ConnectionSettingsProperty(\n            idle_timeout=123\n        ),\n        cross_zone=False,\n        health_check=elb.CfnLoadBalancer.HealthCheckProperty(\n            healthy_threshold="healthyThreshold",\n            interval="interval",\n            target="target",\n            timeout="timeout",\n            unhealthy_threshold="unhealthyThreshold"\n        ),\n        instances=["instances"],\n        lb_cookie_stickiness_policy=[elb.CfnLoadBalancer.LBCookieStickinessPolicyProperty(\n            cookie_expiration_period="cookieExpirationPeriod",\n            policy_name="policyName"\n        )],\n        load_balancer_name="loadBalancerName",\n        policies=[elb.CfnLoadBalancer.PoliciesProperty(\n            attributes=[attributes],\n            policy_name="policyName",\n            policy_type="policyType",\n\n            # the properties below are optional\n            instance_ports=["instancePorts"],\n            load_balancer_ports=["loadBalancerPorts"]\n        )],\n        scheme="scheme",\n        security_groups=["securityGroups"],\n        subnets=["subnets"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listeners', 'access_logging_policy', 'app_cookie_stickiness_policy', 'availability_zones', 'connection_draining_policy', 'connection_settings', 'cross_zone', 'health_check', 'instances', 'lb_cookie_stickiness_policy', 'load_balancer_name', 'policies', 'scheme', 'security_groups', 'subnets', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancing.CfnLoadBalancerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    InstanceTarget: typing.Optional[dict[str, InstanceTargetDef]] = pydantic.Field(None)
    ListenerPort: typing.Optional[dict[str, ListenerPortDef]] = pydantic.Field(None)
    LoadBalancer: typing.Optional[dict[str, LoadBalancerDef]] = pydantic.Field(None)
    CfnLoadBalancer_AccessLoggingPolicyProperty: typing.Optional[dict[str, CfnLoadBalancer_AccessLoggingPolicyPropertyDef]] = pydantic.Field(None)
    CfnLoadBalancer_AppCookieStickinessPolicyProperty: typing.Optional[dict[str, CfnLoadBalancer_AppCookieStickinessPolicyPropertyDef]] = pydantic.Field(None)
    CfnLoadBalancer_ConnectionDrainingPolicyProperty: typing.Optional[dict[str, CfnLoadBalancer_ConnectionDrainingPolicyPropertyDef]] = pydantic.Field(None)
    CfnLoadBalancer_ConnectionSettingsProperty: typing.Optional[dict[str, CfnLoadBalancer_ConnectionSettingsPropertyDef]] = pydantic.Field(None)
    CfnLoadBalancer_HealthCheckProperty: typing.Optional[dict[str, CfnLoadBalancer_HealthCheckPropertyDef]] = pydantic.Field(None)
    CfnLoadBalancer_LBCookieStickinessPolicyProperty: typing.Optional[dict[str, CfnLoadBalancer_LBCookieStickinessPolicyPropertyDef]] = pydantic.Field(None)
    CfnLoadBalancer_ListenersProperty: typing.Optional[dict[str, CfnLoadBalancer_ListenersPropertyDef]] = pydantic.Field(None)
    CfnLoadBalancer_PoliciesProperty: typing.Optional[dict[str, CfnLoadBalancer_PoliciesPropertyDef]] = pydantic.Field(None)
    HealthCheck: typing.Optional[dict[str, HealthCheckDef]] = pydantic.Field(None)
    LoadBalancerListener: typing.Optional[dict[str, LoadBalancerListenerDef]] = pydantic.Field(None)
    LoadBalancerProps: typing.Optional[dict[str, LoadBalancerPropsDef]] = pydantic.Field(None)
    CfnLoadBalancer: typing.Optional[dict[str, CfnLoadBalancerDef]] = pydantic.Field(None)
    CfnLoadBalancerProps: typing.Optional[dict[str, CfnLoadBalancerPropsDef]] = pydantic.Field(None)
    ...
