from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlow.EncryptionProperty
class CfnFlow_EncryptionPropertyDef(BaseStruct):
    role_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the role that you created during setup (when you set up MediaConnect as a trusted entity).\n')
    algorithm: typing.Optional[str] = pydantic.Field(None, description='The type of algorithm that is used for static key encryption (such as aes128, aes192, or aes256). If you are using SPEKE or SRT-password encryption, this property must be left blank.\n')
    constant_initialization_vector: typing.Optional[str] = pydantic.Field(None, description='A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.\n')
    device_id: typing.Optional[str] = pydantic.Field(None, description='The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    key_type: typing.Optional[str] = pydantic.Field(None, description="The type of key that is used for the encryption. If you don't specify a ``keyType`` value, the service uses the default setting ( ``static-key`` ). Valid key types are: ``static-key`` , ``speke`` , and ``srt-password`` .\n")
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    secret_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the secret that you created in AWS Secrets Manager to store the encryption key.\n')
    url: typing.Optional[str] = pydantic.Field(None, description='The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediaconnect-flow-encryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    encryption_property = mediaconnect.CfnFlow.EncryptionProperty(\n        role_arn="roleArn",\n\n        # the properties below are optional\n        algorithm="algorithm",\n        constant_initialization_vector="constantInitializationVector",\n        device_id="deviceId",\n        key_type="keyType",\n        region="region",\n        resource_id="resourceId",\n        secret_arn="secretArn",\n        url="url"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'algorithm', 'constant_initialization_vector', 'device_id', 'key_type', 'region', 'resource_id', 'secret_arn', 'url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlow.EncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlow.FailoverConfigProperty
class CfnFlow_FailoverConfigPropertyDef(BaseStruct):
    failover_mode: typing.Optional[str] = pydantic.Field(None, description='The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams. The string for this property must be entered as MERGE or FAILOVER. No other string entry is valid.\n')
    recovery_window: typing.Union[int, float, None] = pydantic.Field(None, description='The size of the buffer (delay) that the service maintains. A larger buffer means a longer delay in transmitting the stream, but more room for error correction. A smaller buffer means a shorter delay, but less room for error correction. You can choose a value from 100-500 ms. If you keep this field blank, the service uses the default value of 200 ms. This setting only applies when Failover Mode is set to MERGE.\n')
    source_priority: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlow_SourcePriorityPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams. This setting only applies when Failover Mode is set to FAILOVER.\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediaconnect-flow-failoverconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    failover_config_property = mediaconnect.CfnFlow.FailoverConfigProperty(\n        failover_mode="failoverMode",\n        recovery_window=123,\n        source_priority=mediaconnect.CfnFlow.SourcePriorityProperty(\n            primary_source="primarySource"\n        ),\n        state="state"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['failover_mode', 'recovery_window', 'source_priority', 'state']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlow.FailoverConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlow.SourcePriorityProperty
class CfnFlow_SourcePriorityPropertyDef(BaseStruct):
    primary_source: str = pydantic.Field(..., description='The name of the source you choose as the primary source for this flow.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediaconnect-flow-sourcepriority.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    source_priority_property = mediaconnect.CfnFlow.SourcePriorityProperty(\n        primary_source="primarySource"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['primary_source']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlow.SourcePriorityProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlow.SourceProperty
class CfnFlow_SourcePropertyDef(BaseStruct):
    decryption: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlow_EncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of encryption that is used on the content ingested from the source.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the source. This description is not visible outside of the current AWS account.\n')
    entitlement_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originatorâ€™s flow.\n')
    ingest_ip: typing.Optional[str] = pydantic.Field(None, description='The IP address that the flow listens on for incoming content.\n')
    ingest_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port that the flow listens on for incoming content. If the protocol of the source is Zixi, the port must be set to 2088.\n')
    max_bitrate: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum bitrate for RIST, RTP, and RTP-FEC streams.\n')
    max_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum latency in milliseconds for a RIST or Zixi-based source.\n')
    min_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senderâ€™s minimum latency and the receiverâ€™s minimum latency.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the source.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The protocol that is used by the source. AWS CloudFormation does not currently support CDI or ST 2110 JPEG XS source protocols.\n')
    sender_control_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port that the flow uses to send outbound requests to initiate connection with the sender.\n')
    sender_ip_address: typing.Optional[str] = pydantic.Field(None, description='The IP address that the flow communicates with to initiate connection with the sender.\n')
    source_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the source.\n')
    source_ingest_port: typing.Optional[str] = pydantic.Field(None, description='The port that the flow will be listening on for incoming content.\n')
    source_listener_address: typing.Optional[str] = pydantic.Field(None, description='Source IP or domain name for SRT-caller protocol.\n')
    source_listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Source port for SRT-caller protocol.\n')
    stream_id: typing.Optional[str] = pydantic.Field(None, description='The stream ID that you want to use for the transport. This parameter applies only to Zixi-based streams.\n')
    vpc_interface_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC interface that the source content comes from.\n')
    whitelist_cidr: typing.Optional[str] = pydantic.Field(None, description='The range of IP addresses that are allowed to contribute content to your source. Format the IP addresses as a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediaconnect-flow-source.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    source_property = mediaconnect.CfnFlow.SourceProperty(\n        decryption=mediaconnect.CfnFlow.EncryptionProperty(\n            role_arn="roleArn",\n\n            # the properties below are optional\n            algorithm="algorithm",\n            constant_initialization_vector="constantInitializationVector",\n            device_id="deviceId",\n            key_type="keyType",\n            region="region",\n            resource_id="resourceId",\n            secret_arn="secretArn",\n            url="url"\n        ),\n        description="description",\n        entitlement_arn="entitlementArn",\n        ingest_ip="ingestIp",\n        ingest_port=123,\n        max_bitrate=123,\n        max_latency=123,\n        min_latency=123,\n        name="name",\n        protocol="protocol",\n        sender_control_port=123,\n        sender_ip_address="senderIpAddress",\n        source_arn="sourceArn",\n        source_ingest_port="sourceIngestPort",\n        source_listener_address="sourceListenerAddress",\n        source_listener_port=123,\n        stream_id="streamId",\n        vpc_interface_name="vpcInterfaceName",\n        whitelist_cidr="whitelistCidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['decryption', 'description', 'entitlement_arn', 'ingest_ip', 'ingest_port', 'max_bitrate', 'max_latency', 'min_latency', 'name', 'protocol', 'sender_control_port', 'sender_ip_address', 'source_arn', 'source_ingest_port', 'source_listener_address', 'source_listener_port', 'stream_id', 'vpc_interface_name', 'whitelist_cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlow.SourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowEntitlement.EncryptionProperty
class CfnFlowEntitlement_EncryptionPropertyDef(BaseStruct):
    algorithm: str = pydantic.Field(..., description='The type of algorithm that is used for static key encryption (such as aes128, aes192, or aes256). If you are using SPEKE or SRT-password encryption, this property must be left blank.\n')
    role_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the role that you created during setup (when you set up MediaConnect as a trusted entity).\n')
    constant_initialization_vector: typing.Optional[str] = pydantic.Field(None, description='A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.\n')
    device_id: typing.Optional[str] = pydantic.Field(None, description='The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    key_type: typing.Optional[str] = pydantic.Field(None, description="The type of key that is used for the encryption. If you don't specify a ``keyType`` value, the service uses the default setting ( ``static-key`` ). Valid key types are: ``static-key`` , ``speke`` , and ``srt-password`` .\n")
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    secret_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the secret that you created in AWS Secrets Manager to store the encryption key.\n')
    url: typing.Optional[str] = pydantic.Field(None, description='The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediaconnect-flowentitlement-encryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    encryption_property = mediaconnect.CfnFlowEntitlement.EncryptionProperty(\n        algorithm="algorithm",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        constant_initialization_vector="constantInitializationVector",\n        device_id="deviceId",\n        key_type="keyType",\n        region="region",\n        resource_id="resourceId",\n        secret_arn="secretArn",\n        url="url"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['algorithm', 'role_arn', 'constant_initialization_vector', 'device_id', 'key_type', 'region', 'resource_id', 'secret_arn', 'url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowEntitlement.EncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowOutput.EncryptionProperty
class CfnFlowOutput_EncryptionPropertyDef(BaseStruct):
    role_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the role that you created during setup (when you set up MediaConnect as a trusted entity).\n')
    secret_arn: str = pydantic.Field(..., description='The ARN of the secret that you created in AWS Secrets Manager to store the encryption key.\n')
    algorithm: typing.Optional[str] = pydantic.Field(None, description='The type of algorithm that is used for static key encryption (such as aes128, aes192, or aes256). If you are using SPEKE or SRT-password encryption, this property must be left blank.\n')
    key_type: typing.Optional[str] = pydantic.Field(None, description='The type of key that is used for the encryption. If you don\'t specify a ``keyType`` value, the service uses the default setting ( ``static-key`` ). Valid key types are: ``static-key`` , ``speke`` , and ``srt-password`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediaconnect-flowoutput-encryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    encryption_property = mediaconnect.CfnFlowOutput.EncryptionProperty(\n        role_arn="roleArn",\n        secret_arn="secretArn",\n\n        # the properties below are optional\n        algorithm="algorithm",\n        key_type="keyType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'secret_arn', 'algorithm', 'key_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowOutput.EncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowOutput.VpcInterfaceAttachmentProperty
class CfnFlowOutput_VpcInterfaceAttachmentPropertyDef(BaseStruct):
    vpc_interface_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC interface that you want to send your output to.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediaconnect-flowoutput-vpcinterfaceattachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    vpc_interface_attachment_property = mediaconnect.CfnFlowOutput.VpcInterfaceAttachmentProperty(\n        vpc_interface_name="vpcInterfaceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_interface_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowOutput.VpcInterfaceAttachmentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowSource.EncryptionProperty
class CfnFlowSource_EncryptionPropertyDef(BaseStruct):
    role_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the role that you created during setup (when you set up MediaConnect as a trusted entity).\n')
    algorithm: typing.Optional[str] = pydantic.Field(None, description='The type of algorithm that is used for static key encryption (such as aes128, aes192, or aes256). If you are using SPEKE or SRT-password encryption, this property must be left blank.\n')
    constant_initialization_vector: typing.Optional[str] = pydantic.Field(None, description='A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.\n')
    device_id: typing.Optional[str] = pydantic.Field(None, description='The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    key_type: typing.Optional[str] = pydantic.Field(None, description="The type of key that is used for the encryption. If you don't specify a ``keyType`` value, the service uses the default setting ( ``static-key`` ). Valid key types are: ``static-key`` , ``speke`` , and ``srt-password`` .\n")
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n')
    secret_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the secret that you created in AWS Secrets Manager to store the encryption key.\n')
    url: typing.Optional[str] = pydantic.Field(None, description='The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediaconnect-flowsource-encryption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    encryption_property = mediaconnect.CfnFlowSource.EncryptionProperty(\n        role_arn="roleArn",\n\n        # the properties below are optional\n        algorithm="algorithm",\n        constant_initialization_vector="constantInitializationVector",\n        device_id="deviceId",\n        key_type="keyType",\n        region="region",\n        resource_id="resourceId",\n        secret_arn="secretArn",\n        url="url"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'algorithm', 'constant_initialization_vector', 'device_id', 'key_type', 'region', 'resource_id', 'secret_arn', 'url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowSource.EncryptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlow
class CfnFlowDef(BaseCfnResource):
    name: str = pydantic.Field(..., description='The name of the flow.\n')
    source: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlow_SourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The settings for the source that you want to use for the new flow.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS Region.\n')
    source_failover_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlow_FailoverConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The settings for source failover.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'source', 'availability_zone', 'source_failover_config']
    _method_names: typing.ClassVar[list[str]] = ['EncryptionProperty', 'FailoverConfigProperty', 'SourcePriorityProperty', 'SourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlow'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFlowDefConfig] = pydantic.Field(None)


class CfnFlowDefConfig(pydantic.BaseModel):
    EncryptionProperty: typing.Optional[list[CfnFlowDefEncryptionpropertyParams]] = pydantic.Field(None, description='')
    FailoverConfigProperty: typing.Optional[list[CfnFlowDefFailoverconfigpropertyParams]] = pydantic.Field(None, description='')
    SourcePriorityProperty: typing.Optional[list[CfnFlowDefSourceprioritypropertyParams]] = pydantic.Field(None, description='')
    SourceProperty: typing.Optional[list[CfnFlowDefSourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnFlowDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFlowDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFlowDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFlowDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFlowDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFlowDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFlowDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFlowDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFlowDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFlowDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFlowDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFlowDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFlowDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnFlowDefEncryptionpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    algorithm: typing.Optional[str] = pydantic.Field(None, description='')
    constant_initialization_vector: typing.Optional[str] = pydantic.Field(None, description='')
    device_id: typing.Optional[str] = pydantic.Field(None, description='')
    key_type: typing.Optional[str] = pydantic.Field(None, description='')
    region: typing.Optional[str] = pydantic.Field(None, description='')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='')
    secret_arn: typing.Optional[str] = pydantic.Field(None, description='')
    url: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFlowDefFailoverconfigpropertyParams(pydantic.BaseModel):
    failover_mode: typing.Optional[str] = pydantic.Field(None, description='')
    recovery_window: typing.Union[int, float, None] = pydantic.Field(None, description='')
    source_priority: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlow_SourcePriorityPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    state: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFlowDefSourceprioritypropertyParams(pydantic.BaseModel):
    primary_source: str = pydantic.Field(..., description='')
    ...

class CfnFlowDefSourcepropertyParams(pydantic.BaseModel):
    decryption: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlow_EncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    entitlement_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ingest_ip: typing.Optional[str] = pydantic.Field(None, description='')
    ingest_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_bitrate: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_latency: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min_latency: typing.Union[int, float, None] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    sender_control_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    sender_ip_address: typing.Optional[str] = pydantic.Field(None, description='')
    source_arn: typing.Optional[str] = pydantic.Field(None, description='')
    source_ingest_port: typing.Optional[str] = pydantic.Field(None, description='')
    source_listener_address: typing.Optional[str] = pydantic.Field(None, description='')
    source_listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stream_id: typing.Optional[str] = pydantic.Field(None, description='')
    vpc_interface_name: typing.Optional[str] = pydantic.Field(None, description='')
    whitelist_cidr: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFlowDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFlowDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFlowDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFlowDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFlowDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFlowDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFlowDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFlowDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnFlowDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFlowDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowEntitlement
class CfnFlowEntitlementDef(BaseCfnResource):
    description: str = pydantic.Field(..., description='A description of the entitlement. This description appears only on the MediaConnect console and is not visible outside of the current AWS account.\n')
    flow_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the flow.\n')
    name: str = pydantic.Field(..., description='The name of the entitlement. This value must be unique within the current flow.\n')
    subscribers: typing.Sequence[str] = pydantic.Field(..., description='The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flows using your content as the source.\n')
    data_transfer_subscriber_fee_percent: typing.Union[int, float, None] = pydantic.Field(None, description='The percentage of the entitlement data transfer fee that you want the subscriber to be responsible for.\n')
    encryption: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlowEntitlement_EncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of encryption that MediaConnect will use on the output that is associated with the entitlement.\n')
    entitlement_status: typing.Optional[str] = pydantic.Field(None, description='An indication of whether the new entitlement should be enabled or disabled as soon as it is created. If you donâ€™t specify the entitlementStatus field in your request, MediaConnect sets it to ENABLED.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'flow_arn', 'name', 'subscribers', 'data_transfer_subscriber_fee_percent', 'encryption', 'entitlement_status']
    _method_names: typing.ClassVar[list[str]] = ['EncryptionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowEntitlement'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFlowEntitlementDefConfig] = pydantic.Field(None)


class CfnFlowEntitlementDefConfig(pydantic.BaseModel):
    EncryptionProperty: typing.Optional[list[CfnFlowEntitlementDefEncryptionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnFlowEntitlementDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFlowEntitlementDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFlowEntitlementDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFlowEntitlementDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFlowEntitlementDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFlowEntitlementDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFlowEntitlementDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFlowEntitlementDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFlowEntitlementDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFlowEntitlementDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFlowEntitlementDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFlowEntitlementDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFlowEntitlementDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnFlowEntitlementDefEncryptionpropertyParams(pydantic.BaseModel):
    algorithm: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    constant_initialization_vector: typing.Optional[str] = pydantic.Field(None, description='')
    device_id: typing.Optional[str] = pydantic.Field(None, description='')
    key_type: typing.Optional[str] = pydantic.Field(None, description='')
    region: typing.Optional[str] = pydantic.Field(None, description='')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='')
    secret_arn: typing.Optional[str] = pydantic.Field(None, description='')
    url: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFlowEntitlementDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFlowEntitlementDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowEntitlementDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFlowEntitlementDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowEntitlementDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFlowEntitlementDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFlowEntitlementDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFlowEntitlementDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFlowEntitlementDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFlowEntitlementDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowEntitlementDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnFlowEntitlementDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFlowEntitlementDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowEntitlementDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowOutput
class CfnFlowOutputDef(BaseCfnResource):
    flow_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the flow this output is attached to.\n')
    protocol: str = pydantic.Field(..., description='The protocol to use for the output.\n')
    cidr_allow_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The range of IP addresses that are allowed to initiate output requests to this flow. Format the IP addresses as a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the output. This description is not visible outside of the current AWS account even if the account grants entitlements to other accounts.\n')
    destination: typing.Optional[str] = pydantic.Field(None, description='The IP address where you want to send the output.\n')
    encryption: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlowOutput_EncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption credentials that you want to use for the output.\n')
    max_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.\n')
    min_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senderâ€™s minimum latency and the receiverâ€™s minimum latency.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC interface.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port to use when MediaConnect distributes content to the output.\n')
    remote_id: typing.Optional[str] = pydantic.Field(None, description='The identifier that is assigned to the Zixi receiver. This parameter applies only to outputs that use Zixi pull.\n')
    smoothing_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.\n')
    stream_id: typing.Optional[str] = pydantic.Field(None, description='The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.\n')
    vpc_interface_attachment: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlowOutput_VpcInterfaceAttachmentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The VPC interface that you want to send your output to.')
    _init_params: typing.ClassVar[list[str]] = ['flow_arn', 'protocol', 'cidr_allow_list', 'description', 'destination', 'encryption', 'max_latency', 'min_latency', 'name', 'port', 'remote_id', 'smoothing_latency', 'stream_id', 'vpc_interface_attachment']
    _method_names: typing.ClassVar[list[str]] = ['EncryptionProperty', 'VpcInterfaceAttachmentProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowOutput'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFlowOutputDefConfig] = pydantic.Field(None)


class CfnFlowOutputDefConfig(pydantic.BaseModel):
    EncryptionProperty: typing.Optional[list[CfnFlowOutputDefEncryptionpropertyParams]] = pydantic.Field(None, description='')
    VpcInterfaceAttachmentProperty: typing.Optional[list[CfnFlowOutputDefVpcinterfaceattachmentpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnFlowOutputDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFlowOutputDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFlowOutputDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFlowOutputDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFlowOutputDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFlowOutputDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFlowOutputDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFlowOutputDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFlowOutputDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFlowOutputDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFlowOutputDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFlowOutputDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFlowOutputDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnFlowOutputDefEncryptionpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    secret_arn: str = pydantic.Field(..., description='')
    algorithm: typing.Optional[str] = pydantic.Field(None, description='')
    key_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFlowOutputDefVpcinterfaceattachmentpropertyParams(pydantic.BaseModel):
    vpc_interface_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFlowOutputDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFlowOutputDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowOutputDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFlowOutputDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowOutputDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFlowOutputDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFlowOutputDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFlowOutputDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFlowOutputDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFlowOutputDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowOutputDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnFlowOutputDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFlowOutputDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowOutputDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowSource
class CfnFlowSourceDef(BaseCfnResource):
    description: str = pydantic.Field(..., description='A description of the source. This description is not visible outside of the current AWS account.\n')
    name: str = pydantic.Field(..., description='The name of the source.\n')
    decryption: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlowSource_EncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of encryption that is used on the content ingested from the source.\n')
    entitlement_arn: typing.Optional[str] = pydantic.Field(None, description="The ARN of the entitlement that allows you to subscribe to the flow. The entitlement is set by the content originator, and the ARN is generated as part of the originator's flow.\n")
    flow_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the flow this source is connected to. The flow must have Failover enabled to add an additional source.\n')
    ingest_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port that the flow listens on for incoming content. If the protocol of the source is Zixi, the port must be set to 2088.\n')
    max_bitrate: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum bitrate for RIST, RTP, and RTP-FEC streams.\n')
    max_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.\n')
    min_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senderâ€™s minimum latency and the receiverâ€™s minimum latency.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description="The protocol that the source uses to deliver the content to MediaConnect. Adding additional sources to an existing flow requires Failover to be enabled. When you enable Failover, the additional source must use the same protocol as the existing source. Only the following protocols support failover: Zixi-push, RTP-FEC, RTP, RIST and SRT protocols. If you use failover with SRT caller or listener, the ``FailoverMode`` property must be set to ``FAILOVER`` . The ``FailoverMode`` property is found in the ``FailoverConfig`` resource of the same flow ARN you used for the source's ``FlowArn`` property. SRT caller/listener does not support merge mode failover.\n")
    sender_control_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port that the flow uses to send outbound requests to initiate connection with the sender.\n')
    sender_ip_address: typing.Optional[str] = pydantic.Field(None, description='The IP address that the flow communicates with to initiate connection with the sender.\n')
    source_listener_address: typing.Optional[str] = pydantic.Field(None, description='Source IP or domain name for SRT-caller protocol.\n')
    source_listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Source port for SRT-caller protocol.\n')
    stream_id: typing.Optional[str] = pydantic.Field(None, description='The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.\n')
    vpc_interface_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC interface that you want to send your output to.\n')
    whitelist_cidr: typing.Optional[str] = pydantic.Field(None, description='The range of IP addresses that are allowed to contribute content to your source. Format the IP addresses as a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'name', 'decryption', 'entitlement_arn', 'flow_arn', 'ingest_port', 'max_bitrate', 'max_latency', 'min_latency', 'protocol', 'sender_control_port', 'sender_ip_address', 'source_listener_address', 'source_listener_port', 'stream_id', 'vpc_interface_name', 'whitelist_cidr']
    _method_names: typing.ClassVar[list[str]] = ['EncryptionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFlowSourceDefConfig] = pydantic.Field(None)


class CfnFlowSourceDefConfig(pydantic.BaseModel):
    EncryptionProperty: typing.Optional[list[CfnFlowSourceDefEncryptionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnFlowSourceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFlowSourceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFlowSourceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFlowSourceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFlowSourceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFlowSourceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFlowSourceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFlowSourceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFlowSourceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFlowSourceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFlowSourceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFlowSourceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFlowSourceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnFlowSourceDefEncryptionpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    algorithm: typing.Optional[str] = pydantic.Field(None, description='')
    constant_initialization_vector: typing.Optional[str] = pydantic.Field(None, description='')
    device_id: typing.Optional[str] = pydantic.Field(None, description='')
    key_type: typing.Optional[str] = pydantic.Field(None, description='')
    region: typing.Optional[str] = pydantic.Field(None, description='')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='')
    secret_arn: typing.Optional[str] = pydantic.Field(None, description='')
    url: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFlowSourceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFlowSourceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowSourceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFlowSourceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowSourceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFlowSourceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFlowSourceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFlowSourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFlowSourceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFlowSourceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowSourceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnFlowSourceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFlowSourceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowSourceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowVpcInterface
class CfnFlowVpcInterfaceDef(BaseCfnResource):
    flow_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the flow.\n')
    name: str = pydantic.Field(..., description='The name of the VPC Interface. This value must be unique within the current flow.\n')
    role_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the role that you created when you set up MediaConnect as a trusted service.\n')
    security_group_ids: typing.Sequence[str] = pydantic.Field(..., description='The VPC security groups that you want MediaConnect to use for your VPC configuration. You must include at least one security group in the request.\n')
    subnet_id: str = pydantic.Field(..., description='The subnet IDs that you want to use for your VPC interface. A range of IP addresses in your VPC. When you create your VPC, you specify a range of IPv4 addresses for the VPC in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16. This is the primary CIDR block for your VPC. When you create a subnet for your VPC, you specify the CIDR block for the subnet, which is a subset of the VPC CIDR block. The subnets that you use across all VPC interfaces on the flow must be in the same Availability Zone as the flow.')
    _init_params: typing.ClassVar[list[str]] = ['flow_arn', 'name', 'role_arn', 'security_group_ids', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowVpcInterface'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFlowVpcInterfaceDefConfig] = pydantic.Field(None)


class CfnFlowVpcInterfaceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnFlowVpcInterfaceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFlowVpcInterfaceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFlowVpcInterfaceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFlowVpcInterfaceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFlowVpcInterfaceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFlowVpcInterfaceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFlowVpcInterfaceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFlowVpcInterfaceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFlowVpcInterfaceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFlowVpcInterfaceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFlowVpcInterfaceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFlowVpcInterfaceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFlowVpcInterfaceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnFlowVpcInterfaceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFlowVpcInterfaceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowVpcInterfaceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFlowVpcInterfaceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowVpcInterfaceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFlowVpcInterfaceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFlowVpcInterfaceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFlowVpcInterfaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFlowVpcInterfaceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFlowVpcInterfaceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowVpcInterfaceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnFlowVpcInterfaceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFlowVpcInterfaceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowVpcInterfaceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowEntitlementProps
class CfnFlowEntitlementPropsDef(BaseCfnProperty):
    description: str = pydantic.Field(..., description='A description of the entitlement. This description appears only on the MediaConnect console and is not visible outside of the current AWS account.\n')
    flow_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the flow.\n')
    name: str = pydantic.Field(..., description='The name of the entitlement. This value must be unique within the current flow.\n')
    subscribers: typing.Sequence[str] = pydantic.Field(..., description='The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flows using your content as the source.\n')
    data_transfer_subscriber_fee_percent: typing.Union[int, float, None] = pydantic.Field(None, description='The percentage of the entitlement data transfer fee that you want the subscriber to be responsible for.\n')
    encryption: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlowEntitlement_EncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of encryption that MediaConnect will use on the output that is associated with the entitlement.\n')
    entitlement_status: typing.Optional[str] = pydantic.Field(None, description='An indication of whether the new entitlement should be enabled or disabled as soon as it is created. If you donâ€™t specify the entitlementStatus field in your request, MediaConnect sets it to ENABLED.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediaconnect-flowentitlement.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    cfn_flow_entitlement_props = mediaconnect.CfnFlowEntitlementProps(\n        description="description",\n        flow_arn="flowArn",\n        name="name",\n        subscribers=["subscribers"],\n\n        # the properties below are optional\n        data_transfer_subscriber_fee_percent=123,\n        encryption=mediaconnect.CfnFlowEntitlement.EncryptionProperty(\n            algorithm="algorithm",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            constant_initialization_vector="constantInitializationVector",\n            device_id="deviceId",\n            key_type="keyType",\n            region="region",\n            resource_id="resourceId",\n            secret_arn="secretArn",\n            url="url"\n        ),\n        entitlement_status="entitlementStatus"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'flow_arn', 'name', 'subscribers', 'data_transfer_subscriber_fee_percent', 'encryption', 'entitlement_status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowEntitlementProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowOutputProps
class CfnFlowOutputPropsDef(BaseCfnProperty):
    flow_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the flow this output is attached to.\n')
    protocol: str = pydantic.Field(..., description='The protocol to use for the output.\n')
    cidr_allow_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The range of IP addresses that are allowed to initiate output requests to this flow. Format the IP addresses as a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the output. This description is not visible outside of the current AWS account even if the account grants entitlements to other accounts.\n')
    destination: typing.Optional[str] = pydantic.Field(None, description='The IP address where you want to send the output.\n')
    encryption: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlowOutput_EncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption credentials that you want to use for the output.\n')
    max_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.\n')
    min_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senderâ€™s minimum latency and the receiverâ€™s minimum latency.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC interface.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port to use when MediaConnect distributes content to the output.\n')
    remote_id: typing.Optional[str] = pydantic.Field(None, description='The identifier that is assigned to the Zixi receiver. This parameter applies only to outputs that use Zixi pull.\n')
    smoothing_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.\n')
    stream_id: typing.Optional[str] = pydantic.Field(None, description='The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.\n')
    vpc_interface_attachment: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlowOutput_VpcInterfaceAttachmentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The VPC interface that you want to send your output to.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediaconnect-flowoutput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    cfn_flow_output_props = mediaconnect.CfnFlowOutputProps(\n        flow_arn="flowArn",\n        protocol="protocol",\n\n        # the properties below are optional\n        cidr_allow_list=["cidrAllowList"],\n        description="description",\n        destination="destination",\n        encryption=mediaconnect.CfnFlowOutput.EncryptionProperty(\n            role_arn="roleArn",\n            secret_arn="secretArn",\n\n            # the properties below are optional\n            algorithm="algorithm",\n            key_type="keyType"\n        ),\n        max_latency=123,\n        min_latency=123,\n        name="name",\n        port=123,\n        remote_id="remoteId",\n        smoothing_latency=123,\n        stream_id="streamId",\n        vpc_interface_attachment=mediaconnect.CfnFlowOutput.VpcInterfaceAttachmentProperty(\n            vpc_interface_name="vpcInterfaceName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['flow_arn', 'protocol', 'cidr_allow_list', 'description', 'destination', 'encryption', 'max_latency', 'min_latency', 'name', 'port', 'remote_id', 'smoothing_latency', 'stream_id', 'vpc_interface_attachment']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowOutputProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowProps
class CfnFlowPropsDef(BaseCfnProperty):
    name: str = pydantic.Field(..., description='The name of the flow.\n')
    source: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlow_SourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The settings for the source that you want to use for the new flow.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS Region.\n')
    source_failover_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlow_FailoverConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The settings for source failover.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediaconnect-flow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    cfn_flow_props = mediaconnect.CfnFlowProps(\n        name="name",\n        source=mediaconnect.CfnFlow.SourceProperty(\n            decryption=mediaconnect.CfnFlow.EncryptionProperty(\n                role_arn="roleArn",\n\n                # the properties below are optional\n                algorithm="algorithm",\n                constant_initialization_vector="constantInitializationVector",\n                device_id="deviceId",\n                key_type="keyType",\n                region="region",\n                resource_id="resourceId",\n                secret_arn="secretArn",\n                url="url"\n            ),\n            description="description",\n            entitlement_arn="entitlementArn",\n            ingest_ip="ingestIp",\n            ingest_port=123,\n            max_bitrate=123,\n            max_latency=123,\n            min_latency=123,\n            name="name",\n            protocol="protocol",\n            sender_control_port=123,\n            sender_ip_address="senderIpAddress",\n            source_arn="sourceArn",\n            source_ingest_port="sourceIngestPort",\n            source_listener_address="sourceListenerAddress",\n            source_listener_port=123,\n            stream_id="streamId",\n            vpc_interface_name="vpcInterfaceName",\n            whitelist_cidr="whitelistCidr"\n        ),\n\n        # the properties below are optional\n        availability_zone="availabilityZone",\n        source_failover_config=mediaconnect.CfnFlow.FailoverConfigProperty(\n            failover_mode="failoverMode",\n            recovery_window=123,\n            source_priority=mediaconnect.CfnFlow.SourcePriorityProperty(\n                primary_source="primarySource"\n            ),\n            state="state"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'source', 'availability_zone', 'source_failover_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowSourceProps
class CfnFlowSourcePropsDef(BaseCfnProperty):
    description: str = pydantic.Field(..., description='A description of the source. This description is not visible outside of the current AWS account.\n')
    name: str = pydantic.Field(..., description='The name of the source.\n')
    decryption: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_mediaconnect.CfnFlowSource_EncryptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of encryption that is used on the content ingested from the source.\n')
    entitlement_arn: typing.Optional[str] = pydantic.Field(None, description="The ARN of the entitlement that allows you to subscribe to the flow. The entitlement is set by the content originator, and the ARN is generated as part of the originator's flow.\n")
    flow_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the flow this source is connected to. The flow must have Failover enabled to add an additional source.\n')
    ingest_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port that the flow listens on for incoming content. If the protocol of the source is Zixi, the port must be set to 2088.\n')
    max_bitrate: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum bitrate for RIST, RTP, and RTP-FEC streams.\n')
    max_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum latency in milliseconds. This parameter applies only to RIST-based, Zixi-based, and Fujitsu-based streams.\n')
    min_latency: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senderâ€™s minimum latency and the receiverâ€™s minimum latency.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description="The protocol that the source uses to deliver the content to MediaConnect. Adding additional sources to an existing flow requires Failover to be enabled. When you enable Failover, the additional source must use the same protocol as the existing source. Only the following protocols support failover: Zixi-push, RTP-FEC, RTP, RIST and SRT protocols. If you use failover with SRT caller or listener, the ``FailoverMode`` property must be set to ``FAILOVER`` . The ``FailoverMode`` property is found in the ``FailoverConfig`` resource of the same flow ARN you used for the source's ``FlowArn`` property. SRT caller/listener does not support merge mode failover.\n")
    sender_control_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port that the flow uses to send outbound requests to initiate connection with the sender.\n')
    sender_ip_address: typing.Optional[str] = pydantic.Field(None, description='The IP address that the flow communicates with to initiate connection with the sender.\n')
    source_listener_address: typing.Optional[str] = pydantic.Field(None, description='Source IP or domain name for SRT-caller protocol.\n')
    source_listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Source port for SRT-caller protocol.\n')
    stream_id: typing.Optional[str] = pydantic.Field(None, description='The stream ID that you want to use for this transport. This parameter applies only to Zixi and SRT caller-based streams.\n')
    vpc_interface_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC interface that you want to send your output to.\n')
    whitelist_cidr: typing.Optional[str] = pydantic.Field(None, description='The range of IP addresses that are allowed to contribute content to your source. Format the IP addresses as a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediaconnect-flowsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    cfn_flow_source_props = mediaconnect.CfnFlowSourceProps(\n        description="description",\n        name="name",\n\n        # the properties below are optional\n        decryption=mediaconnect.CfnFlowSource.EncryptionProperty(\n            role_arn="roleArn",\n\n            # the properties below are optional\n            algorithm="algorithm",\n            constant_initialization_vector="constantInitializationVector",\n            device_id="deviceId",\n            key_type="keyType",\n            region="region",\n            resource_id="resourceId",\n            secret_arn="secretArn",\n            url="url"\n        ),\n        entitlement_arn="entitlementArn",\n        flow_arn="flowArn",\n        ingest_port=123,\n        max_bitrate=123,\n        max_latency=123,\n        min_latency=123,\n        protocol="protocol",\n        sender_control_port=123,\n        sender_ip_address="senderIpAddress",\n        source_listener_address="sourceListenerAddress",\n        source_listener_port=123,\n        stream_id="streamId",\n        vpc_interface_name="vpcInterfaceName",\n        whitelist_cidr="whitelistCidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'name', 'decryption', 'entitlement_arn', 'flow_arn', 'ingest_port', 'max_bitrate', 'max_latency', 'min_latency', 'protocol', 'sender_control_port', 'sender_ip_address', 'source_listener_address', 'source_listener_port', 'stream_id', 'vpc_interface_name', 'whitelist_cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowSourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediaconnect.CfnFlowVpcInterfaceProps
class CfnFlowVpcInterfacePropsDef(BaseCfnProperty):
    flow_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the flow.\n')
    name: str = pydantic.Field(..., description='The name of the VPC Interface. This value must be unique within the current flow.\n')
    role_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the role that you created when you set up MediaConnect as a trusted service.\n')
    security_group_ids: typing.Sequence[str] = pydantic.Field(..., description='The VPC security groups that you want MediaConnect to use for your VPC configuration. You must include at least one security group in the request.\n')
    subnet_id: str = pydantic.Field(..., description='The subnet IDs that you want to use for your VPC interface. A range of IP addresses in your VPC. When you create your VPC, you specify a range of IPv4 addresses for the VPC in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16. This is the primary CIDR block for your VPC. When you create a subnet for your VPC, you specify the CIDR block for the subnet, which is a subset of the VPC CIDR block. The subnets that you use across all VPC interfaces on the flow must be in the same Availability Zone as the flow.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediaconnect-flowvpcinterface.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediaconnect as mediaconnect\n\n    cfn_flow_vpc_interface_props = mediaconnect.CfnFlowVpcInterfaceProps(\n        flow_arn="flowArn",\n        name="name",\n        role_arn="roleArn",\n        security_group_ids=["securityGroupIds"],\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['flow_arn', 'name', 'role_arn', 'security_group_ids', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediaconnect.CfnFlowVpcInterfaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnFlow_EncryptionProperty: typing.Optional[dict[str, CfnFlow_EncryptionPropertyDef]] = pydantic.Field(None)
    CfnFlow_FailoverConfigProperty: typing.Optional[dict[str, CfnFlow_FailoverConfigPropertyDef]] = pydantic.Field(None)
    CfnFlow_SourcePriorityProperty: typing.Optional[dict[str, CfnFlow_SourcePriorityPropertyDef]] = pydantic.Field(None)
    CfnFlow_SourceProperty: typing.Optional[dict[str, CfnFlow_SourcePropertyDef]] = pydantic.Field(None)
    CfnFlowEntitlement_EncryptionProperty: typing.Optional[dict[str, CfnFlowEntitlement_EncryptionPropertyDef]] = pydantic.Field(None)
    CfnFlowOutput_EncryptionProperty: typing.Optional[dict[str, CfnFlowOutput_EncryptionPropertyDef]] = pydantic.Field(None)
    CfnFlowOutput_VpcInterfaceAttachmentProperty: typing.Optional[dict[str, CfnFlowOutput_VpcInterfaceAttachmentPropertyDef]] = pydantic.Field(None)
    CfnFlowSource_EncryptionProperty: typing.Optional[dict[str, CfnFlowSource_EncryptionPropertyDef]] = pydantic.Field(None)
    CfnFlow: typing.Optional[dict[str, CfnFlowDef]] = pydantic.Field(None)
    CfnFlowEntitlement: typing.Optional[dict[str, CfnFlowEntitlementDef]] = pydantic.Field(None)
    CfnFlowOutput: typing.Optional[dict[str, CfnFlowOutputDef]] = pydantic.Field(None)
    CfnFlowSource: typing.Optional[dict[str, CfnFlowSourceDef]] = pydantic.Field(None)
    CfnFlowVpcInterface: typing.Optional[dict[str, CfnFlowVpcInterfaceDef]] = pydantic.Field(None)
    CfnFlowEntitlementProps: typing.Optional[dict[str, CfnFlowEntitlementPropsDef]] = pydantic.Field(None)
    CfnFlowOutputProps: typing.Optional[dict[str, CfnFlowOutputPropsDef]] = pydantic.Field(None)
    CfnFlowProps: typing.Optional[dict[str, CfnFlowPropsDef]] = pydantic.Field(None)
    CfnFlowSourceProps: typing.Optional[dict[str, CfnFlowSourcePropsDef]] = pydantic.Field(None)
    CfnFlowVpcInterfaceProps: typing.Optional[dict[str, CfnFlowVpcInterfacePropsDef]] = pydantic.Field(None)
    ...
