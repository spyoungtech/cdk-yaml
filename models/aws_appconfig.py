from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_appconfig.Action
class ActionDef(BaseClass):
    action_points: typing.Union[typing.Sequence[aws_cdk.aws_appconfig.ActionPoint], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The action points that will trigger the extension action.')
    event_destination: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The event destination for the action.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the action. Default: - No description.\n')
    execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The execution role for the action. Default: - A role is generated.\n')
    invoke_without_execution_role: typing.Optional[bool] = pydantic.Field(None, description='The flag that specifies whether or not to create the execution role. If set to true, then the role will not be auto-generated under the assumption there is already the corresponding resource-based policy attached to the event destination. If false, the execution role will be generated if not provided. Default: false\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name for the action. Default: - A name is generated.')
    _init_params: typing.ClassVar[list[str]] = ['action_points', 'event_destination', 'description', 'execution_role', 'invoke_without_execution_role', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.Action'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.ConfigurationContent
class ConfigurationContentDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_file', 'from_inline', 'from_inline_json', 'from_inline_text', 'from_inline_yaml']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ConfigurationContent'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_file', 'from_inline', 'from_inline_json', 'from_inline_text', 'from_inline_yaml']
    ...


    from_file: typing.Optional[models.aws_appconfig.ConfigurationContentDefFromFileParams] = pydantic.Field(None, description='Defines the hosted configuration content from a file.')
    from_inline: typing.Optional[models.aws_appconfig.ConfigurationContentDefFromInlineParams] = pydantic.Field(None, description='Defines the hosted configuration content from inline code.')
    from_inline_json: typing.Optional[models.aws_appconfig.ConfigurationContentDefFromInlineJsonParams] = pydantic.Field(None, description='Defines the hosted configuration content as JSON from inline code.')
    from_inline_text: typing.Optional[models.aws_appconfig.ConfigurationContentDefFromInlineTextParams] = pydantic.Field(None, description='Defines the hosted configuration content as text from inline code.')
    from_inline_yaml: typing.Optional[models.aws_appconfig.ConfigurationContentDefFromInlineYamlParams] = pydantic.Field(None, description='Defines the hosted configuration content as YAML from inline code.')

class ConfigurationContentDefFromFileParams(pydantic.BaseModel):
    input_path: str = pydantic.Field(..., description='The path to the file that defines configuration content.\n')
    content_type: typing.Optional[str] = pydantic.Field(None, description='The content type of the configuration.')
    ...

class ConfigurationContentDefFromInlineParams(pydantic.BaseModel):
    content: str = pydantic.Field(..., description='The inline code that defines the configuration content.\n')
    content_type: typing.Optional[str] = pydantic.Field(None, description='The content type of the configuration.')
    ...

class ConfigurationContentDefFromInlineJsonParams(pydantic.BaseModel):
    content: str = pydantic.Field(..., description='The inline code that defines the configuration content.\n')
    content_type: typing.Optional[str] = pydantic.Field(None, description='The content type of the configuration.')
    ...

class ConfigurationContentDefFromInlineTextParams(pydantic.BaseModel):
    content: str = pydantic.Field(..., description='The inline code that defines the configuration content.')
    ...

class ConfigurationContentDefFromInlineYamlParams(pydantic.BaseModel):
    content: str = pydantic.Field(..., description='The inline code that defines the configuration content.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.ConfigurationSource
class ConfigurationSourceDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_bucket', 'from_cfn_document', 'from_parameter', 'from_pipeline', 'from_secret']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ConfigurationSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_bucket', 'from_cfn_document', 'from_parameter', 'from_pipeline', 'from_secret']
    ...


    from_bucket: typing.Optional[models.aws_appconfig.ConfigurationSourceDefFromBucketParams] = pydantic.Field(None, description='Defines configuration content from an Amazon S3 bucket.')
    from_cfn_document: typing.Optional[models.aws_appconfig.ConfigurationSourceDefFromCfnDocumentParams] = pydantic.Field(None, description='Defines configuration content from a Systems Manager (SSM) document.')
    from_parameter: typing.Optional[models.aws_appconfig.ConfigurationSourceDefFromParameterParams] = pydantic.Field(None, description='Defines configuration content from a Systems Manager (SSM) Parameter Store parameter.')
    from_pipeline: typing.Optional[models.aws_appconfig.ConfigurationSourceDefFromPipelineParams] = pydantic.Field(None, description='Defines configuration content from AWS CodePipeline.')
    from_secret: typing.Optional[models.aws_appconfig.ConfigurationSourceDefFromSecretParams] = pydantic.Field(None, description='Defines configuration content from an AWS Secrets Manager secret.')

class ConfigurationSourceDefFromBucketParams(pydantic.BaseModel):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='The S3 bucket where the configuration is stored.\n')
    object_key: str = pydantic.Field(..., description='The path to the configuration.\n')
    key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The KMS Key that the bucket is encrypted with.')
    ...

class ConfigurationSourceDefFromCfnDocumentParams(pydantic.BaseModel):
    document: models.aws_ssm.CfnDocumentDef = pydantic.Field(..., description='The SSM document where the configuration is stored.')
    ...

class ConfigurationSourceDefFromParameterParams(pydantic.BaseModel):
    parameter: typing.Union[models.aws_ssm.StringListParameterDef, models.aws_ssm.StringParameterDef] = pydantic.Field(..., description='The parameter where the configuration is stored.\n')
    key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The KMS Key that the secure string is encrypted with.')
    ...

class ConfigurationSourceDefFromPipelineParams(pydantic.BaseModel):
    pipeline: typing.Union[models.aws_codepipeline.PipelineDef] = pydantic.Field(..., description='The pipeline where the configuration is stored.')
    ...

class ConfigurationSourceDefFromSecretParams(pydantic.BaseModel):
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret where the configuration is stored.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.DeploymentStrategyId
class DeploymentStrategyIdDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_string']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.DeploymentStrategyId'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_string']
    ...


    from_string: typing.Optional[models.aws_appconfig.DeploymentStrategyIdDefFromStringParams] = pydantic.Field(None, description='Builds a deployment strategy ID from a string.')

class DeploymentStrategyIdDefFromStringParams(pydantic.BaseModel):
    deployment_strategy_id: str = pydantic.Field(..., description='The deployment strategy ID.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.EventBridgeDestination
class EventBridgeDestinationDef(BaseClass):
    bus: typing.Union[_REQUIRED_INIT_PARAM, models.aws_events.EventBusDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    _init_params: typing.ClassVar[list[str]] = ['bus']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.EventBridgeDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.ExtensibleBase
class ExtensibleBaseDef(BaseClass):
    resource_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='-\n')
    resource_name: typing.Optional[str] = pydantic.Field(None, description='-')
    _init_params: typing.ClassVar[list[str]] = ['resource_arn', 'resource_name']
    _method_names: typing.ClassVar[list[str]] = ['add_extension', 'on', 'on_deployment_baking', 'on_deployment_complete', 'on_deployment_rolled_back', 'on_deployment_start', 'on_deployment_step', 'pre_create_hosted_configuration_version', 'pre_start_deployment']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ExtensibleBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.ExtensibleBaseDefConfig] = pydantic.Field(None)


class ExtensibleBaseDefConfig(pydantic.BaseModel):
    add_extension: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefAddExtensionParams]] = pydantic.Field(None, description='Adds an extension association to the derived resource.')
    on: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefOnParams]] = pydantic.Field(None, description='Adds an extension defined by the action point and event destination and also creates an extension association to the derived resource.')
    on_deployment_baking: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefOnDeploymentBakingParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_BAKING extension with the provided event destination and also creates an extension association to the derived resource.')
    on_deployment_complete: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefOnDeploymentCompleteParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_COMPLETE extension with the provided event destination and also creates an extension association to the derived resource.')
    on_deployment_rolled_back: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefOnDeploymentRolledBackParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_ROLLED_BACK extension with the provided event destination and also creates an extension association to the derived resource.')
    on_deployment_start: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefOnDeploymentStartParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_START extension with the provided event destination and also creates an extension association to the derived resource.')
    on_deployment_step: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefOnDeploymentStepParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_STEP extension with the provided event destination and also creates an extension association to the derived resource.')
    pre_create_hosted_configuration_version: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefPreCreateHostedConfigurationVersionParams]] = pydantic.Field(None, description='Adds a PRE_CREATE_HOSTED_CONFIGURATION_VERSION extension with the provided event destination and also creates an extension association to the derived resource.')
    pre_start_deployment: typing.Optional[list[models.aws_appconfig.ExtensibleBaseDefPreStartDeploymentParams]] = pydantic.Field(None, description='Adds a PRE_START_DEPLOYMENT extension with the provided event destination and also creates an extension association to the derived resource.')

class ExtensibleBaseDefAddExtensionParams(pydantic.BaseModel):
    extension: typing.Union[models.aws_appconfig.ExtensionDef] = pydantic.Field(..., description='-')
    ...

class ExtensibleBaseDefOnParams(pydantic.BaseModel):
    action_point: aws_cdk.aws_appconfig.ActionPoint = pydantic.Field(..., description='-\n')
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ExtensibleBaseDefOnDeploymentBakingParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ExtensibleBaseDefOnDeploymentCompleteParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ExtensibleBaseDefOnDeploymentRolledBackParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ExtensibleBaseDefOnDeploymentStartParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ExtensibleBaseDefOnDeploymentStepParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ExtensibleBaseDefPreCreateHostedConfigurationVersionParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ExtensibleBaseDefPreStartDeploymentParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.JsonSchemaValidator
class JsonSchemaValidatorDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_file', 'from_inline']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.JsonSchemaValidator'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_file', 'from_inline']
    ...


    from_file: typing.Optional[models.aws_appconfig.JsonSchemaValidatorDefFromFileParams] = pydantic.Field(None, description='Defines a JSON Schema validator from a file.')
    from_inline: typing.Optional[models.aws_appconfig.JsonSchemaValidatorDefFromInlineParams] = pydantic.Field(None, description='Defines a JSON Schema validator from inline code.')

class JsonSchemaValidatorDefFromFileParams(pydantic.BaseModel):
    input_path: str = pydantic.Field(..., description='The path to the file that defines the validator.')
    ...

class JsonSchemaValidatorDefFromInlineParams(pydantic.BaseModel):
    code: str = pydantic.Field(..., description='The inline code that defines the validator.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.LambdaDestination
class LambdaDestinationDef(BaseClass):
    func: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    _init_params: typing.ClassVar[list[str]] = ['func']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.LambdaDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.LambdaValidator
class LambdaValidatorDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_function']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.LambdaValidator'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_function']
    ...


    from_function: typing.Optional[models.aws_appconfig.LambdaValidatorDefFromFunctionParams] = pydantic.Field(None, description='Defines an AWS Lambda validator from a Lambda function.\nThis will call\n``addPermission`` to your function to grant AWS AppConfig permissions.')

class LambdaValidatorDefFromFunctionParams(pydantic.BaseModel):
    func: models.aws_lambda.FunctionDef = pydantic.Field(..., description='The function that defines the validator.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.Monitor
class MonitorDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_cfn_monitors_property', 'from_cloud_watch_alarm']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.Monitor'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_cfn_monitors_property', 'from_cloud_watch_alarm']
    ...


    from_cfn_monitors_property: typing.Optional[models.aws_appconfig.MonitorDefFromCfnMonitorsPropertyParams] = pydantic.Field(None, description='Creates a Monitor from a CfnEnvironment.MonitorsProperty construct.')
    from_cloud_watch_alarm: typing.Optional[models.aws_appconfig.MonitorDefFromCloudWatchAlarmParams] = pydantic.Field(None, description='Creates a Monitor from a CloudWatch alarm.\nIf the alarm role is not specified, a role will\nbe generated.')

class MonitorDefFromCfnMonitorsPropertyParams(pydantic.BaseModel):
    alarm_arn: typing.Optional[str] = pydantic.Field(None, description='')
    alarm_role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class MonitorDefFromCloudWatchAlarmParams(pydantic.BaseModel):
    alarm: typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef] = pydantic.Field(..., description='The Amazon CloudWatch alarm.\n')
    alarm_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role for AWS AppConfig to view the alarm state.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.Parameter
class ParameterDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['not_required', 'required']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.Parameter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.ParameterDefConfig] = pydantic.Field(None)


class ParameterDefConfig(pydantic.BaseModel):
    not_required: typing.Optional[list[models.aws_appconfig.ParameterDefNotRequiredParams]] = pydantic.Field(None, description='An optional parameter for an extension.')
    required: typing.Optional[list[models.aws_appconfig.ParameterDefRequiredParams]] = pydantic.Field(None, description='A required parameter for an extension.')

class ParameterDefNotRequiredParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='The name of the parameter.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the parameter.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the parameter.')
    return_config: typing.Optional[list[models.aws_appconfig.ParameterDefConfig]] = pydantic.Field(None)
    ...

class ParameterDefRequiredParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='The name of the parameter.\n')
    value: str = pydantic.Field(..., description='The value of the parameter.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the parameter.')
    return_config: typing.Optional[list[models.aws_appconfig.ParameterDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appconfig.RolloutStrategy
class RolloutStrategyDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['exponential', 'linear']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.RolloutStrategy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.RolloutStrategyDefConfig] = pydantic.Field(None)


class RolloutStrategyDefConfig(pydantic.BaseModel):
    exponential: typing.Optional[list[models.aws_appconfig.RolloutStrategyDefExponentialParams]] = pydantic.Field(None, description='Build your own exponential rollout strategy.')
    linear: typing.Optional[list[models.aws_appconfig.RolloutStrategyDefLinearParams]] = pydantic.Field(None, description='Build your own linear rollout strategy.')
    deployment_duration_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)

class RolloutStrategyDefExponentialParams(pydantic.BaseModel):
    deployment_duration: models.DurationDef = pydantic.Field(..., description='The deployment duration of the deployment strategy. This defines the total amount of time for a deployment to last.\n')
    growth_factor: typing.Union[int, float] = pydantic.Field(..., description='The growth factor of the deployment strategy. This defines the percentage of targets to receive a deployed configuration during each interval.\n')
    final_bake_time: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The final bake time of the deployment strategy. This setting specifies the amount of time AWS AppConfig monitors for Amazon CloudWatch alarms after the configuration has been deployed to 100% of its targets, before considering the deployment to be complete. If an alarm is triggered during this time, AWS AppConfig rolls back the deployment. Default: Duration.minutes(0)')
    return_config: typing.Optional[list[models.aws_appconfig.RolloutStrategyDefConfig]] = pydantic.Field(None)
    ...

class RolloutStrategyDefLinearParams(pydantic.BaseModel):
    deployment_duration: models.DurationDef = pydantic.Field(..., description='The deployment duration of the deployment strategy. This defines the total amount of time for a deployment to last.\n')
    growth_factor: typing.Union[int, float] = pydantic.Field(..., description='The growth factor of the deployment strategy. This defines the percentage of targets to receive a deployed configuration during each interval.\n')
    final_bake_time: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The final bake time of the deployment strategy. This setting specifies the amount of time AWS AppConfig monitors for Amazon CloudWatch alarms after the configuration has been deployed to 100% of its targets, before considering the deployment to be complete. If an alarm is triggered during this time, AWS AppConfig rolls back the deployment. Default: Duration.minutes(0)')
    return_config: typing.Optional[list[models.aws_appconfig.RolloutStrategyDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appconfig.SnsDestination
class SnsDestinationDef(BaseClass):
    topic: typing.Union[_REQUIRED_INIT_PARAM, models.aws_sns.TopicBaseDef, models.aws_sns.TopicDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    _init_params: typing.ClassVar[list[str]] = ['topic']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.SnsDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.SqsDestination
class SqsDestinationDef(BaseClass):
    queue: typing.Union[_REQUIRED_INIT_PARAM, models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    _init_params: typing.ClassVar[list[str]] = ['queue']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.SqsDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.Application
class ApplicationDef(BaseConstruct):
    application_name: typing.Optional[str] = pydantic.Field(None, description='The name of the application. Default: - A name is generated.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the application. Default: - No description.')
    _init_params: typing.ClassVar[list[str]] = ['application_name', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_environment', 'add_existing_environment', 'add_extension', 'add_hosted_configuration', 'add_sourced_configuration', 'apply_removal_policy', 'environments', 'on', 'on_deployment_baking', 'on_deployment_complete', 'on_deployment_rolled_back', 'on_deployment_start', 'on_deployment_step', 'pre_create_hosted_configuration_version', 'pre_start_deployment']
    _classmethod_names: typing.ClassVar[list[str]] = ['add_agent_to_ecs', 'from_application_arn', 'from_application_id', 'get_lambda_layer_version_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.Application'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_application_arn', 'from_application_id']
    ...


    from_application_arn: typing.Optional[models.aws_appconfig.ApplicationDefFromApplicationArnParams] = pydantic.Field(None, description='Imports an AWS AppConfig application into the CDK using its Amazon Resource Name (ARN).')
    from_application_id: typing.Optional[models.aws_appconfig.ApplicationDefFromApplicationIdParams] = pydantic.Field(None, description='Imports an AWS AppConfig application into the CDK using its ID.')
    resource_config: typing.Optional[models.aws_appconfig.ApplicationDefConfig] = pydantic.Field(None)


class ApplicationDefConfig(pydantic.BaseModel):
    add_agent_to_ecs: typing.Optional[list[models.aws_appconfig.ApplicationDefAddAgentToEcsParams]] = pydantic.Field(None, description='Adds the AWS AppConfig Agent as a container to the provided ECS task definition.')
    add_environment: typing.Optional[list[models.aws_appconfig.ApplicationDefAddEnvironmentParams]] = pydantic.Field(None, description='Adds an environment.')
    add_existing_environment: typing.Optional[list[models.aws_appconfig.ApplicationDefAddExistingEnvironmentParams]] = pydantic.Field(None, description='Adds an existing environment.')
    add_extension: typing.Optional[list[models.aws_appconfig.ApplicationDefAddExtensionParams]] = pydantic.Field(None, description='Adds an extension association to the application.')
    add_hosted_configuration: typing.Optional[list[models.aws_appconfig.ApplicationDefAddHostedConfigurationParams]] = pydantic.Field(None, description='Adds a hosted configuration.')
    add_sourced_configuration: typing.Optional[list[models.aws_appconfig.ApplicationDefAddSourcedConfigurationParams]] = pydantic.Field(None, description='Adds a sourced configuration.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    environments: typing.Optional[bool] = pydantic.Field(None, description='Returns the list of associated environments.')
    get_lambda_layer_version_arn: typing.Optional[list[models.aws_appconfig.ApplicationDefGetLambdaLayerVersionArnParams]] = pydantic.Field(None, description='Retrieves the Lambda layer version Amazon Resource Name (ARN) for the AWS AppConfig Lambda extension.')
    on: typing.Optional[list[models.aws_appconfig.ApplicationDefOnParams]] = pydantic.Field(None, description='Adds an extension defined by the action point and event destination and also creates an extension association to an application.')
    on_deployment_baking: typing.Optional[list[models.aws_appconfig.ApplicationDefOnDeploymentBakingParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_BAKING extension with the provided event destination and also creates an extension association to an application.')
    on_deployment_complete: typing.Optional[list[models.aws_appconfig.ApplicationDefOnDeploymentCompleteParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_COMPLETE extension with the provided event destination and also creates an extension association to an application.')
    on_deployment_rolled_back: typing.Optional[list[models.aws_appconfig.ApplicationDefOnDeploymentRolledBackParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_ROLLED_BACK extension with the provided event destination and also creates an extension association to an application.')
    on_deployment_start: typing.Optional[list[models.aws_appconfig.ApplicationDefOnDeploymentStartParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_START extension with the provided event destination and also creates an extension association to an application.')
    on_deployment_step: typing.Optional[list[models.aws_appconfig.ApplicationDefOnDeploymentStepParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_STEP extension with the provided event destination and also creates an extension association to an application.')
    pre_create_hosted_configuration_version: typing.Optional[list[models.aws_appconfig.ApplicationDefPreCreateHostedConfigurationVersionParams]] = pydantic.Field(None, description='Adds a PRE_CREATE_HOSTED_CONFIGURATION_VERSION extension with the provided event destination and also creates an extension association to an application.')
    pre_start_deployment: typing.Optional[list[models.aws_appconfig.ApplicationDefPreStartDeploymentParams]] = pydantic.Field(None, description='Adds a PRE_START_DEPLOYMENT extension with the provided event destination and also creates an extension association to an application.')

class ApplicationDefAddAgentToEcsParams(pydantic.BaseModel):
    task_def: models.aws_ecs.TaskDefinitionDef = pydantic.Field(..., description='The ECS task definition [disable-awslint:ref-via-interface].')
    ...

class ApplicationDefAddEnvironmentParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the environment. Default: - No description.\n')
    environment_name: typing.Optional[str] = pydantic.Field(None, description='The name of the environment. Default: - A name is generated.\n')
    monitors: typing.Optional[typing.Sequence[models.aws_appconfig.MonitorDef]] = pydantic.Field(None, description='The monitors for the environment. Default: - No monitors.')
    return_config: typing.Optional[list[models._interface_methods.AwsAppconfigIEnvironmentDefConfig]] = pydantic.Field(None)
    ...

class ApplicationDefAddExistingEnvironmentParams(pydantic.BaseModel):
    environment: typing.Union[models.aws_appconfig.EnvironmentDef] = pydantic.Field(..., description='-')
    ...

class ApplicationDefAddExtensionParams(pydantic.BaseModel):
    extension: typing.Union[models.aws_appconfig.ExtensionDef] = pydantic.Field(..., description='The extension to create an association for.')
    ...

class ApplicationDefAddHostedConfigurationParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    content: models.aws_appconfig.ConfigurationContentDef = pydantic.Field(..., description='The content of the hosted configuration.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the hosted configuration. Default: - None.\n')
    version_label: typing.Optional[str] = pydantic.Field(None, description='The version label of the hosted configuration. Default: - None.\n')
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.')
    return_config: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefConfig]] = pydantic.Field(None)
    ...

class ApplicationDefAddSourcedConfigurationParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    location: models.aws_appconfig.ConfigurationSourceDef = pydantic.Field(..., description='The location where the configuration is stored.\n')
    retrieval_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to retrieve the configuration. Default: - A role is generated.\n')
    version_number: typing.Optional[str] = pydantic.Field(None, description='The version number of the sourced configuration to deploy. If this is not specified, then there will be no deployment. Default: - None.\n')
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.')
    return_config: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefConfig]] = pydantic.Field(None)
    ...

class ApplicationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ApplicationDefFromApplicationArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    id: str = pydantic.Field(..., description='The name of the application construct.\n')
    application_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the application.')
    ...

class ApplicationDefFromApplicationIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    id: str = pydantic.Field(..., description='The name of the application construct.\n')
    application_id: str = pydantic.Field(..., description='The ID of the application.')
    ...

class ApplicationDefGetLambdaLayerVersionArnParams(pydantic.BaseModel):
    region: str = pydantic.Field(..., description="The region for the Lambda layer (for example, 'us-east-1').\n")
    platform: typing.Optional[aws_cdk.aws_appconfig.Platform] = pydantic.Field(None, description='The platform for the Lambda layer (default is Platform.X86_64).\n')
    ...

class ApplicationDefOnParams(pydantic.BaseModel):
    action_point: aws_cdk.aws_appconfig.ActionPoint = pydantic.Field(..., description='The action point which triggers the event.\n')
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ApplicationDefOnDeploymentBakingParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ApplicationDefOnDeploymentCompleteParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ApplicationDefOnDeploymentRolledBackParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ApplicationDefOnDeploymentStartParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ApplicationDefOnDeploymentStepParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ApplicationDefPreCreateHostedConfigurationVersionParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class ApplicationDefPreStartDeploymentParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.DeploymentStrategy
class DeploymentStrategyDef(BaseConstruct):
    rollout_strategy: typing.Union[models.aws_appconfig.RolloutStrategyDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The rollout strategy for the deployment strategy. You can use predefined deployment strategies, such as RolloutStrategy.ALL_AT_ONCE, RolloutStrategy.LINEAR_50_PERCENT_EVERY_30_SECONDS, or RolloutStrategy.CANARY_10_PERCENT_20_MINUTES.\n')
    deployment_strategy_name: typing.Optional[str] = pydantic.Field(None, description='A name for the deployment strategy. Default: - A name is generated.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the deployment strategy. Default: - No description.')
    _init_params: typing.ClassVar[list[str]] = ['rollout_strategy', 'deployment_strategy_name', 'description']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_deployment_strategy_arn', 'from_deployment_strategy_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.DeploymentStrategy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_deployment_strategy_arn', 'from_deployment_strategy_id']
    ...


    from_deployment_strategy_arn: typing.Optional[models.aws_appconfig.DeploymentStrategyDefFromDeploymentStrategyArnParams] = pydantic.Field(None, description='Imports a deployment strategy into the CDK using its Amazon Resource Name (ARN).')
    from_deployment_strategy_id: typing.Optional[models.aws_appconfig.DeploymentStrategyDefFromDeploymentStrategyIdParams] = pydantic.Field(None, description='Imports a deployment strategy into the CDK using its ID.')
    resource_config: typing.Optional[models.aws_appconfig.DeploymentStrategyDefConfig] = pydantic.Field(None)


class DeploymentStrategyDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class DeploymentStrategyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class DeploymentStrategyDefFromDeploymentStrategyArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    id: str = pydantic.Field(..., description='The name of the deployment strategy construct.\n')
    deployment_strategy_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the deployment strategy.')
    ...

class DeploymentStrategyDefFromDeploymentStrategyIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    id: str = pydantic.Field(..., description='The name of the deployment strategy construct.\n')
    deployment_strategy_id: models.aws_appconfig.DeploymentStrategyIdDef = pydantic.Field(..., description='The ID of the deployment strategy.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.Environment
class EnvironmentDef(BaseConstruct):
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.ApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application to be associated with the environment.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the environment. Default: - No description.\n')
    environment_name: typing.Optional[str] = pydantic.Field(None, description='The name of the environment. Default: - A name is generated.\n')
    monitors: typing.Optional[typing.Sequence[models.aws_appconfig.MonitorDef]] = pydantic.Field(None, description='The monitors for the environment. Default: - No monitors.')
    _init_params: typing.ClassVar[list[str]] = ['application', 'description', 'environment_name', 'monitors']
    _method_names: typing.ClassVar[list[str]] = ['add_deployment', 'add_deployments', 'add_extension', 'apply_removal_policy', 'grant', 'grant_read_config', 'on', 'on_deployment_baking', 'on_deployment_complete', 'on_deployment_rolled_back', 'on_deployment_start', 'on_deployment_step', 'pre_create_hosted_configuration_version', 'pre_start_deployment']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_environment_arn', 'from_environment_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.Environment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_environment_arn', 'from_environment_attributes']
    ...


    from_environment_arn: typing.Optional[models.aws_appconfig.EnvironmentDefFromEnvironmentArnParams] = pydantic.Field(None, description='Imports an environment into the CDK using its Amazon Resource Name (ARN).')
    from_environment_attributes: typing.Optional[models.aws_appconfig.EnvironmentDefFromEnvironmentAttributesParams] = pydantic.Field(None, description='Imports an environment into the CDK from its attributes.')
    resource_config: typing.Optional[models.aws_appconfig.EnvironmentDefConfig] = pydantic.Field(None)


class EnvironmentDefConfig(pydantic.BaseModel):
    add_deployment: typing.Optional[list[models.aws_appconfig.EnvironmentDefAddDeploymentParams]] = pydantic.Field(None, description='Creates a deployment of the supplied configuration to this environment.\nNote that you can only deploy one configuration at a time to an environment.\nHowever, you can deploy one configuration each to different environments at the same time.\nIf more than one deployment is requested for this environment, they will occur in the same order they were provided.')
    add_deployments: typing.Optional[list[models.aws_appconfig.EnvironmentDefAddDeploymentsParams]] = pydantic.Field(None, description='Creates a deployment for each of the supplied configurations to this environment.\nThese configurations will be deployed in the same order as the input array.')
    add_extension: typing.Optional[list[models.aws_appconfig.EnvironmentDefAddExtensionParams]] = pydantic.Field(None, description='Adds an extension association to the environment.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant: typing.Optional[list[models.aws_appconfig.EnvironmentDefGrantParams]] = pydantic.Field(None, description="Adds an IAM policy statement associated with this environment to an IAM principal's policy.")
    grant_read_config: typing.Optional[list[models.aws_appconfig.EnvironmentDefGrantReadConfigParams]] = pydantic.Field(None, description="Permits an IAM principal to perform read operations on this environment's configurations.\nActions: GetLatestConfiguration, StartConfigurationSession.")
    on: typing.Optional[list[models.aws_appconfig.EnvironmentDefOnParams]] = pydantic.Field(None, description='Adds an extension defined by the action point and event destination and also creates an extension association to the environment.')
    on_deployment_baking: typing.Optional[list[models.aws_appconfig.EnvironmentDefOnDeploymentBakingParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_BAKING extension with the provided event destination and also creates an extension association to the environment.')
    on_deployment_complete: typing.Optional[list[models.aws_appconfig.EnvironmentDefOnDeploymentCompleteParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_COMPLETE extension with the provided event destination and also creates an extension association to the environment.')
    on_deployment_rolled_back: typing.Optional[list[models.aws_appconfig.EnvironmentDefOnDeploymentRolledBackParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_ROLLED_BACK extension with the provided event destination and also creates an extension association to the environment.')
    on_deployment_start: typing.Optional[list[models.aws_appconfig.EnvironmentDefOnDeploymentStartParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_START extension with the provided event destination and also creates an extension association to the environment.')
    on_deployment_step: typing.Optional[list[models.aws_appconfig.EnvironmentDefOnDeploymentStepParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_STEP extension with the provided event destination and also creates an extension association to the environment.')
    pre_create_hosted_configuration_version: typing.Optional[list[models.aws_appconfig.EnvironmentDefPreCreateHostedConfigurationVersionParams]] = pydantic.Field(None, description='Adds a PRE_CREATE_HOSTED_CONFIGURATION_VERSION extension with the provided event destination and also creates an extension association to the environment.')
    pre_start_deployment: typing.Optional[list[models.aws_appconfig.EnvironmentDefPreStartDeploymentParams]] = pydantic.Field(None, description='Adds a PRE_START_DEPLOYMENT extension with the provided event destination and also creates an extension association to the environment.')

class EnvironmentDefAddDeploymentParams(pydantic.BaseModel):
    configuration: typing.Union[models.aws_appconfig.HostedConfigurationDef, models.aws_appconfig.SourcedConfigurationDef] = pydantic.Field(..., description='-')
    ...

class EnvironmentDefAddDeploymentsParams(pydantic.BaseModel):
    configurations: list[typing.Union[models.aws_appconfig.HostedConfigurationDef, models.aws_appconfig.SourcedConfigurationDef]] = pydantic.Field(...)
    ...

class EnvironmentDefAddExtensionParams(pydantic.BaseModel):
    extension: typing.Union[models.aws_appconfig.ExtensionDef] = pydantic.Field(..., description='-')
    ...

class EnvironmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class EnvironmentDefFromEnvironmentArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    id: str = pydantic.Field(..., description='The name of the environment construct.\n')
    environment_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the environment.')
    ...

class EnvironmentDefFromEnvironmentAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    id: str = pydantic.Field(..., description='The name of the environment construct.\n')
    application: typing.Union[models.aws_appconfig.ApplicationDef] = pydantic.Field(..., description='The application associated with the environment.\n')
    environment_id: str = pydantic.Field(..., description='The ID of the environment.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the environment. Default: - None.\n')
    monitors: typing.Optional[typing.Sequence[models.aws_appconfig.MonitorDef]] = pydantic.Field(None, description='The monitors for the environment. Default: - None.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the environment. Default: - None.')
    ...

class EnvironmentDefGrantParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-\n')
    actions: list[str] = pydantic.Field(...)
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class EnvironmentDefGrantReadConfigParams(pydantic.BaseModel):
    identity: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class EnvironmentDefOnParams(pydantic.BaseModel):
    action_point: aws_cdk.aws_appconfig.ActionPoint = pydantic.Field(..., description='-\n')
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class EnvironmentDefOnDeploymentBakingParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class EnvironmentDefOnDeploymentCompleteParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class EnvironmentDefOnDeploymentRolledBackParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class EnvironmentDefOnDeploymentStartParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class EnvironmentDefOnDeploymentStepParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class EnvironmentDefPreCreateHostedConfigurationVersionParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class EnvironmentDefPreStartDeploymentParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.Extension
class ExtensionDef(BaseConstruct):
    actions: typing.Union[typing.Sequence[models.aws_appconfig.ActionDef], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions for the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'description', 'extension_name', 'latest_version_number', 'parameters']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_extension_arn', 'from_extension_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.Extension'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_extension_arn', 'from_extension_attributes']
    ...


    from_extension_arn: typing.Optional[models.aws_appconfig.ExtensionDefFromExtensionArnParams] = pydantic.Field(None, description='Imports an extension into the CDK using its Amazon Resource Name (ARN).')
    from_extension_attributes: typing.Optional[models.aws_appconfig.ExtensionDefFromExtensionAttributesParams] = pydantic.Field(None, description='Imports an extension into the CDK using its attributes.')
    resource_config: typing.Optional[models.aws_appconfig.ExtensionDefConfig] = pydantic.Field(None)


class ExtensionDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ExtensionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ExtensionDefFromExtensionArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    id: str = pydantic.Field(..., description='The name of the extension construct.\n')
    extension_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the extension.')
    ...

class ExtensionDefFromExtensionAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    id: str = pydantic.Field(..., description='The name of the extension construct.\n')
    extension_id: str = pydantic.Field(..., description='The ID of the extension.\n')
    extension_version_number: typing.Union[int, float] = pydantic.Field(..., description='The version number of the extension.\n')
    actions: typing.Optional[typing.Sequence[models.aws_appconfig.ActionDef]] = pydantic.Field(None, description='The actions of the extension. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the extension. Default: - None.\n')
    extension_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the extension. Default: - The extension ARN is generated.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - None.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.HostedConfiguration
class HostedConfigurationDef(BaseConstruct):
    content: typing.Union[models.aws_appconfig.ConfigurationContentDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content of the hosted configuration.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the hosted configuration. Default: - None.\n')
    version_label: typing.Optional[str] = pydantic.Field(None, description='The version label of the hosted configuration. Default: - None.\n')
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.ApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application associated with the configuration.\n')
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.')
    _init_params: typing.ClassVar[list[str]] = ['content', 'latest_version_number', 'version_label', 'application', 'deployment_key', 'deployment_strategy', 'deploy_to', 'description', 'name', 'type', 'validators']
    _method_names: typing.ClassVar[list[str]] = ['add_extension', 'on', 'on_deployment_baking', 'on_deployment_complete', 'on_deployment_rolled_back', 'on_deployment_start', 'on_deployment_step', 'pre_create_hosted_configuration_version', 'pre_start_deployment']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.HostedConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.HostedConfigurationDefConfig] = pydantic.Field(None)


class HostedConfigurationDefConfig(pydantic.BaseModel):
    add_extension: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefAddExtensionParams]] = pydantic.Field(None, description='Adds an extension association to the configuration profile.')
    on: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefOnParams]] = pydantic.Field(None, description='Adds an extension defined by the action point and event destination and also creates an extension association to the configuration profile.')
    on_deployment_baking: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefOnDeploymentBakingParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_BAKING extension with the provided event destination and also creates an extension association to the configuration profile.')
    on_deployment_complete: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefOnDeploymentCompleteParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_COMPLETE extension with the provided event destination and also creates an extension association to the configuration profile.')
    on_deployment_rolled_back: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefOnDeploymentRolledBackParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_ROLLED_BACK extension with the provided event destination and also creates an extension association to the configuration profile.')
    on_deployment_start: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefOnDeploymentStartParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_START extension with the provided event destination and also creates an extension association to the configuration profile.')
    on_deployment_step: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefOnDeploymentStepParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_STEP extension with the provided event destination and also creates an extension association to the configuration profile.')
    pre_create_hosted_configuration_version: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefPreCreateHostedConfigurationVersionParams]] = pydantic.Field(None, description='Adds a PRE_CREATE_HOSTED_CONFIGURATION_VERSION extension with the provided event destination and also creates an extension association to the configuration profile.')
    pre_start_deployment: typing.Optional[list[models.aws_appconfig.HostedConfigurationDefPreStartDeploymentParams]] = pydantic.Field(None, description='Adds a PRE_START_DEPLOYMENT extension with the provided event destination and also creates an extension association to the configuration profile.')
    application_config: typing.Optional[models._interface_methods.AwsAppconfigIApplicationDefConfig] = pydantic.Field(None)

class HostedConfigurationDefAddExtensionParams(pydantic.BaseModel):
    extension: typing.Union[models.aws_appconfig.ExtensionDef] = pydantic.Field(..., description='The extension to create an association for.')
    ...

class HostedConfigurationDefOnParams(pydantic.BaseModel):
    action_point: aws_cdk.aws_appconfig.ActionPoint = pydantic.Field(..., description='The action point which triggers the event.\n')
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class HostedConfigurationDefOnDeploymentBakingParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class HostedConfigurationDefOnDeploymentCompleteParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class HostedConfigurationDefOnDeploymentRolledBackParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class HostedConfigurationDefOnDeploymentStartParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class HostedConfigurationDefOnDeploymentStepParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class HostedConfigurationDefPreCreateHostedConfigurationVersionParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class HostedConfigurationDefPreStartDeploymentParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.SourcedConfiguration
class SourcedConfigurationDef(BaseConstruct):
    location: typing.Union[models.aws_appconfig.ConfigurationSourceDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The location where the configuration is stored.\n')
    retrieval_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to retrieve the configuration. Default: - A role is generated.\n')
    version_number: typing.Optional[str] = pydantic.Field(None, description='The version number of the sourced configuration to deploy. If this is not specified, then there will be no deployment. Default: - None.\n')
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.ApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application associated with the configuration.\n')
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.')
    _init_params: typing.ClassVar[list[str]] = ['location', 'retrieval_role', 'version_number', 'application', 'deployment_key', 'deployment_strategy', 'deploy_to', 'description', 'name', 'type', 'validators']
    _method_names: typing.ClassVar[list[str]] = ['add_extension', 'on', 'on_deployment_baking', 'on_deployment_complete', 'on_deployment_rolled_back', 'on_deployment_start', 'on_deployment_step', 'pre_create_hosted_configuration_version', 'pre_start_deployment']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.SourcedConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.SourcedConfigurationDefConfig] = pydantic.Field(None)


class SourcedConfigurationDefConfig(pydantic.BaseModel):
    add_extension: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefAddExtensionParams]] = pydantic.Field(None, description='Adds an extension association to the configuration profile.')
    on: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefOnParams]] = pydantic.Field(None, description='Adds an extension defined by the action point and event destination and also creates an extension association to the configuration profile.')
    on_deployment_baking: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefOnDeploymentBakingParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_BAKING extension with the provided event destination and also creates an extension association to the configuration profile.')
    on_deployment_complete: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefOnDeploymentCompleteParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_COMPLETE extension with the provided event destination and also creates an extension association to the configuration profile.')
    on_deployment_rolled_back: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefOnDeploymentRolledBackParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_ROLLED_BACK extension with the provided event destination and also creates an extension association to the configuration profile.')
    on_deployment_start: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefOnDeploymentStartParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_START extension with the provided event destination and also creates an extension association to the configuration profile.')
    on_deployment_step: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefOnDeploymentStepParams]] = pydantic.Field(None, description='Adds an ON_DEPLOYMENT_STEP extension with the provided event destination and also creates an extension association to the configuration profile.')
    pre_create_hosted_configuration_version: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefPreCreateHostedConfigurationVersionParams]] = pydantic.Field(None, description='Adds a PRE_CREATE_HOSTED_CONFIGURATION_VERSION extension with the provided event destination and also creates an extension association to the configuration profile.')
    pre_start_deployment: typing.Optional[list[models.aws_appconfig.SourcedConfigurationDefPreStartDeploymentParams]] = pydantic.Field(None, description='Adds a PRE_START_DEPLOYMENT extension with the provided event destination and also creates an extension association to the configuration profile.')
    application_config: typing.Optional[models._interface_methods.AwsAppconfigIApplicationDefConfig] = pydantic.Field(None)

class SourcedConfigurationDefAddExtensionParams(pydantic.BaseModel):
    extension: typing.Union[models.aws_appconfig.ExtensionDef] = pydantic.Field(..., description='The extension to create an association for.')
    ...

class SourcedConfigurationDefOnParams(pydantic.BaseModel):
    action_point: aws_cdk.aws_appconfig.ActionPoint = pydantic.Field(..., description='The action point which triggers the event.\n')
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class SourcedConfigurationDefOnDeploymentBakingParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class SourcedConfigurationDefOnDeploymentCompleteParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class SourcedConfigurationDefOnDeploymentRolledBackParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class SourcedConfigurationDefOnDeploymentStartParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class SourcedConfigurationDefOnDeploymentStepParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class SourcedConfigurationDefPreCreateHostedConfigurationVersionParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...

class SourcedConfigurationDefPreStartDeploymentParams(pydantic.BaseModel):
    event_destination: typing.Union[models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(..., description='The event that occurs during the extension.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.ActionProps
class ActionPropsDef(BaseStruct):
    action_points: typing.Union[typing.Sequence[aws_cdk.aws_appconfig.ActionPoint], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The action points that will trigger the extension action.\n')
    event_destination: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.EventBridgeDestinationDef, models.aws_appconfig.LambdaDestinationDef, models.aws_appconfig.SnsDestinationDef, models.aws_appconfig.SqsDestinationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The event destination for the action.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the action. Default: - No description.\n')
    execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The execution role for the action. Default: - A role is generated.\n')
    invoke_without_execution_role: typing.Optional[bool] = pydantic.Field(None, description='The flag that specifies whether or not to create the execution role. If set to true, then the role will not be auto-generated under the assumption there is already the corresponding resource-based policy attached to the event destination. If false, the execution role will be generated if not provided. Default: false\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name for the action. Default: - A name is generated.\n\n:exampleMetadata: infused\n\nExample::\n\n    # fn: lambda.Function\n\n\n    appconfig.Extension(self, "MyExtension",\n        actions=[\n            appconfig.Action(\n                action_points=[appconfig.ActionPoint.ON_DEPLOYMENT_START],\n                event_destination=appconfig.LambdaDestination(fn)\n            )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action_points', 'event_destination', 'description', 'execution_role', 'invoke_without_execution_role', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ActionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.ApplicationProps
class ApplicationPropsDef(BaseStruct):
    application_name: typing.Optional[str] = pydantic.Field(None, description='The name of the application. Default: - A name is generated.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the application. Default: - No description.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    application_props = appconfig.ApplicationProps(\n        application_name="applicationName",\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_name', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ApplicationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnConfigurationProfile.ValidatorsProperty
class CfnConfigurationProfile_ValidatorsPropertyDef(BaseStruct):
    content: typing.Optional[str] = pydantic.Field(None, description='Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='AWS AppConfig supports validators of type ``JSON_SCHEMA`` and ``LAMBDA``.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appconfig-configurationprofile-validators.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    validators_property = appconfig.CfnConfigurationProfile.ValidatorsProperty(\n        content="content",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['content', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnConfigurationProfile.ValidatorsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnDeployment.DynamicExtensionParametersProperty
class CfnDeployment_DynamicExtensionParametersPropertyDef(BaseStruct):
    extension_reference: typing.Optional[str] = pydantic.Field(None, description='The ARN or ID of the extension for which you are inserting a dynamic parameter.\n')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='The parameter name.\n')
    parameter_value: typing.Optional[str] = pydantic.Field(None, description='The parameter value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appconfig-deployment-dynamicextensionparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    dynamic_extension_parameters_property = appconfig.CfnDeployment.DynamicExtensionParametersProperty(\n        extension_reference="extensionReference",\n        parameter_name="parameterName",\n        parameter_value="parameterValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['extension_reference', 'parameter_name', 'parameter_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnDeployment.DynamicExtensionParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnEnvironment.MonitorProperty
class CfnEnvironment_MonitorPropertyDef(BaseStruct):
    alarm_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.\n')
    alarm_role_arn: typing.Optional[str] = pydantic.Field(None, description='ARN of an AWS Identity and Access Management (IAM) role for AWS AppConfig to monitor ``AlarmArn`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appconfig-environment-monitor.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    monitor_property = appconfig.CfnEnvironment.MonitorProperty(\n        alarm_arn="alarmArn",\n\n        # the properties below are optional\n        alarm_role_arn="alarmRoleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alarm_arn', 'alarm_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnEnvironment.MonitorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnEnvironment.MonitorsProperty
class CfnEnvironment_MonitorsPropertyDef(BaseStruct):
    alarm_arn: typing.Optional[str] = pydantic.Field(None, description='')
    alarm_role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['alarm_arn', 'alarm_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnEnvironment.MonitorsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnExtension.ActionProperty
class CfnExtension_ActionPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The action name.\n')
    uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an AWS Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about actions defined in the extension.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='An Amazon Resource Name (ARN) for an AWS Identity and Access Management assume role.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appconfig-extension-action.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    action_property = appconfig.CfnExtension.ActionProperty(\n        name="name",\n        uri="uri",\n\n        # the properties below are optional\n        description="description",\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'uri', 'description', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnExtension.ActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnExtension.ParameterProperty
class CfnExtension_ParameterPropertyDef(BaseStruct):
    required: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='A parameter value must be specified in the extension association.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the parameter.\n')
    dynamic: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether this parameter\'s value can be supplied at the extension\'s action point instead of during extension association. Dynamic parameters can\'t be marked ``Required`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appconfig-extension-parameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    parameter_property = appconfig.CfnExtension.ParameterProperty(\n        required=False,\n\n        # the properties below are optional\n        description="description",\n        dynamic=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['required', 'description', 'dynamic']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnExtension.ParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.ConfigurationOptions
class ConfigurationOptionsDef(BaseStruct):
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n    from aws_cdk import aws_kms as kms\n\n    # deployment_strategy: appconfig.DeploymentStrategy\n    # environment: appconfig.Environment\n    # key: kms.Key\n    # validator: appconfig.IValidator\n\n    configuration_options = appconfig.ConfigurationOptions(\n        deployment_key=key,\n        deployment_strategy=deployment_strategy,\n        deploy_to=[environment],\n        description="description",\n        name="name",\n        type=appconfig.ConfigurationType.FREEFORM,\n        validators=[validator]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_key', 'deployment_strategy', 'deploy_to', 'description', 'name', 'type', 'validators']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ConfigurationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.ConfigurationProps
class ConfigurationPropsDef(BaseStruct):
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.\n')
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.ApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application associated with the configuration.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n    from aws_cdk import aws_kms as kms\n\n    # application: appconfig.Application\n    # deployment_strategy: appconfig.DeploymentStrategy\n    # environment: appconfig.Environment\n    # key: kms.Key\n    # validator: appconfig.IValidator\n\n    configuration_props = appconfig.ConfigurationProps(\n        application=application,\n\n        # the properties below are optional\n        deployment_key=key,\n        deployment_strategy=deployment_strategy,\n        deploy_to=[environment],\n        description="description",\n        name="name",\n        type=appconfig.ConfigurationType.FREEFORM,\n        validators=[validator]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_key', 'deployment_strategy', 'deploy_to', 'description', 'name', 'type', 'validators', 'application']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.DeploymentStrategyProps
class DeploymentStrategyPropsDef(BaseStruct):
    rollout_strategy: typing.Union[models.aws_appconfig.RolloutStrategyDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The rollout strategy for the deployment strategy. You can use predefined deployment strategies, such as RolloutStrategy.ALL_AT_ONCE, RolloutStrategy.LINEAR_50_PERCENT_EVERY_30_SECONDS, or RolloutStrategy.CANARY_10_PERCENT_20_MINUTES.\n')
    deployment_strategy_name: typing.Optional[str] = pydantic.Field(None, description='A name for the deployment strategy. Default: - A name is generated.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the deployment strategy. Default: - No description.\n\n:exampleMetadata: infused\n\nExample::\n\n    appconfig.DeploymentStrategy(self, "MyDeploymentStrategy",\n        rollout_strategy=appconfig.RolloutStrategy.linear(\n            growth_factor=20,\n            deployment_duration=Duration.minutes(30),\n            final_bake_time=Duration.minutes(30)\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rollout_strategy', 'deployment_strategy_name', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.DeploymentStrategyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.EnvironmentAttributes
class EnvironmentAttributesDef(BaseStruct):
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.ApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application associated with the environment.\n')
    environment_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the environment.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the environment. Default: - None.\n')
    monitors: typing.Optional[typing.Sequence[models.aws_appconfig.MonitorDef]] = pydantic.Field(None, description='The monitors for the environment. Default: - None.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the environment. Default: - None.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    # application: appconfig.Application\n    # monitor: appconfig.Monitor\n\n    environment_attributes = appconfig.EnvironmentAttributes(\n        application=application,\n        environment_id="environmentId",\n\n        # the properties below are optional\n        description="description",\n        monitors=[monitor],\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application', 'environment_id', 'description', 'monitors', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.EnvironmentAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.EnvironmentOptions
class EnvironmentOptionsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the environment. Default: - No description.\n')
    environment_name: typing.Optional[str] = pydantic.Field(None, description='The name of the environment. Default: - A name is generated.\n')
    monitors: typing.Optional[typing.Sequence[models.aws_appconfig.MonitorDef]] = pydantic.Field(None, description='The monitors for the environment. Default: - No monitors.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    # monitor: appconfig.Monitor\n\n    environment_options = appconfig.EnvironmentOptions(\n        description="description",\n        environment_name="environmentName",\n        monitors=[monitor]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'environment_name', 'monitors']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.EnvironmentOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.EnvironmentProps
class EnvironmentPropsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the environment. Default: - No description.\n')
    environment_name: typing.Optional[str] = pydantic.Field(None, description='The name of the environment. Default: - A name is generated.\n')
    monitors: typing.Optional[typing.Sequence[models.aws_appconfig.MonitorDef]] = pydantic.Field(None, description='The monitors for the environment. Default: - No monitors.\n')
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.ApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application to be associated with the environment.\n\n:exampleMetadata: infused\n\nExample::\n\n    app = appconfig.Application(self, "MyApp")\n    env = appconfig.Environment(self, "MyEnv",\n        application=app\n    )\n\n    appconfig.HostedConfiguration(self, "MyFirstHostedConfig",\n        application=app,\n        deploy_to=[env],\n        content=appconfig.ConfigurationContent.from_inline_text("This is my first configuration content.")\n    )\n\n    appconfig.HostedConfiguration(self, "MySecondHostedConfig",\n        application=app,\n        deploy_to=[env],\n        content=appconfig.ConfigurationContent.from_inline_text("This is my second configuration content.")\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'environment_name', 'monitors', 'application']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.EnvironmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.ExtensionAttributes
class ExtensionAttributesDef(BaseStruct):
    extension_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the extension.\n')
    extension_version_number: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The version number of the extension.\n')
    actions: typing.Optional[typing.Sequence[models.aws_appconfig.ActionDef]] = pydantic.Field(None, description='The actions of the extension. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the extension. Default: - None.\n')
    extension_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the extension. Default: - The extension ARN is generated.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - None.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    # action: appconfig.Action\n\n    extension_attributes = appconfig.ExtensionAttributes(\n        extension_id="extensionId",\n        extension_version_number=123,\n\n        # the properties below are optional\n        actions=[action],\n        description="description",\n        extension_arn="extensionArn",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['extension_id', 'extension_version_number', 'actions', 'description', 'extension_arn', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ExtensionAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.ExtensionOptions
class ExtensionOptionsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    # parameter: appconfig.Parameter\n\n    extension_options = appconfig.ExtensionOptions(\n        description="description",\n        extension_name="extensionName",\n        latest_version_number=123,\n        parameters=[parameter]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'extension_name', 'latest_version_number', 'parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ExtensionOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.ExtensionProps
class ExtensionPropsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the extension. Default: - No description.\n')
    extension_name: typing.Optional[str] = pydantic.Field(None, description='The name of the extension. Default: - A name is generated.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field. Default: - None.\n')
    parameters: typing.Optional[typing.Sequence[models.aws_appconfig.ParameterDef]] = pydantic.Field(None, description='The parameters accepted for the extension. Default: - None.\n')
    actions: typing.Union[typing.Sequence[models.aws_appconfig.ActionDef], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions for the extension.\n\n:exampleMetadata: infused\n\nExample::\n\n    # fn: lambda.Function\n\n\n    appconfig.Extension(self, "MyExtension",\n        actions=[\n            appconfig.Action(\n                action_points=[appconfig.ActionPoint.ON_DEPLOYMENT_START],\n                event_destination=appconfig.LambdaDestination(fn)\n            )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'extension_name', 'latest_version_number', 'parameters', 'actions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.ExtensionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.HostedConfigurationOptions
class HostedConfigurationOptionsDef(BaseStruct):
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.\n')
    content: typing.Union[models.aws_appconfig.ConfigurationContentDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content of the hosted configuration.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the hosted configuration. Default: - None.\n')
    version_label: typing.Optional[str] = pydantic.Field(None, description='The version label of the hosted configuration. Default: - None.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n    from aws_cdk import aws_kms as kms\n\n    # configuration_content: appconfig.ConfigurationContent\n    # deployment_strategy: appconfig.DeploymentStrategy\n    # environment: appconfig.Environment\n    # key: kms.Key\n    # validator: appconfig.IValidator\n\n    hosted_configuration_options = appconfig.HostedConfigurationOptions(\n        content=configuration_content,\n\n        # the properties below are optional\n        deployment_key=key,\n        deployment_strategy=deployment_strategy,\n        deploy_to=[environment],\n        description="description",\n        latest_version_number=123,\n        name="name",\n        type=appconfig.ConfigurationType.FREEFORM,\n        validators=[validator],\n        version_label="versionLabel"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_key', 'deployment_strategy', 'deploy_to', 'description', 'name', 'type', 'validators', 'content', 'latest_version_number', 'version_label']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.HostedConfigurationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.HostedConfigurationProps
class HostedConfigurationPropsDef(BaseStruct):
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.\n')
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.ApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application associated with the configuration.\n')
    content: typing.Union[models.aws_appconfig.ConfigurationContentDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content of the hosted configuration.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The latest version number of the hosted configuration. Default: - None.\n')
    version_label: typing.Optional[str] = pydantic.Field(None, description='The version label of the hosted configuration. Default: - None.\n\n:exampleMetadata: infused\n\nExample::\n\n    app = appconfig.Application(self, "MyApp")\n    env = appconfig.Environment(self, "MyEnv",\n        application=app\n    )\n\n    appconfig.HostedConfiguration(self, "MyHostedConfig",\n        application=app,\n        deploy_to=[env],\n        content=appconfig.ConfigurationContent.from_inline_text("This is my configuration content.")\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_key', 'deployment_strategy', 'deploy_to', 'description', 'name', 'type', 'validators', 'application', 'content', 'latest_version_number', 'version_label']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.HostedConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.RolloutStrategyProps
class RolloutStrategyPropsDef(BaseStruct):
    deployment_duration: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The deployment duration of the deployment strategy. This defines the total amount of time for a deployment to last.\n')
    growth_factor: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The growth factor of the deployment strategy. This defines the percentage of targets to receive a deployed configuration during each interval.\n')
    final_bake_time: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The final bake time of the deployment strategy. This setting specifies the amount of time AWS AppConfig monitors for Amazon CloudWatch alarms after the configuration has been deployed to 100% of its targets, before considering the deployment to be complete. If an alarm is triggered during this time, AWS AppConfig rolls back the deployment. Default: Duration.minutes(0)\n\n:exampleMetadata: infused\n\nExample::\n\n    # application: appconfig.Application\n\n\n    appconfig.HostedConfiguration(self, "MyHostedConfiguration",\n        application=application,\n        content=appconfig.ConfigurationContent.from_inline_text("This is my configuration content."),\n        deployment_strategy=appconfig.DeploymentStrategy(self, "MyDeploymentStrategy",\n            rollout_strategy=appconfig.RolloutStrategy.linear(\n                growth_factor=15,\n                deployment_duration=Duration.minutes(30),\n                final_bake_time=Duration.minutes(15)\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_duration', 'growth_factor', 'final_bake_time']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.RolloutStrategyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.RolloutStrategyPropsDefConfig] = pydantic.Field(None)


class RolloutStrategyPropsDefConfig(pydantic.BaseModel):
    deployment_duration_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appconfig.SourcedConfigurationOptions
class SourcedConfigurationOptionsDef(BaseStruct):
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.\n')
    location: typing.Union[models.aws_appconfig.ConfigurationSourceDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The location where the configuration is stored.\n')
    retrieval_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to retrieve the configuration. Default: - A role is generated.\n')
    version_number: typing.Optional[str] = pydantic.Field(None, description='The version number of the sourced configuration to deploy. If this is not specified, then there will be no deployment. Default: - None.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_kms as kms\n\n    # configuration_source: appconfig.ConfigurationSource\n    # deployment_strategy: appconfig.DeploymentStrategy\n    # environment: appconfig.Environment\n    # key: kms.Key\n    # role: iam.Role\n    # validator: appconfig.IValidator\n\n    sourced_configuration_options = appconfig.SourcedConfigurationOptions(\n        location=configuration_source,\n\n        # the properties below are optional\n        deployment_key=key,\n        deployment_strategy=deployment_strategy,\n        deploy_to=[environment],\n        description="description",\n        name="name",\n        retrieval_role=role,\n        type=appconfig.ConfigurationType.FREEFORM,\n        validators=[validator],\n        version_number="versionNumber"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_key', 'deployment_strategy', 'deploy_to', 'description', 'name', 'type', 'validators', 'location', 'retrieval_role', 'version_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.SourcedConfigurationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.SourcedConfigurationProps
class SourcedConfigurationPropsDef(BaseStruct):
    deployment_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The deployment key of the configuration. Default: - None.\n')
    deployment_strategy: typing.Optional[typing.Union[models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None, description='The deployment strategy for the configuration. Default: - A deployment strategy with the rollout strategy set to RolloutStrategy.CANARY_10_PERCENT_20_MINUTES\n')
    deploy_to: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.EnvironmentDef]]] = pydantic.Field(None, description='The list of environments to deploy the configuration to. If this parameter is not specified, then there will be no deployment created alongside this configuration. Deployments can be added later using the ``IEnvironment.addDeployment`` or ``IEnvironment.addDeployments`` methods. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the configuration. Default: - No description.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration. Default: - A name is generated.\n')
    type: typing.Optional[aws_cdk.aws_appconfig.ConfigurationType] = pydantic.Field(None, description='The type of configuration. Default: ConfigurationType.FREEFORM\n')
    validators: typing.Optional[typing.Sequence[typing.Union[models.aws_appconfig.JsonSchemaValidatorDef, models.aws_appconfig.LambdaValidatorDef]]] = pydantic.Field(None, description='The validators for the configuration. Default: - No validators.\n')
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_appconfig.ApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application associated with the configuration.\n')
    location: typing.Union[models.aws_appconfig.ConfigurationSourceDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The location where the configuration is stored.\n')
    retrieval_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to retrieve the configuration. Default: - A role is generated.\n')
    version_number: typing.Optional[str] = pydantic.Field(None, description='The version number of the sourced configuration to deploy. If this is not specified, then there will be no deployment. Default: - None.\n\n:exampleMetadata: infused\n\nExample::\n\n    # application: appconfig.Application\n    # bucket: s3.Bucket\n\n\n    appconfig.SourcedConfiguration(self, "MySourcedConfiguration",\n        application=application,\n        location=appconfig.ConfigurationSource.from_bucket(bucket, "path/to/file.json"),\n        type=appconfig.ConfigurationType.FEATURE_FLAGS,\n        name="MyConfig",\n        description="This is my sourced configuration from CDK."\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_key', 'deployment_strategy', 'deploy_to', 'description', 'name', 'type', 'validators', 'application', 'location', 'retrieval_role', 'version_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.SourcedConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.SourcedConfigurationPropsDefConfig] = pydantic.Field(None)


class SourcedConfigurationPropsDefConfig(pydantic.BaseModel):
    application_config: typing.Optional[models._interface_methods.AwsAppconfigIApplicationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appconfig.ActionPoint
# skipping emum

#  autogenerated from aws_cdk.aws_appconfig.ConfigurationSourceType
# skipping emum

#  autogenerated from aws_cdk.aws_appconfig.ConfigurationType
# skipping emum

#  autogenerated from aws_cdk.aws_appconfig.GrowthType
# skipping emum

#  autogenerated from aws_cdk.aws_appconfig.MonitorType
# skipping emum

#  autogenerated from aws_cdk.aws_appconfig.Platform
# skipping emum

#  autogenerated from aws_cdk.aws_appconfig.SourceType
# skipping emum

#  autogenerated from aws_cdk.aws_appconfig.ValidatorType
# skipping emum

#  autogenerated from aws_cdk.aws_appconfig.IApplication
#  skipping Interface

#  autogenerated from aws_cdk.aws_appconfig.IConfiguration
#  skipping Interface

#  autogenerated from aws_cdk.aws_appconfig.IDeploymentStrategy
#  skipping Interface

#  autogenerated from aws_cdk.aws_appconfig.IEnvironment
#  skipping Interface

#  autogenerated from aws_cdk.aws_appconfig.IEventDestination
#  skipping Interface

#  autogenerated from aws_cdk.aws_appconfig.IExtensible
#  skipping Interface

#  autogenerated from aws_cdk.aws_appconfig.IExtension
#  skipping Interface

#  autogenerated from aws_cdk.aws_appconfig.IValidator
#  skipping Interface

#  autogenerated from aws_cdk.aws_appconfig.CfnApplication
class CfnApplicationDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the application.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the application.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata to assign to the application. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnApplication'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.CfnApplicationDefConfig] = pydantic.Field(None)


class CfnApplicationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_appconfig.CfnApplicationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_appconfig.CfnApplicationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_appconfig.CfnApplicationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_appconfig.CfnApplicationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_appconfig.CfnApplicationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_appconfig.CfnApplicationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_appconfig.CfnApplicationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_appconfig.CfnApplicationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_appconfig.CfnApplicationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_appconfig.CfnApplicationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_appconfig.CfnApplicationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_appconfig.CfnApplicationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_appconfig.CfnApplicationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnApplicationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnApplicationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApplicationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnApplicationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApplicationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnApplicationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnApplicationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnApplicationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnApplicationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnApplicationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApplicationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnApplicationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnApplicationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApplicationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.CfnConfigurationProfile
class CfnConfigurationProfileDef(BaseCfnResource):
    application_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application ID.\n')
    location_uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A URI to locate the configuration. You can specify the following:. - For the AWS AppConfig hosted configuration store and for feature flags, specify ``hosted`` . - For an AWS Systems Manager Parameter Store parameter, specify either the parameter name in the format ``ssm-parameter://<parameter name>`` or the ARN. - For an AWS CodePipeline pipeline, specify the URI in the following format: ``codepipeline`` ://. - For an AWS Secrets Manager secret, specify the URI in the following format: ``secretsmanager`` ://. - For an Amazon S3 object, specify the URI in the following format: ``s3://<bucket>/<objectKey>`` . Here is an example: ``s3://my-bucket/my-app/us-east-1/my-config.json`` - For an SSM document, specify either the document name in the format ``ssm-document://<document name>`` or the Amazon Resource Name (ARN).\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the configuration profile.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the configuration profile.\n')
    kms_key_identifier: typing.Optional[str] = pydantic.Field(None, description='The AWS Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.\n')
    retrieval_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an IAM role with permission to access the configuration at the specified ``LocationUri`` . .. epigraph:: A retrieval role ARN is not required for configurations stored in the AWS AppConfig hosted configuration store. It is required for all other sources that store your configuration.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata to assign to the configuration profile. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of configurations contained in the profile. AWS AppConfig supports ``feature flags`` and ``freeform`` configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for ``Type`` : ``AWS.AppConfig.FeatureFlags`` ``AWS.Freeform``\n')
    validators: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_appconfig.CfnConfigurationProfile_ValidatorsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of methods for validating the configuration.')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'location_uri', 'name', 'description', 'kms_key_identifier', 'retrieval_role_arn', 'tags', 'type', 'validators']
    _method_names: typing.ClassVar[list[str]] = ['ValidatorsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnConfigurationProfile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.CfnConfigurationProfileDefConfig] = pydantic.Field(None)


class CfnConfigurationProfileDefConfig(pydantic.BaseModel):
    ValidatorsProperty: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefValidatorspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_appconfig.CfnConfigurationProfileDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnConfigurationProfileDefValidatorspropertyParams(pydantic.BaseModel):
    content: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConfigurationProfileDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConfigurationProfileDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfigurationProfileDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConfigurationProfileDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfigurationProfileDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConfigurationProfileDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConfigurationProfileDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConfigurationProfileDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConfigurationProfileDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConfigurationProfileDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfigurationProfileDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConfigurationProfileDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConfigurationProfileDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfigurationProfileDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.CfnDeployment
class CfnDeploymentDef(BaseCfnResource):
    application_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application ID.\n')
    configuration_profile_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration profile ID.\n')
    configuration_version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration version to deploy. If deploying an AWS AppConfig hosted configuration version, you can specify either the version number or version label. For all other configurations, you must specify the version number.\n')
    deployment_strategy_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The deployment strategy ID.\n')
    environment_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The environment ID.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the deployment.\n')
    dynamic_extension_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_appconfig.CfnDeployment_DynamicExtensionParametersPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A map of dynamic extension parameter names to values to pass to associated extensions with ``PRE_START_DEPLOYMENT`` actions.\n')
    kms_key_identifier: typing.Optional[str] = pydantic.Field(None, description='The AWS Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata to assign to the deployment. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define.')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'configuration_profile_id', 'configuration_version', 'deployment_strategy_id', 'environment_id', 'description', 'dynamic_extension_parameters', 'kms_key_identifier', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['DynamicExtensionParametersProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnDeployment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.CfnDeploymentDefConfig] = pydantic.Field(None)


class CfnDeploymentDefConfig(pydantic.BaseModel):
    DynamicExtensionParametersProperty: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefDynamicextensionparameterspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_appconfig.CfnDeploymentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDeploymentDefDynamicextensionparameterspropertyParams(pydantic.BaseModel):
    extension_reference: typing.Optional[str] = pydantic.Field(None, description='')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='')
    parameter_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeploymentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeploymentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeploymentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeploymentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeploymentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeploymentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeploymentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDeploymentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeploymentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.CfnDeploymentStrategy
class CfnDeploymentStrategyDef(BaseCfnResource):
    deployment_duration_in_minutes: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Total amount of time for a deployment to last.\n')
    growth_factor: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage of targets to receive a deployed configuration during each interval.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the deployment strategy.\n')
    replicate_to: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Save the deployment strategy to a Systems Manager (SSM) document.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the deployment strategy.\n')
    final_bake_time_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the amount of time AWS AppConfig monitors for Amazon CloudWatch alarms after the configuration has been deployed to 100% of its targets, before considering the deployment to be complete. If an alarm is triggered during this time, AWS AppConfig rolls back the deployment. You must configure permissions for AWS AppConfig to roll back based on CloudWatch alarms. For more information, see `Configuring permissions for rollback based on Amazon CloudWatch alarms <https://docs.aws.amazon.com/appconfig/latest/userguide/getting-started-with-appconfig-cloudwatch-alarms-permissions.html>`_ in the *AWS AppConfig User Guide* .\n')
    growth_type: typing.Optional[str] = pydantic.Field(None, description='The algorithm used to define how percentage grows over time. AWS AppConfig supports the following growth types:. *Linear* : For this type, AWS AppConfig processes the deployment by dividing the total number of targets by the value specified for ``Step percentage`` . For example, a linear deployment that uses a ``Step percentage`` of 10 deploys the configuration to 10 percent of the hosts. After those deployments are complete, the system deploys the configuration to the next 10 percent. This continues until 100% of the targets have successfully received the configuration. *Exponential* : For this type, AWS AppConfig processes the deployment exponentially using the following formula: ``G*(2^N)`` . In this formula, ``G`` is the growth factor specified by the user and ``N`` is the number of steps until the configuration is deployed to all targets. For example, if you specify a growth factor of 2, then the system rolls out the configuration as follows: ``2*(2^0)`` ``2*(2^1)`` ``2*(2^2)`` Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the targets, 8% of the targets, and continues until the configuration has been deployed to all targets.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Assigns metadata to an AWS AppConfig resource. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define. You can specify a maximum of 50 tags for a resource.')
    _init_params: typing.ClassVar[list[str]] = ['deployment_duration_in_minutes', 'growth_factor', 'name', 'replicate_to', 'description', 'final_bake_time_in_minutes', 'growth_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnDeploymentStrategy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.CfnDeploymentStrategyDefConfig] = pydantic.Field(None)


class CfnDeploymentStrategyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_appconfig.CfnDeploymentStrategyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDeploymentStrategyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeploymentStrategyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentStrategyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeploymentStrategyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentStrategyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeploymentStrategyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeploymentStrategyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeploymentStrategyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeploymentStrategyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeploymentStrategyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentStrategyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDeploymentStrategyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeploymentStrategyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentStrategyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.CfnEnvironment
class CfnEnvironmentDef(BaseCfnResource):
    application_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application ID.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the environment.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the environment.\n')
    monitors: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_appconfig.CfnEnvironment_MonitorsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Amazon CloudWatch alarms to monitor during the deployment process.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata to assign to the environment. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define.')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'name', 'description', 'monitors', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['MonitorProperty', 'MonitorsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnEnvironment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.CfnEnvironmentDefConfig] = pydantic.Field(None)


class CfnEnvironmentDefConfig(pydantic.BaseModel):
    MonitorProperty: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefMonitorpropertyParams]] = pydantic.Field(None, description='')
    MonitorsProperty: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefMonitorspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_appconfig.CfnEnvironmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnEnvironmentDefMonitorpropertyParams(pydantic.BaseModel):
    alarm_arn: str = pydantic.Field(..., description='')
    alarm_role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEnvironmentDefMonitorspropertyParams(pydantic.BaseModel):
    alarm_arn: typing.Optional[str] = pydantic.Field(None, description='')
    alarm_role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEnvironmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEnvironmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEnvironmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEnvironmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEnvironmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEnvironmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEnvironmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEnvironmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEnvironmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEnvironmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEnvironmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnEnvironmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEnvironmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEnvironmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.CfnExtension
class CfnExtensionDef(BaseCfnResource):
    actions: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions defined in the extension.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the extension. Each extension name in your account must be unique. Extension versions use the same name.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the extension.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='You can omit this field when you create an extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_appconfig.CfnExtension_ParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The parameters accepted by the extension. You specify parameter values when you associate the extension to an AWS AppConfig resource by using the ``CreateExtensionAssociation`` API action. For AWS Lambda extension actions, these parameters are included in the Lambda request object.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Adds one or more tags for the specified extension. Tags are metadata that help you categorize resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'name', 'description', 'latest_version_number', 'parameters', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ActionProperty', 'ParameterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnExtension'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.CfnExtensionDefConfig] = pydantic.Field(None)


class CfnExtensionDefConfig(pydantic.BaseModel):
    ActionProperty: typing.Optional[list[models.aws_appconfig.CfnExtensionDefActionpropertyParams]] = pydantic.Field(None, description='')
    ParameterProperty: typing.Optional[list[models.aws_appconfig.CfnExtensionDefParameterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_appconfig.CfnExtensionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_appconfig.CfnExtensionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_appconfig.CfnExtensionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_appconfig.CfnExtensionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_appconfig.CfnExtensionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_appconfig.CfnExtensionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_appconfig.CfnExtensionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_appconfig.CfnExtensionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_appconfig.CfnExtensionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_appconfig.CfnExtensionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_appconfig.CfnExtensionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_appconfig.CfnExtensionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_appconfig.CfnExtensionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnExtensionDefActionpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    uri: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnExtensionDefParameterpropertyParams(pydantic.BaseModel):
    required: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    dynamic: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnExtensionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnExtensionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnExtensionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnExtensionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnExtensionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnExtensionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnExtensionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnExtensionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnExtensionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnExtensionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnExtensionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnExtensionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnExtensionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnExtensionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.CfnExtensionAssociation
class CfnExtensionAssociationDef(BaseCfnResource):
    extension_identifier: typing.Optional[str] = pydantic.Field(None, description='The name, the ID, or the Amazon Resource Name (ARN) of the extension.\n')
    extension_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the extension. If not specified, AWS AppConfig uses the maximum version of the extension.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The parameter names and values defined in the extensions. Extension parameters marked ``Required`` must be entered for this field.\n')
    resource_identifier: typing.Optional[str] = pydantic.Field(None, description='The ARN of an application, configuration profile, or environment.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Adds one or more tags for the specified extension association. Tags are metadata that help you categorize resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.')
    _init_params: typing.ClassVar[list[str]] = ['extension_identifier', 'extension_version_number', 'parameters', 'resource_identifier', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnExtensionAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.CfnExtensionAssociationDefConfig] = pydantic.Field(None)


class CfnExtensionAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_appconfig.CfnExtensionAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnExtensionAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnExtensionAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnExtensionAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnExtensionAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnExtensionAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnExtensionAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnExtensionAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnExtensionAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnExtensionAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnExtensionAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnExtensionAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnExtensionAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnExtensionAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnExtensionAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.CfnHostedConfigurationVersion
class CfnHostedConfigurationVersionDef(BaseCfnResource):
    application_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application ID.\n')
    configuration_profile_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration profile ID.\n')
    content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration data, as bytes. .. epigraph:: AWS AppConfig accepts any type of data, including text formats like JSON or TOML, or binary formats like protocol buffers or compressed data.\n')
    content_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A standard MIME type describing the format of the configuration content. For more information, see `Content-Type <https://docs.aws.amazon.com/https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17>`_ .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the configuration.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='An optional locking token used to prevent race conditions from overwriting configuration updates when creating a new version. To ensure your data is not overwritten when creating multiple hosted configuration versions in rapid succession, specify the version number of the latest hosted configuration version.\n')
    version_label: typing.Optional[str] = pydantic.Field(None, description='A user-defined label for an AWS AppConfig hosted configuration version.')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'configuration_profile_id', 'content', 'content_type', 'description', 'latest_version_number', 'version_label']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnHostedConfigurationVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_appconfig.CfnHostedConfigurationVersionDefConfig] = pydantic.Field(None)


class CfnHostedConfigurationVersionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_appconfig.CfnHostedConfigurationVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnHostedConfigurationVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnHostedConfigurationVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnHostedConfigurationVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnHostedConfigurationVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnHostedConfigurationVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnHostedConfigurationVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnHostedConfigurationVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnHostedConfigurationVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnHostedConfigurationVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnHostedConfigurationVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnHostedConfigurationVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnHostedConfigurationVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnHostedConfigurationVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnHostedConfigurationVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appconfig.CfnApplicationProps
class CfnApplicationPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the application.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the application.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata to assign to the application. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appconfig-application.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    cfn_application_props = appconfig.CfnApplicationProps(\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnApplicationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnConfigurationProfileProps
class CfnConfigurationProfilePropsDef(BaseCfnProperty):
    application_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application ID.\n')
    location_uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A URI to locate the configuration. You can specify the following:. - For the AWS AppConfig hosted configuration store and for feature flags, specify ``hosted`` . - For an AWS Systems Manager Parameter Store parameter, specify either the parameter name in the format ``ssm-parameter://<parameter name>`` or the ARN. - For an AWS CodePipeline pipeline, specify the URI in the following format: ``codepipeline`` ://. - For an AWS Secrets Manager secret, specify the URI in the following format: ``secretsmanager`` ://. - For an Amazon S3 object, specify the URI in the following format: ``s3://<bucket>/<objectKey>`` . Here is an example: ``s3://my-bucket/my-app/us-east-1/my-config.json`` - For an SSM document, specify either the document name in the format ``ssm-document://<document name>`` or the Amazon Resource Name (ARN).\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the configuration profile.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the configuration profile.\n')
    kms_key_identifier: typing.Optional[str] = pydantic.Field(None, description='The AWS Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.\n')
    retrieval_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an IAM role with permission to access the configuration at the specified ``LocationUri`` . .. epigraph:: A retrieval role ARN is not required for configurations stored in the AWS AppConfig hosted configuration store. It is required for all other sources that store your configuration.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata to assign to the configuration profile. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of configurations contained in the profile. AWS AppConfig supports ``feature flags`` and ``freeform`` configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for ``Type`` : ``AWS.AppConfig.FeatureFlags`` ``AWS.Freeform``\n')
    validators: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_appconfig.CfnConfigurationProfile_ValidatorsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of methods for validating the configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appconfig-configurationprofile.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    cfn_configuration_profile_props = appconfig.CfnConfigurationProfileProps(\n        application_id="applicationId",\n        location_uri="locationUri",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        kms_key_identifier="kmsKeyIdentifier",\n        retrieval_role_arn="retrievalRoleArn",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        type="type",\n        validators=[appconfig.CfnConfigurationProfile.ValidatorsProperty(\n            content="content",\n            type="type"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'location_uri', 'name', 'description', 'kms_key_identifier', 'retrieval_role_arn', 'tags', 'type', 'validators']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnConfigurationProfileProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnDeploymentProps
class CfnDeploymentPropsDef(BaseCfnProperty):
    application_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application ID.\n')
    configuration_profile_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration profile ID.\n')
    configuration_version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration version to deploy. If deploying an AWS AppConfig hosted configuration version, you can specify either the version number or version label. For all other configurations, you must specify the version number.\n')
    deployment_strategy_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The deployment strategy ID.\n')
    environment_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The environment ID.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the deployment.\n')
    dynamic_extension_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_appconfig.CfnDeployment_DynamicExtensionParametersPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A map of dynamic extension parameter names to values to pass to associated extensions with ``PRE_START_DEPLOYMENT`` actions.\n')
    kms_key_identifier: typing.Optional[str] = pydantic.Field(None, description='The AWS Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata to assign to the deployment. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appconfig-deployment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    cfn_deployment_props = appconfig.CfnDeploymentProps(\n        application_id="applicationId",\n        configuration_profile_id="configurationProfileId",\n        configuration_version="configurationVersion",\n        deployment_strategy_id="deploymentStrategyId",\n        environment_id="environmentId",\n\n        # the properties below are optional\n        description="description",\n        dynamic_extension_parameters=[appconfig.CfnDeployment.DynamicExtensionParametersProperty(\n            extension_reference="extensionReference",\n            parameter_name="parameterName",\n            parameter_value="parameterValue"\n        )],\n        kms_key_identifier="kmsKeyIdentifier",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'configuration_profile_id', 'configuration_version', 'deployment_strategy_id', 'environment_id', 'description', 'dynamic_extension_parameters', 'kms_key_identifier', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnDeploymentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnDeploymentStrategyProps
class CfnDeploymentStrategyPropsDef(BaseCfnProperty):
    deployment_duration_in_minutes: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Total amount of time for a deployment to last.\n')
    growth_factor: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage of targets to receive a deployed configuration during each interval.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the deployment strategy.\n')
    replicate_to: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Save the deployment strategy to a Systems Manager (SSM) document.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the deployment strategy.\n')
    final_bake_time_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the amount of time AWS AppConfig monitors for Amazon CloudWatch alarms after the configuration has been deployed to 100% of its targets, before considering the deployment to be complete. If an alarm is triggered during this time, AWS AppConfig rolls back the deployment. You must configure permissions for AWS AppConfig to roll back based on CloudWatch alarms. For more information, see `Configuring permissions for rollback based on Amazon CloudWatch alarms <https://docs.aws.amazon.com/appconfig/latest/userguide/getting-started-with-appconfig-cloudwatch-alarms-permissions.html>`_ in the *AWS AppConfig User Guide* .\n')
    growth_type: typing.Optional[str] = pydantic.Field(None, description='The algorithm used to define how percentage grows over time. AWS AppConfig supports the following growth types:. *Linear* : For this type, AWS AppConfig processes the deployment by dividing the total number of targets by the value specified for ``Step percentage`` . For example, a linear deployment that uses a ``Step percentage`` of 10 deploys the configuration to 10 percent of the hosts. After those deployments are complete, the system deploys the configuration to the next 10 percent. This continues until 100% of the targets have successfully received the configuration. *Exponential* : For this type, AWS AppConfig processes the deployment exponentially using the following formula: ``G*(2^N)`` . In this formula, ``G`` is the growth factor specified by the user and ``N`` is the number of steps until the configuration is deployed to all targets. For example, if you specify a growth factor of 2, then the system rolls out the configuration as follows: ``2*(2^0)`` ``2*(2^1)`` ``2*(2^2)`` Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the targets, 8% of the targets, and continues until the configuration has been deployed to all targets.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Assigns metadata to an AWS AppConfig resource. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define. You can specify a maximum of 50 tags for a resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appconfig-deploymentstrategy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    cfn_deployment_strategy_props = appconfig.CfnDeploymentStrategyProps(\n        deployment_duration_in_minutes=123,\n        growth_factor=123,\n        name="name",\n        replicate_to="replicateTo",\n\n        # the properties below are optional\n        description="description",\n        final_bake_time_in_minutes=123,\n        growth_type="growthType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_duration_in_minutes', 'growth_factor', 'name', 'replicate_to', 'description', 'final_bake_time_in_minutes', 'growth_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnDeploymentStrategyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnEnvironmentProps
class CfnEnvironmentPropsDef(BaseCfnProperty):
    application_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application ID.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the environment.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the environment.\n')
    monitors: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_appconfig.CfnEnvironment_MonitorsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Amazon CloudWatch alarms to monitor during the deployment process.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata to assign to the environment. Tags help organize and categorize your AWS AppConfig resources. Each tag consists of a key and an optional value, both of which you define.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appconfig-environment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    cfn_environment_props = appconfig.CfnEnvironmentProps(\n        application_id="applicationId",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        monitors=[appconfig.CfnEnvironment.MonitorsProperty(\n            alarm_arn="alarmArn",\n            alarm_role_arn="alarmRoleArn"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'name', 'description', 'monitors', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnEnvironmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnExtensionAssociationProps
class CfnExtensionAssociationPropsDef(BaseCfnProperty):
    extension_identifier: typing.Optional[str] = pydantic.Field(None, description='The name, the ID, or the Amazon Resource Name (ARN) of the extension.\n')
    extension_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the extension. If not specified, AWS AppConfig uses the maximum version of the extension.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The parameter names and values defined in the extensions. Extension parameters marked ``Required`` must be entered for this field.\n')
    resource_identifier: typing.Optional[str] = pydantic.Field(None, description='The ARN of an application, configuration profile, or environment.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Adds one or more tags for the specified extension association. Tags are metadata that help you categorize resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appconfig-extensionassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    cfn_extension_association_props = appconfig.CfnExtensionAssociationProps(\n        extension_identifier="extensionIdentifier",\n        extension_version_number=123,\n        parameters={\n            "parameters_key": "parameters"\n        },\n        resource_identifier="resourceIdentifier",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['extension_identifier', 'extension_version_number', 'parameters', 'resource_identifier', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnExtensionAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnExtensionProps
class CfnExtensionPropsDef(BaseCfnProperty):
    actions: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions defined in the extension.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the extension. Each extension name in your account must be unique. Extension versions use the same name.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the extension.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='You can omit this field when you create an extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_appconfig.CfnExtension_ParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The parameters accepted by the extension. You specify parameter values when you associate the extension to an AWS AppConfig resource by using the ``CreateExtensionAssociation`` API action. For AWS Lambda extension actions, these parameters are included in the Lambda request object.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Adds one or more tags for the specified extension. Tags are metadata that help you categorize resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appconfig-extension.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    # actions: Any\n\n    cfn_extension_props = appconfig.CfnExtensionProps(\n        actions=actions,\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        latest_version_number=123,\n        parameters={\n            "parameters_key": appconfig.CfnExtension.ParameterProperty(\n                required=False,\n\n                # the properties below are optional\n                description="description",\n                dynamic=False\n            )\n        },\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'name', 'description', 'latest_version_number', 'parameters', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnExtensionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appconfig.CfnHostedConfigurationVersionProps
class CfnHostedConfigurationVersionPropsDef(BaseCfnProperty):
    application_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The application ID.\n')
    configuration_profile_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration profile ID.\n')
    content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration data, as bytes. .. epigraph:: AWS AppConfig accepts any type of data, including text formats like JSON or TOML, or binary formats like protocol buffers or compressed data.\n')
    content_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A standard MIME type describing the format of the configuration content. For more information, see `Content-Type <https://docs.aws.amazon.com/https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17>`_ .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the configuration.\n')
    latest_version_number: typing.Union[int, float, None] = pydantic.Field(None, description='An optional locking token used to prevent race conditions from overwriting configuration updates when creating a new version. To ensure your data is not overwritten when creating multiple hosted configuration versions in rapid succession, specify the version number of the latest hosted configuration version.\n')
    version_label: typing.Optional[str] = pydantic.Field(None, description='A user-defined label for an AWS AppConfig hosted configuration version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appconfig-hostedconfigurationversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appconfig as appconfig\n\n    cfn_hosted_configuration_version_props = appconfig.CfnHostedConfigurationVersionProps(\n        application_id="applicationId",\n        configuration_profile_id="configurationProfileId",\n        content="content",\n        content_type="contentType",\n\n        # the properties below are optional\n        description="description",\n        latest_version_number=123,\n        version_label="versionLabel"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'configuration_profile_id', 'content', 'content_type', 'description', 'latest_version_number', 'version_label']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appconfig.CfnHostedConfigurationVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    Action: typing.Optional[dict[str, models.aws_appconfig.ActionDef]] = pydantic.Field(None)
    ConfigurationContent: typing.Optional[dict[str, models.aws_appconfig.ConfigurationContentDef]] = pydantic.Field(None)
    ConfigurationSource: typing.Optional[dict[str, models.aws_appconfig.ConfigurationSourceDef]] = pydantic.Field(None)
    DeploymentStrategyId: typing.Optional[dict[str, models.aws_appconfig.DeploymentStrategyIdDef]] = pydantic.Field(None)
    EventBridgeDestination: typing.Optional[dict[str, models.aws_appconfig.EventBridgeDestinationDef]] = pydantic.Field(None)
    ExtensibleBase: typing.Optional[dict[str, models.aws_appconfig.ExtensibleBaseDef]] = pydantic.Field(None)
    JsonSchemaValidator: typing.Optional[dict[str, models.aws_appconfig.JsonSchemaValidatorDef]] = pydantic.Field(None)
    LambdaDestination: typing.Optional[dict[str, models.aws_appconfig.LambdaDestinationDef]] = pydantic.Field(None)
    LambdaValidator: typing.Optional[dict[str, models.aws_appconfig.LambdaValidatorDef]] = pydantic.Field(None)
    Monitor: typing.Optional[dict[str, models.aws_appconfig.MonitorDef]] = pydantic.Field(None)
    Parameter: typing.Optional[dict[str, models.aws_appconfig.ParameterDef]] = pydantic.Field(None)
    RolloutStrategy: typing.Optional[dict[str, models.aws_appconfig.RolloutStrategyDef]] = pydantic.Field(None)
    SnsDestination: typing.Optional[dict[str, models.aws_appconfig.SnsDestinationDef]] = pydantic.Field(None)
    SqsDestination: typing.Optional[dict[str, models.aws_appconfig.SqsDestinationDef]] = pydantic.Field(None)
    Application: typing.Optional[dict[str, models.aws_appconfig.ApplicationDef]] = pydantic.Field(None)
    DeploymentStrategy: typing.Optional[dict[str, models.aws_appconfig.DeploymentStrategyDef]] = pydantic.Field(None)
    Environment: typing.Optional[dict[str, models.aws_appconfig.EnvironmentDef]] = pydantic.Field(None)
    Extension: typing.Optional[dict[str, models.aws_appconfig.ExtensionDef]] = pydantic.Field(None)
    HostedConfiguration: typing.Optional[dict[str, models.aws_appconfig.HostedConfigurationDef]] = pydantic.Field(None)
    SourcedConfiguration: typing.Optional[dict[str, models.aws_appconfig.SourcedConfigurationDef]] = pydantic.Field(None)
    ActionProps: typing.Optional[dict[str, models.aws_appconfig.ActionPropsDef]] = pydantic.Field(None)
    ApplicationProps: typing.Optional[dict[str, models.aws_appconfig.ApplicationPropsDef]] = pydantic.Field(None)
    CfnConfigurationProfile_ValidatorsProperty: typing.Optional[dict[str, models.aws_appconfig.CfnConfigurationProfile_ValidatorsPropertyDef]] = pydantic.Field(None)
    CfnDeployment_DynamicExtensionParametersProperty: typing.Optional[dict[str, models.aws_appconfig.CfnDeployment_DynamicExtensionParametersPropertyDef]] = pydantic.Field(None)
    CfnEnvironment_MonitorProperty: typing.Optional[dict[str, models.aws_appconfig.CfnEnvironment_MonitorPropertyDef]] = pydantic.Field(None)
    CfnEnvironment_MonitorsProperty: typing.Optional[dict[str, models.aws_appconfig.CfnEnvironment_MonitorsPropertyDef]] = pydantic.Field(None)
    CfnExtension_ActionProperty: typing.Optional[dict[str, models.aws_appconfig.CfnExtension_ActionPropertyDef]] = pydantic.Field(None)
    CfnExtension_ParameterProperty: typing.Optional[dict[str, models.aws_appconfig.CfnExtension_ParameterPropertyDef]] = pydantic.Field(None)
    ConfigurationOptions: typing.Optional[dict[str, models.aws_appconfig.ConfigurationOptionsDef]] = pydantic.Field(None)
    ConfigurationProps: typing.Optional[dict[str, models.aws_appconfig.ConfigurationPropsDef]] = pydantic.Field(None)
    DeploymentStrategyProps: typing.Optional[dict[str, models.aws_appconfig.DeploymentStrategyPropsDef]] = pydantic.Field(None)
    EnvironmentAttributes: typing.Optional[dict[str, models.aws_appconfig.EnvironmentAttributesDef]] = pydantic.Field(None)
    EnvironmentOptions: typing.Optional[dict[str, models.aws_appconfig.EnvironmentOptionsDef]] = pydantic.Field(None)
    EnvironmentProps: typing.Optional[dict[str, models.aws_appconfig.EnvironmentPropsDef]] = pydantic.Field(None)
    ExtensionAttributes: typing.Optional[dict[str, models.aws_appconfig.ExtensionAttributesDef]] = pydantic.Field(None)
    ExtensionOptions: typing.Optional[dict[str, models.aws_appconfig.ExtensionOptionsDef]] = pydantic.Field(None)
    ExtensionProps: typing.Optional[dict[str, models.aws_appconfig.ExtensionPropsDef]] = pydantic.Field(None)
    HostedConfigurationOptions: typing.Optional[dict[str, models.aws_appconfig.HostedConfigurationOptionsDef]] = pydantic.Field(None)
    HostedConfigurationProps: typing.Optional[dict[str, models.aws_appconfig.HostedConfigurationPropsDef]] = pydantic.Field(None)
    RolloutStrategyProps: typing.Optional[dict[str, models.aws_appconfig.RolloutStrategyPropsDef]] = pydantic.Field(None)
    SourcedConfigurationOptions: typing.Optional[dict[str, models.aws_appconfig.SourcedConfigurationOptionsDef]] = pydantic.Field(None)
    SourcedConfigurationProps: typing.Optional[dict[str, models.aws_appconfig.SourcedConfigurationPropsDef]] = pydantic.Field(None)
    CfnApplication: typing.Optional[dict[str, models.aws_appconfig.CfnApplicationDef]] = pydantic.Field(None)
    CfnConfigurationProfile: typing.Optional[dict[str, models.aws_appconfig.CfnConfigurationProfileDef]] = pydantic.Field(None)
    CfnDeployment: typing.Optional[dict[str, models.aws_appconfig.CfnDeploymentDef]] = pydantic.Field(None)
    CfnDeploymentStrategy: typing.Optional[dict[str, models.aws_appconfig.CfnDeploymentStrategyDef]] = pydantic.Field(None)
    CfnEnvironment: typing.Optional[dict[str, models.aws_appconfig.CfnEnvironmentDef]] = pydantic.Field(None)
    CfnExtension: typing.Optional[dict[str, models.aws_appconfig.CfnExtensionDef]] = pydantic.Field(None)
    CfnExtensionAssociation: typing.Optional[dict[str, models.aws_appconfig.CfnExtensionAssociationDef]] = pydantic.Field(None)
    CfnHostedConfigurationVersion: typing.Optional[dict[str, models.aws_appconfig.CfnHostedConfigurationVersionDef]] = pydantic.Field(None)
    CfnApplicationProps: typing.Optional[dict[str, models.aws_appconfig.CfnApplicationPropsDef]] = pydantic.Field(None)
    CfnConfigurationProfileProps: typing.Optional[dict[str, models.aws_appconfig.CfnConfigurationProfilePropsDef]] = pydantic.Field(None)
    CfnDeploymentProps: typing.Optional[dict[str, models.aws_appconfig.CfnDeploymentPropsDef]] = pydantic.Field(None)
    CfnDeploymentStrategyProps: typing.Optional[dict[str, models.aws_appconfig.CfnDeploymentStrategyPropsDef]] = pydantic.Field(None)
    CfnEnvironmentProps: typing.Optional[dict[str, models.aws_appconfig.CfnEnvironmentPropsDef]] = pydantic.Field(None)
    CfnExtensionAssociationProps: typing.Optional[dict[str, models.aws_appconfig.CfnExtensionAssociationPropsDef]] = pydantic.Field(None)
    CfnExtensionProps: typing.Optional[dict[str, models.aws_appconfig.CfnExtensionPropsDef]] = pydantic.Field(None)
    CfnHostedConfigurationVersionProps: typing.Optional[dict[str, models.aws_appconfig.CfnHostedConfigurationVersionPropsDef]] = pydantic.Field(None)
    ...

import models
