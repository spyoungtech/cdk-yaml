from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_backup.BackupPlanRule
class BackupPlanRuleDef(BaseClass):
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='The backup vault where backups are. Default: - use the vault defined at the plan level. If not defined a new common vault for the plan will be created')
    completion_window: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The duration after a backup job is successfully started before it must be completed or it is canceled by AWS Backup. Default: - 8 hours\n')
    copy_actions: typing.Optional[typing.Sequence[typing.Union[models.aws_backup.BackupPlanCopyActionPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Copy operations to perform on recovery points created by this rule. Default: - no copy actions\n')
    delete_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the duration after creation that a recovery point is deleted. Must be greater than ``moveToColdStorageAfter``. Default: - recovery point is never deleted\n')
    enable_continuous_backup: typing.Optional[bool] = pydantic.Field(None, description='Enables continuous backup and point-in-time restores (PITR). Property ``deleteAfter`` defines the retention period for the backup. It is mandatory if PITR is enabled. If no value is specified, the retention period is set to 35 days which is the maximum retention period supported by PITR. Property ``moveToColdStorageAfter`` must not be specified because PITR does not support this option. Default: false\n')
    move_to_cold_storage_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the duration after creation that a recovery point is moved to cold storage. Default: - recovery point is never moved to cold storage\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A display name for the backup rule. Default: - a CDK generated name\n')
    schedule_expression: typing.Optional[models.aws_events.ScheduleDef] = pydantic.Field(None, description='A CRON expression specifying when AWS Backup initiates a backup job. Default: - no schedule\n')
    start_window: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The duration after a backup is scheduled before a job is canceled if it doesn't start successfully. Default: - 8 hours")
    _init_params: typing.ClassVar[list[str]] = ['backup_vault', 'completion_window', 'copy_actions', 'delete_after', 'enable_continuous_backup', 'move_to_cold_storage_after', 'rule_name', 'schedule_expression', 'start_window']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['daily', 'monthly1_year', 'monthly5_year', 'monthly7_year', 'weekly']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupPlanRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[BackupPlanRuleDefConfig] = pydantic.Field(None)


class BackupPlanRuleDefConfig(pydantic.BaseModel):
    daily: typing.Optional[list[BackupPlanRuleDefDailyParams]] = pydantic.Field(None, description='Daily with 35 days retention.')
    monthly1_year: typing.Optional[list[BackupPlanRuleDefMonthly1YearParams]] = pydantic.Field(None, description='Monthly 1 year retention, move to cold storage after 1 month.')
    monthly5_year: typing.Optional[list[BackupPlanRuleDefMonthly5YearParams]] = pydantic.Field(None, description='Monthly 5 year retention, move to cold storage after 3 months.')
    monthly7_year: typing.Optional[list[BackupPlanRuleDefMonthly7YearParams]] = pydantic.Field(None, description='Monthly 7 year retention, move to cold storage after 3 months.')
    weekly: typing.Optional[list[BackupPlanRuleDefWeeklyParams]] = pydantic.Field(None, description='Weekly with 3 months retention.')

class BackupPlanRuleDefDailyParams(pydantic.BaseModel):
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanRuleDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanRuleDefMonthly1YearParams(pydantic.BaseModel):
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanRuleDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanRuleDefMonthly5YearParams(pydantic.BaseModel):
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanRuleDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanRuleDefMonthly7YearParams(pydantic.BaseModel):
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanRuleDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanRuleDefWeeklyParams(pydantic.BaseModel):
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanRuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_backup.BackupResource
class BackupResourceDef(BaseClass):
    resource: typing.Optional[str] = pydantic.Field(None, description='-')
    tag_condition: typing.Union[models.aws_backup.TagConditionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='-\n')
    construct_: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='-', alias='construct')
    _init_params: typing.ClassVar[list[str]] = ['resource', 'tag_condition', 'construct']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_arn', 'from_construct', 'from_dynamo_db_table', 'from_ec2_instance', 'from_efs_file_system', 'from_rds_database_cluster', 'from_rds_database_instance', 'from_rds_serverless_cluster', 'from_tag']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupResource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[BackupResourceDefConfig] = pydantic.Field(None)


class BackupResourceDefConfig(pydantic.BaseModel):
    from_arn: typing.Optional[list[BackupResourceDefFromArnParams]] = pydantic.Field(None, description='A list of ARNs or match patterns such as ``arn:aws:ec2:us-east-1:123456789012:volume/*``.')
    from_construct: typing.Optional[list[BackupResourceDefFromConstructParams]] = pydantic.Field(None, description='Adds all supported resources in a construct.')
    from_dynamo_db_table: typing.Optional[list[BackupResourceDefFromDynamoDbTableParams]] = pydantic.Field(None, description='A DynamoDB table.')
    from_ec2_instance: typing.Optional[list[BackupResourceDefFromEc2InstanceParams]] = pydantic.Field(None, description='An EC2 instance.')
    from_efs_file_system: typing.Optional[list[BackupResourceDefFromEfsFileSystemParams]] = pydantic.Field(None, description='An EFS file system.')
    from_rds_database_cluster: typing.Optional[list[BackupResourceDefFromRdsDatabaseClusterParams]] = pydantic.Field(None, description='A RDS database cluter.')
    from_rds_database_instance: typing.Optional[list[BackupResourceDefFromRdsDatabaseInstanceParams]] = pydantic.Field(None, description='A RDS database instance.')
    from_rds_serverless_cluster: typing.Optional[list[BackupResourceDefFromRdsServerlessClusterParams]] = pydantic.Field(None, description='An Aurora database instance.')
    from_tag: typing.Optional[list[BackupResourceDefFromTagParams]] = pydantic.Field(None, description='A tag condition.')

class BackupResourceDefFromArnParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...

class BackupResourceDefFromConstructParams(pydantic.BaseModel):
    construct_: models.constructs.ConstructDef = pydantic.Field(..., description='The construct containing resources to backup.', alias='construct')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...

class BackupResourceDefFromDynamoDbTableParams(pydantic.BaseModel):
    table: typing.Union[models.aws_dynamodb.TableDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...

class BackupResourceDefFromEc2InstanceParams(pydantic.BaseModel):
    instance: typing.Union[models.aws_ec2.BastionHostLinuxDef, models.aws_ec2.InstanceDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...

class BackupResourceDefFromEfsFileSystemParams(pydantic.BaseModel):
    file_system: typing.Union[models.aws_efs.FileSystemDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...

class BackupResourceDefFromRdsDatabaseClusterParams(pydantic.BaseModel):
    cluster: typing.Union[models.aws_rds.DatabaseClusterBaseDef, models.aws_rds.DatabaseClusterDef, models.aws_rds.DatabaseClusterFromSnapshotDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...

class BackupResourceDefFromRdsDatabaseInstanceParams(pydantic.BaseModel):
    instance: typing.Union[models.aws_rds.DatabaseInstanceBaseDef, models.aws_rds.DatabaseInstanceDef, models.aws_rds.DatabaseInstanceDef, models.aws_rds.DatabaseInstanceFromSnapshotDef, models.aws_rds.DatabaseInstanceFromSnapshotDef, models.aws_rds.DatabaseInstanceReadReplicaDef, models.aws_rds.DatabaseInstanceReadReplicaDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...

class BackupResourceDefFromRdsServerlessClusterParams(pydantic.BaseModel):
    cluster: typing.Union[models.aws_rds.ServerlessClusterDef, models.aws_rds.ServerlessClusterFromSnapshotDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...

class BackupResourceDefFromTagParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: str = pydantic.Field(..., description='-\n')
    operation: typing.Optional[aws_cdk.aws_backup.TagOperation] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupResourceDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_backup.BackupPlan
class BackupPlanDef(BaseConstruct):
    backup_plan_name: typing.Optional[str] = pydantic.Field(None, description='The display name of the backup plan. Default: - A CDK generated name\n')
    backup_plan_rules: typing.Optional[typing.Sequence[models.aws_backup.BackupPlanRuleDef]] = pydantic.Field(None, description='Rules for the backup plan. Use ``addRule()`` to add rules after instantiation. Default: - use ``addRule()`` to add rules\n')
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='The backup vault where backups are stored. Default: - use the vault defined at the rule level. If not defined a new common vault for the plan will be created\n')
    windows_vss: typing.Optional[bool] = pydantic.Field(None, description='Enable Windows VSS backup. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['backup_plan_name', 'backup_plan_rules', 'backup_vault', 'windows_vss']
    _method_names: typing.ClassVar[list[str]] = ['add_rule', 'add_selection', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['daily35_day_retention', 'daily_monthly1_year_retention', 'daily_weekly_monthly5_year_retention', 'daily_weekly_monthly7_year_retention', 'from_backup_plan_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupPlan'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_backup_plan_id']
    ...


    from_backup_plan_id: typing.Optional[BackupPlanDefFromBackupPlanIdParams] = pydantic.Field(None, description='Import an existing backup plan.')
    resource_config: typing.Optional[BackupPlanDefConfig] = pydantic.Field(None)


class BackupPlanDefConfig(pydantic.BaseModel):
    add_rule: typing.Optional[list[BackupPlanDefAddRuleParams]] = pydantic.Field(None, description='Adds a rule to a plan.')
    add_selection: typing.Optional[list[BackupPlanDefAddSelectionParams]] = pydantic.Field(None, description='Adds a selection to this plan.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    daily35_day_retention: typing.Optional[list[BackupPlanDefDaily35DayRetentionParams]] = pydantic.Field(None, description='Daily with 35 day retention.')
    daily_monthly1_year_retention: typing.Optional[list[BackupPlanDefDailyMonthly1YearRetentionParams]] = pydantic.Field(None, description='Daily and monthly with 1 year retention.')
    daily_weekly_monthly5_year_retention: typing.Optional[list[BackupPlanDefDailyWeeklyMonthly5YearRetentionParams]] = pydantic.Field(None, description='Daily, weekly and monthly with 5 year retention.')
    daily_weekly_monthly7_year_retention: typing.Optional[list[BackupPlanDefDailyWeeklyMonthly7YearRetentionParams]] = pydantic.Field(None, description='Daily, weekly and monthly with 7 year retention.')
    backup_vault_config: typing.Optional[models._interface_methods.AwsBackupIBackupVaultDefConfig] = pydantic.Field(None)

class BackupPlanDefAddRuleParams(pydantic.BaseModel):
    rule: models.aws_backup.BackupPlanRuleDef = pydantic.Field(..., description='the rule to add.')
    ...

class BackupPlanDefAddSelectionParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    resources: typing.Sequence[models.aws_backup.BackupResourceDef] = pydantic.Field(..., description='The resources to backup. Use the helper static methods defined on ``BackupResource``.\n')
    allow_restores: typing.Optional[bool] = pydantic.Field(None, description='Whether to automatically give restores permissions to the role that AWS Backup uses. If ``true``, the ``AWSBackupServiceRolePolicyForRestores`` managed policy will be attached to the role. Default: false\n')
    backup_selection_name: typing.Optional[str] = pydantic.Field(None, description='The name for this selection. Default: - a CDK generated name\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The role that AWS Backup uses to authenticate when backuping or restoring the resources. The ``AWSBackupServiceRolePolicyForBackup`` managed policy will be attached to this role. Default: - a new role will be created')
    return_config: typing.Optional[list[models.aws_backup.BackupSelectionDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class BackupPlanDefDaily35DayRetentionParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanDefDailyMonthly1YearRetentionParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanDefDailyWeeklyMonthly5YearRetentionParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanDefDailyWeeklyMonthly7YearRetentionParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_backup.BackupPlanDefConfig]] = pydantic.Field(None)
    ...

class BackupPlanDefFromBackupPlanIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    backup_plan_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_backup.BackupSelection
class BackupSelectionDef(BaseConstruct):
    backup_plan: typing.Union[models.aws_backup.BackupPlanDef] = pydantic.Field(..., description='The backup plan for this selection.\n')
    resources: typing.Sequence[models.aws_backup.BackupResourceDef] = pydantic.Field(..., description='The resources to backup. Use the helper static methods defined on ``BackupResource``.\n')
    allow_restores: typing.Optional[bool] = pydantic.Field(None, description='Whether to automatically give restores permissions to the role that AWS Backup uses. If ``true``, the ``AWSBackupServiceRolePolicyForRestores`` managed policy will be attached to the role. Default: false\n')
    backup_selection_name: typing.Optional[str] = pydantic.Field(None, description='The name for this selection. Default: - a CDK generated name\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The role that AWS Backup uses to authenticate when backuping or restoring the resources. The ``AWSBackupServiceRolePolicyForBackup`` managed policy will be attached to this role. Default: - a new role will be created')
    _init_params: typing.ClassVar[list[str]] = ['backup_plan', 'resources', 'allow_restores', 'backup_selection_name', 'role']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupSelection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[BackupSelectionDefConfig] = pydantic.Field(None)


class BackupSelectionDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class BackupSelectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_backup.BackupVault
class BackupVaultDef(BaseConstruct):
    access_policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A resource-based policy that is used to manage access permissions on the backup vault. Default: - access is not restricted\n')
    backup_vault_name: typing.Optional[str] = pydantic.Field(None, description='The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. Default: - A CDK generated name\n')
    block_recovery_point_deletion: typing.Optional[bool] = pydantic.Field(None, description='Whether to add statements to the vault access policy that prevents anyone from deleting a recovery point. Default: false\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The server-side encryption key to use to protect your backups. Default: - an Amazon managed KMS key\n')
    lock_configuration: typing.Union[models.aws_backup.LockConfigurationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration for AWS Backup Vault Lock. Default: - AWS Backup Vault Lock is disabled\n')
    notification_events: typing.Optional[typing.Sequence[aws_cdk.aws_backup.BackupVaultEvents]] = pydantic.Field(None, description='The vault events to send. Default: - all vault events if ``notificationTopic`` is defined\n')
    notification_topic: typing.Optional[typing.Union[models.aws_sns.TopicBaseDef, models.aws_sns.TopicDef]] = pydantic.Field(None, description='A SNS topic to send vault events to. Default: - no notifications\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The removal policy to apply to the vault. Note that removing a vault that contains recovery points will fail. Default: RemovalPolicy.RETAIN')
    _init_params: typing.ClassVar[list[str]] = ['access_policy', 'backup_vault_name', 'block_recovery_point_deletion', 'encryption_key', 'lock_configuration', 'notification_events', 'notification_topic', 'removal_policy']
    _method_names: typing.ClassVar[list[str]] = ['add_to_access_policy', 'apply_removal_policy', 'block_recovery_point_deletion', 'grant']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_backup_vault_arn', 'from_backup_vault_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupVault'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_backup_vault_arn', 'from_backup_vault_name']
    ...


    from_backup_vault_arn: typing.Optional[BackupVaultDefFromBackupVaultArnParams] = pydantic.Field(None, description='Import an existing backup vault by arn.')
    from_backup_vault_name: typing.Optional[BackupVaultDefFromBackupVaultNameParams] = pydantic.Field(None, description='Import an existing backup vault by name.')
    resource_config: typing.Optional[BackupVaultDefConfig] = pydantic.Field(None)


class BackupVaultDefConfig(pydantic.BaseModel):
    add_to_access_policy: typing.Optional[list[BackupVaultDefAddToAccessPolicyParams]] = pydantic.Field(None, description='Adds a statement to the vault access policy.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    block_recovery_point_deletion: typing.Optional[bool] = pydantic.Field(None, description='Adds a statement to the vault access policy that prevents anyone from deleting a recovery point.')
    grant: typing.Optional[list[BackupVaultDefGrantParams]] = pydantic.Field(None, description='Grant the actions defined in actions to the given grantee on this Backup Vault resource.')

class BackupVaultDefAddToAccessPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class BackupVaultDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class BackupVaultDefFromBackupVaultArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    backup_vault_arn: str = pydantic.Field(..., description='-')
    ...

class BackupVaultDefFromBackupVaultNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    backup_vault_name: str = pydantic.Field(..., description='-')
    ...

class BackupVaultDefGrantParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='Principal to grant right to.\n')
    actions: list[str] = pydantic.Field(...)
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_backup.BackupPlanCopyActionProps
class BackupPlanCopyActionPropsDef(BaseStruct):
    destination_backup_vault: typing.Union[models.aws_backup.BackupVaultDef] = pydantic.Field(..., description='Destination Vault for recovery points to be copied into.\n')
    delete_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the duration after creation that a copied recovery point is deleted from the destination vault. Must be at least 90 days greater than ``moveToColdStorageAfter``, if specified. Default: - recovery point is never deleted\n')
    move_to_cold_storage_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the duration after creation that a copied recovery point is moved to cold storage. Default: - recovery point is never moved to cold storage\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_backup as backup\n\n    # backup_vault: backup.BackupVault\n\n    backup_plan_copy_action_props = backup.BackupPlanCopyActionProps(\n        destination_backup_vault=backup_vault,\n\n        # the properties below are optional\n        delete_after=cdk.Duration.minutes(30),\n        move_to_cold_storage_after=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_backup_vault', 'delete_after', 'move_to_cold_storage_after']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupPlanCopyActionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.BackupPlanProps
class BackupPlanPropsDef(BaseStruct):
    backup_plan_name: typing.Optional[str] = pydantic.Field(None, description='The display name of the backup plan. Default: - A CDK generated name\n')
    backup_plan_rules: typing.Optional[typing.Sequence[models.aws_backup.BackupPlanRuleDef]] = pydantic.Field(None, description='Rules for the backup plan. Use ``addRule()`` to add rules after instantiation. Default: - use ``addRule()`` to add rules\n')
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='The backup vault where backups are stored. Default: - use the vault defined at the rule level. If not defined a new common vault for the plan will be created\n')
    windows_vss: typing.Optional[bool] = pydantic.Field(None, description='Enable Windows VSS backup. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    plan = backup.BackupPlan(self, "Plan",\n        windows_vss=True\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backup_plan_name', 'backup_plan_rules', 'backup_vault', 'windows_vss']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupPlanProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.BackupPlanRuleProps
class BackupPlanRulePropsDef(BaseStruct):
    backup_vault: typing.Optional[typing.Union[models.aws_backup.BackupVaultDef]] = pydantic.Field(None, description='The backup vault where backups are. Default: - use the vault defined at the plan level. If not defined a new common vault for the plan will be created\n')
    completion_window: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The duration after a backup job is successfully started before it must be completed or it is canceled by AWS Backup. Default: - 8 hours\n')
    copy_actions: typing.Optional[typing.Sequence[typing.Union[models.aws_backup.BackupPlanCopyActionPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Copy operations to perform on recovery points created by this rule. Default: - no copy actions\n')
    delete_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the duration after creation that a recovery point is deleted. Must be greater than ``moveToColdStorageAfter``. Default: - recovery point is never deleted\n')
    enable_continuous_backup: typing.Optional[bool] = pydantic.Field(None, description='Enables continuous backup and point-in-time restores (PITR). Property ``deleteAfter`` defines the retention period for the backup. It is mandatory if PITR is enabled. If no value is specified, the retention period is set to 35 days which is the maximum retention period supported by PITR. Property ``moveToColdStorageAfter`` must not be specified because PITR does not support this option. Default: false\n')
    move_to_cold_storage_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the duration after creation that a recovery point is moved to cold storage. Default: - recovery point is never moved to cold storage\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A display name for the backup rule. Default: - a CDK generated name\n')
    schedule_expression: typing.Optional[models.aws_events.ScheduleDef] = pydantic.Field(None, description='A CRON expression specifying when AWS Backup initiates a backup job. Default: - no schedule\n')
    start_window: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The duration after a backup is scheduled before a job is canceled if it doesn't start successfully. Default: - 8 hours\n\n:exampleMetadata: infused\n\nExample::\n\n    # plan: backup.BackupPlan\n    # secondary_vault: backup.BackupVault\n\n    plan.add_rule(backup.BackupPlanRule(\n        copy_actions=[backup.BackupPlanCopyActionProps(\n            destination_backup_vault=secondary_vault,\n            move_to_cold_storage_after=Duration.days(30),\n            delete_after=Duration.days(120)\n        )]\n    ))\n")
    _init_params: typing.ClassVar[list[str]] = ['backup_vault', 'completion_window', 'copy_actions', 'delete_after', 'enable_continuous_backup', 'move_to_cold_storage_after', 'rule_name', 'schedule_expression', 'start_window']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupPlanRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.BackupSelectionOptions
class BackupSelectionOptionsDef(BaseStruct):
    resources: typing.Sequence[models.aws_backup.BackupResourceDef] = pydantic.Field(..., description='The resources to backup. Use the helper static methods defined on ``BackupResource``.\n')
    allow_restores: typing.Optional[bool] = pydantic.Field(None, description='Whether to automatically give restores permissions to the role that AWS Backup uses. If ``true``, the ``AWSBackupServiceRolePolicyForRestores`` managed policy will be attached to the role. Default: false\n')
    backup_selection_name: typing.Optional[str] = pydantic.Field(None, description='The name for this selection. Default: - a CDK generated name\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The role that AWS Backup uses to authenticate when backuping or restoring the resources. The ``AWSBackupServiceRolePolicyForBackup`` managed policy will be attached to this role. Default: - a new role will be created\n\n:exampleMetadata: infused\n\nExample::\n\n    # plan: backup.BackupPlan\n    # vpc: ec2.Vpc\n\n    my_table = dynamodb.Table.from_table_name(self, "Table", "myTableName")\n    my_database_instance = rds.DatabaseInstance(self, "DatabaseInstance",\n        engine=rds.DatabaseInstanceEngine.mysql(version=rds.MysqlEngineVersion.VER_8_0_26),\n        vpc=vpc\n    )\n    my_database_cluster = rds.DatabaseCluster(self, "DatabaseCluster",\n        engine=rds.DatabaseClusterEngine.aurora_mysql(version=rds.AuroraMysqlEngineVersion.VER_2_08_1),\n        credentials=rds.Credentials.from_generated_secret("clusteradmin"),\n        instance_props=rds.InstanceProps(\n            vpc=vpc\n        )\n    )\n    my_serverless_cluster = rds.ServerlessCluster(self, "ServerlessCluster",\n        engine=rds.DatabaseClusterEngine.AURORA_POSTGRESQL,\n        parameter_group=rds.ParameterGroup.from_parameter_group_name(self, "ParameterGroup", "default.aurora-postgresql10"),\n        vpc=vpc\n    )\n    my_cool_construct = Construct(self, "MyCoolConstruct")\n\n    plan.add_selection("Selection",\n        resources=[\n            backup.BackupResource.from_dynamo_db_table(my_table),  # A DynamoDB table\n            backup.BackupResource.from_rds_database_instance(my_database_instance),  # A RDS instance\n            backup.BackupResource.from_rds_database_cluster(my_database_cluster),  # A RDS database cluster\n            backup.BackupResource.from_rds_serverless_cluster(my_serverless_cluster),  # An Aurora Serverless cluster\n            backup.BackupResource.from_tag("stage", "prod"),  # All resources that are tagged stage=prod in the region/account\n            backup.BackupResource.from_construct(my_cool_construct)\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resources', 'allow_restores', 'backup_selection_name', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupSelectionOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.BackupSelectionProps
class BackupSelectionPropsDef(BaseStruct):
    resources: typing.Sequence[models.aws_backup.BackupResourceDef] = pydantic.Field(..., description='The resources to backup. Use the helper static methods defined on ``BackupResource``.\n')
    allow_restores: typing.Optional[bool] = pydantic.Field(None, description='Whether to automatically give restores permissions to the role that AWS Backup uses. If ``true``, the ``AWSBackupServiceRolePolicyForRestores`` managed policy will be attached to the role. Default: false\n')
    backup_selection_name: typing.Optional[str] = pydantic.Field(None, description='The name for this selection. Default: - a CDK generated name\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The role that AWS Backup uses to authenticate when backuping or restoring the resources. The ``AWSBackupServiceRolePolicyForBackup`` managed policy will be attached to this role. Default: - a new role will be created\n')
    backup_plan: typing.Union[models.aws_backup.BackupPlanDef] = pydantic.Field(..., description='The backup plan for this selection.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n    from aws_cdk import aws_iam as iam\n\n    # backup_plan: backup.BackupPlan\n    # backup_resource: backup.BackupResource\n    # role: iam.Role\n\n    backup_selection_props = backup.BackupSelectionProps(\n        backup_plan=backup_plan,\n        resources=[backup_resource],\n\n        # the properties below are optional\n        allow_restores=False,\n        backup_selection_name="backupSelectionName",\n        role=role\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resources', 'allow_restores', 'backup_selection_name', 'role', 'backup_plan']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupSelectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.BackupVaultProps
class BackupVaultPropsDef(BaseStruct):
    access_policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A resource-based policy that is used to manage access permissions on the backup vault. Default: - access is not restricted\n')
    backup_vault_name: typing.Optional[str] = pydantic.Field(None, description='The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. Default: - A CDK generated name\n')
    block_recovery_point_deletion: typing.Optional[bool] = pydantic.Field(None, description='Whether to add statements to the vault access policy that prevents anyone from deleting a recovery point. Default: false\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The server-side encryption key to use to protect your backups. Default: - an Amazon managed KMS key\n')
    lock_configuration: typing.Union[models.aws_backup.LockConfigurationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration for AWS Backup Vault Lock. Default: - AWS Backup Vault Lock is disabled\n')
    notification_events: typing.Optional[typing.Sequence[aws_cdk.aws_backup.BackupVaultEvents]] = pydantic.Field(None, description='The vault events to send. Default: - all vault events if ``notificationTopic`` is defined\n')
    notification_topic: typing.Optional[typing.Union[models.aws_sns.TopicBaseDef, models.aws_sns.TopicDef]] = pydantic.Field(None, description='A SNS topic to send vault events to. Default: - no notifications\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The removal policy to apply to the vault. Note that removing a vault that contains recovery points will fail. Default: RemovalPolicy.RETAIN\n\n:exampleMetadata: infused\n\nExample::\n\n    my_key = kms.Key.from_key_arn(self, "MyKey", "aaa")\n    my_topic = sns.Topic.from_topic_arn(self, "MyTopic", "bbb")\n\n    vault = backup.BackupVault(self, "Vault",\n        encryption_key=my_key,  # Custom encryption key\n        notification_topic=my_topic\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_policy', 'backup_vault_name', 'block_recovery_point_deletion', 'encryption_key', 'lock_configuration', 'notification_events', 'notification_topic', 'removal_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.BackupVaultProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupPlan.AdvancedBackupSettingResourceTypeProperty
class CfnBackupPlan_AdvancedBackupSettingResourceTypePropertyDef(BaseStruct):
    backup_options: typing.Any = pydantic.Field(..., description='The backup option for the resource. Each option is a key-value pair. This option is only available for Windows VSS backup jobs. Valid values: Set to ``"WindowsVSS":"enabled"`` to enable the ``WindowsVSS`` backup option and create a Windows VSS backup. Set to ``"WindowsVSS":"disabled"`` to create a regular backup. The ``WindowsVSS`` option is not enabled by default. If you specify an invalid option, you get an ``InvalidParameterValueException`` exception. For more information about Windows VSS backups, see `Creating a VSS-Enabled Windows Backup <https://docs.aws.amazon.com/aws-backup/latest/devguide/windows-backups.html>`_ .\n')
    resource_type: str = pydantic.Field(..., description='The name of a resource type. The only supported resource type is EC2.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupplan-advancedbackupsettingresourcetype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # backup_options: Any\n\n    advanced_backup_setting_resource_type_property = backup.CfnBackupPlan.AdvancedBackupSettingResourceTypeProperty(\n        backup_options=backup_options,\n        resource_type="resourceType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backup_options', 'resource_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupPlan.AdvancedBackupSettingResourceTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupPlan.BackupPlanResourceTypeProperty
class CfnBackupPlan_BackupPlanResourceTypePropertyDef(BaseStruct):
    backup_plan_name: str = pydantic.Field(..., description='The display name of a backup plan.\n')
    backup_plan_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_BackupRuleResourceTypePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='An array of ``BackupRule`` objects, each of which specifies a scheduled task that is used to back up a selection of resources.\n')
    advanced_backup_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_AdvancedBackupSettingResourceTypePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of backup options for each resource type.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupplan-backupplanresourcetype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # backup_options: Any\n\n    backup_plan_resource_type_property = backup.CfnBackupPlan.BackupPlanResourceTypeProperty(\n        backup_plan_name="backupPlanName",\n        backup_plan_rule=[backup.CfnBackupPlan.BackupRuleResourceTypeProperty(\n            rule_name="ruleName",\n            target_backup_vault="targetBackupVault",\n\n            # the properties below are optional\n            completion_window_minutes=123,\n            copy_actions=[backup.CfnBackupPlan.CopyActionResourceTypeProperty(\n                destination_backup_vault_arn="destinationBackupVaultArn",\n\n                # the properties below are optional\n                lifecycle=backup.CfnBackupPlan.LifecycleResourceTypeProperty(\n                    delete_after_days=123,\n                    move_to_cold_storage_after_days=123\n                )\n            )],\n            enable_continuous_backup=False,\n            lifecycle=backup.CfnBackupPlan.LifecycleResourceTypeProperty(\n                delete_after_days=123,\n                move_to_cold_storage_after_days=123\n            ),\n            recovery_point_tags={\n                "recovery_point_tags_key": "recoveryPointTags"\n            },\n            schedule_expression="scheduleExpression",\n            start_window_minutes=123\n        )],\n\n        # the properties below are optional\n        advanced_backup_settings=[backup.CfnBackupPlan.AdvancedBackupSettingResourceTypeProperty(\n            backup_options=backup_options,\n            resource_type="resourceType"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backup_plan_name', 'backup_plan_rule', 'advanced_backup_settings']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupPlan.BackupPlanResourceTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupPlan.BackupRuleResourceTypeProperty
class CfnBackupPlan_BackupRuleResourceTypePropertyDef(BaseStruct):
    rule_name: str = pydantic.Field(..., description='A display name for a backup rule.\n')
    target_backup_vault: str = pydantic.Field(..., description='The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of letters, numbers, and hyphens.\n')
    completion_window_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='A value in minutes after a backup job is successfully started before it must be completed or it is canceled by AWS Backup .\n')
    copy_actions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_CopyActionResourceTypePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of CopyAction objects, which contains the details of the copy operation.\n')
    enable_continuous_backup: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Enables continuous backup and point-in-time restores (PITR).\n')
    lifecycle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_LifecycleResourceTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. AWS Backup transitions and expires backups automatically according to the lifecycle that you define.\n')
    recovery_point_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.\n')
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='A CRON expression specifying when AWS Backup initiates a backup job.\n')
    start_window_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='An optional value that specifies a period of time in minutes after a backup is scheduled before a job is canceled if it doesn\'t start successfully. If this value is included, it must be at least 60 minutes to avoid errors.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupplan-backupruleresourcetype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    backup_rule_resource_type_property = backup.CfnBackupPlan.BackupRuleResourceTypeProperty(\n        rule_name="ruleName",\n        target_backup_vault="targetBackupVault",\n\n        # the properties below are optional\n        completion_window_minutes=123,\n        copy_actions=[backup.CfnBackupPlan.CopyActionResourceTypeProperty(\n            destination_backup_vault_arn="destinationBackupVaultArn",\n\n            # the properties below are optional\n            lifecycle=backup.CfnBackupPlan.LifecycleResourceTypeProperty(\n                delete_after_days=123,\n                move_to_cold_storage_after_days=123\n            )\n        )],\n        enable_continuous_backup=False,\n        lifecycle=backup.CfnBackupPlan.LifecycleResourceTypeProperty(\n            delete_after_days=123,\n            move_to_cold_storage_after_days=123\n        ),\n        recovery_point_tags={\n            "recovery_point_tags_key": "recoveryPointTags"\n        },\n        schedule_expression="scheduleExpression",\n        start_window_minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rule_name', 'target_backup_vault', 'completion_window_minutes', 'copy_actions', 'enable_continuous_backup', 'lifecycle', 'recovery_point_tags', 'schedule_expression', 'start_window_minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupPlan.BackupRuleResourceTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupPlan.CopyActionResourceTypeProperty
class CfnBackupPlan_CopyActionResourceTypePropertyDef(BaseStruct):
    destination_backup_vault_arn: str = pydantic.Field(..., description='An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup. For example, ``arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.``\n')
    lifecycle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_LifecycleResourceTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines when a protected resource is transitioned to cold storage and when it expires. AWS Backup transitions and expires backups automatically according to the lifecycle that you define. If you do not specify a lifecycle, AWS Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupplan-copyactionresourcetype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    copy_action_resource_type_property = backup.CfnBackupPlan.CopyActionResourceTypeProperty(\n        destination_backup_vault_arn="destinationBackupVaultArn",\n\n        # the properties below are optional\n        lifecycle=backup.CfnBackupPlan.LifecycleResourceTypeProperty(\n            delete_after_days=123,\n            move_to_cold_storage_after_days=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_backup_vault_arn', 'lifecycle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupPlan.CopyActionResourceTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupPlan.LifecycleResourceTypeProperty
class CfnBackupPlan_LifecycleResourceTypePropertyDef(BaseStruct):
    delete_after_days: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the number of days after creation that a recovery point is deleted. Must be greater than ``MoveToColdStorageAfterDays`` .\n')
    move_to_cold_storage_after_days: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the number of days after creation that a recovery point is moved to cold storage.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupplan-lifecycleresourcetype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    lifecycle_resource_type_property = backup.CfnBackupPlan.LifecycleResourceTypeProperty(\n        delete_after_days=123,\n        move_to_cold_storage_after_days=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_after_days', 'move_to_cold_storage_after_days']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupPlan.LifecycleResourceTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupSelection.BackupSelectionResourceTypeProperty
class CfnBackupSelection_BackupSelectionResourceTypePropertyDef(BaseStruct):
    iam_role_arn: str = pydantic.Field(..., description='The ARN of the IAM role that AWS Backup uses to authenticate when backing up the target resource; for example, ``arn:aws:iam::123456789012:role/S3Access`` .\n')
    selection_name: str = pydantic.Field(..., description='The display name of a resource selection document.\n')
    conditions: typing.Any = pydantic.Field(None, description='A list of conditions that you define to assign resources to your backup plans using tags. For example, ``"StringEquals": { "ConditionKey": "aws:ResourceTag/CreatedByCryo", "ConditionValue": "true" },`` . Condition operators are case sensitive. ``Conditions`` differs from ``ListOfTags`` as follows: - When you specify more than one condition, you only assign the resources that match ALL conditions (using AND logic). - ``Conditions`` supports ``StringEquals`` , ``StringLike`` , ``StringNotEquals`` , and ``StringNotLike`` . ``ListOfTags`` only supports ``StringEquals`` .\n')
    list_of_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionResourceTypePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of conditions that you define to assign resources to your backup plans using tags. For example, ``"StringEquals": { "ConditionKey": "aws:ResourceTag/CreatedByCryo", "ConditionValue": "true" },`` . Condition operators are case sensitive. ``ListOfTags`` differs from ``Conditions`` as follows: - When you specify more than one condition, you assign all resources that match AT LEAST ONE condition (using OR logic). - ``ListOfTags`` only supports ``StringEquals`` . ``Conditions`` supports ``StringEquals`` , ``StringLike`` , ``StringNotEquals`` , and ``StringNotLike`` .\n')
    not_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of Amazon Resource Names (ARNs) to exclude from a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to exclude many resources from a backup plan, consider a different resource selection strategy, such as assigning only one or a few resource types or refining your resource selection using tags.\n')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of strings that contain Amazon Resource Names (ARNs) of resources to assign to a backup plan.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupselection-backupselectionresourcetype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # conditions: Any\n\n    backup_selection_resource_type_property = backup.CfnBackupSelection.BackupSelectionResourceTypeProperty(\n        iam_role_arn="iamRoleArn",\n        selection_name="selectionName",\n\n        # the properties below are optional\n        conditions=conditions,\n        list_of_tags=[backup.CfnBackupSelection.ConditionResourceTypeProperty(\n            condition_key="conditionKey",\n            condition_type="conditionType",\n            condition_value="conditionValue"\n        )],\n        not_resources=["notResources"],\n        resources=["resources"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['iam_role_arn', 'selection_name', 'conditions', 'list_of_tags', 'not_resources', 'resources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupSelection.BackupSelectionResourceTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupSelection.ConditionParameterProperty
class CfnBackupSelection_ConditionParameterPropertyDef(BaseStruct):
    condition_key: typing.Optional[str] = pydantic.Field(None, description='The key in a key-value pair. For example, in the tag ``Department: Accounting`` , ``Department`` is the key.\n')
    condition_value: typing.Optional[str] = pydantic.Field(None, description='The value in a key-value pair. For example, in the tag ``Department: Accounting`` , ``Accounting`` is the value.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupselection-conditionparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    condition_parameter_property = backup.CfnBackupSelection.ConditionParameterProperty(\n        condition_key="conditionKey",\n        condition_value="conditionValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['condition_key', 'condition_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupSelection.ConditionParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupSelection.ConditionResourceTypeProperty
class CfnBackupSelection_ConditionResourceTypePropertyDef(BaseStruct):
    condition_key: str = pydantic.Field(..., description='The key in a key-value pair. For example, in ``"Department": "accounting"`` , ``"Department"`` is the key.\n')
    condition_type: str = pydantic.Field(..., description='An operation, such as ``STRINGEQUALS`` , that is applied to a key-value pair used to filter resources in a selection.\n')
    condition_value: str = pydantic.Field(..., description='The value in a key-value pair. For example, in ``"Department": "accounting"`` , ``"accounting"`` is the value.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupselection-conditionresourcetype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    condition_resource_type_property = backup.CfnBackupSelection.ConditionResourceTypeProperty(\n        condition_key="conditionKey",\n        condition_type="conditionType",\n        condition_value="conditionValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['condition_key', 'condition_type', 'condition_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupSelection.ConditionResourceTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupSelection.ConditionsProperty
class CfnBackupSelection_ConditionsPropertyDef(BaseStruct):
    string_equals: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Filters the values of your tagged resources for only those resources that you tagged with the same value. Also called "exact matching."\n')
    string_like: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Filters the values of your tagged resources for matching tag values with the use of a wildcard character (*) anywhere in the string. For example, "prod*" or "*rod*" matches the tag value "production".\n')
    string_not_equals: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Filters the values of your tagged resources for only those resources that you tagged that do not have the same value. Also called "negated matching."\n')
    string_not_like: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Filters the values of your tagged resources for non-matching tag values with the use of a wildcard character (*) anywhere in the string.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupselection-conditions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    conditions_property = backup.CfnBackupSelection.ConditionsProperty(\n        string_equals=[backup.CfnBackupSelection.ConditionParameterProperty(\n            condition_key="conditionKey",\n            condition_value="conditionValue"\n        )],\n        string_like=[backup.CfnBackupSelection.ConditionParameterProperty(\n            condition_key="conditionKey",\n            condition_value="conditionValue"\n        )],\n        string_not_equals=[backup.CfnBackupSelection.ConditionParameterProperty(\n            condition_key="conditionKey",\n            condition_value="conditionValue"\n        )],\n        string_not_like=[backup.CfnBackupSelection.ConditionParameterProperty(\n            condition_key="conditionKey",\n            condition_value="conditionValue"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['string_equals', 'string_like', 'string_not_equals', 'string_not_like']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupSelection.ConditionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupVault.LockConfigurationTypeProperty
class CfnBackupVault_LockConfigurationTypePropertyDef(BaseStruct):
    min_retention_days: typing.Union[int, float] = pydantic.Field(..., description="The AWS Backup Vault Lock configuration that specifies the minimum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to retain certain data for at least seven years (2555 days). If this parameter is not specified, Vault Lock will not enforce a minimum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails that backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already saved in the vault prior to Vault Lock are not affected.\n")
    changeable_for_days: typing.Union[int, float, None] = pydantic.Field(None, description='The AWS Backup Vault Lock configuration that specifies the number of days before the lock date. For example, setting ``ChangeableForDays`` to 30 on Jan. 1, 2022 at 8pm UTC will set the lock date to Jan. 31, 2022 at 8pm UTC. AWS Backup enforces a 72-hour cooling-off period before Vault Lock takes effect and becomes immutable. Therefore, you must set ``ChangeableForDays`` to 3 or greater. Before the lock date, you can delete Vault Lock from the vault using ``DeleteBackupVaultLockConfiguration`` or change the Vault Lock configuration using ``PutBackupVaultLockConfiguration`` . On and after the lock date, the Vault Lock becomes immutable and cannot be changed or deleted. If this parameter is not specified, you can delete Vault Lock from the vault using ``DeleteBackupVaultLockConfiguration`` or change the Vault Lock configuration using ``PutBackupVaultLockConfiguration`` at any time.\n')
    max_retention_days: typing.Union[int, float, None] = pydantic.Field(None, description="The AWS Backup Vault Lock configuration that specifies the maximum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to destroy certain data after retaining it for four years (1460 days). If this parameter is not included, Vault Lock does not enforce a maximum retention period on the recovery points in the vault. If this parameter is included without a value, Vault Lock will not enforce a maximum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already saved in the vault prior to Vault Lock are not affected.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupvault-lockconfigurationtype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    lock_configuration_type_property = backup.CfnBackupVault.LockConfigurationTypeProperty(\n        min_retention_days=123,\n\n        # the properties below are optional\n        changeable_for_days=123,\n        max_retention_days=123\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['min_retention_days', 'changeable_for_days', 'max_retention_days']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupVault.LockConfigurationTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupVault.NotificationObjectTypeProperty
class CfnBackupVault_NotificationObjectTypePropertyDef(BaseStruct):
    backup_vault_events: typing.Sequence[str] = pydantic.Field(..., description='An array of events that indicate the status of jobs to back up resources to the backup vault. For valid events, see `BackupVaultEvents <https://docs.aws.amazon.com/aws-backup/latest/devguide/API_PutBackupVaultNotifications.html#API_PutBackupVaultNotifications_RequestSyntax>`_ in the *AWS Backup API Guide* .\n')
    sns_topic_arn: str = pydantic.Field(..., description='An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon SNS) topic; for example, ``arn:aws:sns:us-west-2:111122223333:MyTopic`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-backupvault-notificationobjecttype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    notification_object_type_property = backup.CfnBackupVault.NotificationObjectTypeProperty(\n        backup_vault_events=["backupVaultEvents"],\n        sns_topic_arn="snsTopicArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backup_vault_events', 'sns_topic_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupVault.NotificationObjectTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnFramework.ControlInputParameterProperty
class CfnFramework_ControlInputParameterPropertyDef(BaseStruct):
    parameter_name: str = pydantic.Field(..., description='The name of a parameter, for example, ``BackupPlanFrequency`` .\n')
    parameter_value: str = pydantic.Field(..., description='The value of parameter, for example, ``hourly`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-framework-controlinputparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    control_input_parameter_property = backup.CfnFramework.ControlInputParameterProperty(\n        parameter_name="parameterName",\n        parameter_value="parameterValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'parameter_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnFramework.ControlInputParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnFramework.ControlScopeProperty
class CfnFramework_ControlScopePropertyDef(BaseStruct):
    compliance_resource_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ID of the only AWS resource that you want your control scope to contain.\n')
    compliance_resource_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Describes whether the control scope includes one or more types of resources, such as ``EFS`` or ``RDS`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tag key-value pair applied to those AWS resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided. The tag value is optional, but it cannot be an empty string. The structure to assign a tag is: ``[{"Key":"string","Value":"string"}]`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-framework-controlscope.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    control_scope_property = backup.CfnFramework.ControlScopeProperty(\n        compliance_resource_ids=["complianceResourceIds"],\n        compliance_resource_types=["complianceResourceTypes"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['compliance_resource_ids', 'compliance_resource_types', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnFramework.ControlScopeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnFramework.FrameworkControlProperty
class CfnFramework_FrameworkControlPropertyDef(BaseStruct):
    control_name: str = pydantic.Field(..., description='The name of a control. This name is between 1 and 256 characters.\n')
    control_input_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnFramework_ControlInputParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of ``ParameterName`` and ``ParameterValue`` pairs.\n')
    control_scope: typing.Any = pydantic.Field(None, description='The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. For more information, see ```ControlScope`` . <https://docs.aws.amazon.com/aws-backup/latest/devguide/API_ControlScope.html>`_\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-framework-frameworkcontrol.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # control_scope: Any\n\n    framework_control_property = backup.CfnFramework.FrameworkControlProperty(\n        control_name="controlName",\n\n        # the properties below are optional\n        control_input_parameters=[backup.CfnFramework.ControlInputParameterProperty(\n            parameter_name="parameterName",\n            parameter_value="parameterValue"\n        )],\n        control_scope=control_scope\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['control_name', 'control_input_parameters', 'control_scope']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnFramework.FrameworkControlProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnReportPlan.ReportDeliveryChannelProperty
class CfnReportPlan_ReportDeliveryChannelPropertyDef(BaseStruct):
    s3_bucket_name: str = pydantic.Field(..., description='The unique name of the S3 bucket that receives your reports.\n')
    formats: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the format of your reports: ``CSV`` , ``JSON`` , or both. If not specified, the default format is ``CSV`` .\n')
    s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix for where AWS Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/ ``prefix`` /Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-reportplan-reportdeliverychannel.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    report_delivery_channel_property = backup.CfnReportPlan.ReportDeliveryChannelProperty(\n        s3_bucket_name="s3BucketName",\n\n        # the properties below are optional\n        formats=["formats"],\n        s3_key_prefix="s3KeyPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_bucket_name', 'formats', 's3_key_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnReportPlan.ReportDeliveryChannelProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnReportPlan.ReportSettingProperty
class CfnReportPlan_ReportSettingPropertyDef(BaseStruct):
    report_template: str = pydantic.Field(..., description='Identifies the report template for the report. Reports are built using a report template. The report templates are:. ``RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT``\n')
    accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='These are the accounts to be included in the report.\n')
    framework_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARNs) of the frameworks a report covers.\n')
    organization_units: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='These are the Organizational Units to be included in the report.\n')
    regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='These are the Regions to be included in the report.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-backup-reportplan-reportsetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    report_setting_property = backup.CfnReportPlan.ReportSettingProperty(\n        report_template="reportTemplate",\n\n        # the properties below are optional\n        accounts=["accounts"],\n        framework_arns=["frameworkArns"],\n        organization_units=["organizationUnits"],\n        regions=["regions"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['report_template', 'accounts', 'framework_arns', 'organization_units', 'regions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnReportPlan.ReportSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.LockConfiguration
class LockConfigurationDef(BaseStruct):
    min_retention: models.DurationDef = pydantic.Field(..., description="The minimum retention period that the vault retains its recovery points. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails that backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already saved in the vault prior to Vault Lock are not affected.\n")
    changeable_for: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The duration before the lock date. AWS Backup enforces a 72-hour cooling-off period before Vault Lock takes effect and becomes immutable. Before the lock date, you can delete Vault Lock from the vault or change the Vault Lock configuration. On and after the lock date, the Vault Lock becomes immutable and cannot be changed or deleted. Default: - Vault Lock can be deleted or changed at any time\n')
    max_retention: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum retention period that the vault retains its recovery points. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job\'s retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already saved in the vault prior to Vault Lock are not affected. Default: - Vault Lock does not enforce a maximum retention period\n\n:see: https://docs.aws.amazon.com/aws-backup/latest/devguide/vault-lock.html\n:exampleMetadata: infused\n\nExample::\n\n    backup.BackupVault(self, "Vault",\n        lock_configuration=backup.LockConfiguration(\n            min_retention=Duration.days(30)\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['min_retention', 'changeable_for', 'max_retention']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.LockConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LockConfigurationDefConfig] = pydantic.Field(None)


class LockConfigurationDefConfig(pydantic.BaseModel):
    min_retention_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_backup.TagCondition
class TagConditionDef(BaseStruct):
    key: str = pydantic.Field(..., description='The key in a key-value pair. For example, in ``"ec2:ResourceTag/Department": "accounting"``, ``ec2:ResourceTag/Department`` is the key.\n')
    value: str = pydantic.Field(..., description='The value in a key-value pair. For example, in ``"ec2:ResourceTag/Department": "accounting"``, ``accounting`` is the value.\n')
    operation: typing.Optional[aws_cdk.aws_backup.TagOperation] = pydantic.Field(None, description='An operation that is applied to a key-value pair used to filter resources in a selection. Default: STRING_EQUALS\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    tag_condition = backup.TagCondition(\n        key="key",\n        value="value",\n\n        # the properties below are optional\n        operation=backup.TagOperation.STRING_EQUALS\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value', 'operation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.TagCondition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.BackupVaultEvents
# skipping emum

#  autogenerated from aws_cdk.aws_backup.TagOperation
# skipping emum

#  autogenerated from aws_cdk.aws_backup.IBackupPlan
#  skipping Interface

#  autogenerated from aws_cdk.aws_backup.IBackupVault
#  skipping Interface

#  autogenerated from aws_cdk.aws_backup.CfnBackupPlan
class CfnBackupPlanDef(BaseCfnResource):
    backup_plan: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_BackupPlanResourceTypePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Uniquely identifies the backup plan to be associated with the selection of resources.\n')
    backup_plan_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair. The specified tags are assigned to all backups created with this plan.')
    _init_params: typing.ClassVar[list[str]] = ['backup_plan', 'backup_plan_tags']
    _method_names: typing.ClassVar[list[str]] = ['AdvancedBackupSettingResourceTypeProperty', 'BackupPlanResourceTypeProperty', 'BackupRuleResourceTypeProperty', 'CopyActionResourceTypeProperty', 'LifecycleResourceTypeProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupPlan'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnBackupPlanDefConfig] = pydantic.Field(None)


class CfnBackupPlanDefConfig(pydantic.BaseModel):
    AdvancedBackupSettingResourceTypeProperty: typing.Optional[list[CfnBackupPlanDefAdvancedbackupsettingresourcetypepropertyParams]] = pydantic.Field(None, description='')
    BackupPlanResourceTypeProperty: typing.Optional[list[CfnBackupPlanDefBackupplanresourcetypepropertyParams]] = pydantic.Field(None, description='')
    BackupRuleResourceTypeProperty: typing.Optional[list[CfnBackupPlanDefBackupruleresourcetypepropertyParams]] = pydantic.Field(None, description='')
    CopyActionResourceTypeProperty: typing.Optional[list[CfnBackupPlanDefCopyactionresourcetypepropertyParams]] = pydantic.Field(None, description='')
    LifecycleResourceTypeProperty: typing.Optional[list[CfnBackupPlanDefLifecycleresourcetypepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnBackupPlanDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnBackupPlanDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnBackupPlanDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnBackupPlanDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnBackupPlanDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnBackupPlanDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnBackupPlanDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnBackupPlanDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnBackupPlanDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnBackupPlanDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnBackupPlanDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnBackupPlanDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnBackupPlanDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnBackupPlanDefAdvancedbackupsettingresourcetypepropertyParams(pydantic.BaseModel):
    backup_options: typing.Any = pydantic.Field(..., description='')
    resource_type: str = pydantic.Field(..., description='')
    ...

class CfnBackupPlanDefBackupplanresourcetypepropertyParams(pydantic.BaseModel):
    backup_plan_name: str = pydantic.Field(..., description='')
    backup_plan_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_BackupRuleResourceTypePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    advanced_backup_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_AdvancedBackupSettingResourceTypePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnBackupPlanDefBackupruleresourcetypepropertyParams(pydantic.BaseModel):
    rule_name: str = pydantic.Field(..., description='')
    target_backup_vault: str = pydantic.Field(..., description='')
    completion_window_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    copy_actions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_CopyActionResourceTypePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    enable_continuous_backup: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    lifecycle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_LifecycleResourceTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    recovery_point_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='')
    start_window_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnBackupPlanDefCopyactionresourcetypepropertyParams(pydantic.BaseModel):
    destination_backup_vault_arn: str = pydantic.Field(..., description='')
    lifecycle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_LifecycleResourceTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnBackupPlanDefLifecycleresourcetypepropertyParams(pydantic.BaseModel):
    delete_after_days: typing.Union[int, float, None] = pydantic.Field(None, description='')
    move_to_cold_storage_after_days: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnBackupPlanDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnBackupPlanDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBackupPlanDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnBackupPlanDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBackupPlanDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnBackupPlanDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnBackupPlanDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnBackupPlanDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnBackupPlanDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnBackupPlanDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBackupPlanDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnBackupPlanDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnBackupPlanDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBackupPlanDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_backup.CfnBackupSelection
class CfnBackupSelectionDef(BaseCfnResource):
    backup_plan_id: str = pydantic.Field(..., description='Uniquely identifies a backup plan.\n')
    backup_selection: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_BackupSelectionResourceTypePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Specifies the body of a request to assign a set of resources to a backup plan. It includes an array of resources, an optional array of patterns to exclude resources, an optional role to provide access to the AWS service the resource belongs to, and an optional array of tags used to identify a set of resources.')
    _init_params: typing.ClassVar[list[str]] = ['backup_plan_id', 'backup_selection']
    _method_names: typing.ClassVar[list[str]] = ['BackupSelectionResourceTypeProperty', 'ConditionParameterProperty', 'ConditionResourceTypeProperty', 'ConditionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupSelection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnBackupSelectionDefConfig] = pydantic.Field(None)


class CfnBackupSelectionDefConfig(pydantic.BaseModel):
    BackupSelectionResourceTypeProperty: typing.Optional[list[CfnBackupSelectionDefBackupselectionresourcetypepropertyParams]] = pydantic.Field(None, description='')
    ConditionParameterProperty: typing.Optional[list[CfnBackupSelectionDefConditionparameterpropertyParams]] = pydantic.Field(None, description='')
    ConditionResourceTypeProperty: typing.Optional[list[CfnBackupSelectionDefConditionresourcetypepropertyParams]] = pydantic.Field(None, description='')
    ConditionsProperty: typing.Optional[list[CfnBackupSelectionDefConditionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnBackupSelectionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnBackupSelectionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnBackupSelectionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnBackupSelectionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnBackupSelectionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnBackupSelectionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnBackupSelectionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnBackupSelectionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnBackupSelectionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnBackupSelectionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnBackupSelectionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnBackupSelectionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnBackupSelectionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnBackupSelectionDefBackupselectionresourcetypepropertyParams(pydantic.BaseModel):
    iam_role_arn: str = pydantic.Field(..., description='')
    selection_name: str = pydantic.Field(..., description='')
    conditions: typing.Any = pydantic.Field(None, description='')
    list_of_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionResourceTypePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    not_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnBackupSelectionDefConditionparameterpropertyParams(pydantic.BaseModel):
    condition_key: typing.Optional[str] = pydantic.Field(None, description='')
    condition_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnBackupSelectionDefConditionresourcetypepropertyParams(pydantic.BaseModel):
    condition_key: str = pydantic.Field(..., description='')
    condition_type: str = pydantic.Field(..., description='')
    condition_value: str = pydantic.Field(..., description='')
    ...

class CfnBackupSelectionDefConditionspropertyParams(pydantic.BaseModel):
    string_equals: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    string_like: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    string_not_equals: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    string_not_like: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_ConditionParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnBackupSelectionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnBackupSelectionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBackupSelectionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnBackupSelectionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBackupSelectionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnBackupSelectionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnBackupSelectionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnBackupSelectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnBackupSelectionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnBackupSelectionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBackupSelectionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnBackupSelectionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnBackupSelectionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBackupSelectionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_backup.CfnBackupVault
class CfnBackupVaultDef(BaseCfnResource):
    backup_vault_name: str = pydantic.Field(..., description='The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.\n')
    access_policy: typing.Any = pydantic.Field(None, description='A resource-based policy that is used to manage access permissions on the target backup vault.\n')
    backup_vault_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Metadata that you can assign to help organize the resources that you create. Each tag is a key-value pair.\n')
    encryption_key_arn: typing.Optional[str] = pydantic.Field(None, description='A server-side encryption key you can specify to encrypt your backups from services that support full AWS Backup management; for example, ``arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`` . If you specify a key, you must specify its ARN, not its alias. If you do not specify a key, AWS Backup creates a KMS key for you by default. To learn which AWS Backup services support full AWS Backup management and how AWS Backup handles encryption for backups from services that do not yet support full AWS Backup , see `Encryption for backups in AWS Backup <https://docs.aws.amazon.com/aws-backup/latest/devguide/encryption.html>`_\n')
    lock_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupVault_LockConfigurationTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration for `AWS Backup Vault Lock <https://docs.aws.amazon.com/aws-backup/latest/devguide/vault-lock.html>`_ .\n')
    notifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupVault_NotificationObjectTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The SNS event notifications for the specified backup vault.')
    _init_params: typing.ClassVar[list[str]] = ['backup_vault_name', 'access_policy', 'backup_vault_tags', 'encryption_key_arn', 'lock_configuration', 'notifications']
    _method_names: typing.ClassVar[list[str]] = ['LockConfigurationTypeProperty', 'NotificationObjectTypeProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupVault'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnBackupVaultDefConfig] = pydantic.Field(None)


class CfnBackupVaultDefConfig(pydantic.BaseModel):
    LockConfigurationTypeProperty: typing.Optional[list[CfnBackupVaultDefLockconfigurationtypepropertyParams]] = pydantic.Field(None, description='')
    NotificationObjectTypeProperty: typing.Optional[list[CfnBackupVaultDefNotificationobjecttypepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnBackupVaultDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnBackupVaultDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnBackupVaultDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnBackupVaultDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnBackupVaultDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnBackupVaultDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnBackupVaultDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnBackupVaultDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnBackupVaultDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnBackupVaultDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnBackupVaultDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnBackupVaultDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnBackupVaultDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnBackupVaultDefLockconfigurationtypepropertyParams(pydantic.BaseModel):
    min_retention_days: typing.Union[int, float] = pydantic.Field(..., description='')
    changeable_for_days: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_retention_days: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnBackupVaultDefNotificationobjecttypepropertyParams(pydantic.BaseModel):
    backup_vault_events: typing.Sequence[str] = pydantic.Field(..., description='')
    sns_topic_arn: str = pydantic.Field(..., description='')
    ...

class CfnBackupVaultDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnBackupVaultDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBackupVaultDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnBackupVaultDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBackupVaultDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnBackupVaultDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnBackupVaultDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnBackupVaultDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnBackupVaultDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnBackupVaultDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBackupVaultDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnBackupVaultDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnBackupVaultDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBackupVaultDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_backup.CfnFramework
class CfnFrameworkDef(BaseCfnResource):
    framework_controls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnFramework_FrameworkControlPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='Contains detailed information about all of the controls of a framework. Each framework must contain at least one control.\n')
    framework_description: typing.Optional[str] = pydantic.Field(None, description='An optional description of the framework with a maximum 1,024 characters.\n')
    framework_name: typing.Optional[str] = pydantic.Field(None, description='The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).\n')
    framework_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of tags with which to tag your framework.')
    _init_params: typing.ClassVar[list[str]] = ['framework_controls', 'framework_description', 'framework_name', 'framework_tags']
    _method_names: typing.ClassVar[list[str]] = ['ControlInputParameterProperty', 'ControlScopeProperty', 'FrameworkControlProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnFramework'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFrameworkDefConfig] = pydantic.Field(None)


class CfnFrameworkDefConfig(pydantic.BaseModel):
    ControlInputParameterProperty: typing.Optional[list[CfnFrameworkDefControlinputparameterpropertyParams]] = pydantic.Field(None, description='')
    ControlScopeProperty: typing.Optional[list[CfnFrameworkDefControlscopepropertyParams]] = pydantic.Field(None, description='')
    FrameworkControlProperty: typing.Optional[list[CfnFrameworkDefFrameworkcontrolpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnFrameworkDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFrameworkDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFrameworkDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFrameworkDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFrameworkDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFrameworkDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFrameworkDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFrameworkDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFrameworkDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFrameworkDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFrameworkDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFrameworkDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFrameworkDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnFrameworkDefControlinputparameterpropertyParams(pydantic.BaseModel):
    parameter_name: str = pydantic.Field(..., description='')
    parameter_value: str = pydantic.Field(..., description='')
    ...

class CfnFrameworkDefControlscopepropertyParams(pydantic.BaseModel):
    compliance_resource_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    compliance_resource_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    ...

class CfnFrameworkDefFrameworkcontrolpropertyParams(pydantic.BaseModel):
    control_name: str = pydantic.Field(..., description='')
    control_input_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnFramework_ControlInputParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    control_scope: typing.Any = pydantic.Field(None, description='')
    ...

class CfnFrameworkDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFrameworkDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFrameworkDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFrameworkDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFrameworkDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFrameworkDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFrameworkDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFrameworkDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFrameworkDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFrameworkDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFrameworkDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnFrameworkDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFrameworkDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFrameworkDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_backup.CfnReportPlan
class CfnReportPlanDef(BaseCfnResource):
    report_delivery_channel: typing.Any = pydantic.Field(..., description='Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.\n')
    report_setting: typing.Any = pydantic.Field(..., description='Identifies the report template for the report. Reports are built using a report template. The report templates are:. ``RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT`` If the report template is ``RESOURCE_COMPLIANCE_REPORT`` or ``CONTROL_COMPLIANCE_REPORT`` , this API resource also describes the report coverage by AWS Regions and frameworks.\n')
    report_plan_description: typing.Optional[str] = pydantic.Field(None, description='An optional description of the report plan with a maximum 1,024 characters.\n')
    report_plan_name: typing.Optional[str] = pydantic.Field(None, description='The unique name of the report plan. This name is between 1 and 256 characters starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).\n')
    report_plan_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of tags to tag your report plan.')
    _init_params: typing.ClassVar[list[str]] = ['report_delivery_channel', 'report_setting', 'report_plan_description', 'report_plan_name', 'report_plan_tags']
    _method_names: typing.ClassVar[list[str]] = ['ReportDeliveryChannelProperty', 'ReportSettingProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnReportPlan'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnReportPlanDefConfig] = pydantic.Field(None)


class CfnReportPlanDefConfig(pydantic.BaseModel):
    ReportDeliveryChannelProperty: typing.Optional[list[CfnReportPlanDefReportdeliverychannelpropertyParams]] = pydantic.Field(None, description='')
    ReportSettingProperty: typing.Optional[list[CfnReportPlanDefReportsettingpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnReportPlanDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnReportPlanDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnReportPlanDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnReportPlanDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnReportPlanDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnReportPlanDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnReportPlanDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnReportPlanDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnReportPlanDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnReportPlanDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnReportPlanDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnReportPlanDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnReportPlanDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnReportPlanDefReportdeliverychannelpropertyParams(pydantic.BaseModel):
    s3_bucket_name: str = pydantic.Field(..., description='')
    formats: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnReportPlanDefReportsettingpropertyParams(pydantic.BaseModel):
    report_template: str = pydantic.Field(..., description='')
    accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    framework_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    organization_units: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnReportPlanDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnReportPlanDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnReportPlanDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnReportPlanDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnReportPlanDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnReportPlanDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnReportPlanDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnReportPlanDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnReportPlanDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnReportPlanDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnReportPlanDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnReportPlanDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnReportPlanDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnReportPlanDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_backup.CfnBackupPlanProps
class CfnBackupPlanPropsDef(BaseCfnProperty):
    backup_plan: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupPlan_BackupPlanResourceTypePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Uniquely identifies the backup plan to be associated with the selection of resources.\n')
    backup_plan_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair. The specified tags are assigned to all backups created with this plan.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-backup-backupplan.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # backup_options: Any\n\n    cfn_backup_plan_props = backup.CfnBackupPlanProps(\n        backup_plan=backup.CfnBackupPlan.BackupPlanResourceTypeProperty(\n            backup_plan_name="backupPlanName",\n            backup_plan_rule=[backup.CfnBackupPlan.BackupRuleResourceTypeProperty(\n                rule_name="ruleName",\n                target_backup_vault="targetBackupVault",\n\n                # the properties below are optional\n                completion_window_minutes=123,\n                copy_actions=[backup.CfnBackupPlan.CopyActionResourceTypeProperty(\n                    destination_backup_vault_arn="destinationBackupVaultArn",\n\n                    # the properties below are optional\n                    lifecycle=backup.CfnBackupPlan.LifecycleResourceTypeProperty(\n                        delete_after_days=123,\n                        move_to_cold_storage_after_days=123\n                    )\n                )],\n                enable_continuous_backup=False,\n                lifecycle=backup.CfnBackupPlan.LifecycleResourceTypeProperty(\n                    delete_after_days=123,\n                    move_to_cold_storage_after_days=123\n                ),\n                recovery_point_tags={\n                    "recovery_point_tags_key": "recoveryPointTags"\n                },\n                schedule_expression="scheduleExpression",\n                start_window_minutes=123\n            )],\n\n            # the properties below are optional\n            advanced_backup_settings=[backup.CfnBackupPlan.AdvancedBackupSettingResourceTypeProperty(\n                backup_options=backup_options,\n                resource_type="resourceType"\n            )]\n        ),\n\n        # the properties below are optional\n        backup_plan_tags={\n            "backup_plan_tags_key": "backupPlanTags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backup_plan', 'backup_plan_tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupPlanProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupSelectionProps
class CfnBackupSelectionPropsDef(BaseCfnProperty):
    backup_plan_id: str = pydantic.Field(..., description='Uniquely identifies a backup plan.\n')
    backup_selection: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupSelection_BackupSelectionResourceTypePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Specifies the body of a request to assign a set of resources to a backup plan. It includes an array of resources, an optional array of patterns to exclude resources, an optional role to provide access to the AWS service the resource belongs to, and an optional array of tags used to identify a set of resources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-backup-backupselection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # conditions: Any\n\n    cfn_backup_selection_props = backup.CfnBackupSelectionProps(\n        backup_plan_id="backupPlanId",\n        backup_selection=backup.CfnBackupSelection.BackupSelectionResourceTypeProperty(\n            iam_role_arn="iamRoleArn",\n            selection_name="selectionName",\n\n            # the properties below are optional\n            conditions=conditions,\n            list_of_tags=[backup.CfnBackupSelection.ConditionResourceTypeProperty(\n                condition_key="conditionKey",\n                condition_type="conditionType",\n                condition_value="conditionValue"\n            )],\n            not_resources=["notResources"],\n            resources=["resources"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backup_plan_id', 'backup_selection']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupSelectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnBackupVaultProps
class CfnBackupVaultPropsDef(BaseCfnProperty):
    backup_vault_name: str = pydantic.Field(..., description='The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the AWS Region where they are created. They consist of lowercase letters, numbers, and hyphens.\n')
    access_policy: typing.Any = pydantic.Field(None, description='A resource-based policy that is used to manage access permissions on the target backup vault.\n')
    backup_vault_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Metadata that you can assign to help organize the resources that you create. Each tag is a key-value pair.\n')
    encryption_key_arn: typing.Optional[str] = pydantic.Field(None, description='A server-side encryption key you can specify to encrypt your backups from services that support full AWS Backup management; for example, ``arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`` . If you specify a key, you must specify its ARN, not its alias. If you do not specify a key, AWS Backup creates a KMS key for you by default. To learn which AWS Backup services support full AWS Backup management and how AWS Backup handles encryption for backups from services that do not yet support full AWS Backup , see `Encryption for backups in AWS Backup <https://docs.aws.amazon.com/aws-backup/latest/devguide/encryption.html>`_\n')
    lock_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupVault_LockConfigurationTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration for `AWS Backup Vault Lock <https://docs.aws.amazon.com/aws-backup/latest/devguide/vault-lock.html>`_ .\n')
    notifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnBackupVault_NotificationObjectTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The SNS event notifications for the specified backup vault.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-backup-backupvault.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # access_policy: Any\n\n    cfn_backup_vault_props = backup.CfnBackupVaultProps(\n        backup_vault_name="backupVaultName",\n\n        # the properties below are optional\n        access_policy=access_policy,\n        backup_vault_tags={\n            "backup_vault_tags_key": "backupVaultTags"\n        },\n        encryption_key_arn="encryptionKeyArn",\n        lock_configuration=backup.CfnBackupVault.LockConfigurationTypeProperty(\n            min_retention_days=123,\n\n            # the properties below are optional\n            changeable_for_days=123,\n            max_retention_days=123\n        ),\n        notifications=backup.CfnBackupVault.NotificationObjectTypeProperty(\n            backup_vault_events=["backupVaultEvents"],\n            sns_topic_arn="snsTopicArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backup_vault_name', 'access_policy', 'backup_vault_tags', 'encryption_key_arn', 'lock_configuration', 'notifications']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnBackupVaultProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnFrameworkProps
class CfnFrameworkPropsDef(BaseCfnProperty):
    framework_controls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_backup.CfnFramework_FrameworkControlPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='Contains detailed information about all of the controls of a framework. Each framework must contain at least one control.\n')
    framework_description: typing.Optional[str] = pydantic.Field(None, description='An optional description of the framework with a maximum 1,024 characters.\n')
    framework_name: typing.Optional[str] = pydantic.Field(None, description='The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).\n')
    framework_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of tags with which to tag your framework.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-backup-framework.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # control_scope: Any\n\n    cfn_framework_props = backup.CfnFrameworkProps(\n        framework_controls=[backup.CfnFramework.FrameworkControlProperty(\n            control_name="controlName",\n\n            # the properties below are optional\n            control_input_parameters=[backup.CfnFramework.ControlInputParameterProperty(\n                parameter_name="parameterName",\n                parameter_value="parameterValue"\n            )],\n            control_scope=control_scope\n        )],\n\n        # the properties below are optional\n        framework_description="frameworkDescription",\n        framework_name="frameworkName",\n        framework_tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['framework_controls', 'framework_description', 'framework_name', 'framework_tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnFrameworkProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_backup.CfnReportPlanProps
class CfnReportPlanPropsDef(BaseCfnProperty):
    report_delivery_channel: typing.Any = pydantic.Field(..., description='Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.\n')
    report_setting: typing.Any = pydantic.Field(..., description='Identifies the report template for the report. Reports are built using a report template. The report templates are:. ``RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT`` If the report template is ``RESOURCE_COMPLIANCE_REPORT`` or ``CONTROL_COMPLIANCE_REPORT`` , this API resource also describes the report coverage by AWS Regions and frameworks.\n')
    report_plan_description: typing.Optional[str] = pydantic.Field(None, description='An optional description of the report plan with a maximum 1,024 characters.\n')
    report_plan_name: typing.Optional[str] = pydantic.Field(None, description='The unique name of the report plan. This name is between 1 and 256 characters starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).\n')
    report_plan_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of tags to tag your report plan.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-backup-reportplan.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_backup as backup\n\n    # report_delivery_channel: Any\n    # report_setting: Any\n\n    cfn_report_plan_props = backup.CfnReportPlanProps(\n        report_delivery_channel=report_delivery_channel,\n        report_setting=report_setting,\n\n        # the properties below are optional\n        report_plan_description="reportPlanDescription",\n        report_plan_name="reportPlanName",\n        report_plan_tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['report_delivery_channel', 'report_setting', 'report_plan_description', 'report_plan_name', 'report_plan_tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_backup.CfnReportPlanProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    BackupPlanRule: typing.Optional[dict[str, BackupPlanRuleDef]] = pydantic.Field(None)
    BackupResource: typing.Optional[dict[str, BackupResourceDef]] = pydantic.Field(None)
    BackupPlan: typing.Optional[dict[str, BackupPlanDef]] = pydantic.Field(None)
    BackupSelection: typing.Optional[dict[str, BackupSelectionDef]] = pydantic.Field(None)
    BackupVault: typing.Optional[dict[str, BackupVaultDef]] = pydantic.Field(None)
    BackupPlanCopyActionProps: typing.Optional[dict[str, BackupPlanCopyActionPropsDef]] = pydantic.Field(None)
    BackupPlanProps: typing.Optional[dict[str, BackupPlanPropsDef]] = pydantic.Field(None)
    BackupPlanRuleProps: typing.Optional[dict[str, BackupPlanRulePropsDef]] = pydantic.Field(None)
    BackupSelectionOptions: typing.Optional[dict[str, BackupSelectionOptionsDef]] = pydantic.Field(None)
    BackupSelectionProps: typing.Optional[dict[str, BackupSelectionPropsDef]] = pydantic.Field(None)
    BackupVaultProps: typing.Optional[dict[str, BackupVaultPropsDef]] = pydantic.Field(None)
    CfnBackupPlan_AdvancedBackupSettingResourceTypeProperty: typing.Optional[dict[str, CfnBackupPlan_AdvancedBackupSettingResourceTypePropertyDef]] = pydantic.Field(None)
    CfnBackupPlan_BackupPlanResourceTypeProperty: typing.Optional[dict[str, CfnBackupPlan_BackupPlanResourceTypePropertyDef]] = pydantic.Field(None)
    CfnBackupPlan_BackupRuleResourceTypeProperty: typing.Optional[dict[str, CfnBackupPlan_BackupRuleResourceTypePropertyDef]] = pydantic.Field(None)
    CfnBackupPlan_CopyActionResourceTypeProperty: typing.Optional[dict[str, CfnBackupPlan_CopyActionResourceTypePropertyDef]] = pydantic.Field(None)
    CfnBackupPlan_LifecycleResourceTypeProperty: typing.Optional[dict[str, CfnBackupPlan_LifecycleResourceTypePropertyDef]] = pydantic.Field(None)
    CfnBackupSelection_BackupSelectionResourceTypeProperty: typing.Optional[dict[str, CfnBackupSelection_BackupSelectionResourceTypePropertyDef]] = pydantic.Field(None)
    CfnBackupSelection_ConditionParameterProperty: typing.Optional[dict[str, CfnBackupSelection_ConditionParameterPropertyDef]] = pydantic.Field(None)
    CfnBackupSelection_ConditionResourceTypeProperty: typing.Optional[dict[str, CfnBackupSelection_ConditionResourceTypePropertyDef]] = pydantic.Field(None)
    CfnBackupSelection_ConditionsProperty: typing.Optional[dict[str, CfnBackupSelection_ConditionsPropertyDef]] = pydantic.Field(None)
    CfnBackupVault_LockConfigurationTypeProperty: typing.Optional[dict[str, CfnBackupVault_LockConfigurationTypePropertyDef]] = pydantic.Field(None)
    CfnBackupVault_NotificationObjectTypeProperty: typing.Optional[dict[str, CfnBackupVault_NotificationObjectTypePropertyDef]] = pydantic.Field(None)
    CfnFramework_ControlInputParameterProperty: typing.Optional[dict[str, CfnFramework_ControlInputParameterPropertyDef]] = pydantic.Field(None)
    CfnFramework_ControlScopeProperty: typing.Optional[dict[str, CfnFramework_ControlScopePropertyDef]] = pydantic.Field(None)
    CfnFramework_FrameworkControlProperty: typing.Optional[dict[str, CfnFramework_FrameworkControlPropertyDef]] = pydantic.Field(None)
    CfnReportPlan_ReportDeliveryChannelProperty: typing.Optional[dict[str, CfnReportPlan_ReportDeliveryChannelPropertyDef]] = pydantic.Field(None)
    CfnReportPlan_ReportSettingProperty: typing.Optional[dict[str, CfnReportPlan_ReportSettingPropertyDef]] = pydantic.Field(None)
    LockConfiguration: typing.Optional[dict[str, LockConfigurationDef]] = pydantic.Field(None)
    TagCondition: typing.Optional[dict[str, TagConditionDef]] = pydantic.Field(None)
    CfnBackupPlan: typing.Optional[dict[str, CfnBackupPlanDef]] = pydantic.Field(None)
    CfnBackupSelection: typing.Optional[dict[str, CfnBackupSelectionDef]] = pydantic.Field(None)
    CfnBackupVault: typing.Optional[dict[str, CfnBackupVaultDef]] = pydantic.Field(None)
    CfnFramework: typing.Optional[dict[str, CfnFrameworkDef]] = pydantic.Field(None)
    CfnReportPlan: typing.Optional[dict[str, CfnReportPlanDef]] = pydantic.Field(None)
    CfnBackupPlanProps: typing.Optional[dict[str, CfnBackupPlanPropsDef]] = pydantic.Field(None)
    CfnBackupSelectionProps: typing.Optional[dict[str, CfnBackupSelectionPropsDef]] = pydantic.Field(None)
    CfnBackupVaultProps: typing.Optional[dict[str, CfnBackupVaultPropsDef]] = pydantic.Field(None)
    CfnFrameworkProps: typing.Optional[dict[str, CfnFrameworkPropsDef]] = pydantic.Field(None)
    CfnReportPlanProps: typing.Optional[dict[str, CfnReportPlanPropsDef]] = pydantic.Field(None)
    ...
