from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_docdb.Endpoint
class EndpointDef(BaseClass):
    address: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='- The hostname or address of the endpoint.\n')
    port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='- The port number of the endpoint.')
    _init_params: typing.ClassVar[list[str]] = ['address', 'port']
    _method_names: typing.ClassVar[list[str]] = ['port_as_string']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.Endpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.EndpointDefConfig] = pydantic.Field(None)


class EndpointDefConfig(pydantic.BaseModel):
    port_as_string: typing.Optional[bool] = pydantic.Field(None, description="Returns the port number as a string representation that can be used for embedding within other strings.\nThis is intended to deal with CDK's token system. Numeric CDK tokens are not expanded when their string\nrepresentation is embedded in a string. This function returns the port either as an unresolved string token or\nas a resolved string representation of the port value.\n\n:return: An (un)resolved string representation of the endpoint's port number")


#  autogenerated from aws_cdk.aws_docdb.ClusterParameterGroup
class ClusterParameterGroupDef(BaseConstruct):
    family: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Database family of this parameter group.\n')
    parameters: typing.Union[typing.Mapping[str, str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parameters in this parameter group.\n')
    db_cluster_parameter_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the cluster parameter group. Default: A CDK generated name for the cluster parameter group\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Description for this parameter group. Default: a CDK generated description')
    _init_params: typing.ClassVar[list[str]] = ['family', 'parameters', 'db_cluster_parameter_group_name', 'description']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_parameter_group_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.ClusterParameterGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_parameter_group_name']
    ...


    from_parameter_group_name: typing.Optional[models.aws_docdb.ClusterParameterGroupDefFromParameterGroupNameParams] = pydantic.Field(None, description='Imports a parameter group.')
    resource_config: typing.Optional[models.aws_docdb.ClusterParameterGroupDefConfig] = pydantic.Field(None)


class ClusterParameterGroupDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ClusterParameterGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ClusterParameterGroupDefFromParameterGroupNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    parameter_group_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_docdb.DatabaseCluster
class DatabaseClusterDef(BaseConstruct):
    instance_type: typing.Union[models.aws_ec2.InstanceTypeDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='What type of instance to start for the replicas.\n')
    master_user: typing.Union[_REQUIRED_INIT_PARAM, models.aws_docdb.LoginDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Username and password for the administrative user.\n')
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='What subnets to run the DocumentDB instances in. Must be at least 2 subnets in two different AZs.\n')
    backup: typing.Union[models.aws_docdb.BackupPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Backup settings. Default: - Backup retention period for automated backups is 1 day. Backup preferred window is set to a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.\n')
    cloud_watch_logs_retention: typing.Optional[aws_cdk.aws_logs.RetentionDays] = pydantic.Field(None, description="The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire\n")
    cloud_watch_logs_retention_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.\n')
    db_cluster_name: typing.Optional[str] = pydantic.Field(None, description='An optional identifier for the cluster. Default: - A name is automatically generated.\n')
    deletion_protection: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether this cluster can be deleted. If deletionProtection is enabled, the cluster cannot be deleted unless it is modified and deletionProtection is disabled. deletionProtection protects clusters from being accidentally deleted. Default: - false\n')
    enable_performance_insights: typing.Optional[bool] = pydantic.Field(None, description='A value that indicates whether to enable Performance Insights for the instances in the DB Cluster. Default: - false\n')
    engine_version: typing.Optional[str] = pydantic.Field(None, description='What version of the database to start. Default: - The default engine version.\n')
    export_audit_logs_to_cloud_watch: typing.Optional[bool] = pydantic.Field(None, description="Whether the audit logs should be exported to CloudWatch. Note that you also have to configure the audit log export in the Cluster's Parameter Group. Default: false\n")
    export_profiler_logs_to_cloud_watch: typing.Optional[bool] = pydantic.Field(None, description="Whether the profiler logs should be exported to CloudWatch. Note that you also have to configure the profiler log export in the Cluster's Parameter Group. Default: false\n")
    instance_identifier_base: typing.Optional[str] = pydantic.Field(None, description='Base identifier for instances. Every replica is named by appending the replica number to this string, 1-based. Default: - ``dbClusterName`` is used with the word "Instance" appended. If ``dbClusterName`` is not provided, the identifier is automatically generated.\n')
    instances: typing.Union[int, float, None] = pydantic.Field(None, description='Number of DocDB compute instances. Default: 1\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The KMS key for storage encryption. Default: - default master key.\n')
    parameter_group: typing.Optional[typing.Union[models.aws_docdb.ClusterParameterGroupDef]] = pydantic.Field(None, description='The DB parameter group to associate with the instance. Default: no parameter group\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port the DocumentDB cluster will listen on. Default: DatabaseCluster.DEFAULT_PORT\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description="A weekly time range in which maintenance should preferably execute. Must be at least 30 minutes long. Example: 'tue:04:17-tue:04:47' Default: - 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.\n")
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The removal policy to apply when the cluster and its instances are removed or replaced during a stack update, or when the stack is deleted. This removal policy also applies to the implicit security group created for the cluster if one is not supplied as a parameter. Default: - Retain cluster.\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security group. Default: a new security group is created.\n')
    storage_encrypted: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable storage encryption. Default: true\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Where to place the instances within the VPC. Default: private subnets')
    _init_params: typing.ClassVar[list[str]] = ['instance_type', 'master_user', 'vpc', 'backup', 'cloud_watch_logs_retention', 'cloud_watch_logs_retention_role', 'db_cluster_name', 'deletion_protection', 'enable_performance_insights', 'engine_version', 'export_audit_logs_to_cloud_watch', 'export_profiler_logs_to_cloud_watch', 'instance_identifier_base', 'instances', 'kms_key', 'parameter_group', 'port', 'preferred_maintenance_window', 'removal_policy', 'security_group', 'storage_encrypted', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = ['add_rotation_multi_user', 'add_rotation_single_user', 'add_security_groups', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_database_cluster_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.DatabaseCluster'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_database_cluster_attributes']
    ...


    from_database_cluster_attributes: typing.Optional[models.aws_docdb.DatabaseClusterDefFromDatabaseClusterAttributesParams] = pydantic.Field(None, description='Import an existing DatabaseCluster from properties.')
    resource_config: typing.Optional[models.aws_docdb.DatabaseClusterDefConfig] = pydantic.Field(None)


class DatabaseClusterDefConfig(pydantic.BaseModel):
    add_rotation_multi_user: typing.Optional[list[models.aws_docdb.DatabaseClusterDefAddRotationMultiUserParams]] = pydantic.Field(None, description='Adds the multi user rotation to this cluster.')
    add_rotation_single_user: typing.Optional[list[models.aws_docdb.DatabaseClusterDefAddRotationSingleUserParams]] = pydantic.Field(None, description='Adds the single user rotation of the master password to this cluster.')
    add_security_groups: typing.Optional[list[models.aws_docdb.DatabaseClusterDefAddSecurityGroupsParams]] = pydantic.Field(None, description='Adds security groups to this cluster.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    cluster_endpoint_config: typing.Optional[models.aws_docdb.EndpointDefConfig] = pydantic.Field(None)
    cluster_read_endpoint_config: typing.Optional[models.aws_docdb.EndpointDefConfig] = pydantic.Field(None)
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)

class DatabaseClusterDefAddRotationMultiUserParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to rotate. It must be a JSON string with the following format:: { "engine": <required: must be set to \'mongo\'>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port 27017 will be used>, "masterarn": <required: the arn of the master secret which will be used to create users/change passwords> "ssl": <optional: if not specified, defaults to false. This must be true if being used for DocumentDB rotations where the cluster has TLS enabled> }\n')
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: Duration.days(30)')
    ...

class DatabaseClusterDefAddRotationSingleUserParams(pydantic.BaseModel):
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation.')
    ...

class DatabaseClusterDefAddSecurityGroupsParams(pydantic.BaseModel):
    security_groups: list[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(...)
    ...

class DatabaseClusterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class DatabaseClusterDefFromDatabaseClusterAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    cluster_identifier: str = pydantic.Field(..., description='Identifier for the cluster.\n')
    cluster_endpoint_address: typing.Optional[str] = pydantic.Field(None, description='Cluster endpoint address. Default: - no cluster endpoint address\n')
    instance_endpoint_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Endpoint addresses of individual instances. Default: - no instance endpoint addresses\n')
    instance_identifiers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Identifier for the instances. Default: - no instance identifiers\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The database port. Default: - none\n')
    reader_endpoint_address: typing.Optional[str] = pydantic.Field(None, description='Reader endpoint address. Default: - no reader endpoint address\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='The security group of the database cluster. Default: - no security groups')
    ...


#  autogenerated from aws_cdk.aws_docdb.DatabaseInstance
class DatabaseInstanceDef(BaseConstruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_docdb.DatabaseClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The DocumentDB database cluster the instance should launch into.\n')
    instance_type: typing.Union[models.aws_ec2.InstanceTypeDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the compute and memory capacity classes.\n')
    auto_minor_version_upgrade: typing.Optional[bool] = pydantic.Field(None, description='Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The name of the Availability Zone where the DB instance will be located. Default: - no preference\n')
    db_instance_name: typing.Optional[str] = pydantic.Field(None, description='A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name\n')
    enable_performance_insights: typing.Optional[bool] = pydantic.Field(None, description='A value that indicates whether to enable Performance Insights for the DB Instance. Default: - false\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description='The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/documentdb/latest/developerguide/db-instance-maintain.html#maintenance-window\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: RemovalPolicy.Retain')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'instance_type', 'auto_minor_version_upgrade', 'availability_zone', 'db_instance_name', 'enable_performance_insights', 'preferred_maintenance_window', 'removal_policy']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_database_instance_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.DatabaseInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_database_instance_attributes']
    ...


    from_database_instance_attributes: typing.Optional[models.aws_docdb.DatabaseInstanceDefFromDatabaseInstanceAttributesParams] = pydantic.Field(None, description='Import an existing database instance.')
    resource_config: typing.Optional[models.aws_docdb.DatabaseInstanceDefConfig] = pydantic.Field(None)


class DatabaseInstanceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    cluster_config: typing.Optional[models._interface_methods.AwsDocdbIDatabaseClusterDefConfig] = pydantic.Field(None)
    instance_endpoint_config: typing.Optional[models.aws_docdb.EndpointDefConfig] = pydantic.Field(None)

class DatabaseInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class DatabaseInstanceDefFromDatabaseInstanceAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    instance_endpoint_address: str = pydantic.Field(..., description='The endpoint address.\n')
    instance_identifier: str = pydantic.Field(..., description='The instance identifier.\n')
    port: typing.Union[int, float] = pydantic.Field(..., description='The database port.')
    ...


#  autogenerated from aws_cdk.aws_docdb.DatabaseSecret
class DatabaseSecretDef(BaseConstruct):
    username: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The username.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The KMS key to use to encrypt the secret. Default: default master key\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='Characters to not include in the generated password. Default: ""@/"\n')
    master_secret: typing.Optional[typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef]] = pydantic.Field(None, description='The master secret which will be used to rotate this secret. Default: - no master secret information will be included\n')
    secret_name: typing.Optional[str] = pydantic.Field(None, description='The physical name of the secret. Default: Secretsmanager will generate a physical name for the secret')
    _init_params: typing.ClassVar[list[str]] = ['username', 'encryption_key', 'exclude_characters', 'master_secret', 'secret_name']
    _method_names: typing.ClassVar[list[str]] = ['add_replica_region', 'add_rotation_schedule', 'add_to_resource_policy', 'apply_removal_policy', 'attach', 'deny_account_root_delete', 'grant_read', 'grant_write', 'secret_value_from_json']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_secret_attributes', 'from_secret_complete_arn', 'from_secret_name_v2', 'from_secret_partial_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.DatabaseSecret'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_secret_attributes', 'from_secret_complete_arn', 'from_secret_name_v2', 'from_secret_partial_arn']
    ...


    from_secret_attributes: typing.Optional[models.aws_docdb.DatabaseSecretDefFromSecretAttributesParams] = pydantic.Field(None, description='Import an existing secret into the Stack.')
    from_secret_complete_arn: typing.Optional[models.aws_docdb.DatabaseSecretDefFromSecretCompleteArnParams] = pydantic.Field(None, description='Imports a secret by complete ARN.\nThe complete ARN is the ARN with the Secrets Manager-supplied suffix.')
    from_secret_name_v2: typing.Optional[models.aws_docdb.DatabaseSecretDefFromSecretNameV2Params] = pydantic.Field(None, description='Imports a secret by secret name.\nA secret with this name must exist in the same account & region.\nReplaces the deprecated ``fromSecretName``.\nPlease note this method returns ISecret that only contains partial ARN and could lead to AccessDeniedException\nwhen you pass the partial ARN to CLI or SDK to get the secret value. If your secret name ends with a hyphen and\n6 characters, you should always use fromSecretCompleteArn() to avoid potential AccessDeniedException.')
    from_secret_partial_arn: typing.Optional[models.aws_docdb.DatabaseSecretDefFromSecretPartialArnParams] = pydantic.Field(None, description='Imports a secret by partial ARN.\nThe partial ARN is the ARN without the Secrets Manager-supplied suffix.')
    resource_config: typing.Optional[models.aws_docdb.DatabaseSecretDefConfig] = pydantic.Field(None)


class DatabaseSecretDefConfig(pydantic.BaseModel):
    add_replica_region: typing.Optional[list[models.aws_docdb.DatabaseSecretDefAddReplicaRegionParams]] = pydantic.Field(None, description='Adds a replica region for the secret.')
    add_rotation_schedule: typing.Optional[list[models.aws_docdb.DatabaseSecretDefAddRotationScheduleParams]] = pydantic.Field(None, description='Adds a rotation schedule to the secret.')
    add_to_resource_policy: typing.Optional[list[models.aws_docdb.DatabaseSecretDefAddToResourcePolicyParams]] = pydantic.Field(None, description='Adds a statement to the IAM resource policy associated with this secret.\nIf this secret was created in this stack, a resource policy will be\nautomatically created upon the first call to ``addToResourcePolicy``. If\nthe secret is imported, then this is a no-op.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach: typing.Optional[list[models.aws_docdb.DatabaseSecretDefAttachParams]] = pydantic.Field(None, description='Attach a target to this secret.')
    deny_account_root_delete: typing.Optional[bool] = pydantic.Field(None, description='Denies the ``DeleteSecret`` action to all principals within the current account.')
    grant_read: typing.Optional[list[models.aws_docdb.DatabaseSecretDefGrantReadParams]] = pydantic.Field(None, description='Grants reading the secret value to some role.')
    grant_write: typing.Optional[list[models.aws_docdb.DatabaseSecretDefGrantWriteParams]] = pydantic.Field(None, description='Grants writing and updating the secret value to some role.')
    secret_value_from_json: typing.Optional[list[models.aws_docdb.DatabaseSecretDefSecretValueFromJsonParams]] = pydantic.Field(None, description="Interpret the secret as a JSON object and return a field's value from it as a ``SecretValue``.")
    secret_value_config: typing.Optional[models.core.SecretValueDefConfig] = pydantic.Field(None)

class DatabaseSecretDefAddReplicaRegionParams(pydantic.BaseModel):
    region: str = pydantic.Field(..., description='The name of the region.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key to use for encrypting the secret value.')
    ...

class DatabaseSecretDefAddRotationScheduleParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. The maximum value is 1000 days. A value of zero (``Duration.days(0)``) will not create RotationRules. Default: Duration.days(30)\n')
    hosted_rotation: typing.Optional[models.aws_secretsmanager.HostedRotationDef] = pydantic.Field(None, description='Hosted rotation. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified\n')
    rotate_immediately_on_update: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window. Default: true\n')
    rotation_lambda: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='A Lambda function that can rotate the secret. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified')
    return_config: typing.Optional[list[models.aws_secretsmanager.RotationScheduleDefConfig]] = pydantic.Field(None)
    ...

class DatabaseSecretDefAddToResourcePolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class DatabaseSecretDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class DatabaseSecretDefAttachParams(pydantic.BaseModel):
    target: typing.Union[models.aws_rds.DatabaseProxyDef] = pydantic.Field(..., description='The target to attach.\n')
    return_config: typing.Optional[list[models._interface_methods.AwsSecretsmanagerISecretDefConfig]] = pydantic.Field(None)
    ...

class DatabaseSecretDefFromSecretAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the scope of the import.\n')
    id: str = pydantic.Field(..., description='the ID of the imported Secret in the construct tree.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The encryption key that is used to encrypt the secret, unless the default SecretsManager key is used.\n')
    secret_complete_arn: typing.Optional[str] = pydantic.Field(None, description='The complete ARN of the secret in SecretsManager. This is the ARN including the Secrets Manager 6-character suffix. Cannot be used with ``secretArn`` or ``secretPartialArn``.\n')
    secret_partial_arn: typing.Optional[str] = pydantic.Field(None, description='The partial ARN of the secret in SecretsManager. This is the ARN without the Secrets Manager 6-character suffix. Cannot be used with ``secretArn`` or ``secretCompleteArn``.')
    ...

class DatabaseSecretDefFromSecretCompleteArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    secret_complete_arn: str = pydantic.Field(..., description='-')
    ...

class DatabaseSecretDefFromSecretNameV2Params(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    secret_name: str = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/secretsmanager/latest/userguide/troubleshoot.html#ARN_secretnamehyphen\n')
    ...

class DatabaseSecretDefFromSecretPartialArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    secret_partial_arn: str = pydantic.Field(..., description='-')
    ...

class DatabaseSecretDefGrantReadParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-\n')
    version_stages: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DatabaseSecretDefGrantWriteParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DatabaseSecretDefSecretValueFromJsonParams(pydantic.BaseModel):
    json_field: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.core.SecretValueDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_docdb.BackupProps
class BackupPropsDef(BaseStruct):
    retention: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='How many days to retain the backup.\n')
    preferred_window: typing.Optional[str] = pydantic.Field(None, description='A daily time range in 24-hours UTC format in which backups preferably execute. Must be at least 30 minutes long. Example: \'01:00-02:00\' Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/documentdb/latest/developerguide/backup-restore.db-cluster-snapshots.html#backup-restore.backup-window\n\n:default:\n\n- The retention period for automated backups is 1 day.\nThe preferred backup window will be a 30-minute window selected at random\nfrom an 8-hour block of time for each AWS Region.\n\n:see: https://docs.aws.amazon.com/documentdb/latest/developerguide/backup-restore.db-cluster-snapshots.html#backup-restore.backup-window\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_docdb as docdb\n\n    backup_props = docdb.BackupProps(\n        retention=cdk.Duration.minutes(30),\n\n        # the properties below are optional\n        preferred_window="preferredWindow"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['retention', 'preferred_window']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.BackupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.BackupPropsDefConfig] = pydantic.Field(None)


class BackupPropsDefConfig(pydantic.BaseModel):
    retention_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_docdb.ClusterParameterGroupProps
class ClusterParameterGroupPropsDef(BaseStruct):
    family: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Database family of this parameter group.\n')
    parameters: typing.Union[typing.Mapping[str, str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parameters in this parameter group.\n')
    db_cluster_parameter_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the cluster parameter group. Default: A CDK generated name for the cluster parameter group\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Description for this parameter group. Default: a CDK generated description\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_docdb as docdb\n\n    cluster_parameter_group_props = docdb.ClusterParameterGroupProps(\n        family="family",\n        parameters={\n            "parameters_key": "parameters"\n        },\n\n        # the properties below are optional\n        db_cluster_parameter_group_name="dbClusterParameterGroupName",\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['family', 'parameters', 'db_cluster_parameter_group_name', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.ClusterParameterGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_docdb.DatabaseClusterAttributes
class DatabaseClusterAttributesDef(BaseStruct):
    cluster_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Identifier for the cluster.\n')
    cluster_endpoint_address: typing.Optional[str] = pydantic.Field(None, description='Cluster endpoint address. Default: - no cluster endpoint address\n')
    instance_endpoint_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Endpoint addresses of individual instances. Default: - no instance endpoint addresses\n')
    instance_identifiers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Identifier for the instances. Default: - no instance identifiers\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The database port. Default: - none\n')
    reader_endpoint_address: typing.Optional[str] = pydantic.Field(None, description='Reader endpoint address. Default: - no reader endpoint address\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='The security group of the database cluster. Default: - no security groups\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_docdb as docdb\n    from aws_cdk import aws_ec2 as ec2\n\n    # security_group: ec2.SecurityGroup\n\n    database_cluster_attributes = docdb.DatabaseClusterAttributes(\n        cluster_identifier="clusterIdentifier",\n\n        # the properties below are optional\n        cluster_endpoint_address="clusterEndpointAddress",\n        instance_endpoint_addresses=["instanceEndpointAddresses"],\n        instance_identifiers=["instanceIdentifiers"],\n        port=123,\n        reader_endpoint_address="readerEndpointAddress",\n        security_group=security_group\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_identifier', 'cluster_endpoint_address', 'instance_endpoint_addresses', 'instance_identifiers', 'port', 'reader_endpoint_address', 'security_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.DatabaseClusterAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_docdb.DatabaseClusterProps
class DatabaseClusterPropsDef(BaseStruct):
    instance_type: typing.Union[models.aws_ec2.InstanceTypeDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='What type of instance to start for the replicas.\n')
    master_user: typing.Union[_REQUIRED_INIT_PARAM, models.aws_docdb.LoginDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Username and password for the administrative user.\n')
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='What subnets to run the DocumentDB instances in. Must be at least 2 subnets in two different AZs.\n')
    backup: typing.Union[models.aws_docdb.BackupPropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Backup settings. Default: - Backup retention period for automated backups is 1 day. Backup preferred window is set to a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.\n')
    cloud_watch_logs_retention: typing.Optional[aws_cdk.aws_logs.RetentionDays] = pydantic.Field(None, description="The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire\n")
    cloud_watch_logs_retention_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.\n')
    db_cluster_name: typing.Optional[str] = pydantic.Field(None, description='An optional identifier for the cluster. Default: - A name is automatically generated.\n')
    deletion_protection: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether this cluster can be deleted. If deletionProtection is enabled, the cluster cannot be deleted unless it is modified and deletionProtection is disabled. deletionProtection protects clusters from being accidentally deleted. Default: - false\n')
    enable_performance_insights: typing.Optional[bool] = pydantic.Field(None, description='A value that indicates whether to enable Performance Insights for the instances in the DB Cluster. Default: - false\n')
    engine_version: typing.Optional[str] = pydantic.Field(None, description='What version of the database to start. Default: - The default engine version.\n')
    export_audit_logs_to_cloud_watch: typing.Optional[bool] = pydantic.Field(None, description="Whether the audit logs should be exported to CloudWatch. Note that you also have to configure the audit log export in the Cluster's Parameter Group. Default: false\n")
    export_profiler_logs_to_cloud_watch: typing.Optional[bool] = pydantic.Field(None, description="Whether the profiler logs should be exported to CloudWatch. Note that you also have to configure the profiler log export in the Cluster's Parameter Group. Default: false\n")
    instance_identifier_base: typing.Optional[str] = pydantic.Field(None, description='Base identifier for instances. Every replica is named by appending the replica number to this string, 1-based. Default: - ``dbClusterName`` is used with the word "Instance" appended. If ``dbClusterName`` is not provided, the identifier is automatically generated.\n')
    instances: typing.Union[int, float, None] = pydantic.Field(None, description='Number of DocDB compute instances. Default: 1\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The KMS key for storage encryption. Default: - default master key.\n')
    parameter_group: typing.Optional[typing.Union[models.aws_docdb.ClusterParameterGroupDef]] = pydantic.Field(None, description='The DB parameter group to associate with the instance. Default: no parameter group\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port the DocumentDB cluster will listen on. Default: DatabaseCluster.DEFAULT_PORT\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description="A weekly time range in which maintenance should preferably execute. Must be at least 30 minutes long. Example: 'tue:04:17-tue:04:47' Default: - 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.\n")
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The removal policy to apply when the cluster and its instances are removed or replaced during a stack update, or when the stack is deleted. This removal policy also applies to the implicit security group created for the cluster if one is not supplied as a parameter. Default: - Retain cluster.\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security group. Default: a new security group is created.\n')
    storage_encrypted: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable storage encryption. Default: true\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Where to place the instances within the VPC. Default: private subnets\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n\n    cluster = docdb.DatabaseCluster(self, "Database",\n        master_user=docdb.Login(\n            username="myuser"\n        ),\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.MEMORY5, ec2.InstanceSize.LARGE),\n        vpc_subnets=ec2.SubnetSelection(\n            subnet_type=ec2.SubnetType.PUBLIC\n        ),\n        vpc=vpc,\n        deletion_protection=True\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_type', 'master_user', 'vpc', 'backup', 'cloud_watch_logs_retention', 'cloud_watch_logs_retention_role', 'db_cluster_name', 'deletion_protection', 'enable_performance_insights', 'engine_version', 'export_audit_logs_to_cloud_watch', 'export_profiler_logs_to_cloud_watch', 'instance_identifier_base', 'instances', 'kms_key', 'parameter_group', 'port', 'preferred_maintenance_window', 'removal_policy', 'security_group', 'storage_encrypted', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.DatabaseClusterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.DatabaseClusterPropsDefConfig] = pydantic.Field(None)


class DatabaseClusterPropsDefConfig(pydantic.BaseModel):
    instance_type_config: typing.Optional[models.aws_ec2.InstanceTypeDefConfig] = pydantic.Field(None)
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_docdb.DatabaseInstanceAttributes
class DatabaseInstanceAttributesDef(BaseStruct):
    instance_endpoint_address: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The endpoint address.\n')
    instance_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The instance identifier.\n')
    port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The database port.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_docdb as docdb\n\n    database_instance_attributes = docdb.DatabaseInstanceAttributes(\n        instance_endpoint_address="instanceEndpointAddress",\n        instance_identifier="instanceIdentifier",\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_endpoint_address', 'instance_identifier', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.DatabaseInstanceAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_docdb.DatabaseInstanceProps
class DatabaseInstancePropsDef(BaseStruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_docdb.DatabaseClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The DocumentDB database cluster the instance should launch into.\n')
    instance_type: typing.Union[models.aws_ec2.InstanceTypeDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the compute and memory capacity classes.\n')
    auto_minor_version_upgrade: typing.Optional[bool] = pydantic.Field(None, description='Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The name of the Availability Zone where the DB instance will be located. Default: - no preference\n')
    db_instance_name: typing.Optional[str] = pydantic.Field(None, description='A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name\n')
    enable_performance_insights: typing.Optional[bool] = pydantic.Field(None, description='A value that indicates whether to enable Performance Insights for the DB Instance. Default: - false\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description='The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/documentdb/latest/developerguide/db-instance-maintain.html#maintenance-window\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: RemovalPolicy.Retain\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_docdb as docdb\n    from aws_cdk import aws_ec2 as ec2\n\n    # database_cluster: docdb.DatabaseCluster\n    # instance_type: ec2.InstanceType\n\n    database_instance_props = docdb.DatabaseInstanceProps(\n        cluster=database_cluster,\n        instance_type=instance_type,\n\n        # the properties below are optional\n        auto_minor_version_upgrade=False,\n        availability_zone="availabilityZone",\n        db_instance_name="dbInstanceName",\n        enable_performance_insights=False,\n        preferred_maintenance_window="preferredMaintenanceWindow",\n        removal_policy=cdk.RemovalPolicy.DESTROY\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'instance_type', 'auto_minor_version_upgrade', 'availability_zone', 'db_instance_name', 'enable_performance_insights', 'preferred_maintenance_window', 'removal_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.DatabaseInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.DatabaseInstancePropsDefConfig] = pydantic.Field(None)


class DatabaseInstancePropsDefConfig(pydantic.BaseModel):
    instance_type_config: typing.Optional[models.aws_ec2.InstanceTypeDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_docdb.DatabaseSecretProps
class DatabaseSecretPropsDef(BaseStruct):
    username: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The username.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The KMS key to use to encrypt the secret. Default: default master key\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='Characters to not include in the generated password. Default: ""@/"\n')
    master_secret: typing.Optional[typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef]] = pydantic.Field(None, description='The master secret which will be used to rotate this secret. Default: - no master secret information will be included\n')
    secret_name: typing.Optional[str] = pydantic.Field(None, description='The physical name of the secret. Default: Secretsmanager will generate a physical name for the secret\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: docdb.DatabaseCluster\n\n    my_user_secret = docdb.DatabaseSecret(self, "MyUserSecret",\n        username="myuser",\n        master_secret=cluster.secret\n    )\n    my_user_secret_attached = my_user_secret.attach(cluster) # Adds DB connections information in the secret\n\n    cluster.add_rotation_multi_user("MyUser",  # Add rotation using the multi user scheme\n        secret=my_user_secret_attached)\n')
    _init_params: typing.ClassVar[list[str]] = ['username', 'encryption_key', 'exclude_characters', 'master_secret', 'secret_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.DatabaseSecretProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_docdb.Login
class LoginDef(BaseStruct):
    username: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Username.\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='Specifies characters to not include in generated passwords. Default: ""@/"\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='KMS encryption key to encrypt the generated secret. Default: default master key\n')
    password: typing.Optional[models.SecretValueDef] = pydantic.Field(None, description='Password. Do not put passwords in your CDK code directly. Default: a Secrets Manager generated password\n')
    secret_name: typing.Optional[str] = pydantic.Field(None, description='The physical name of the secret, that will be generated. Default: Secretsmanager will generate a physical name for the secret\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n\n    cluster = docdb.DatabaseCluster(self, "Database",\n        master_user=docdb.Login(\n            username="myuser"\n        ),\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.MEMORY5, ec2.InstanceSize.LARGE),\n        vpc_subnets=ec2.SubnetSelection(\n            subnet_type=ec2.SubnetType.PUBLIC\n        ),\n        vpc=vpc,\n        deletion_protection=True\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['username', 'exclude_characters', 'kms_key', 'password', 'secret_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.Login'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_docdb.RotationMultiUserOptions
class RotationMultiUserOptionsDef(BaseStruct):
    secret: typing.Union[_REQUIRED_INIT_PARAM, models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The secret to rotate. It must be a JSON string with the following format:: { "engine": <required: must be set to \'mongo\'>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port 27017 will be used>, "masterarn": <required: the arn of the master secret which will be used to create users/change passwords> "ssl": <optional: if not specified, defaults to false. This must be true if being used for DocumentDB rotations where the cluster has TLS enabled> }\n')
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: Duration.days(30)\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_secretsmanager as secretsmanager\n\n    # my_imported_secret: secretsmanager.Secret\n    # cluster: docdb.DatabaseCluster\n\n\n    cluster.add_rotation_multi_user("MyUser",\n        secret=my_imported_secret\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['secret', 'automatically_after']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.RotationMultiUserOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.RotationMultiUserOptionsDefConfig] = pydantic.Field(None)


class RotationMultiUserOptionsDefConfig(pydantic.BaseModel):
    secret_config: typing.Optional[models._interface_methods.AwsSecretsmanagerISecretDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_docdb.IClusterParameterGroup
#  skipping Interface

#  autogenerated from aws_cdk.aws_docdb.IDatabaseCluster
#  skipping Interface

#  autogenerated from aws_cdk.aws_docdb.IDatabaseInstance
#  skipping Interface

#  autogenerated from aws_cdk.aws_docdb.CfnDBCluster
class CfnDBClusterDef(BaseCfnResource):
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of Amazon EC2 Availability Zones that instances in the cluster can be created in.\n')
    backup_retention_period: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days for which automated backups are retained. You must specify a minimum value of 1. Default: 1 Constraints: - Must be a value from 1 to 35.\n')
    copy_tags_to_snapshot: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    db_cluster_identifier: typing.Optional[str] = pydantic.Field(None, description='The cluster identifier. This parameter is stored as a lowercase string. Constraints: - Must contain from 1 to 63 letters, numbers, or hyphens. - The first character must be a letter. - Cannot end with a hyphen or contain two consecutive hyphens. Example: ``my-cluster``\n')
    db_cluster_parameter_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the cluster parameter group to associate with this cluster.\n')
    db_subnet_group_name: typing.Optional[str] = pydantic.Field(None, description='A subnet group to associate with this cluster. Constraints: Must match the name of an existing ``DBSubnetGroup`` . Must not be default. Example: ``mySubnetgroup``\n')
    deletion_protection: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Protects clusters from being accidentally deleted. If enabled, the cluster cannot be deleted unless it is modified and ``DeletionProtection`` is disabled.\n')
    enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of log types that need to be enabled for exporting to Amazon CloudWatch Logs. You can enable audit logs or profiler logs. For more information, see `Auditing Amazon DocumentDB Events <https://docs.aws.amazon.com/documentdb/latest/developerguide/event-auditing.html>`_ and `Profiling Amazon DocumentDB Operations <https://docs.aws.amazon.com/documentdb/latest/developerguide/profiling.html>`_ .\n')
    engine_version: typing.Optional[str] = pydantic.Field(None, description='The version number of the database engine to use. The ``--engine-version`` will default to the latest major engine version. For production workloads, we recommend explicitly declaring this parameter with the intended major engine version.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The AWS KMS key identifier for an encrypted cluster. The AWS KMS key identifier is the Amazon Resource Name (ARN) for the AWS KMS encryption key. If you are creating a cluster using the same AWS account that owns the AWS KMS encryption key that is used to encrypt the new cluster, you can use the AWS KMS key alias instead of the ARN for the AWS KMS encryption key. If an encryption key is not specified in ``KmsKeyId`` : - If the ``StorageEncrypted`` parameter is ``true`` , Amazon DocumentDB uses your default encryption key. AWS KMS creates the default encryption key for your AWS account . Your AWS account has a different default encryption key for each AWS Regions .\n')
    master_username: typing.Optional[str] = pydantic.Field(None, description='The name of the master user for the cluster. Constraints: - Must be from 1 to 63 letters or numbers. - The first character must be a letter. - Cannot be a reserved word for the chosen database engine.\n')
    master_user_password: typing.Optional[str] = pydantic.Field(None, description='The password for the master database user. This password can contain any printable ASCII character except forward slash (/), double quote ("), or the "at" symbol (@). Constraints: Must contain from 8 to 100 characters.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the port that the database engine is listening on.\n')
    preferred_backup_window: typing.Optional[str] = pydantic.Field(None, description='The daily time range during which automated backups are created if automated backups are enabled using the ``BackupRetentionPeriod`` parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region . Constraints: - Must be in the format ``hh24:mi-hh24:mi`` . - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes.\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description='The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi`` The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region , occurring on a random day of the week. Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.\n')
    restore_to_time: typing.Optional[str] = pydantic.Field(None, description='The date and time to restore the cluster to. Valid values: A time in Universal Coordinated Time (UTC) format. Constraints: - Must be before the latest restorable time for the instance. - Must be specified if the ``UseLatestRestorableTime`` parameter is not provided. - Cannot be specified if the ``UseLatestRestorableTime`` parameter is ``true`` . - Cannot be specified if the ``RestoreType`` parameter is ``copy-on-write`` . Example: ``2015-03-07T23:45:00Z``\n')
    restore_type: typing.Optional[str] = pydantic.Field(None, description="The type of restore to be performed. You can specify one of the following values:. - ``full-copy`` - The new DB cluster is restored as a full copy of the source DB cluster. - ``copy-on-write`` - The new DB cluster is restored as a clone of the source DB cluster. Constraints: You can't specify ``copy-on-write`` if the engine version of the source DB cluster is earlier than 1.11. If you don't specify a ``RestoreType`` value, then the new DB cluster is restored as a full copy of the source DB cluster.\n")
    snapshot_identifier: typing.Optional[str] = pydantic.Field(None, description='The identifier for the snapshot or cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a cluster snapshot. However, you can use only the ARN to specify a snapshot. Constraints: - Must match the identifier of an existing snapshot.\n')
    source_db_cluster_identifier: typing.Optional[str] = pydantic.Field(None, description='The identifier of the source cluster from which to restore. Constraints: - Must match the identifier of an existing ``DBCluster`` .\n')
    storage_encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the cluster is encrypted.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to be assigned to the cluster.\n')
    use_latest_restorable_time: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A value that is set to ``true`` to restore the cluster to the latest restorable backup time, and ``false`` otherwise. Default: ``false`` Constraints: Cannot be specified if the ``RestoreToTime`` parameter is provided.\n')
    vpc_security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of EC2 VPC security groups to associate with this cluster.')
    _init_params: typing.ClassVar[list[str]] = ['availability_zones', 'backup_retention_period', 'copy_tags_to_snapshot', 'db_cluster_identifier', 'db_cluster_parameter_group_name', 'db_subnet_group_name', 'deletion_protection', 'enable_cloudwatch_logs_exports', 'engine_version', 'kms_key_id', 'master_username', 'master_user_password', 'port', 'preferred_backup_window', 'preferred_maintenance_window', 'restore_to_time', 'restore_type', 'snapshot_identifier', 'source_db_cluster_identifier', 'storage_encrypted', 'tags', 'use_latest_restorable_time', 'vpc_security_group_ids']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.CfnDBCluster'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.CfnDBClusterDefConfig] = pydantic.Field(None)


class CfnDBClusterDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_docdb.CfnDBClusterDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_docdb.CfnDBClusterDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_docdb.CfnDBClusterDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_docdb.CfnDBClusterDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_docdb.CfnDBClusterDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_docdb.CfnDBClusterDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_docdb.CfnDBClusterDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_docdb.CfnDBClusterDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_docdb.CfnDBClusterDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_docdb.CfnDBClusterDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_docdb.CfnDBClusterDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_docdb.CfnDBClusterDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_docdb.CfnDBClusterDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDBClusterDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDBClusterDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDBClusterDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDBClusterDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDBClusterDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDBClusterDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDBClusterDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDBClusterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDBClusterDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDBClusterDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDBClusterDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDBClusterDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDBClusterDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDBClusterDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_docdb.CfnDBClusterParameterGroup
class CfnDBClusterParameterGroupDef(BaseCfnResource):
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description for the cluster parameter group.\n')
    family: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cluster parameter group family name.\n')
    parameters: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Provides a list of parameters for the cluster parameter group.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the DB cluster parameter group. Constraints: - Must not match the name of an existing ``DBClusterParameterGroup`` . .. epigraph:: This value is stored as a lowercase string.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to be assigned to the cluster parameter group.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'family', 'parameters', 'name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.CfnDBClusterParameterGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.CfnDBClusterParameterGroupDefConfig] = pydantic.Field(None)


class CfnDBClusterParameterGroupDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_docdb.CfnDBClusterParameterGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDBClusterParameterGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDBClusterParameterGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDBClusterParameterGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDBClusterParameterGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDBClusterParameterGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDBClusterParameterGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDBClusterParameterGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDBClusterParameterGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDBClusterParameterGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDBClusterParameterGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDBClusterParameterGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDBClusterParameterGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDBClusterParameterGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDBClusterParameterGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_docdb.CfnDBInstance
class CfnDBInstanceDef(BaseCfnResource):
    db_cluster_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the cluster that the instance will belong to.\n')
    db_instance_class: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The compute and memory capacity of the instance; for example, ``db.m4.large`` . If you change the class of an instance there can be some interruption in the cluster's service.\n")
    auto_minor_version_upgrade: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='This parameter does not apply to Amazon DocumentDB. Amazon DocumentDB does not perform minor version upgrades regardless of the value set. Default: ``false``\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description="The Amazon EC2 Availability Zone that the instance is created in. Default: A random, system-chosen Availability Zone in the endpoint's AWS Region . Example: ``us-east-1d``\n")
    db_instance_identifier: typing.Optional[str] = pydantic.Field(None, description='The instance identifier. This parameter is stored as a lowercase string. Constraints: - Must contain from 1 to 63 letters, numbers, or hyphens. - The first character must be a letter. - Cannot end with a hyphen or contain two consecutive hyphens. Example: ``mydbinstance``\n')
    enable_performance_insights: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A value that indicates whether to enable Performance Insights for the DB Instance. For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/documentdb/latest/developerguide/performance-insights.html>`_ .\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description='The time range each week during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi`` The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region , occurring on a random day of the week. Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to be assigned to the instance. You can assign up to 10 tags to an instance.')
    _init_params: typing.ClassVar[list[str]] = ['db_cluster_identifier', 'db_instance_class', 'auto_minor_version_upgrade', 'availability_zone', 'db_instance_identifier', 'enable_performance_insights', 'preferred_maintenance_window', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.CfnDBInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.CfnDBInstanceDefConfig] = pydantic.Field(None)


class CfnDBInstanceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_docdb.CfnDBInstanceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDBInstanceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDBInstanceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDBInstanceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDBInstanceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDBInstanceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDBInstanceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDBInstanceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDBInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDBInstanceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDBInstanceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDBInstanceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDBInstanceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDBInstanceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDBInstanceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_docdb.CfnDBSubnetGroup
class CfnDBSubnetGroupDef(BaseCfnResource):
    db_subnet_group_description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description for the subnet group.\n')
    subnet_ids: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon EC2 subnet IDs for the subnet group.\n')
    db_subnet_group_name: typing.Optional[str] = pydantic.Field(None, description='The name for the subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 letters, numbers, periods, underscores, spaces, or hyphens. Must not be default. Example: ``mySubnetgroup``\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to be assigned to the subnet group.')
    _init_params: typing.ClassVar[list[str]] = ['db_subnet_group_description', 'subnet_ids', 'db_subnet_group_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.CfnDBSubnetGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_docdb.CfnDBSubnetGroupDefConfig] = pydantic.Field(None)


class CfnDBSubnetGroupDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_docdb.CfnDBSubnetGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDBSubnetGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDBSubnetGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDBSubnetGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDBSubnetGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDBSubnetGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDBSubnetGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDBSubnetGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDBSubnetGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDBSubnetGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDBSubnetGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDBSubnetGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDBSubnetGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDBSubnetGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDBSubnetGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_docdb.CfnDBClusterParameterGroupProps
class CfnDBClusterParameterGroupPropsDef(BaseCfnProperty):
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description for the cluster parameter group.\n')
    family: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cluster parameter group family name.\n')
    parameters: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Provides a list of parameters for the cluster parameter group.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the DB cluster parameter group. Constraints: - Must not match the name of an existing ``DBClusterParameterGroup`` . .. epigraph:: This value is stored as a lowercase string.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to be assigned to the cluster parameter group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-docdb-dbclusterparametergroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_docdb as docdb\n\n    # parameters: Any\n\n    cfn_dBCluster_parameter_group_props = docdb.CfnDBClusterParameterGroupProps(\n        description="description",\n        family="family",\n        parameters=parameters,\n\n        # the properties below are optional\n        name="name",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'family', 'parameters', 'name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.CfnDBClusterParameterGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_docdb.CfnDBClusterProps
class CfnDBClusterPropsDef(BaseCfnProperty):
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of Amazon EC2 Availability Zones that instances in the cluster can be created in.\n')
    backup_retention_period: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days for which automated backups are retained. You must specify a minimum value of 1. Default: 1 Constraints: - Must be a value from 1 to 35.\n')
    copy_tags_to_snapshot: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    db_cluster_identifier: typing.Optional[str] = pydantic.Field(None, description='The cluster identifier. This parameter is stored as a lowercase string. Constraints: - Must contain from 1 to 63 letters, numbers, or hyphens. - The first character must be a letter. - Cannot end with a hyphen or contain two consecutive hyphens. Example: ``my-cluster``\n')
    db_cluster_parameter_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the cluster parameter group to associate with this cluster.\n')
    db_subnet_group_name: typing.Optional[str] = pydantic.Field(None, description='A subnet group to associate with this cluster. Constraints: Must match the name of an existing ``DBSubnetGroup`` . Must not be default. Example: ``mySubnetgroup``\n')
    deletion_protection: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Protects clusters from being accidentally deleted. If enabled, the cluster cannot be deleted unless it is modified and ``DeletionProtection`` is disabled.\n')
    enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of log types that need to be enabled for exporting to Amazon CloudWatch Logs. You can enable audit logs or profiler logs. For more information, see `Auditing Amazon DocumentDB Events <https://docs.aws.amazon.com/documentdb/latest/developerguide/event-auditing.html>`_ and `Profiling Amazon DocumentDB Operations <https://docs.aws.amazon.com/documentdb/latest/developerguide/profiling.html>`_ .\n')
    engine_version: typing.Optional[str] = pydantic.Field(None, description='The version number of the database engine to use. The ``--engine-version`` will default to the latest major engine version. For production workloads, we recommend explicitly declaring this parameter with the intended major engine version.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The AWS KMS key identifier for an encrypted cluster. The AWS KMS key identifier is the Amazon Resource Name (ARN) for the AWS KMS encryption key. If you are creating a cluster using the same AWS account that owns the AWS KMS encryption key that is used to encrypt the new cluster, you can use the AWS KMS key alias instead of the ARN for the AWS KMS encryption key. If an encryption key is not specified in ``KmsKeyId`` : - If the ``StorageEncrypted`` parameter is ``true`` , Amazon DocumentDB uses your default encryption key. AWS KMS creates the default encryption key for your AWS account . Your AWS account has a different default encryption key for each AWS Regions .\n')
    master_username: typing.Optional[str] = pydantic.Field(None, description='The name of the master user for the cluster. Constraints: - Must be from 1 to 63 letters or numbers. - The first character must be a letter. - Cannot be a reserved word for the chosen database engine.\n')
    master_user_password: typing.Optional[str] = pydantic.Field(None, description='The password for the master database user. This password can contain any printable ASCII character except forward slash (/), double quote ("), or the "at" symbol (@). Constraints: Must contain from 8 to 100 characters.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the port that the database engine is listening on.\n')
    preferred_backup_window: typing.Optional[str] = pydantic.Field(None, description='The daily time range during which automated backups are created if automated backups are enabled using the ``BackupRetentionPeriod`` parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region . Constraints: - Must be in the format ``hh24:mi-hh24:mi`` . - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes.\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description='The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi`` The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region , occurring on a random day of the week. Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.\n')
    restore_to_time: typing.Optional[str] = pydantic.Field(None, description='The date and time to restore the cluster to. Valid values: A time in Universal Coordinated Time (UTC) format. Constraints: - Must be before the latest restorable time for the instance. - Must be specified if the ``UseLatestRestorableTime`` parameter is not provided. - Cannot be specified if the ``UseLatestRestorableTime`` parameter is ``true`` . - Cannot be specified if the ``RestoreType`` parameter is ``copy-on-write`` . Example: ``2015-03-07T23:45:00Z``\n')
    restore_type: typing.Optional[str] = pydantic.Field(None, description="The type of restore to be performed. You can specify one of the following values:. - ``full-copy`` - The new DB cluster is restored as a full copy of the source DB cluster. - ``copy-on-write`` - The new DB cluster is restored as a clone of the source DB cluster. Constraints: You can't specify ``copy-on-write`` if the engine version of the source DB cluster is earlier than 1.11. If you don't specify a ``RestoreType`` value, then the new DB cluster is restored as a full copy of the source DB cluster.\n")
    snapshot_identifier: typing.Optional[str] = pydantic.Field(None, description='The identifier for the snapshot or cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a cluster snapshot. However, you can use only the ARN to specify a snapshot. Constraints: - Must match the identifier of an existing snapshot.\n')
    source_db_cluster_identifier: typing.Optional[str] = pydantic.Field(None, description='The identifier of the source cluster from which to restore. Constraints: - Must match the identifier of an existing ``DBCluster`` .\n')
    storage_encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the cluster is encrypted.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to be assigned to the cluster.\n')
    use_latest_restorable_time: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A value that is set to ``true`` to restore the cluster to the latest restorable backup time, and ``false`` otherwise. Default: ``false`` Constraints: Cannot be specified if the ``RestoreToTime`` parameter is provided.\n')
    vpc_security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of EC2 VPC security groups to associate with this cluster.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-docdb-dbcluster.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_docdb as docdb\n\n    cfn_dBCluster_props = docdb.CfnDBClusterProps(\n        availability_zones=["availabilityZones"],\n        backup_retention_period=123,\n        copy_tags_to_snapshot=False,\n        db_cluster_identifier="dbClusterIdentifier",\n        db_cluster_parameter_group_name="dbClusterParameterGroupName",\n        db_subnet_group_name="dbSubnetGroupName",\n        deletion_protection=False,\n        enable_cloudwatch_logs_exports=["enableCloudwatchLogsExports"],\n        engine_version="engineVersion",\n        kms_key_id="kmsKeyId",\n        master_username="masterUsername",\n        master_user_password="masterUserPassword",\n        port=123,\n        preferred_backup_window="preferredBackupWindow",\n        preferred_maintenance_window="preferredMaintenanceWindow",\n        restore_to_time="restoreToTime",\n        restore_type="restoreType",\n        snapshot_identifier="snapshotIdentifier",\n        source_db_cluster_identifier="sourceDbClusterIdentifier",\n        storage_encrypted=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        use_latest_restorable_time=False,\n        vpc_security_group_ids=["vpcSecurityGroupIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zones', 'backup_retention_period', 'copy_tags_to_snapshot', 'db_cluster_identifier', 'db_cluster_parameter_group_name', 'db_subnet_group_name', 'deletion_protection', 'enable_cloudwatch_logs_exports', 'engine_version', 'kms_key_id', 'master_username', 'master_user_password', 'port', 'preferred_backup_window', 'preferred_maintenance_window', 'restore_to_time', 'restore_type', 'snapshot_identifier', 'source_db_cluster_identifier', 'storage_encrypted', 'tags', 'use_latest_restorable_time', 'vpc_security_group_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.CfnDBClusterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_docdb.CfnDBInstanceProps
class CfnDBInstancePropsDef(BaseCfnProperty):
    db_cluster_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the cluster that the instance will belong to.\n')
    db_instance_class: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The compute and memory capacity of the instance; for example, ``db.m4.large`` . If you change the class of an instance there can be some interruption in the cluster's service.\n")
    auto_minor_version_upgrade: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='This parameter does not apply to Amazon DocumentDB. Amazon DocumentDB does not perform minor version upgrades regardless of the value set. Default: ``false``\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description="The Amazon EC2 Availability Zone that the instance is created in. Default: A random, system-chosen Availability Zone in the endpoint's AWS Region . Example: ``us-east-1d``\n")
    db_instance_identifier: typing.Optional[str] = pydantic.Field(None, description='The instance identifier. This parameter is stored as a lowercase string. Constraints: - Must contain from 1 to 63 letters, numbers, or hyphens. - The first character must be a letter. - Cannot end with a hyphen or contain two consecutive hyphens. Example: ``mydbinstance``\n')
    enable_performance_insights: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A value that indicates whether to enable Performance Insights for the DB Instance. For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/documentdb/latest/developerguide/performance-insights.html>`_ .\n')
    preferred_maintenance_window: typing.Optional[str] = pydantic.Field(None, description='The time range each week during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi`` The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region , occurring on a random day of the week. Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to be assigned to the instance. You can assign up to 10 tags to an instance.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-docdb-dbinstance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_docdb as docdb\n\n    cfn_dBInstance_props = docdb.CfnDBInstanceProps(\n        db_cluster_identifier="dbClusterIdentifier",\n        db_instance_class="dbInstanceClass",\n\n        # the properties below are optional\n        auto_minor_version_upgrade=False,\n        availability_zone="availabilityZone",\n        db_instance_identifier="dbInstanceIdentifier",\n        enable_performance_insights=False,\n        preferred_maintenance_window="preferredMaintenanceWindow",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['db_cluster_identifier', 'db_instance_class', 'auto_minor_version_upgrade', 'availability_zone', 'db_instance_identifier', 'enable_performance_insights', 'preferred_maintenance_window', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.CfnDBInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_docdb.CfnDBSubnetGroupProps
class CfnDBSubnetGroupPropsDef(BaseCfnProperty):
    db_subnet_group_description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description for the subnet group.\n')
    subnet_ids: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon EC2 subnet IDs for the subnet group.\n')
    db_subnet_group_name: typing.Optional[str] = pydantic.Field(None, description='The name for the subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 letters, numbers, periods, underscores, spaces, or hyphens. Must not be default. Example: ``mySubnetgroup``\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to be assigned to the subnet group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-docdb-dbsubnetgroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_docdb as docdb\n\n    cfn_dBSubnet_group_props = docdb.CfnDBSubnetGroupProps(\n        db_subnet_group_description="dbSubnetGroupDescription",\n        subnet_ids=["subnetIds"],\n\n        # the properties below are optional\n        db_subnet_group_name="dbSubnetGroupName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['db_subnet_group_description', 'subnet_ids', 'db_subnet_group_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_docdb.CfnDBSubnetGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    Endpoint: typing.Optional[dict[str, models.aws_docdb.EndpointDef]] = pydantic.Field(None)
    ClusterParameterGroup: typing.Optional[dict[str, models.aws_docdb.ClusterParameterGroupDef]] = pydantic.Field(None)
    DatabaseCluster: typing.Optional[dict[str, models.aws_docdb.DatabaseClusterDef]] = pydantic.Field(None)
    DatabaseInstance: typing.Optional[dict[str, models.aws_docdb.DatabaseInstanceDef]] = pydantic.Field(None)
    DatabaseSecret: typing.Optional[dict[str, models.aws_docdb.DatabaseSecretDef]] = pydantic.Field(None)
    BackupProps: typing.Optional[dict[str, models.aws_docdb.BackupPropsDef]] = pydantic.Field(None)
    ClusterParameterGroupProps: typing.Optional[dict[str, models.aws_docdb.ClusterParameterGroupPropsDef]] = pydantic.Field(None)
    DatabaseClusterAttributes: typing.Optional[dict[str, models.aws_docdb.DatabaseClusterAttributesDef]] = pydantic.Field(None)
    DatabaseClusterProps: typing.Optional[dict[str, models.aws_docdb.DatabaseClusterPropsDef]] = pydantic.Field(None)
    DatabaseInstanceAttributes: typing.Optional[dict[str, models.aws_docdb.DatabaseInstanceAttributesDef]] = pydantic.Field(None)
    DatabaseInstanceProps: typing.Optional[dict[str, models.aws_docdb.DatabaseInstancePropsDef]] = pydantic.Field(None)
    DatabaseSecretProps: typing.Optional[dict[str, models.aws_docdb.DatabaseSecretPropsDef]] = pydantic.Field(None)
    Login: typing.Optional[dict[str, models.aws_docdb.LoginDef]] = pydantic.Field(None)
    RotationMultiUserOptions: typing.Optional[dict[str, models.aws_docdb.RotationMultiUserOptionsDef]] = pydantic.Field(None)
    CfnDBCluster: typing.Optional[dict[str, models.aws_docdb.CfnDBClusterDef]] = pydantic.Field(None)
    CfnDBClusterParameterGroup: typing.Optional[dict[str, models.aws_docdb.CfnDBClusterParameterGroupDef]] = pydantic.Field(None)
    CfnDBInstance: typing.Optional[dict[str, models.aws_docdb.CfnDBInstanceDef]] = pydantic.Field(None)
    CfnDBSubnetGroup: typing.Optional[dict[str, models.aws_docdb.CfnDBSubnetGroupDef]] = pydantic.Field(None)
    CfnDBClusterParameterGroupProps: typing.Optional[dict[str, models.aws_docdb.CfnDBClusterParameterGroupPropsDef]] = pydantic.Field(None)
    CfnDBClusterProps: typing.Optional[dict[str, models.aws_docdb.CfnDBClusterPropsDef]] = pydantic.Field(None)
    CfnDBInstanceProps: typing.Optional[dict[str, models.aws_docdb.CfnDBInstancePropsDef]] = pydantic.Field(None)
    CfnDBSubnetGroupProps: typing.Optional[dict[str, models.aws_docdb.CfnDBSubnetGroupPropsDef]] = pydantic.Field(None)
    ...

import models
