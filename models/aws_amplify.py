from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_amplify.CfnApp.AutoBranchCreationConfigProperty
class CfnApp_AutoBranchCreationConfigPropertyDef(BaseStruct):
    auto_branch_creation_patterns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Automated branch creation glob patterns for the Amplify app.\n')
    basic_auth_config: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_BasicAuthConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Sets password protection for your auto created branch.\n')
    build_spec: typing.Optional[str] = pydantic.Field(None, description='The build specification (build spec) for the autocreated branch. *Length Constraints:* Minimum length of 1. Maximum length of 25000.\n')
    enable_auto_branch_creation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables automated branch creation for the Amplify app.\n')
    enable_auto_build: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables auto building for the auto created branch.\n')
    enable_performance_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.\n')
    enable_pull_request_preview: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Sets whether pull request previews are enabled for each branch that Amplify Hosting automatically creates for your app. Amplify creates previews by deploying your app to a unique URL whenever a pull request is opened for the branch. Development and QA teams can use this preview to test the pull request before it's merged into a production or integration branch. To provide backend support for your preview, Amplify Hosting automatically provisions a temporary backend environment that it deletes when the pull request is closed. If you want to specify a dedicated backend environment for your previews, use the ``PullRequestEnvironmentName`` property. For more information, see `Web Previews <https://docs.aws.amazon.com/amplify/latest/userguide/pr-previews.html>`_ in the *AWS Amplify Hosting User Guide* .\n")
    environment_variables: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_EnvironmentVariablePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Environment variables for the auto created branch.\n')
    framework: typing.Optional[str] = pydantic.Field(None, description='The framework for the autocreated branch.\n')
    pull_request_environment_name: typing.Optional[str] = pydantic.Field(None, description="If pull request previews are enabled, you can use this property to specify a dedicated backend environment for your previews. For example, you could specify an environment named ``prod`` , ``test`` , or ``dev`` that you initialized with the Amplify CLI. To enable pull request previews, set the ``EnablePullRequestPreview`` property to ``true`` . If you don't specify an environment, Amplify Hosting provides backend support for each preview by automatically provisioning a temporary backend environment. Amplify deletes this environment when the pull request is closed. For more information about creating backend environments, see `Feature Branch Deployments and Team Workflows <https://docs.aws.amazon.com/amplify/latest/userguide/multi-environments.html>`_ in the *AWS Amplify Hosting User Guide* . *Length Constraints:* Maximum length of 20. *Pattern:* (?s).*\n")
    stage: typing.Optional[str] = pydantic.Field(None, description='Stage for the auto created branch.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-amplify-app-autobranchcreationconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    auto_branch_creation_config_property = amplify.CfnApp.AutoBranchCreationConfigProperty(\n        auto_branch_creation_patterns=["autoBranchCreationPatterns"],\n        basic_auth_config=amplify.CfnApp.BasicAuthConfigProperty(\n            enable_basic_auth=False,\n            password="password",\n            username="username"\n        ),\n        build_spec="buildSpec",\n        enable_auto_branch_creation=False,\n        enable_auto_build=False,\n        enable_performance_mode=False,\n        enable_pull_request_preview=False,\n        environment_variables=[amplify.CfnApp.EnvironmentVariableProperty(\n            name="name",\n            value="value"\n        )],\n        framework="framework",\n        pull_request_environment_name="pullRequestEnvironmentName",\n        stage="stage"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_branch_creation_patterns', 'basic_auth_config', 'build_spec', 'enable_auto_branch_creation', 'enable_auto_build', 'enable_performance_mode', 'enable_pull_request_preview', 'environment_variables', 'framework', 'pull_request_environment_name', 'stage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnApp.AutoBranchCreationConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnApp.BasicAuthConfigProperty
class CfnApp_BasicAuthConfigPropertyDef(BaseStruct):
    enable_basic_auth: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Enables basic authorization for the Amplify app's branches.\n")
    password: typing.Optional[str] = pydantic.Field(None, description='The password for basic authorization. *Length Constraints:* Minimum length of 1. Maximum length of 255.\n')
    username: typing.Optional[str] = pydantic.Field(None, description='The user name for basic authorization. *Length Constraints:* Minimum length of 1. Maximum length of 255.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-amplify-app-basicauthconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    basic_auth_config_property = amplify.CfnApp.BasicAuthConfigProperty(\n        enable_basic_auth=False,\n        password="password",\n        username="username"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enable_basic_auth', 'password', 'username']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnApp.BasicAuthConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnApp.CustomRuleProperty
class CfnApp_CustomRulePropertyDef(BaseStruct):
    source: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The source pattern for a URL rewrite or redirect rule. *Length Constraints:* Minimum length of 1. Maximum length of 2048. *Pattern:* (?s).+\n')
    target: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The target pattern for a URL rewrite or redirect rule. *Length Constraints:* Minimum length of 1. Maximum length of 2048. *Pattern:* (?s).+\n')
    condition: typing.Optional[str] = pydantic.Field(None, description='The condition for a URL rewrite or redirect rule, such as a country code. *Length Constraints:* Minimum length of 0. Maximum length of 2048. *Pattern:* (?s).*\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status code for a URL rewrite or redirect rule. - **200** - Represents a 200 rewrite rule. - **301** - Represents a 301 (moved pemanently) redirect rule. This and all future requests should be directed to the target URL. - **302** - Represents a 302 temporary redirect rule. - **404** - Represents a 404 redirect rule. - **404-200** - Represents a 404 rewrite rule. *Length Constraints:* Minimum length of 3. Maximum length of 7. *Pattern:* .{3,7}\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-amplify-app-customrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    custom_rule_property = amplify.CfnApp.CustomRuleProperty(\n        source="source",\n        target="target",\n\n        # the properties below are optional\n        condition="condition",\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source', 'target', 'condition', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnApp.CustomRuleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnApp.EnvironmentVariableProperty
class CfnApp_EnvironmentVariablePropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The environment variable name. *Length Constraints:* Maximum length of 255. *Pattern:* (?s).*\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The environment variable value. *Length Constraints:* Maximum length of 5500. *Pattern:* (?s).*\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-amplify-app-environmentvariable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    environment_variable_property = amplify.CfnApp.EnvironmentVariableProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnApp.EnvironmentVariableProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnBranch.BackendProperty
class CfnBranch_BackendPropertyDef(BaseStruct):
    stack_arn: typing.Optional[str] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['stack_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnBranch.BackendProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnBranch.BasicAuthConfigProperty
class CfnBranch_BasicAuthConfigPropertyDef(BaseStruct):
    password: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The password for basic authorization. *Length Constraints:* Minimum length of 1. Maximum length of 255.\n')
    username: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The user name for basic authorization. *Length Constraints:* Minimum length of 1. Maximum length of 255.\n')
    enable_basic_auth: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables basic authorization for the branch.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-amplify-branch-basicauthconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    basic_auth_config_property = amplify.CfnBranch.BasicAuthConfigProperty(\n        password="password",\n        username="username",\n\n        # the properties below are optional\n        enable_basic_auth=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['password', 'username', 'enable_basic_auth']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnBranch.BasicAuthConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnBranch.EnvironmentVariableProperty
class CfnBranch_EnvironmentVariablePropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The environment variable name. *Length Constraints:* Maximum length of 255. *Pattern:* (?s).*\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The environment variable value. *Length Constraints:* Maximum length of 5500. *Pattern:* (?s).*\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-amplify-branch-environmentvariable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    environment_variable_property = amplify.CfnBranch.EnvironmentVariableProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnBranch.EnvironmentVariableProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnDomain.SubDomainSettingProperty
class CfnDomain_SubDomainSettingPropertyDef(BaseStruct):
    branch_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The branch name setting for the subdomain. *Length Constraints:* Minimum length of 1. Maximum length of 255. *Pattern:* (?s).+\n')
    prefix: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The prefix setting for the subdomain. *Length Constraints:* Maximum length of 255. *Pattern:* (?s).*\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-amplify-domain-subdomainsetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    sub_domain_setting_property = amplify.CfnDomain.SubDomainSettingProperty(\n        branch_name="branchName",\n        prefix="prefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['branch_name', 'prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnDomain.SubDomainSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnApp
class CfnAppDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name for an Amplify app. *Length Constraints:* Minimum length of 1. Maximum length of 255. *Pattern:* (?s).+\n')
    access_token: typing.Optional[str] = pydantic.Field(None, description='The personal access token for a GitHub repository for an Amplify app. The personal access token is used to authorize access to a GitHub repository using the Amplify GitHub App. The token is not stored. Use ``AccessToken`` for GitHub repositories only. To authorize access to a repository provider such as Bitbucket or CodeCommit, use ``OauthToken`` . You must specify either ``AccessToken`` or ``OauthToken`` when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see `Migrating an existing OAuth app to the Amplify GitHub App <https://docs.aws.amazon.com/amplify/latest/userguide/setting-up-GitHub-access.html#migrating-to-github-app-auth>`_ in the *Amplify User Guide* . *Length Constraints:* Minimum length of 1. Maximum length of 255.\n')
    auto_branch_creation_config: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_AutoBranchCreationConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Sets the configuration for your automatic branch creation.\n')
    basic_auth_config: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_BasicAuthConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The credentials for basic authorization for an Amplify app. You must base64-encode the authorization credentials and provide them in the format ``user:password`` .\n')
    build_spec: typing.Optional[str] = pydantic.Field(None, description='The build specification (build spec) for an Amplify app. *Length Constraints:* Minimum length of 1. Maximum length of 25000. *Pattern:* (?s).+\n')
    custom_headers: typing.Optional[str] = pydantic.Field(None, description='The custom HTTP headers for an Amplify app. *Length Constraints:* Minimum length of 0. Maximum length of 25000. *Pattern:* (?s).*\n')
    custom_rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_CustomRulePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The custom rewrite and redirect rules for an Amplify app.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for an Amplify app. *Length Constraints:* Maximum length of 1000. *Pattern:* (?s).*\n')
    enable_branch_auto_deletion: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Automatically disconnect a branch in Amplify Hosting when you delete a branch from your Git repository.\n')
    environment_variables: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_EnvironmentVariablePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The environment variables map for an Amplify app. For a list of the environment variables that are accessible to Amplify by default, see `Amplify Environment variables <https://docs.aws.amazon.com/amplify/latest/userguide/amplify-console-environment-variables.html>`_ in the *Amplify Hosting User Guide* .\n')
    iam_service_role: typing.Optional[str] = pydantic.Field(None, description='The AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) of the Amplify app. *Length Constraints:* Minimum length of 0. Maximum length of 1000. *Pattern:* (?s).*\n')
    oauth_token: typing.Optional[str] = pydantic.Field(None, description='The OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key using SSH cloning. The OAuth token is not stored. Use ``OauthToken`` for repository providers other than GitHub, such as Bitbucket or CodeCommit. To authorize access to GitHub as your repository provider, use ``AccessToken`` . You must specify either ``OauthToken`` or ``AccessToken`` when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see `Migrating an existing OAuth app to the Amplify GitHub App <https://docs.aws.amazon.com/amplify/latest/userguide/setting-up-GitHub-access.html#migrating-to-github-app-auth>`_ in the *Amplify User Guide* . *Length Constraints:* Maximum length of 1000. *Pattern:* (?s).*\n')
    platform: typing.Optional[str] = pydantic.Field(None, description="The platform for the Amplify app. For a static app, set the platform type to ``WEB`` . For a dynamic server-side rendered (SSR) app, set the platform type to ``WEB_COMPUTE`` . For an app requiring Amplify Hosting's original SSR support only, set the platform type to ``WEB_DYNAMIC`` .\n")
    repository: typing.Optional[str] = pydantic.Field(None, description='The repository for an Amplify app. *Pattern:* (?s).*\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tag for an Amplify app.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'access_token', 'auto_branch_creation_config', 'basic_auth_config', 'build_spec', 'custom_headers', 'custom_rules', 'description', 'enable_branch_auto_deletion', 'environment_variables', 'iam_service_role', 'oauth_token', 'platform', 'repository', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AutoBranchCreationConfigProperty', 'BasicAuthConfigProperty', 'CustomRuleProperty', 'EnvironmentVariableProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnApp'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnAppDefConfig] = pydantic.Field(None)


class CfnAppDefConfig(pydantic.BaseModel):
    AutoBranchCreationConfigProperty: typing.Optional[list[CfnAppDefAutobranchcreationconfigpropertyParams]] = pydantic.Field(None, description='')
    BasicAuthConfigProperty: typing.Optional[list[CfnAppDefBasicauthconfigpropertyParams]] = pydantic.Field(None, description='')
    CustomRuleProperty: typing.Optional[list[CfnAppDefCustomrulepropertyParams]] = pydantic.Field(None, description='')
    EnvironmentVariableProperty: typing.Optional[list[CfnAppDefEnvironmentvariablepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnAppDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnAppDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnAppDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnAppDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnAppDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnAppDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnAppDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnAppDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnAppDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnAppDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnAppDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnAppDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnAppDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAppDefAutobranchcreationconfigpropertyParams(pydantic.BaseModel):
    auto_branch_creation_patterns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    basic_auth_config: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_BasicAuthConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    build_spec: typing.Optional[str] = pydantic.Field(None, description='')
    enable_auto_branch_creation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    enable_auto_build: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    enable_performance_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    enable_pull_request_preview: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    environment_variables: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_EnvironmentVariablePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    framework: typing.Optional[str] = pydantic.Field(None, description='')
    pull_request_environment_name: typing.Optional[str] = pydantic.Field(None, description='')
    stage: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAppDefBasicauthconfigpropertyParams(pydantic.BaseModel):
    enable_basic_auth: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    password: typing.Optional[str] = pydantic.Field(None, description='')
    username: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAppDefCustomrulepropertyParams(pydantic.BaseModel):
    source: str = pydantic.Field(..., description='')
    target: str = pydantic.Field(..., description='')
    condition: typing.Optional[str] = pydantic.Field(None, description='')
    status: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAppDefEnvironmentvariablepropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnAppDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAppDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAppDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAppDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAppDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAppDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAppDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAppDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAppDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAppDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAppDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAppDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAppDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAppDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_amplify.CfnBranch
class CfnBranchDef(BaseCfnResource):
    app_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID for an Amplify app. *Length Constraints:* Minimum length of 1. Maximum length of 20. *Pattern:* d[a-z0-9]+\n')
    branch_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name for the branch. *Length Constraints:* Minimum length of 1. Maximum length of 255. *Pattern:* (?s).+\n')
    backend: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnBranch_BackendPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    basic_auth_config: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnBranch_BasicAuthConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The basic authorization credentials for a branch of an Amplify app. You must base64-encode the authorization credentials and provide them in the format ``user:password`` .\n')
    build_spec: typing.Optional[str] = pydantic.Field(None, description='The build specification (build spec) for the branch. *Length Constraints:* Minimum length of 1. Maximum length of 25000. *Pattern:* (?s).+\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the branch that is part of an Amplify app. *Length Constraints:* Maximum length of 1000. *Pattern:* (?s).*\n')
    enable_auto_build: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables auto building for the branch.\n')
    enable_performance_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.\n')
    enable_pull_request_preview: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifies whether Amplify Hosting creates a preview for each pull request that is made for this branch. If this property is enabled, Amplify deploys your app to a unique preview URL after each pull request is opened. Development and QA teams can use this preview to test the pull request before it's merged into a production or integration branch. To provide backend support for your preview, Amplify automatically provisions a temporary backend environment that it deletes when the pull request is closed. If you want to specify a dedicated backend environment for your previews, use the ``PullRequestEnvironmentName`` property. For more information, see `Web Previews <https://docs.aws.amazon.com/amplify/latest/userguide/pr-previews.html>`_ in the *AWS Amplify Hosting User Guide* .\n")
    environment_variables: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnBranch_EnvironmentVariablePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The environment variables for the branch.\n')
    framework: typing.Optional[str] = pydantic.Field(None, description='The framework for the branch.\n')
    pull_request_environment_name: typing.Optional[str] = pydantic.Field(None, description="If pull request previews are enabled for this branch, you can use this property to specify a dedicated backend environment for your previews. For example, you could specify an environment named ``prod`` , ``test`` , or ``dev`` that you initialized with the Amplify CLI and mapped to this branch. To enable pull request previews, set the ``EnablePullRequestPreview`` property to ``true`` . If you don't specify an environment, Amplify Hosting provides backend support for each preview by automatically provisioning a temporary backend environment. Amplify Hosting deletes this environment when the pull request is closed. For more information about creating backend environments, see `Feature Branch Deployments and Team Workflows <https://docs.aws.amazon.com/amplify/latest/userguide/multi-environments.html>`_ in the *AWS Amplify Hosting User Guide* . *Length Constraints:* Maximum length of 20. *Pattern:* (?s).*\n")
    stage: typing.Optional[str] = pydantic.Field(None, description='Describes the current stage for the branch. *Valid Values:* PRODUCTION | BETA | DEVELOPMENT | EXPERIMENTAL | PULL_REQUEST\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tag for the branch.')
    _init_params: typing.ClassVar[list[str]] = ['app_id', 'branch_name', 'backend', 'basic_auth_config', 'build_spec', 'description', 'enable_auto_build', 'enable_performance_mode', 'enable_pull_request_preview', 'environment_variables', 'framework', 'pull_request_environment_name', 'stage', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['BackendProperty', 'BasicAuthConfigProperty', 'EnvironmentVariableProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnBranch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnBranchDefConfig] = pydantic.Field(None)


class CfnBranchDefConfig(pydantic.BaseModel):
    BackendProperty: typing.Optional[list[CfnBranchDefBackendpropertyParams]] = pydantic.Field(None, description='')
    BasicAuthConfigProperty: typing.Optional[list[CfnBranchDefBasicauthconfigpropertyParams]] = pydantic.Field(None, description='')
    EnvironmentVariableProperty: typing.Optional[list[CfnBranchDefEnvironmentvariablepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnBranchDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnBranchDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnBranchDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnBranchDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnBranchDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnBranchDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnBranchDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnBranchDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnBranchDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnBranchDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnBranchDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnBranchDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnBranchDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnBranchDefBackendpropertyParams(pydantic.BaseModel):
    stack_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnBranchDefBasicauthconfigpropertyParams(pydantic.BaseModel):
    password: str = pydantic.Field(..., description='')
    username: str = pydantic.Field(..., description='')
    enable_basic_auth: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnBranchDefEnvironmentvariablepropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnBranchDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnBranchDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBranchDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnBranchDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBranchDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnBranchDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnBranchDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnBranchDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnBranchDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnBranchDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBranchDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnBranchDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnBranchDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBranchDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_amplify.CfnDomain
class CfnDomainDef(BaseCfnResource):
    app_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID for an Amplify app. *Length Constraints:* Minimum length of 1. Maximum length of 20. *Pattern:* d[a-z0-9]+\n')
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain name for the domain association. *Length Constraints:* Maximum length of 255. *Pattern:* ^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9]).)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])(.)?$\n')
    sub_domain_settings: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnDomain_SubDomainSettingPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The setting for the subdomain.\n')
    auto_sub_domain_creation_patterns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Sets the branch patterns for automatic subdomain creation.\n')
    auto_sub_domain_iam_role: typing.Optional[str] = pydantic.Field(None, description='The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains. *Length Constraints:* Maximum length of 1000. *Pattern:* ^$|^arn:aws:iam::\\d{12}:role.+\n')
    enable_auto_sub_domain: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables the automated creation of subdomains for branches.')
    _init_params: typing.ClassVar[list[str]] = ['app_id', 'domain_name', 'sub_domain_settings', 'auto_sub_domain_creation_patterns', 'auto_sub_domain_iam_role', 'enable_auto_sub_domain']
    _method_names: typing.ClassVar[list[str]] = ['SubDomainSettingProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnDomain'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDomainDefConfig] = pydantic.Field(None)


class CfnDomainDefConfig(pydantic.BaseModel):
    SubDomainSettingProperty: typing.Optional[list[CfnDomainDefSubdomainsettingpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDomainDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDomainDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDomainDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDomainDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDomainDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDomainDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDomainDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDomainDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDomainDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDomainDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDomainDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDomainDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDomainDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_enable_auto_sub_domain_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnDomainDefSubdomainsettingpropertyParams(pydantic.BaseModel):
    branch_name: str = pydantic.Field(..., description='')
    prefix: str = pydantic.Field(..., description='')
    ...

class CfnDomainDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDomainDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDomainDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDomainDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDomainDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDomainDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDomainDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDomainDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDomainDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDomainDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_amplify.CfnAppProps
class CfnAppPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name for an Amplify app. *Length Constraints:* Minimum length of 1. Maximum length of 255. *Pattern:* (?s).+\n')
    access_token: typing.Optional[str] = pydantic.Field(None, description='The personal access token for a GitHub repository for an Amplify app. The personal access token is used to authorize access to a GitHub repository using the Amplify GitHub App. The token is not stored. Use ``AccessToken`` for GitHub repositories only. To authorize access to a repository provider such as Bitbucket or CodeCommit, use ``OauthToken`` . You must specify either ``AccessToken`` or ``OauthToken`` when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see `Migrating an existing OAuth app to the Amplify GitHub App <https://docs.aws.amazon.com/amplify/latest/userguide/setting-up-GitHub-access.html#migrating-to-github-app-auth>`_ in the *Amplify User Guide* . *Length Constraints:* Minimum length of 1. Maximum length of 255.\n')
    auto_branch_creation_config: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_AutoBranchCreationConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Sets the configuration for your automatic branch creation.\n')
    basic_auth_config: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_BasicAuthConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The credentials for basic authorization for an Amplify app. You must base64-encode the authorization credentials and provide them in the format ``user:password`` .\n')
    build_spec: typing.Optional[str] = pydantic.Field(None, description='The build specification (build spec) for an Amplify app. *Length Constraints:* Minimum length of 1. Maximum length of 25000. *Pattern:* (?s).+\n')
    custom_headers: typing.Optional[str] = pydantic.Field(None, description='The custom HTTP headers for an Amplify app. *Length Constraints:* Minimum length of 0. Maximum length of 25000. *Pattern:* (?s).*\n')
    custom_rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_CustomRulePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The custom rewrite and redirect rules for an Amplify app.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for an Amplify app. *Length Constraints:* Maximum length of 1000. *Pattern:* (?s).*\n')
    enable_branch_auto_deletion: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Automatically disconnect a branch in Amplify Hosting when you delete a branch from your Git repository.\n')
    environment_variables: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnApp_EnvironmentVariablePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The environment variables map for an Amplify app. For a list of the environment variables that are accessible to Amplify by default, see `Amplify Environment variables <https://docs.aws.amazon.com/amplify/latest/userguide/amplify-console-environment-variables.html>`_ in the *Amplify Hosting User Guide* .\n')
    iam_service_role: typing.Optional[str] = pydantic.Field(None, description='The AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) of the Amplify app. *Length Constraints:* Minimum length of 0. Maximum length of 1000. *Pattern:* (?s).*\n')
    oauth_token: typing.Optional[str] = pydantic.Field(None, description='The OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key using SSH cloning. The OAuth token is not stored. Use ``OauthToken`` for repository providers other than GitHub, such as Bitbucket or CodeCommit. To authorize access to GitHub as your repository provider, use ``AccessToken`` . You must specify either ``OauthToken`` or ``AccessToken`` when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see `Migrating an existing OAuth app to the Amplify GitHub App <https://docs.aws.amazon.com/amplify/latest/userguide/setting-up-GitHub-access.html#migrating-to-github-app-auth>`_ in the *Amplify User Guide* . *Length Constraints:* Maximum length of 1000. *Pattern:* (?s).*\n')
    platform: typing.Optional[str] = pydantic.Field(None, description="The platform for the Amplify app. For a static app, set the platform type to ``WEB`` . For a dynamic server-side rendered (SSR) app, set the platform type to ``WEB_COMPUTE`` . For an app requiring Amplify Hosting's original SSR support only, set the platform type to ``WEB_DYNAMIC`` .\n")
    repository: typing.Optional[str] = pydantic.Field(None, description='The repository for an Amplify app. *Pattern:* (?s).*\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tag for an Amplify app.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-amplify-app.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    cfn_app_props = amplify.CfnAppProps(\n        name="name",\n\n        # the properties below are optional\n        access_token="accessToken",\n        auto_branch_creation_config=amplify.CfnApp.AutoBranchCreationConfigProperty(\n            auto_branch_creation_patterns=["autoBranchCreationPatterns"],\n            basic_auth_config=amplify.CfnApp.BasicAuthConfigProperty(\n                enable_basic_auth=False,\n                password="password",\n                username="username"\n            ),\n            build_spec="buildSpec",\n            enable_auto_branch_creation=False,\n            enable_auto_build=False,\n            enable_performance_mode=False,\n            enable_pull_request_preview=False,\n            environment_variables=[amplify.CfnApp.EnvironmentVariableProperty(\n                name="name",\n                value="value"\n            )],\n            framework="framework",\n            pull_request_environment_name="pullRequestEnvironmentName",\n            stage="stage"\n        ),\n        basic_auth_config=amplify.CfnApp.BasicAuthConfigProperty(\n            enable_basic_auth=False,\n            password="password",\n            username="username"\n        ),\n        build_spec="buildSpec",\n        custom_headers="customHeaders",\n        custom_rules=[amplify.CfnApp.CustomRuleProperty(\n            source="source",\n            target="target",\n\n            # the properties below are optional\n            condition="condition",\n            status="status"\n        )],\n        description="description",\n        enable_branch_auto_deletion=False,\n        environment_variables=[amplify.CfnApp.EnvironmentVariableProperty(\n            name="name",\n            value="value"\n        )],\n        iam_service_role="iamServiceRole",\n        oauth_token="oauthToken",\n        platform="platform",\n        repository="repository",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'access_token', 'auto_branch_creation_config', 'basic_auth_config', 'build_spec', 'custom_headers', 'custom_rules', 'description', 'enable_branch_auto_deletion', 'environment_variables', 'iam_service_role', 'oauth_token', 'platform', 'repository', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnAppProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnBranchProps
class CfnBranchPropsDef(BaseCfnProperty):
    app_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID for an Amplify app. *Length Constraints:* Minimum length of 1. Maximum length of 20. *Pattern:* d[a-z0-9]+\n')
    branch_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name for the branch. *Length Constraints:* Minimum length of 1. Maximum length of 255. *Pattern:* (?s).+\n')
    backend: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnBranch_BackendPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    basic_auth_config: typing.Union[models.UnsupportedResource, models.aws_amplify.CfnBranch_BasicAuthConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The basic authorization credentials for a branch of an Amplify app. You must base64-encode the authorization credentials and provide them in the format ``user:password`` .\n')
    build_spec: typing.Optional[str] = pydantic.Field(None, description='The build specification (build spec) for the branch. *Length Constraints:* Minimum length of 1. Maximum length of 25000. *Pattern:* (?s).+\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the branch that is part of an Amplify app. *Length Constraints:* Maximum length of 1000. *Pattern:* (?s).*\n')
    enable_auto_build: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables auto building for the branch.\n')
    enable_performance_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.\n')
    enable_pull_request_preview: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifies whether Amplify Hosting creates a preview for each pull request that is made for this branch. If this property is enabled, Amplify deploys your app to a unique preview URL after each pull request is opened. Development and QA teams can use this preview to test the pull request before it's merged into a production or integration branch. To provide backend support for your preview, Amplify automatically provisions a temporary backend environment that it deletes when the pull request is closed. If you want to specify a dedicated backend environment for your previews, use the ``PullRequestEnvironmentName`` property. For more information, see `Web Previews <https://docs.aws.amazon.com/amplify/latest/userguide/pr-previews.html>`_ in the *AWS Amplify Hosting User Guide* .\n")
    environment_variables: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnBranch_EnvironmentVariablePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The environment variables for the branch.\n')
    framework: typing.Optional[str] = pydantic.Field(None, description='The framework for the branch.\n')
    pull_request_environment_name: typing.Optional[str] = pydantic.Field(None, description="If pull request previews are enabled for this branch, you can use this property to specify a dedicated backend environment for your previews. For example, you could specify an environment named ``prod`` , ``test`` , or ``dev`` that you initialized with the Amplify CLI and mapped to this branch. To enable pull request previews, set the ``EnablePullRequestPreview`` property to ``true`` . If you don't specify an environment, Amplify Hosting provides backend support for each preview by automatically provisioning a temporary backend environment. Amplify Hosting deletes this environment when the pull request is closed. For more information about creating backend environments, see `Feature Branch Deployments and Team Workflows <https://docs.aws.amazon.com/amplify/latest/userguide/multi-environments.html>`_ in the *AWS Amplify Hosting User Guide* . *Length Constraints:* Maximum length of 20. *Pattern:* (?s).*\n")
    stage: typing.Optional[str] = pydantic.Field(None, description='Describes the current stage for the branch. *Valid Values:* PRODUCTION | BETA | DEVELOPMENT | EXPERIMENTAL | PULL_REQUEST\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tag for the branch.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-amplify-branch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    cfn_branch_props = amplify.CfnBranchProps(\n        app_id="appId",\n        branch_name="branchName",\n\n        # the properties below are optional\n        backend=amplify.CfnBranch.BackendProperty(\n            stack_arn="stackArn"\n        ),\n        basic_auth_config=amplify.CfnBranch.BasicAuthConfigProperty(\n            password="password",\n            username="username",\n\n            # the properties below are optional\n            enable_basic_auth=False\n        ),\n        build_spec="buildSpec",\n        description="description",\n        enable_auto_build=False,\n        enable_performance_mode=False,\n        enable_pull_request_preview=False,\n        environment_variables=[amplify.CfnBranch.EnvironmentVariableProperty(\n            name="name",\n            value="value"\n        )],\n        framework="framework",\n        pull_request_environment_name="pullRequestEnvironmentName",\n        stage="stage",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['app_id', 'branch_name', 'backend', 'basic_auth_config', 'build_spec', 'description', 'enable_auto_build', 'enable_performance_mode', 'enable_pull_request_preview', 'environment_variables', 'framework', 'pull_request_environment_name', 'stage', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnBranchProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_amplify.CfnDomainProps
class CfnDomainPropsDef(BaseCfnProperty):
    app_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID for an Amplify app. *Length Constraints:* Minimum length of 1. Maximum length of 20. *Pattern:* d[a-z0-9]+\n')
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain name for the domain association. *Length Constraints:* Maximum length of 255. *Pattern:* ^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9]).)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])(.)?$\n')
    sub_domain_settings: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_amplify.CfnDomain_SubDomainSettingPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The setting for the subdomain.\n')
    auto_sub_domain_creation_patterns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Sets the branch patterns for automatic subdomain creation.\n')
    auto_sub_domain_iam_role: typing.Optional[str] = pydantic.Field(None, description='The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains. *Length Constraints:* Maximum length of 1000. *Pattern:* ^$|^arn:aws:iam::\\d{12}:role.+\n')
    enable_auto_sub_domain: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables the automated creation of subdomains for branches.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-amplify-domain.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_amplify as amplify\n\n    cfn_domain_props = amplify.CfnDomainProps(\n        app_id="appId",\n        domain_name="domainName",\n        sub_domain_settings=[amplify.CfnDomain.SubDomainSettingProperty(\n            branch_name="branchName",\n            prefix="prefix"\n        )],\n\n        # the properties below are optional\n        auto_sub_domain_creation_patterns=["autoSubDomainCreationPatterns"],\n        auto_sub_domain_iam_role="autoSubDomainIamRole",\n        enable_auto_sub_domain=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['app_id', 'domain_name', 'sub_domain_settings', 'auto_sub_domain_creation_patterns', 'auto_sub_domain_iam_role', 'enable_auto_sub_domain']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_amplify.CfnDomainProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnApp_AutoBranchCreationConfigProperty: typing.Optional[dict[str, CfnApp_AutoBranchCreationConfigPropertyDef]] = pydantic.Field(None)
    CfnApp_BasicAuthConfigProperty: typing.Optional[dict[str, CfnApp_BasicAuthConfigPropertyDef]] = pydantic.Field(None)
    CfnApp_CustomRuleProperty: typing.Optional[dict[str, CfnApp_CustomRulePropertyDef]] = pydantic.Field(None)
    CfnApp_EnvironmentVariableProperty: typing.Optional[dict[str, CfnApp_EnvironmentVariablePropertyDef]] = pydantic.Field(None)
    CfnBranch_BackendProperty: typing.Optional[dict[str, CfnBranch_BackendPropertyDef]] = pydantic.Field(None)
    CfnBranch_BasicAuthConfigProperty: typing.Optional[dict[str, CfnBranch_BasicAuthConfigPropertyDef]] = pydantic.Field(None)
    CfnBranch_EnvironmentVariableProperty: typing.Optional[dict[str, CfnBranch_EnvironmentVariablePropertyDef]] = pydantic.Field(None)
    CfnDomain_SubDomainSettingProperty: typing.Optional[dict[str, CfnDomain_SubDomainSettingPropertyDef]] = pydantic.Field(None)
    CfnApp: typing.Optional[dict[str, CfnAppDef]] = pydantic.Field(None)
    CfnBranch: typing.Optional[dict[str, CfnBranchDef]] = pydantic.Field(None)
    CfnDomain: typing.Optional[dict[str, CfnDomainDef]] = pydantic.Field(None)
    CfnAppProps: typing.Optional[dict[str, CfnAppPropsDef]] = pydantic.Field(None)
    CfnBranchProps: typing.Optional[dict[str, CfnBranchPropsDef]] = pydantic.Field(None)
    CfnDomainProps: typing.Optional[dict[str, CfnDomainPropsDef]] = pydantic.Field(None)
    ...
