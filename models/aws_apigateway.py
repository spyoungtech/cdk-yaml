from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_apigateway.AccessLogField
class AccessLogFieldDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['context_account_id', 'context_api_id', 'context_authenticate_error', 'context_authenticate_latency', 'context_authenticate_status', 'context_authorize_error', 'context_authorize_latency', 'context_authorize_status', 'context_authorizer', 'context_authorizer_claims', 'context_authorizer_error', 'context_authorizer_integration_latency', 'context_authorizer_integration_status', 'context_authorizer_latency', 'context_authorizer_principal_id', 'context_authorizer_request_id', 'context_authorizer_status', 'context_aws_endpoint_request_id', 'context_caller_account_id', 'context_custom_domain_base_path_matched', 'context_domain_name', 'context_domain_prefix', 'context_error_message', 'context_error_message_string', 'context_error_response_type', 'context_error_validation_error_string', 'context_extended_request_id', 'context_http_method', 'context_identity_account_id', 'context_identity_api_key', 'context_identity_api_key_id', 'context_identity_caller', 'context_identity_client_cert_issuner_dn', 'context_identity_client_cert_pem', 'context_identity_client_cert_serial_number', 'context_identity_client_cert_subject_dn', 'context_identity_client_cert_validity_not_after', 'context_identity_client_cert_validity_not_before', 'context_identity_cognito_authentication_provider', 'context_identity_cognito_authentication_type', 'context_identity_cognito_identity_id', 'context_identity_cognito_identity_pool_id', 'context_identity_principal_org_id', 'context_identity_source_ip', 'context_identity_user', 'context_identity_user_agent', 'context_identity_user_arn', 'context_integration_error_message', 'context_integration_latency', 'context_integration_status', 'context_owner_account_id', 'context_path', 'context_protocol', 'context_request_id', 'context_request_override_header', 'context_request_override_path', 'context_request_override_querystring', 'context_request_time', 'context_request_time_epoch', 'context_resource_id', 'context_resource_path', 'context_response_latency', 'context_response_length', 'context_response_override_header', 'context_response_override_status', 'context_stage', 'context_status', 'context_waf_error', 'context_waf_latency', 'context_waf_response_code', 'context_waf_status', 'context_webacl_arn', 'context_xray_trace_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.AccessLogField'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AccessLogFieldDefConfig] = pydantic.Field(None)


class AccessLogFieldDefConfig(pydantic.BaseModel):
    context_account_id: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) The API callers AWS account ID.\n:deprecated: Use ``contextCallerAccountId`` or ``contextOwnerAccountId`` instead\n\n:stability: deprecated')
    context_api_id: typing.Optional[bool] = pydantic.Field(None, description='The identifier API Gateway assigns to your API.')
    context_authenticate_error: typing.Optional[bool] = pydantic.Field(None, description='The error message returned from an authentication attempt.')
    context_authenticate_latency: typing.Optional[bool] = pydantic.Field(None, description='The authentication latency in ms.')
    context_authenticate_status: typing.Optional[bool] = pydantic.Field(None, description='The status code returned from an authentication attempt.')
    context_authorize_error: typing.Optional[bool] = pydantic.Field(None, description='The authorization error message.')
    context_authorize_latency: typing.Optional[bool] = pydantic.Field(None, description='The authorization latency in ms.')
    context_authorize_status: typing.Optional[bool] = pydantic.Field(None, description='The status code returned from an authorization attempt.')
    context_authorizer: typing.Optional[list[AccessLogFieldDefContextAuthorizerParams]] = pydantic.Field(None, description='The stringified value of the specified key-value pair of the ``context`` map returned from an API Gateway Lambda authorizer function.')
    context_authorizer_claims: typing.Optional[list[AccessLogFieldDefContextAuthorizerClaimsParams]] = pydantic.Field(None, description='A property of the claims returned from the Amazon Cognito user pool after the method caller is successfully authenticated.')
    context_authorizer_error: typing.Optional[bool] = pydantic.Field(None, description='The error message returned from an authorizer.')
    context_authorizer_integration_latency: typing.Optional[bool] = pydantic.Field(None, description='The authorizer latency in ms.')
    context_authorizer_integration_status: typing.Optional[bool] = pydantic.Field(None, description='The status code returned from a Lambda authorizer.')
    context_authorizer_latency: typing.Optional[bool] = pydantic.Field(None, description='The authorizer latency in ms.')
    context_authorizer_principal_id: typing.Optional[bool] = pydantic.Field(None, description='The principal user identification associated with the token sent by the client and returned from an API Gateway Lambda authorizer (formerly known as a custom authorizer).\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html')
    context_authorizer_request_id: typing.Optional[bool] = pydantic.Field(None, description="The AWS endpoint's request ID.")
    context_authorizer_status: typing.Optional[bool] = pydantic.Field(None, description='The status code returned from an authorizer.')
    context_aws_endpoint_request_id: typing.Optional[bool] = pydantic.Field(None, description="The AWS endpoint's request ID.")
    context_caller_account_id: typing.Optional[bool] = pydantic.Field(None, description='The API callers AWS account ID.')
    context_custom_domain_base_path_matched: typing.Optional[bool] = pydantic.Field(None, description='The path for an API mapping that an incoming request matched.\nApplicable when a client uses a custom domain name to access an API. For example if a client sends a request to\nhttps://api.example.com/v1/orders/1234, and the request matches the API mapping with the path v1/orders, the value is v1/orders.\n\n:see: https://docs.aws.amazon.com/en_jp/apigateway/latest/developerguide/rest-api-mappings.html')
    context_domain_name: typing.Optional[bool] = pydantic.Field(None, description='The full domain name used to invoke the API.\nThis should be the same as the incoming ``Host`` header.')
    context_domain_prefix: typing.Optional[bool] = pydantic.Field(None, description='The first label of the ``$context.domainName``. This is often used as a caller/customer identifier.')
    context_error_message: typing.Optional[bool] = pydantic.Field(None, description='A string containing an API Gateway error message.')
    context_error_message_string: typing.Optional[bool] = pydantic.Field(None, description='The quoted value of $context.error.message, namely "$context.error.message".')
    context_error_response_type: typing.Optional[bool] = pydantic.Field(None, description='A type of GatewayResponse.\nThis variable can only be used for simple variable substitution in a GatewayResponse body-mapping template,\nwhich is not processed by the Velocity Template Language engine, and in access logging.\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html')
    context_error_validation_error_string: typing.Optional[bool] = pydantic.Field(None, description='A string containing a detailed validation error message.')
    context_extended_request_id: typing.Optional[bool] = pydantic.Field(None, description='The extended ID that API Gateway assigns to the API request, which contains more useful information for debugging/troubleshooting.')
    context_http_method: typing.Optional[bool] = pydantic.Field(None, description='The HTTP method used.\nValid values include: ``DELETE``, ``GET``, ``HEAD``, ``OPTIONS``, ``PATCH``, ``POST``, and ``PUT``.')
    context_identity_account_id: typing.Optional[bool] = pydantic.Field(None, description='The AWS account ID associated with the request.')
    context_identity_api_key: typing.Optional[bool] = pydantic.Field(None, description="For API methods that require an API key, this variable is the API key associated with the method request.\nFor methods that don't require an API key, this variable is\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html")
    context_identity_api_key_id: typing.Optional[bool] = pydantic.Field(None, description='The API key ID associated with an API request that requires an API key.')
    context_identity_caller: typing.Optional[bool] = pydantic.Field(None, description='The principal identifier of the caller making the request.')
    context_identity_client_cert_issuner_dn: typing.Optional[bool] = pydantic.Field(None, description='The distinguished name of the issuer of the certificate that a client presents.\nPresent when a client accesses an API by using a custom domain name that has mutual TLS enabled.\nPresent only in access logs if mutual TLS authentication fails.')
    context_identity_client_cert_pem: typing.Optional[bool] = pydantic.Field(None, description='The PEM-encoded client certificate that the client presented during mutual TLS authentication.\nPresent when a client accesses an API by using a custom domain name that has mutual TLS enabled.\nPresent only in access logs if mutual TLS authentication fails.')
    context_identity_client_cert_serial_number: typing.Optional[bool] = pydantic.Field(None, description='The serial number of the certificate.\nPresent when a client accesses an API by using a custom domain name that has mutual TLS enabled.\nPresent only in access logs if mutual TLS authentication fails.')
    context_identity_client_cert_subject_dn: typing.Optional[bool] = pydantic.Field(None, description='The distinguished name of the subject of the certificate that a client presents.\nPresent when a client accesses an API by using a custom domain name that has mutual TLS enabled.\nPresent only in access logs if mutual TLS authentication fails.')
    context_identity_client_cert_validity_not_after: typing.Optional[bool] = pydantic.Field(None, description='The date after which the certificate is invalid.\nPresent when a client accesses an API by using a custom domain name that has mutual TLS enabled.\nPresent only in access logs if mutual TLS authentication fails.')
    context_identity_client_cert_validity_not_before: typing.Optional[bool] = pydantic.Field(None, description='The date before which the certificate is invalid.\nPresent when a client accesses an API by using a custom domain name that has mutual TLS enabled.\nPresent only in access logs if mutual TLS authentication fails.')
    context_identity_cognito_authentication_provider: typing.Optional[bool] = pydantic.Field(None, description='The Amazon Cognito authentication provider used by the caller making the request.\nAvailable only if the request was signed with Amazon Cognito credentials.\n\n:see: https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html')
    context_identity_cognito_authentication_type: typing.Optional[bool] = pydantic.Field(None, description='The Amazon Cognito authentication type of the caller making the request.\nAvailable only if the request was signed with Amazon Cognito credentials.')
    context_identity_cognito_identity_id: typing.Optional[bool] = pydantic.Field(None, description='The Amazon Cognito identity ID of the caller making the request.\nAvailable only if the request was signed with Amazon Cognito credentials.')
    context_identity_cognito_identity_pool_id: typing.Optional[bool] = pydantic.Field(None, description='The Amazon Cognito identity pool ID of the caller making the request.\nAvailable only if the request was signed with Amazon Cognito credentials.')
    context_identity_principal_org_id: typing.Optional[bool] = pydantic.Field(None, description='The AWS organization ID.')
    context_identity_source_ip: typing.Optional[bool] = pydantic.Field(None, description='The source IP address of the TCP connection making the request to API Gateway.\nWarning: You should not trust this value if there is any chance that the ``X-Forwarded-For`` header could be forged.')
    context_identity_user: typing.Optional[bool] = pydantic.Field(None, description='The principal identifier of the user making the request.\nUsed in Lambda authorizers.\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-output.html')
    context_identity_user_agent: typing.Optional[bool] = pydantic.Field(None, description='The User-Agent header of the API caller.')
    context_identity_user_arn: typing.Optional[bool] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the effective user identified after authentication.\n:see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html')
    context_integration_error_message: typing.Optional[bool] = pydantic.Field(None, description='A string that contains an integration error message.')
    context_integration_latency: typing.Optional[bool] = pydantic.Field(None, description='The integration latency in ms.')
    context_integration_status: typing.Optional[bool] = pydantic.Field(None, description='For Lambda proxy integration, this parameter represents the status code returned from AWS Lambda, not from the backend Lambda function.')
    context_owner_account_id: typing.Optional[bool] = pydantic.Field(None, description="The API owner's AWS account ID.")
    context_path: typing.Optional[bool] = pydantic.Field(None, description='The request path.\nFor example, for a non-proxy request URL of https://{rest-api-id.execute-api.{region}.amazonaws.com/{stage}/root/child,\nthis value is /{stage}/root/child.')
    context_protocol: typing.Optional[bool] = pydantic.Field(None, description='The request protocol, for example, HTTP/1.1.')
    context_request_id: typing.Optional[bool] = pydantic.Field(None, description='The ID that API Gateway assigns to the API request.')
    context_request_override_header: typing.Optional[list[AccessLogFieldDefContextRequestOverrideHeaderParams]] = pydantic.Field(None, description='The request header override.\nIf this parameter is defined, it contains the headers to be used instead of the HTTP Headers that are defined in the Integration Request pane.')
    context_request_override_path: typing.Optional[list[AccessLogFieldDefContextRequestOverridePathParams]] = pydantic.Field(None, description='The request path override.\nIf this parameter is defined,\nit contains the request path to be used instead of the URL Path Parameters that are defined in the Integration Request pane.')
    context_request_override_querystring: typing.Optional[list[AccessLogFieldDefContextRequestOverrideQuerystringParams]] = pydantic.Field(None, description='The request query string override.\nIf this parameter is defined, it contains the request query strings to be used instead\nof the URL Query String Parameters that are defined in the Integration Request pane.')
    context_request_time: typing.Optional[bool] = pydantic.Field(None, description='The CLF-formatted request time (dd/MMM/yyyy:HH:mm:ss +-hhmm).')
    context_request_time_epoch: typing.Optional[bool] = pydantic.Field(None, description='The Epoch-formatted request time.')
    context_resource_id: typing.Optional[bool] = pydantic.Field(None, description='The identifier that API Gateway assigns to your resource.')
    context_resource_path: typing.Optional[bool] = pydantic.Field(None, description='The path to your resource.\nFor example, for the non-proxy request URI of ``https://{rest-api-id.execute-api.{region}.amazonaws.com/{stage}/root/child``,\nThe $context.resourcePath value is ``/root/child``.\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-step-by-step.html')
    context_response_latency: typing.Optional[bool] = pydantic.Field(None, description='The response latency in ms.')
    context_response_length: typing.Optional[bool] = pydantic.Field(None, description='The response payload length.')
    context_response_override_header: typing.Optional[list[AccessLogFieldDefContextResponseOverrideHeaderParams]] = pydantic.Field(None, description='The response header override.\nIf this parameter is defined, it contains the header to be returned instead of the Response header\nthat is defined as the Default mapping in the Integration Response pane.')
    context_response_override_status: typing.Optional[bool] = pydantic.Field(None, description='The response status code override.\nIf this parameter is defined, it contains the status code to be returned instead of the Method response status\nthat is defined as the Default mapping in the Integration Response pane.\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-override-request-response-parameters.html')
    context_stage: typing.Optional[bool] = pydantic.Field(None, description='The deployment stage of the API request (for example, ``Beta`` or ``Prod``).')
    context_status: typing.Optional[bool] = pydantic.Field(None, description='The method response status.')
    context_waf_error: typing.Optional[bool] = pydantic.Field(None, description='The error message returned from AWS WAF.')
    context_waf_latency: typing.Optional[bool] = pydantic.Field(None, description='The AWS WAF latency in ms.')
    context_waf_response_code: typing.Optional[bool] = pydantic.Field(None, description='The response received from AWS WAF: ``WAF_ALLOW`` or ``WAF_BLOCK``.\nWill not be set if the stage is not associated with a web ACL.\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-aws-waf.html')
    context_waf_status: typing.Optional[bool] = pydantic.Field(None, description='The status code returned from AWS WAF.')
    context_webacl_arn: typing.Optional[bool] = pydantic.Field(None, description='The complete ARN of the web ACL that is used to decide whether to allow or block the request.\nWill not be set if the stage is not associated with a web ACL.\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-aws-waf.html')
    context_xray_trace_id: typing.Optional[bool] = pydantic.Field(None, description='The trace ID for the X-Ray trace.\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-enabling-xray.html')

class AccessLogFieldDefContextAuthorizerParams(pydantic.BaseModel):
    property: str = pydantic.Field(..., description='key of the context map.\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html\n')
    ...

class AccessLogFieldDefContextAuthorizerClaimsParams(pydantic.BaseModel):
    property: str = pydantic.Field(..., description='A property key of the claims.\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html\n')
    ...

class AccessLogFieldDefContextRequestOverrideHeaderParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-override-request-response-parameters.html\n')
    ...

class AccessLogFieldDefContextRequestOverridePathParams(pydantic.BaseModel):
    path_name: str = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-override-request-response-parameters.html\n')
    ...

class AccessLogFieldDefContextRequestOverrideQuerystringParams(pydantic.BaseModel):
    querystring_name: str = pydantic.Field(..., description='-')
    ...

class AccessLogFieldDefContextResponseOverrideHeaderParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-override-request-response-parameters.html\n')
    ...


#  autogenerated from aws_cdk.aws_apigateway.AccessLogFormat
class AccessLogFormatDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['clf', 'custom', 'json_with_standard_fields']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.AccessLogFormat'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AccessLogFormatDefConfig] = pydantic.Field(None)


class AccessLogFormatDefConfig(pydantic.BaseModel):
    clf: typing.Optional[list[AccessLogFormatDefClfParams]] = pydantic.Field(None, description='Generate Common Log Format.')
    custom: typing.Optional[list[AccessLogFormatDefCustomParams]] = pydantic.Field(None, description='Custom log format.\nYou can create any log format string. You can easily get the $ context variable by using the methods of AccessLogField.')
    json_with_standard_fields: typing.Optional[list[AccessLogFormatDefJsonWithStandardFieldsParams]] = pydantic.Field(None, description='Access log will be produced in the JSON format with a set of fields most useful in the access log.\nAll fields are turned on by default with the\noption to turn off specific fields.')

class AccessLogFormatDefClfParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_apigateway.AccessLogFormatDefConfig]] = pydantic.Field(None)
    ...

class AccessLogFormatDefCustomParams(pydantic.BaseModel):
    format: str = pydantic.Field(..., description='-\n\nExample::\n\n    apigateway.AccessLogFormat.custom(JSON.stringify({\n        "request_id": apigateway.AccessLogField.context_request_id(),\n        "source_ip": apigateway.AccessLogField.context_identity_source_ip(),\n        "method": apigateway.AccessLogField.context_http_method(),\n        "user_context": {\n            "sub": apigateway.AccessLogField.context_authorizer_claims("sub"),\n            "email": apigateway.AccessLogField.context_authorizer_claims("email")\n        }\n    }))\n')
    return_config: typing.Optional[list[models.aws_apigateway.AccessLogFormatDefConfig]] = pydantic.Field(None)
    ...

class AccessLogFormatDefJsonWithStandardFieldsParams(pydantic.BaseModel):
    caller: bool = pydantic.Field(..., description='If this flag is enabled, the principal identifier of the caller will be output to the log.\n')
    http_method: bool = pydantic.Field(..., description='If this flag is enabled, the http method will be output to the log.\n')
    ip: bool = pydantic.Field(..., description='If this flag is enabled, the source IP of request will be output to the log.\n')
    protocol: bool = pydantic.Field(..., description='If this flag is enabled, the request protocol will be output to the log.\n')
    request_time: bool = pydantic.Field(..., description='If this flag is enabled, the CLF-formatted request time((dd/MMM/yyyy:HH:mm:ss +-hhmm) will be output to the log.\n')
    resource_path: bool = pydantic.Field(..., description='If this flag is enabled, the path to your resource will be output to the log.\n')
    response_length: bool = pydantic.Field(..., description='If this flag is enabled, the response payload length will be output to the log.\n')
    status: bool = pydantic.Field(..., description='If this flag is enabled, the method response status will be output to the log.\n')
    user: bool = pydantic.Field(..., description='If this flag is enabled, the principal identifier of the user will be output to the log.')
    return_config: typing.Optional[list[models.aws_apigateway.AccessLogFormatDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.ApiDefinition
class ApiDefinitionDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind', 'bind_after_create']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_asset', 'from_bucket', 'from_inline']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ApiDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ApiDefinitionDefConfig] = pydantic.Field(None)


class ApiDefinitionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[ApiDefinitionDefBindParams]] = pydantic.Field(None, description='Called when the specification is initialized to allow this object to bind to the stack, add resources and have fun.')
    bind_after_create: typing.Optional[list[ApiDefinitionDefBindAfterCreateParams]] = pydantic.Field(None, description="Called after the CFN RestApi resource has been created to allow the Api Definition to bind to it.\nSpecifically it's required to allow assets to add\nmetadata for tooling like SAM CLI to be able to find their origins.")
    from_asset: typing.Optional[list[ApiDefinitionDefFromAssetParams]] = pydantic.Field(None, description='Loads the API specification from a local disk asset.')
    from_bucket: typing.Optional[list[ApiDefinitionDefFromBucketParams]] = pydantic.Field(None, description='Creates an API definition from a specification file in an S3 bucket.')
    from_inline: typing.Optional[list[ApiDefinitionDefFromInlineParams]] = pydantic.Field(None, description='Create an API definition from an inline object.\nThe inline object must follow the\nschema of OpenAPI 2.0 or OpenAPI 3.0')

class ApiDefinitionDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description="The binding scope. Don't be smart about trying to down-cast or assume it's initialized. You may just use it as a construct scope.")
    ...

class ApiDefinitionDefBindAfterCreateParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    _rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='-')
    ...

class ApiDefinitionDefFromAssetParams(pydantic.BaseModel):
    file: str = pydantic.Field(..., description='-\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    return_config: typing.Optional[list[models.aws_apigateway.AssetApiDefinitionDefConfig]] = pydantic.Field(None)
    ...

class ApiDefinitionDefFromBucketParams(pydantic.BaseModel):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='-\n')
    key: str = pydantic.Field(..., description='-\n')
    object_version: typing.Optional[str] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_apigateway.S3ApiDefinitionDefConfig]] = pydantic.Field(None)
    ...

class ApiDefinitionDefFromInlineParams(pydantic.BaseModel):
    definition: typing.Any = pydantic.Field(..., description='-\n\nExample::\n\n    apigateway.ApiDefinition.from_inline({\n        "openapi": "3.0.2",\n        "paths": {\n            "/pets": {\n                "get": {\n                    "responses": {\n                        "200": {\n                            "content": {\n                                "application/json": {\n                                    "schema": {\n                                        "$ref": "#/components/schemas/Empty"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    "x-amazon-apigateway-integration": {\n                        "responses": {\n                            "default": {\n                                "status_code": "200"\n                            }\n                        },\n                        "request_templates": {\n                            "application/json": "{"statusCode": 200}"\n                        },\n                        "passthrough_behavior": "when_no_match",\n                        "type": "mock"\n                    }\n                }\n            }\n        },\n        "components": {\n            "schemas": {\n                "Empty": {\n                    "title": "Empty Schema",\n                    "type": "object"\n                }\n            }\n        }\n    })\n')
    return_config: typing.Optional[list[models.aws_apigateway.InlineApiDefinitionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.AssetApiDefinition
class AssetApiDefinitionDef(BaseClass):
    path: str = pydantic.Field(..., description='-')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    _init_params: typing.ClassVar[list[str]] = ['path', 'deploy_time', 'readers', 'asset_hash', 'asset_hash_type', 'bundling', 'exclude', 'follow_symlinks', 'ignore_mode']
    _method_names: typing.ClassVar[list[str]] = ['bind', 'bind_after_create']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_asset', 'from_bucket', 'from_inline']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.AssetApiDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AssetApiDefinitionDefConfig] = pydantic.Field(None)


class AssetApiDefinitionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[AssetApiDefinitionDefBindParams]] = pydantic.Field(None, description='Called when the specification is initialized to allow this object to bind to the stack, add resources and have fun.')
    bind_after_create: typing.Optional[list[AssetApiDefinitionDefBindAfterCreateParams]] = pydantic.Field(None, description="Called after the CFN RestApi resource has been created to allow the Api Definition to bind to it.\nSpecifically it's required to allow assets to add\nmetadata for tooling like SAM CLI to be able to find their origins.")
    from_asset: typing.Optional[list[AssetApiDefinitionDefFromAssetParams]] = pydantic.Field(None, description='Loads the API specification from a local disk asset.')
    from_bucket: typing.Optional[list[AssetApiDefinitionDefFromBucketParams]] = pydantic.Field(None, description='Creates an API definition from a specification file in an S3 bucket.')
    from_inline: typing.Optional[list[AssetApiDefinitionDefFromInlineParams]] = pydantic.Field(None, description='Create an API definition from an inline object.\nThe inline object must follow the\nschema of OpenAPI 2.0 or OpenAPI 3.0')

class AssetApiDefinitionDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class AssetApiDefinitionDefBindAfterCreateParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='-')
    ...

class AssetApiDefinitionDefFromAssetParams(pydantic.BaseModel):
    file: str = pydantic.Field(..., description='-\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    return_config: typing.Optional[list[models.aws_apigateway.AssetApiDefinitionDefConfig]] = pydantic.Field(None)
    ...

class AssetApiDefinitionDefFromBucketParams(pydantic.BaseModel):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='-\n')
    key: str = pydantic.Field(..., description='-\n')
    object_version: typing.Optional[str] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_apigateway.S3ApiDefinitionDefConfig]] = pydantic.Field(None)
    ...

class AssetApiDefinitionDefFromInlineParams(pydantic.BaseModel):
    definition: typing.Any = pydantic.Field(..., description='-\n\nExample::\n\n    apigateway.ApiDefinition.from_inline({\n        "openapi": "3.0.2",\n        "paths": {\n            "/pets": {\n                "get": {\n                    "responses": {\n                        "200": {\n                            "content": {\n                                "application/json": {\n                                    "schema": {\n                                        "$ref": "#/components/schemas/Empty"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    "x-amazon-apigateway-integration": {\n                        "responses": {\n                            "default": {\n                                "status_code": "200"\n                            }\n                        },\n                        "request_templates": {\n                            "application/json": "{"statusCode": 200}"\n                        },\n                        "passthrough_behavior": "when_no_match",\n                        "type": "mock"\n                    }\n                }\n            }\n        },\n        "components": {\n            "schemas": {\n                "Empty": {\n                    "title": "Empty Schema",\n                    "type": "object"\n                }\n            }\n        }\n    })\n')
    return_config: typing.Optional[list[models.aws_apigateway.InlineApiDefinitionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.Authorizer
class AuthorizerDef(BaseClass):
    account: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to\n')
    environment_from_arn: typing.Optional[str] = pydantic.Field(None, description='ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.\n')
    physical_name: typing.Optional[str] = pydantic.Field(None, description='The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to')
    _init_params: typing.ClassVar[list[str]] = ['account', 'environment_from_arn', 'physical_name', 'region']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.Authorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AuthorizerDefConfig] = pydantic.Field(None)


class AuthorizerDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class AuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.AwsIntegration
class AwsIntegrationDef(BaseClass):
    service: str = pydantic.Field(..., description='The name of the integrated AWS service (e.g. ``s3``).')
    action: typing.Optional[str] = pydantic.Field(None, description='The AWS action to perform in the integration. Use ``actionParams`` to specify key-value params for the action. Mutually exclusive with ``path``.\n')
    action_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Parameters for the action. ``action`` must be set, and ``path`` must be undefined. The action params will be URL encoded.\n')
    integration_http_method: typing.Optional[str] = pydantic.Field(None, description="The integration's HTTP method type. Default: POST\n")
    options: typing.Union[models.aws_apigateway.IntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Integration options, such as content handling, request/response mapping, etc.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to use for path-base APIs. For example, for S3 GET, you can set path to ``bucket/key``. For lambda, you can set path to ``2015-03-31/functions/${function-arn}/invocations`` Mutually exclusive with the ``action`` options.\n')
    proxy: typing.Optional[bool] = pydantic.Field(None, description='Use AWS_PROXY integration. Default: false\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region of the integrated AWS service. Default: - same region as the stack\n')
    subdomain: typing.Optional[str] = pydantic.Field(None, description='A designated subdomain supported by certain AWS service for fast host-name lookup.')
    _init_params: typing.ClassVar[list[str]] = ['service', 'action', 'action_parameters', 'integration_http_method', 'options', 'path', 'proxy', 'region', 'subdomain']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.AwsIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AwsIntegrationDefConfig] = pydantic.Field(None)


class AwsIntegrationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[AwsIntegrationDefBindParams]] = pydantic.Field(None, description='Can be overridden by subclasses to allow the integration to interact with the method being integrated, access the REST API object, method ARNs, etc.')

class AwsIntegrationDefBindParams(pydantic.BaseModel):
    method: models.aws_apigateway.MethodDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.Cors
class CorsDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.Cors'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.HttpIntegration
class HttpIntegrationDef(BaseClass):
    url: str = pydantic.Field(..., description='-')
    http_method: typing.Optional[str] = pydantic.Field(None, description='HTTP method to use when invoking the backend URL. Default: GET\n')
    options: typing.Union[models.aws_apigateway.IntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Integration options, such as request/resopnse mapping, content handling, etc. Default: defaults based on ``IntegrationOptions`` defaults\n')
    proxy: typing.Optional[bool] = pydantic.Field(None, description='Determines whether to use proxy integration or custom integration. Default: true')
    _init_params: typing.ClassVar[list[str]] = ['url', 'http_method', 'options', 'proxy']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.HttpIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[HttpIntegrationDefConfig] = pydantic.Field(None)


class HttpIntegrationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[HttpIntegrationDefBindParams]] = pydantic.Field(None, description='Can be overridden by subclasses to allow the integration to interact with the method being integrated, access the REST API object, method ARNs, etc.')

class HttpIntegrationDefBindParams(pydantic.BaseModel):
    _method: models.aws_apigateway.MethodDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.IdentitySource
class IdentitySourceDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['context', 'header', 'query_string', 'stage_variable']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.IdentitySource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[IdentitySourceDefConfig] = pydantic.Field(None)


class IdentitySourceDefConfig(pydantic.BaseModel):
    context: typing.Optional[list[IdentitySourceDefContextParams]] = pydantic.Field(None, description='Provides a properly formatted request context identity source.')
    header: typing.Optional[list[IdentitySourceDefHeaderParams]] = pydantic.Field(None, description='Provides a properly formatted header identity source.')
    query_string: typing.Optional[list[IdentitySourceDefQueryStringParams]] = pydantic.Field(None, description='Provides a properly formatted query string identity source.')
    stage_variable: typing.Optional[list[IdentitySourceDefStageVariableParams]] = pydantic.Field(None, description='Provides a properly formatted API Gateway stage variable identity source.')

class IdentitySourceDefContextParams(pydantic.BaseModel):
    context: str = pydantic.Field(..., description='the name of the context variable the ``IdentitySource`` will represent.\n')
    ...

class IdentitySourceDefHeaderParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header the ``IdentitySource`` will represent.\n')
    ...

class IdentitySourceDefQueryStringParams(pydantic.BaseModel):
    query_string: str = pydantic.Field(..., description='the name of the query string the ``IdentitySource`` will represent.\n')
    ...

class IdentitySourceDefStageVariableParams(pydantic.BaseModel):
    stage_variable: str = pydantic.Field(..., description='the name of the stage variable the ``IdentitySource`` will represent.\n')
    ...


#  autogenerated from aws_cdk.aws_apigateway.InlineApiDefinition
class InlineApiDefinitionDef(BaseClass):
    definition: typing.Any = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['definition']
    _method_names: typing.ClassVar[list[str]] = ['bind', 'bind_after_create']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_asset', 'from_bucket', 'from_inline']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.InlineApiDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InlineApiDefinitionDefConfig] = pydantic.Field(None)


class InlineApiDefinitionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[InlineApiDefinitionDefBindParams]] = pydantic.Field(None, description='Called when the specification is initialized to allow this object to bind to the stack, add resources and have fun.')
    bind_after_create: typing.Optional[list[InlineApiDefinitionDefBindAfterCreateParams]] = pydantic.Field(None, description="Called after the CFN RestApi resource has been created to allow the Api Definition to bind to it.\nSpecifically it's required to allow assets to add\nmetadata for tooling like SAM CLI to be able to find their origins.")
    from_asset: typing.Optional[list[InlineApiDefinitionDefFromAssetParams]] = pydantic.Field(None, description='Loads the API specification from a local disk asset.')
    from_bucket: typing.Optional[list[InlineApiDefinitionDefFromBucketParams]] = pydantic.Field(None, description='Creates an API definition from a specification file in an S3 bucket.')
    from_inline: typing.Optional[list[InlineApiDefinitionDefFromInlineParams]] = pydantic.Field(None, description='Create an API definition from an inline object.\nThe inline object must follow the\nschema of OpenAPI 2.0 or OpenAPI 3.0')

class InlineApiDefinitionDefBindParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class InlineApiDefinitionDefBindAfterCreateParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    _rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='-')
    ...

class InlineApiDefinitionDefFromAssetParams(pydantic.BaseModel):
    file: str = pydantic.Field(..., description='-\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    return_config: typing.Optional[list[models.aws_apigateway.AssetApiDefinitionDefConfig]] = pydantic.Field(None)
    ...

class InlineApiDefinitionDefFromBucketParams(pydantic.BaseModel):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='-\n')
    key: str = pydantic.Field(..., description='-\n')
    object_version: typing.Optional[str] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_apigateway.S3ApiDefinitionDefConfig]] = pydantic.Field(None)
    ...

class InlineApiDefinitionDefFromInlineParams(pydantic.BaseModel):
    definition: typing.Any = pydantic.Field(..., description='-\n\nExample::\n\n    apigateway.ApiDefinition.from_inline({\n        "openapi": "3.0.2",\n        "paths": {\n            "/pets": {\n                "get": {\n                    "responses": {\n                        "200": {\n                            "content": {\n                                "application/json": {\n                                    "schema": {\n                                        "$ref": "#/components/schemas/Empty"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    "x-amazon-apigateway-integration": {\n                        "responses": {\n                            "default": {\n                                "status_code": "200"\n                            }\n                        },\n                        "request_templates": {\n                            "application/json": "{"statusCode": 200}"\n                        },\n                        "passthrough_behavior": "when_no_match",\n                        "type": "mock"\n                    }\n                }\n            }\n        },\n        "components": {\n            "schemas": {\n                "Empty": {\n                    "title": "Empty Schema",\n                    "type": "object"\n                }\n            }\n        }\n    })\n')
    return_config: typing.Optional[list[models.aws_apigateway.InlineApiDefinitionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.Integration
class IntegrationDef(BaseClass):
    type: aws_cdk.aws_apigateway.IntegrationType = pydantic.Field(..., description='Specifies an API method integration type.')
    integration_http_method: typing.Optional[str] = pydantic.Field(None, description="The integration's HTTP method type. Required unless you use a MOCK integration.\n")
    options: typing.Union[models.aws_apigateway.IntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Integration options.\n')
    uri: typing.Any = pydantic.Field(None, description="The Uniform Resource Identifier (URI) for the integration. - If you specify HTTP for the ``type`` property, specify the API endpoint URL. - If you specify MOCK for the ``type`` property, don't specify this property. - If you specify AWS for the ``type`` property, specify an AWS service that follows this form: ``arn:partition:apigateway:region:subdomain.service|service:path|action/service_api.`` For example, a Lambda function URI follows this form: arn:partition:apigateway:region:lambda:path/path. The path is usually in the form /2015-03-31/functions/LambdaFunctionARN/invocations.")
    _init_params: typing.ClassVar[list[str]] = ['type', 'integration_http_method', 'options', 'uri']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.Integration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[IntegrationDefConfig] = pydantic.Field(None)


class IntegrationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[IntegrationDefBindParams]] = pydantic.Field(None, description='Can be overridden by subclasses to allow the integration to interact with the method being integrated, access the REST API object, method ARNs, etc.')

class IntegrationDefBindParams(pydantic.BaseModel):
    _method: models.aws_apigateway.MethodDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.LambdaIntegration
class LambdaIntegrationDef(BaseClass):
    handler: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description='-')
    allow_test_invoke: typing.Optional[bool] = pydantic.Field(None, description='Allow invoking method from AWS Console UI (for testing purposes). This will add another permission to the AWS Lambda resource policy which will allow the ``test-invoke-stage`` stage to invoke this handler. If this is set to ``false``, the function will only be usable from the deployment endpoint. Default: true\n')
    proxy: typing.Optional[bool] = pydantic.Field(None, description='Use proxy integration or normal (request/response mapping) integration. Default: true\n')
    cache_key_parameters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of request parameters whose values are to be cached. It determines request parameters that will make it into the cache key.\n')
    cache_namespace: typing.Optional[str] = pydantic.Field(None, description='An API-specific tag group of related cached parameters.\n')
    connection_type: typing.Optional[aws_cdk.aws_apigateway.ConnectionType] = pydantic.Field(None, description='The type of network connection to the integration endpoint. Default: - ConnectionType.VPC_LINK if ``vpcLink`` property is configured; ConnectionType.Internet otherwise.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigateway.ContentHandling] = pydantic.Field(None, description="Specifies how to handle request payload content type conversions. Default: none if this property isn't defined, the request payload is passed through from the method request to the integration request without modification, provided that the ``passthroughBehaviors`` property is configured to support payload pass-through.\n")
    credentials_passthrough: typing.Optional[bool] = pydantic.Field(None, description="Requires that the caller's identity be passed through from the request. Default: Caller identity is not passed through\n")
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that API Gateway assumes. Mutually exclusive with ``credentialsPassThrough``. Default: A role is not assumed\n')
    integration_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.IntegrationResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The response that API Gateway provides after a method's backend completes processing a request. API Gateway intercepts the response from the backend so that you can control how API Gateway surfaces backend responses. For example, you can map the backend status codes to codes that you define.\n")
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigateway.PassthroughBehavior] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The request parameters that API Gateway sends with the backend request. Specify request parameters as key-value pairs (string-to-string mappings), with a destination as the key and a source as the value. Specify the destination by using the following pattern integration.request.location.name, where location is querystring, path, or header, and name is a valid, unique parameter name. The source must be an existing method request parameter or a static value. You must enclose static values in single quotation marks and pre-encode these values based on their destination in the request.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map of Apache Velocity templates that are applied on the request payload. The template that API Gateway uses is based on the value of the Content-Type header that\'s sent by the client. The content type value is the key, and the template is the value (specified as a string), such as the following snippet:: { "application/json": "{ \\"statusCode\\": 200 }" }\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n')
    vpc_link: typing.Optional[typing.Union[models.aws_apigateway.VpcLinkDef]] = pydantic.Field(None, description='The VpcLink used for the integration. Required if connectionType is VPC_LINK')
    _init_params: typing.ClassVar[list[str]] = ['handler', 'allow_test_invoke', 'proxy', 'cache_key_parameters', 'cache_namespace', 'connection_type', 'content_handling', 'credentials_passthrough', 'credentials_role', 'integration_responses', 'passthrough_behavior', 'request_parameters', 'request_templates', 'timeout', 'vpc_link']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.LambdaIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LambdaIntegrationDefConfig] = pydantic.Field(None)


class LambdaIntegrationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[LambdaIntegrationDefBindParams]] = pydantic.Field(None, description='Can be overridden by subclasses to allow the integration to interact with the method being integrated, access the REST API object, method ARNs, etc.')

class LambdaIntegrationDefBindParams(pydantic.BaseModel):
    method: models.aws_apigateway.MethodDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.LogGroupLogDestination
class LogGroupLogDestinationDef(BaseClass):
    log_group: typing.Union[models.aws_logs.LogGroupDef] = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['log_group']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.LogGroupLogDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LogGroupLogDestinationDefConfig] = pydantic.Field(None)


class LogGroupLogDestinationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[LogGroupLogDestinationDefBindParams]] = pydantic.Field(None, description='Binds this destination to the CloudWatch Logs.')

class LogGroupLogDestinationDefBindParams(pydantic.BaseModel):
    _stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.MockIntegration
class MockIntegrationDef(BaseClass):
    cache_key_parameters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of request parameters whose values are to be cached. It determines request parameters that will make it into the cache key.')
    cache_namespace: typing.Optional[str] = pydantic.Field(None, description='An API-specific tag group of related cached parameters.\n')
    connection_type: typing.Optional[aws_cdk.aws_apigateway.ConnectionType] = pydantic.Field(None, description='The type of network connection to the integration endpoint. Default: - ConnectionType.VPC_LINK if ``vpcLink`` property is configured; ConnectionType.Internet otherwise.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigateway.ContentHandling] = pydantic.Field(None, description="Specifies how to handle request payload content type conversions. Default: none if this property isn't defined, the request payload is passed through from the method request to the integration request without modification, provided that the ``passthroughBehaviors`` property is configured to support payload pass-through.\n")
    credentials_passthrough: typing.Optional[bool] = pydantic.Field(None, description="Requires that the caller's identity be passed through from the request. Default: Caller identity is not passed through\n")
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that API Gateway assumes. Mutually exclusive with ``credentialsPassThrough``. Default: A role is not assumed\n')
    integration_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.IntegrationResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The response that API Gateway provides after a method's backend completes processing a request. API Gateway intercepts the response from the backend so that you can control how API Gateway surfaces backend responses. For example, you can map the backend status codes to codes that you define.\n")
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigateway.PassthroughBehavior] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The request parameters that API Gateway sends with the backend request. Specify request parameters as key-value pairs (string-to-string mappings), with a destination as the key and a source as the value. Specify the destination by using the following pattern integration.request.location.name, where location is querystring, path, or header, and name is a valid, unique parameter name. The source must be an existing method request parameter or a static value. You must enclose static values in single quotation marks and pre-encode these values based on their destination in the request.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map of Apache Velocity templates that are applied on the request payload. The template that API Gateway uses is based on the value of the Content-Type header that\'s sent by the client. The content type value is the key, and the template is the value (specified as a string), such as the following snippet:: { "application/json": "{ \\"statusCode\\": 200 }" }\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n')
    vpc_link: typing.Optional[typing.Union[models.aws_apigateway.VpcLinkDef]] = pydantic.Field(None, description='The VpcLink used for the integration. Required if connectionType is VPC_LINK')
    _init_params: typing.ClassVar[list[str]] = ['cache_key_parameters', 'cache_namespace', 'connection_type', 'content_handling', 'credentials_passthrough', 'credentials_role', 'integration_responses', 'passthrough_behavior', 'request_parameters', 'request_templates', 'timeout', 'vpc_link']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.MockIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MockIntegrationDefConfig] = pydantic.Field(None)


class MockIntegrationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[MockIntegrationDefBindParams]] = pydantic.Field(None, description='Can be overridden by subclasses to allow the integration to interact with the method being integrated, access the REST API object, method ARNs, etc.')

class MockIntegrationDefBindParams(pydantic.BaseModel):
    _method: models.aws_apigateway.MethodDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.ResourceBase
class ResourceBaseDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['add_cors_preflight', 'add_method', 'add_proxy', 'add_resource', 'apply_removal_policy', 'get_resource', 'resource_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ResourceBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ResourceBaseDefConfig] = pydantic.Field(None)


class ResourceBaseDefConfig(pydantic.BaseModel):
    add_cors_preflight: typing.Optional[list[ResourceBaseDefAddCorsPreflightParams]] = pydantic.Field(None, description='Adds an OPTIONS method to this resource which responds to Cross-Origin Resource Sharing (CORS) preflight requests.\nCross-Origin Resource Sharing (CORS) is a mechanism that uses additional\nHTTP headers to tell browsers to give a web application running at one\norigin, access to selected resources from a different origin. A web\napplication executes a cross-origin HTTP request when it requests a\nresource that has a different origin (domain, protocol, or port) from its\nown.')
    add_method: typing.Optional[list[ResourceBaseDefAddMethodParams]] = pydantic.Field(None, description='Defines a new method for this resource.')
    add_proxy: typing.Optional[list[ResourceBaseDefAddProxyParams]] = pydantic.Field(None, description='Adds a greedy proxy resource ("{proxy+}") and an ANY method to this route.')
    add_resource: typing.Optional[list[ResourceBaseDefAddResourceParams]] = pydantic.Field(None, description='Defines a new child resource where this resource is the parent.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_resource: typing.Optional[list[ResourceBaseDefGetResourceParams]] = pydantic.Field(None, description='Retrieves a child resource by path part.')
    resource_for_path: typing.Optional[list[ResourceBaseDefResourceForPathParams]] = pydantic.Field(None, description='Gets or create all resources leading up to the specified path.\n- Path may only start with "/" if this method is called on the root resource.\n- All resources are created using default options.')
    api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)

class ResourceBaseDefAddCorsPreflightParams(pydantic.BaseModel):
    allow_origins: typing.Sequence[str] = pydantic.Field(..., description='Specifies the list of origins that are allowed to make requests to this resource. If you wish to allow all origins, specify ``Cors.ALL_ORIGINS`` or ``[ * ]``. Responses will include the ``Access-Control-Allow-Origin`` response header. If ``Cors.ALL_ORIGINS`` is specified, the ``Vary: Origin`` response header will also be included.\n')
    allow_credentials: typing.Optional[bool] = pydantic.Field(None, description='The Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request\'s credentials mode (Request.credentials) is "include". When a request\'s credentials mode (Request.credentials) is "include", browsers will only expose the response to frontend JavaScript code if the Access-Control-Allow-Credentials value is true. Credentials are cookies, authorization headers or TLS client certificates. Default: false\n')
    allow_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Allow-Headers response header is used in response to a preflight request which includes the Access-Control-Request-Headers to indicate which HTTP headers can be used during the actual request. Default: Cors.DEFAULT_HEADERS\n')
    allow_methods: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Allow-Methods response header specifies the method or methods allowed when accessing the resource in response to a preflight request. If ``ANY`` is specified, it will be expanded to ``Cors.ALL_METHODS``. Default: Cors.ALL_METHODS\n')
    disable_cache: typing.Optional[bool] = pydantic.Field(None, description='Sets Access-Control-Max-Age to -1, which means that caching is disabled. This option cannot be used with ``maxAge``. Default: - cache is enabled\n')
    expose_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Expose-Headers response header indicates which headers can be exposed as part of the response by listing their names. If you want clients to be able to access other headers, you have to list them using the Access-Control-Expose-Headers header. Default: - only the 6 CORS-safelisted response headers are exposed: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma\n')
    max_age: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The Access-Control-Max-Age response header indicates how long the results of a preflight request (that is the information contained in the Access-Control-Allow-Methods and Access-Control-Allow-Headers headers) can be cached. To disable caching altogether use ``disableCache: true``. Default: - browser-specific (see reference)\n')
    status_code: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the response status code returned from the OPTIONS method. Default: 204')
    return_config: typing.Optional[list[models.aws_apigateway.MethodDefConfig]] = pydantic.Field(None)
    ...

class ResourceBaseDefAddMethodParams(pydantic.BaseModel):
    http_method: str = pydantic.Field(..., description='-\n')
    integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='-\n')
    api_key_required: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the method requires clients to submit a valid API key. Default: false\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. Default: - no authorization scopes\n')
    authorization_type: typing.Optional[aws_cdk.aws_apigateway.AuthorizationType] = pydantic.Field(None, description="Method authorization. If the value is set of ``Custom``, an ``authorizer`` must also be specified. If you're using one of the authorizers that are available via the ``Authorizer`` class, such as ``Authorizer#token()``, it is recommended that this option not be specified. The authorizer will take care of setting the correct authorization type. However, specifying an authorization type using this property that conflicts with what is expected by the ``Authorizer`` will result in an error. Default: - open access unless ``authorizer`` is specified\n")
    authorizer: typing.Optional[typing.Union[models.aws_apigateway.AuthorizerDef, models.aws_apigateway.CognitoUserPoolsAuthorizerDef, models.aws_apigateway.CognitoUserPoolsAuthorizerDef, models.aws_apigateway.RequestAuthorizerDef, models.aws_apigateway.RequestAuthorizerDef, models.aws_apigateway.TokenAuthorizerDef, models.aws_apigateway.TokenAuthorizerDef]] = pydantic.Field(None, description='If ``authorizationType`` is ``Custom``, this specifies the ID of the method authorizer resource. If specified, the value of ``authorizationType`` must be set to ``Custom``\n')
    method_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.MethodResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The responses that can be sent to the client who calls the method. Default: None This property is not required, but if these are not supplied for a Lambda proxy integration, the Lambda function must return a value of the correct format, for the integration response to be correctly mapped to a response to the client.\n')
    operation_name: typing.Optional[str] = pydantic.Field(None, description='A friendly operation name for the method. For example, you can assign the OperationName of ListPets for the GET /pets method.\n')
    request_models: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.ModelDef]]] = pydantic.Field(None, description="The models which describe data structure of request payload. When combined with ``requestValidator`` or ``requestValidatorOptions``, the service will validate the API request payload before it reaches the API's Integration (including proxies). Specify ``requestModels`` as key-value pairs, with a content type (e.g. ``'application/json'``) as the key and an API Gateway Model as the value.\n")
    request_parameters: typing.Optional[typing.Mapping[str, bool]] = pydantic.Field(None, description='The request parameters that API Gateway accepts. Specify request parameters as key-value pairs (string-to-Boolean mapping), with a source as the key and a Boolean as the value. The Boolean specifies whether a parameter is required. A source must match the format method.request.location.name, where the location is querystring, path, or header, and name is a valid, unique parameter name. Default: None\n')
    request_validator: typing.Optional[typing.Union[models.aws_apigateway.RequestValidatorDef]] = pydantic.Field(None, description='The ID of the associated request validator. Only one of ``requestValidator`` or ``requestValidatorOptions`` must be specified. Works together with ``requestModels`` or ``requestParameters`` to validate the request before it reaches integration like Lambda Proxy Integration. Default: - No default validator\n')
    request_validator_options: typing.Union[models.aws_apigateway.RequestValidatorOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Request validator options to create new validator Only one of ``requestValidator`` or ``requestValidatorOptions`` must be specified. Works together with ``requestModels`` or ``requestParameters`` to validate the request before it reaches integration like Lambda Proxy Integration. Default: - No default validator')
    return_config: typing.Optional[list[models.aws_apigateway.MethodDefConfig]] = pydantic.Field(None)
    ...

class ResourceBaseDefAddProxyParams(pydantic.BaseModel):
    any_method: typing.Optional[bool] = pydantic.Field(None, description='Adds an "ANY" method to this resource. If set to ``false``, you will have to explicitly add methods to this resource after it\'s created. Default: true\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models.aws_apigateway.ProxyResourceDefConfig]] = pydantic.Field(None)
    ...

class ResourceBaseDefAddResourceParams(pydantic.BaseModel):
    path_part: str = pydantic.Field(..., description='-\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models.aws_apigateway.ResourceDefConfig]] = pydantic.Field(None)
    ...

class ResourceBaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ResourceBaseDefGetResourceParams(pydantic.BaseModel):
    path_part: str = pydantic.Field(..., description='-')
    ...

class ResourceBaseDefResourceForPathParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigateway.ResourceDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.ResponseType
class ResponseTypeDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ResponseType'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ResponseTypeDefConfig] = pydantic.Field(None)


class ResponseTypeDefConfig(pydantic.BaseModel):
    of: typing.Optional[list[ResponseTypeDefOfParams]] = pydantic.Field(None, description='A custom response type to support future cases.')

class ResponseTypeDefOfParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigateway.ResponseTypeDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.RestApiBase
class RestApiBaseDef(BaseClass):
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments']
    _method_names: typing.ClassVar[list[str]] = ['add_api_key', 'add_domain_name', 'add_gateway_response', 'add_usage_plan', 'apply_removal_policy', 'arn_for_execute_api', 'metric', 'metric_cache_hit_count', 'metric_cache_miss_count', 'metric_client_error', 'metric_count', 'metric_integration_latency', 'metric_latency', 'metric_server_error', 'url_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RestApiBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RestApiBaseDefConfig] = pydantic.Field(None)


class RestApiBaseDefConfig(pydantic.BaseModel):
    add_api_key: typing.Optional[list[RestApiBaseDefAddApiKeyParams]] = pydantic.Field(None, description='Add an ApiKey to the deploymentStage.')
    add_domain_name: typing.Optional[list[RestApiBaseDefAddDomainNameParams]] = pydantic.Field(None, description='Defines an API Gateway domain name and maps it to this API.')
    add_gateway_response: typing.Optional[list[RestApiBaseDefAddGatewayResponseParams]] = pydantic.Field(None, description='Adds a new gateway response.')
    add_usage_plan: typing.Optional[list[RestApiBaseDefAddUsagePlanParams]] = pydantic.Field(None, description='Adds a usage plan.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    arn_for_execute_api: typing.Optional[list[RestApiBaseDefArnForExecuteApiParams]] = pydantic.Field(None, description='Gets the "execute-api" ARN.')
    metric: typing.Optional[list[RestApiBaseDefMetricParams]] = pydantic.Field(None, description='Returns the given named metric for this API.')
    metric_cache_hit_count: typing.Optional[list[RestApiBaseDefMetricCacheHitCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the API cache in a given period.\nDefault: sum over 5 minutes')
    metric_cache_miss_count: typing.Optional[list[RestApiBaseDefMetricCacheMissCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the backend in a given period, when API caching is enabled.\nDefault: sum over 5 minutes')
    metric_client_error: typing.Optional[list[RestApiBaseDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.\nDefault: sum over 5 minutes')
    metric_count: typing.Optional[list[RestApiBaseDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.\nDefault: sample count over 5 minutes')
    metric_integration_latency: typing.Optional[list[RestApiBaseDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.\nDefault: average over 5 minutes.')
    metric_latency: typing.Optional[list[RestApiBaseDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.\n\nDefault: average over 5 minutes.')
    metric_server_error: typing.Optional[list[RestApiBaseDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.\nDefault: sum over 5 minutes')
    url_for_path: typing.Optional[list[RestApiBaseDefUrlForPathParams]] = pydantic.Field(None, description='Returns the URL for an HTTP path.\nFails if ``deploymentStage`` is not set either by ``deploy`` or explicitly.')
    root_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)

class RestApiBaseDefAddApiKeyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models._interface_methods.AwsApigatewayIApiKeyDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefAddDomainNameParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The construct id.\n')
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The reference to an AWS-managed certificate for use by the edge-optimized endpoint for the domain name. For "EDGE" domain names, the certificate needs to be in the US East (N. Virginia) region.\n')
    domain_name: str = pydantic.Field(..., description='The custom domain name for your API. Uppercase letters are not supported.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``).\n")
    endpoint_type: typing.Optional[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: REGIONAL\n')
    mtls: typing.Union[models.aws_apigateway.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    security_policy: typing.Optional[aws_cdk.aws_apigateway.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2')
    return_config: typing.Optional[list[models.aws_apigateway.DomainNameDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefAddGatewayResponseParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    type: models.aws_apigateway.ResponseTypeDef = pydantic.Field(..., description='Response type to associate with gateway response.\n')
    response_headers: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom headers parameters for response. Default: - no headers\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='Http status code for response. Default: - standard http status code for the response type.\n')
    templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom templates to get mapped as response. Default: - Response from api will be returned without applying any transformation.')
    return_config: typing.Optional[list[models.aws_apigateway.GatewayResponseDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefAddUsagePlanParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the usage plan. Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Represents usage plan purpose. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='Name for this usage plan. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none')
    return_config: typing.Optional[list[models.aws_apigateway.UsagePlanDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class RestApiBaseDefArnForExecuteApiParams(pydantic.BaseModel):
    method: typing.Optional[str] = pydantic.Field(None, description='-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='-\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class RestApiBaseDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefMetricCacheHitCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefMetricCacheMissCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiBaseDefUrlForPathParams(pydantic.BaseModel):
    path: typing.Optional[str] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.S3ApiDefinition
class S3ApiDefinitionDef(BaseClass):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='-')
    key: str = pydantic.Field(..., description='-\n')
    object_version: typing.Optional[str] = pydantic.Field(None, description='-')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'key', 'object_version']
    _method_names: typing.ClassVar[list[str]] = ['bind', 'bind_after_create']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_asset', 'from_bucket', 'from_inline']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.S3ApiDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[S3ApiDefinitionDefConfig] = pydantic.Field(None)


class S3ApiDefinitionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[S3ApiDefinitionDefBindParams]] = pydantic.Field(None, description='Called when the specification is initialized to allow this object to bind to the stack, add resources and have fun.')
    bind_after_create: typing.Optional[list[S3ApiDefinitionDefBindAfterCreateParams]] = pydantic.Field(None, description="Called after the CFN RestApi resource has been created to allow the Api Definition to bind to it.\nSpecifically it's required to allow assets to add\nmetadata for tooling like SAM CLI to be able to find their origins.")
    from_asset: typing.Optional[list[S3ApiDefinitionDefFromAssetParams]] = pydantic.Field(None, description='Loads the API specification from a local disk asset.')
    from_bucket: typing.Optional[list[S3ApiDefinitionDefFromBucketParams]] = pydantic.Field(None, description='Creates an API definition from a specification file in an S3 bucket.')
    from_inline: typing.Optional[list[S3ApiDefinitionDefFromInlineParams]] = pydantic.Field(None, description='Create an API definition from an inline object.\nThe inline object must follow the\nschema of OpenAPI 2.0 or OpenAPI 3.0')

class S3ApiDefinitionDefBindParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class S3ApiDefinitionDefBindAfterCreateParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    _rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='-')
    ...

class S3ApiDefinitionDefFromAssetParams(pydantic.BaseModel):
    file: str = pydantic.Field(..., description='-\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    return_config: typing.Optional[list[models.aws_apigateway.AssetApiDefinitionDefConfig]] = pydantic.Field(None)
    ...

class S3ApiDefinitionDefFromBucketParams(pydantic.BaseModel):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='-\n')
    key: str = pydantic.Field(..., description='-\n')
    object_version: typing.Optional[str] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_apigateway.S3ApiDefinitionDefConfig]] = pydantic.Field(None)
    ...

class S3ApiDefinitionDefFromInlineParams(pydantic.BaseModel):
    definition: typing.Any = pydantic.Field(..., description='-\n\nExample::\n\n    apigateway.ApiDefinition.from_inline({\n        "openapi": "3.0.2",\n        "paths": {\n            "/pets": {\n                "get": {\n                    "responses": {\n                        "200": {\n                            "content": {\n                                "application/json": {\n                                    "schema": {\n                                        "$ref": "#/components/schemas/Empty"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    "x-amazon-apigateway-integration": {\n                        "responses": {\n                            "default": {\n                                "status_code": "200"\n                            }\n                        },\n                        "request_templates": {\n                            "application/json": "{"statusCode": 200}"\n                        },\n                        "passthrough_behavior": "when_no_match",\n                        "type": "mock"\n                    }\n                }\n            }\n        },\n        "components": {\n            "schemas": {\n                "Empty": {\n                    "title": "Empty Schema",\n                    "type": "object"\n                }\n            }\n        }\n    })\n')
    return_config: typing.Optional[list[models.aws_apigateway.InlineApiDefinitionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.StageBase
class StageBaseDef(BaseClass):
    account: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to\n')
    environment_from_arn: typing.Optional[str] = pydantic.Field(None, description='ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.\n')
    physical_name: typing.Optional[str] = pydantic.Field(None, description='The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to')
    _init_params: typing.ClassVar[list[str]] = ['account', 'environment_from_arn', 'physical_name', 'region']
    _method_names: typing.ClassVar[list[str]] = ['add_api_key', 'apply_removal_policy', 'metric', 'metric_cache_hit_count', 'metric_cache_miss_count', 'metric_client_error', 'metric_count', 'metric_integration_latency', 'metric_latency', 'metric_server_error', 'url_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.StageBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[StageBaseDefConfig] = pydantic.Field(None)


class StageBaseDefConfig(pydantic.BaseModel):
    add_api_key: typing.Optional[list[StageBaseDefAddApiKeyParams]] = pydantic.Field(None, description='Add an ApiKey to this stage.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    metric: typing.Optional[list[StageBaseDefMetricParams]] = pydantic.Field(None, description='Returns the given named metric for this stage.')
    metric_cache_hit_count: typing.Optional[list[StageBaseDefMetricCacheHitCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the API cache in a given period.')
    metric_cache_miss_count: typing.Optional[list[StageBaseDefMetricCacheMissCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the backend in a given period, when API caching is enabled.')
    metric_client_error: typing.Optional[list[StageBaseDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.')
    metric_count: typing.Optional[list[StageBaseDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.')
    metric_integration_latency: typing.Optional[list[StageBaseDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.')
    metric_latency: typing.Optional[list[StageBaseDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.')
    metric_server_error: typing.Optional[list[StageBaseDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.')
    url_for_path: typing.Optional[list[StageBaseDefUrlForPathParams]] = pydantic.Field(None, description='Returns the invoke URL for a certain path.')
    rest_api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)

class StageBaseDefAddApiKeyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models._interface_methods.AwsApigatewayIApiKeyDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class StageBaseDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefMetricCacheHitCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefMetricCacheMissCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sample count over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - average over 5 minutes.\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - average over 5 minutes.\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageBaseDefUrlForPathParams(pydantic.BaseModel):
    path: typing.Optional[str] = pydantic.Field(None, description='The resource path.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.StepFunctionsIntegration
class StepFunctionsIntegrationDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['start_execution']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.StepFunctionsIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[StepFunctionsIntegrationDefConfig] = pydantic.Field(None)


class StepFunctionsIntegrationDefConfig(pydantic.BaseModel):
    start_execution: typing.Optional[list[StepFunctionsIntegrationDefStartExecutionParams]] = pydantic.Field(None, description='Integrates a Synchronous Express State Machine from AWS Step Functions to an API Gateway method.')

class StepFunctionsIntegrationDefStartExecutionParams(pydantic.BaseModel):
    state_machine: typing.Union[models.aws_stepfunctions.StateMachineDef] = pydantic.Field(..., description='-\n')
    authorizer: typing.Optional[bool] = pydantic.Field(None, description='If the whole authorizer object, including custom context values should be in the execution input. The execution input will include a new key ``authorizer``: { "body": {}, "authorizer": { "key": "value" } } Default: false\n')
    headers: typing.Optional[bool] = pydantic.Field(None, description='Check if header is to be included inside the execution input. The execution input will include a new key ``headers``: { "body": {}, "headers": { "header1": "value", "header2": "value" } } Default: false\n')
    path: typing.Optional[bool] = pydantic.Field(None, description='Check if path is to be included inside the execution input. The execution input will include a new key ``path``: { "body": {}, "path": { "resourceName": "resourceValue" } } Default: true\n')
    querystring: typing.Optional[bool] = pydantic.Field(None, description='Check if querystring is to be included inside the execution input. The execution input will include a new key ``queryString``: { "body": {}, "querystring": { "key": "value" } } Default: true\n')
    request_context: typing.Union[models.aws_apigateway.RequestContextDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which details of the incoming request must be passed onto the underlying state machine, such as, account id, user identity, request id, etc. The execution input will include a new key ``requestContext``: { "body": {}, "requestContext": { "key": "value" } } Default: - all parameters within request context will be set as false\n')
    cache_key_parameters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of request parameters whose values are to be cached. It determines request parameters that will make it into the cache key.\n')
    cache_namespace: typing.Optional[str] = pydantic.Field(None, description='An API-specific tag group of related cached parameters.\n')
    connection_type: typing.Optional[aws_cdk.aws_apigateway.ConnectionType] = pydantic.Field(None, description='The type of network connection to the integration endpoint. Default: - ConnectionType.VPC_LINK if ``vpcLink`` property is configured; ConnectionType.Internet otherwise.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigateway.ContentHandling] = pydantic.Field(None, description="Specifies how to handle request payload content type conversions. Default: none if this property isn't defined, the request payload is passed through from the method request to the integration request without modification, provided that the ``passthroughBehaviors`` property is configured to support payload pass-through.\n")
    credentials_passthrough: typing.Optional[bool] = pydantic.Field(None, description="Requires that the caller's identity be passed through from the request. Default: Caller identity is not passed through\n")
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that API Gateway assumes. Mutually exclusive with ``credentialsPassThrough``. Default: A role is not assumed\n')
    integration_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.IntegrationResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The response that API Gateway provides after a method's backend completes processing a request. API Gateway intercepts the response from the backend so that you can control how API Gateway surfaces backend responses. For example, you can map the backend status codes to codes that you define.\n")
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigateway.PassthroughBehavior] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The request parameters that API Gateway sends with the backend request. Specify request parameters as key-value pairs (string-to-string mappings), with a destination as the key and a source as the value. Specify the destination by using the following pattern integration.request.location.name, where location is querystring, path, or header, and name is a valid, unique parameter name. The source must be an existing method request parameter or a static value. You must enclose static values in single quotation marks and pre-encode these values based on their destination in the request.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map of Apache Velocity templates that are applied on the request payload. The template that API Gateway uses is based on the value of the Content-Type header that\'s sent by the client. The content type value is the key, and the template is the value (specified as a string), such as the following snippet:: { "application/json": "{ \\"statusCode\\": 200 }" }\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n')
    vpc_link: typing.Optional[typing.Union[models.aws_apigateway.VpcLinkDef]] = pydantic.Field(None, description='The VpcLink used for the integration. Required if connectionType is VPC_LINK\n\nExample::\n\n    state_machine = stepfunctions.StateMachine(self, "MyStateMachine",\n        state_machine_type=stepfunctions.StateMachineType.EXPRESS,\n        definition=stepfunctions.Chain.start(stepfunctions.Pass(self, "Pass"))\n    )\n\n    api = apigateway.RestApi(self, "Api",\n        rest_api_name="MyApi"\n    )\n    api.root.add_method("GET", apigateway.StepFunctionsIntegration.start_execution(state_machine))\n')
    return_config: typing.Optional[list[models.aws_apigateway.AwsIntegrationDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.ApiKey
class ApiKeyDef(BaseConstruct):
    customer_id: typing.Optional[str] = pydantic.Field(None, description='An AWS Marketplace customer identifier to use when integrating with the AWS SaaS Marketplace. Default: none\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the API key can be used by clients. Default: true\n')
    generate_distinct_id: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the key identifier is distinct from the created API key value. Default: false\n')
    resources: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]]] = pydantic.Field(None, description='(deprecated) A list of resources this api key is associated with. Default: none\n')
    stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef]]] = pydantic.Field(None, description='A list of Stages this api key is associated with. Default: - the api key is not associated with any stages\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    _init_params: typing.ClassVar[list[str]] = ['customer_id', 'enabled', 'generate_distinct_id', 'resources', 'stages', 'api_key_name', 'description', 'value', 'default_cors_preflight_options', 'default_integration', 'default_method_options']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'grant_read', 'grant_read_write', 'grant_write']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_api_key_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ApiKey'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_api_key_id']
    ...


    from_api_key_id: typing.Optional[ApiKeyDefFromApiKeyIdParams] = pydantic.Field(None, description='Import an ApiKey by its Id.')
    resource_config: typing.Optional[ApiKeyDefConfig] = pydantic.Field(None)


class ApiKeyDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_read: typing.Optional[list[ApiKeyDefGrantReadParams]] = pydantic.Field(None, description='Permits the IAM principal all read operations through this key.')
    grant_read_write: typing.Optional[list[ApiKeyDefGrantReadWriteParams]] = pydantic.Field(None, description='Permits the IAM principal all read and write operations through this key.')
    grant_write: typing.Optional[list[ApiKeyDefGrantWriteParams]] = pydantic.Field(None, description='Permits the IAM principal all write operations through this key.')

class ApiKeyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ApiKeyDefFromApiKeyIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    api_key_id: str = pydantic.Field(..., description='-')
    ...

class ApiKeyDefGrantReadParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal to grant access to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class ApiKeyDefGrantReadWriteParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal to grant access to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class ApiKeyDefGrantWriteParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal to grant access to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.BasePathMapping
class BasePathMappingDef(BaseConstruct):
    domain_name: typing.Union[models.aws_apigateway.DomainNameDef] = pydantic.Field(..., description='The DomainName to associate with this base path mapping.\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The RestApi resource to target.\n')
    attach_to_stage: typing.Optional[bool] = pydantic.Field(None, description='Whether to attach the base path mapping to a stage. Use this property to create a base path mapping without attaching it to the Rest API default stage. This property is ignored if ``stage`` is provided. Default: - true\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``). If this is undefined, no additional mappings will be allowed on this domain name.\n")
    stage: typing.Optional[models.aws_apigateway.StageDef] = pydantic.Field(None, description='The Deployment stage of API [disable-awslint:ref-via-interface]. Default: - map to deploymentStage of restApi otherwise stage needs to pass in URL')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'rest_api', 'attach_to_stage', 'base_path', 'stage']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.BasePathMapping'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[BasePathMappingDefConfig] = pydantic.Field(None)


class BasePathMappingDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class BasePathMappingDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CognitoUserPoolsAuthorizer
class CognitoUserPoolsAuthorizerDef(BaseConstruct):
    cognito_user_pools: typing.Sequence[typing.Union[models.aws_cognito.UserPoolDef]] = pydantic.Field(..., description='The user pools to associate with this authorizer.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='An optional human friendly name for the authorizer. Note that, this is not the primary identifier of the authorizer. Default: - the unique construct ID\n')
    identity_source: typing.Optional[str] = pydantic.Field(None, description="The request header mapping expression for the bearer token. This is typically passed as part of the header, in which case this should be ``method.request.header.Authorizer`` where Authorizer is the header containing the bearer token. Default: ``IdentitySource.header('Authorization')``\n")
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to 0. Default: Duration.minutes(5)')
    _init_params: typing.ClassVar[list[str]] = ['cognito_user_pools', 'authorizer_name', 'identity_source', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CognitoUserPoolsAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CognitoUserPoolsAuthorizerDefConfig] = pydantic.Field(None)


class CognitoUserPoolsAuthorizerDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class CognitoUserPoolsAuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.Deployment
class DeploymentDef(BaseConstruct):
    api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The Rest API to deploy.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API Gateway deployment. Default: - No description.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='When an API Gateway model is updated, a new deployment will automatically be created. If this is true, the old API Gateway Deployment resource will not be deleted. This will allow manually reverting back to a previous deployment in case for example Default: false')
    _init_params: typing.ClassVar[list[str]] = ['api', 'description', 'retain_deployments']
    _method_names: typing.ClassVar[list[str]] = ['add_to_logical_id', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.Deployment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[DeploymentDefConfig] = pydantic.Field(None)


class DeploymentDefConfig(pydantic.BaseModel):
    add_to_logical_id: typing.Optional[list[DeploymentDefAddToLogicalIdParams]] = pydantic.Field(None, description="Adds a component to the hash that determines this Deployment resource's logical ID.\nThis should be called by constructs of the API Gateway model that want to\ninvalidate the deployment when their settings change. The component will\nbe resolve()ed during synthesis so tokens are welcome.")
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class DeploymentDefAddToLogicalIdParams(pydantic.BaseModel):
    data: typing.Any = pydantic.Field(..., description='-')
    ...

class DeploymentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.DomainName
class DomainNameDef(BaseConstruct):
    mapping: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='If specified, all requests to this domain will be mapped to the production deployment of this API. If you wish to map this domain to multiple APIs with different base paths, use ``addBasePathMapping`` or ``addApiMapping``. Default: - you will have to call ``addBasePathMapping`` to map this domain to API endpoints.\n')
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The reference to an AWS-managed certificate for use by the edge-optimized endpoint for the domain name. For "EDGE" domain names, the certificate needs to be in the US East (N. Virginia) region.\n')
    domain_name: str = pydantic.Field(..., description='The custom domain name for your API. Uppercase letters are not supported.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``).\n")
    endpoint_type: typing.Optional[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: REGIONAL\n')
    mtls: typing.Union[models.aws_apigateway.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    security_policy: typing.Optional[aws_cdk.aws_apigateway.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2')
    _init_params: typing.ClassVar[list[str]] = ['mapping', 'certificate', 'domain_name', 'base_path', 'endpoint_type', 'mtls', 'security_policy']
    _method_names: typing.ClassVar[list[str]] = ['add_api_mapping', 'add_base_path_mapping', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_domain_name_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.DomainName'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_domain_name_attributes']
    ...


    from_domain_name_attributes: typing.Optional[DomainNameDefFromDomainNameAttributesParams] = pydantic.Field(None, description='Imports an existing domain name.')
    resource_config: typing.Optional[DomainNameDefConfig] = pydantic.Field(None)


class DomainNameDefConfig(pydantic.BaseModel):
    add_api_mapping: typing.Optional[list[DomainNameDefAddApiMappingParams]] = pydantic.Field(None, description='Maps this domain to an API endpoint.\nThis uses the ApiMapping from ApiGatewayV2 which supports multi-level paths, but\nalso only supports:\n\n- SecurityPolicy.TLS_1_2\n- EndpointType.REGIONAL')
    add_base_path_mapping: typing.Optional[list[DomainNameDefAddBasePathMappingParams]] = pydantic.Field(None, description='Maps this domain to an API endpoint.\nThis uses the BasePathMapping from ApiGateway v1 which does not support multi-level paths.\n\nIf you need to create a mapping for a multi-level path use ``addApiMapping`` instead.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class DomainNameDefAddApiMappingParams(pydantic.BaseModel):
    target_stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='the target API stage.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The api path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. If this is undefined, a mapping will be added for the empty path. Any request that does not match a mapping will get sent to the API that has been mapped to the empty path. Default: - map requests from the domain root (e.g. ``example.com``).")
    ...

class DomainNameDefAddBasePathMappingParams(pydantic.BaseModel):
    target_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='That target API endpoint, requests will be mapped to the deployment stage.\n')
    attach_to_stage: typing.Optional[bool] = pydantic.Field(None, description='Whether to attach the base path mapping to a stage. Use this property to create a base path mapping without attaching it to the Rest API default stage. This property is ignored if ``stage`` is provided. Default: - true\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``). If this is undefined, no additional mappings will be allowed on this domain name.\n")
    stage: typing.Optional[models.aws_apigateway.StageDef] = pydantic.Field(None, description='The Deployment stage of API [disable-awslint:ref-via-interface]. Default: - map to deploymentStage of restApi otherwise stage needs to pass in URL')
    return_config: typing.Optional[list[models.aws_apigateway.BasePathMappingDefConfig]] = pydantic.Field(None)
    ...

class DomainNameDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class DomainNameDefFromDomainNameAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    domain_name: str = pydantic.Field(..., description='The domain name (e.g. ``example.com``).\n')
    domain_name_alias_hosted_zone_id: str = pydantic.Field(..., description='The Route53 hosted zone ID to use in order to connect a record set to this domain through an alias.\n')
    domain_name_alias_target: str = pydantic.Field(..., description='The Route53 alias target to use in order to connect a record set to this domain through an alias.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.GatewayResponse
class GatewayResponseDef(BaseConstruct):
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='Rest api resource to target.\n')
    type: models.aws_apigateway.ResponseTypeDef = pydantic.Field(..., description='Response type to associate with gateway response.\n')
    response_headers: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom headers parameters for response. Default: - no headers\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='Http status code for response. Default: - standard http status code for the response type.\n')
    templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom templates to get mapped as response. Default: - Response from api will be returned without applying any transformation.')
    _init_params: typing.ClassVar[list[str]] = ['rest_api', 'type', 'response_headers', 'status_code', 'templates']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.GatewayResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[GatewayResponseDefConfig] = pydantic.Field(None)


class GatewayResponseDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class GatewayResponseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.LambdaRestApi
class LambdaRestApiDef(BaseConstruct):
    handler: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description='The default Lambda function that handles all requests from this API. This handler will be used as a the default integration for all methods in this API, unless specified otherwise in ``addMethod``.\n')
    integration_options: typing.Union[models.aws_apigateway.LambdaIntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specific Lambda integration options. Default: see defaults defined in ``LambdaIntegrationOptions``.\n')
    proxy: typing.Optional[bool] = pydantic.Field(None, description='If true, route all requests to the Lambda Function. If set to false, you will need to explicitly define the API model using ``addResource`` and ``addMethod`` (or ``addProxy``). Default: true\n')
    api_key_source_type: typing.Optional[aws_cdk.aws_apigateway.ApiKeySourceType] = pydantic.Field(None, description='The source of the API key for metering requests according to a usage plan. Default: - Metering is disabled.\n')
    binary_media_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of binary media mime-types that are supported by the RestApi resource, such as "image/png" or "application/octet-stream". Default: - RestApi supports only UTF-8-encoded text payloads.\n')
    clone_from: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='The ID of the API Gateway RestApi resource that you want to clone. Default: - None.\n')
    endpoint_configuration: typing.Union[models.aws_apigateway.EndpointConfigurationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The EndpointConfiguration property type specifies the endpoint types of a REST API. Default: EndpointType.EDGE\n')
    min_compression_size: typing.Optional[models.SizeDef] = pydantic.Field(None, description='A Size(in bytes, kibibytes, mebibytes etc) that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    minimum_compression_size: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['handler', 'integration_options', 'proxy', 'api_key_source_type', 'binary_media_types', 'clone_from', 'endpoint_configuration', 'min_compression_size', 'minimum_compression_size', 'default_cors_preflight_options', 'default_integration', 'default_method_options', 'cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments']
    _method_names: typing.ClassVar[list[str]] = ['add_api_key', 'add_domain_name', 'add_gateway_response', 'add_model', 'add_request_validator', 'add_usage_plan', 'apply_removal_policy', 'arn_for_execute_api', 'metric', 'metric_cache_hit_count', 'metric_cache_miss_count', 'metric_client_error', 'metric_count', 'metric_integration_latency', 'metric_latency', 'metric_server_error', 'url_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_rest_api_attributes', 'from_rest_api_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.LambdaRestApi'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_rest_api_attributes', 'from_rest_api_id']
    ...


    from_rest_api_attributes: typing.Optional[LambdaRestApiDefFromRestApiAttributesParams] = pydantic.Field(None, description='Import an existing RestApi that can be configured with additional Methods and Resources.')
    from_rest_api_id: typing.Optional[LambdaRestApiDefFromRestApiIdParams] = pydantic.Field(None, description='Import an existing RestApi.')
    resource_config: typing.Optional[LambdaRestApiDefConfig] = pydantic.Field(None)


class LambdaRestApiDefConfig(pydantic.BaseModel):
    add_api_key: typing.Optional[list[LambdaRestApiDefAddApiKeyParams]] = pydantic.Field(None, description='Add an ApiKey to the deploymentStage.')
    add_domain_name: typing.Optional[list[LambdaRestApiDefAddDomainNameParams]] = pydantic.Field(None, description='Defines an API Gateway domain name and maps it to this API.')
    add_gateway_response: typing.Optional[list[LambdaRestApiDefAddGatewayResponseParams]] = pydantic.Field(None, description='Adds a new gateway response.')
    add_model: typing.Optional[list[LambdaRestApiDefAddModelParams]] = pydantic.Field(None, description='Adds a new model.')
    add_request_validator: typing.Optional[list[LambdaRestApiDefAddRequestValidatorParams]] = pydantic.Field(None, description='Adds a new request validator.')
    add_usage_plan: typing.Optional[list[LambdaRestApiDefAddUsagePlanParams]] = pydantic.Field(None, description='Adds a usage plan.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    arn_for_execute_api: typing.Optional[list[LambdaRestApiDefArnForExecuteApiParams]] = pydantic.Field(None, description='Gets the "execute-api" ARN.')
    metric: typing.Optional[list[LambdaRestApiDefMetricParams]] = pydantic.Field(None, description='Returns the given named metric for this API.')
    metric_cache_hit_count: typing.Optional[list[LambdaRestApiDefMetricCacheHitCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the API cache in a given period.\nDefault: sum over 5 minutes')
    metric_cache_miss_count: typing.Optional[list[LambdaRestApiDefMetricCacheMissCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the backend in a given period, when API caching is enabled.\nDefault: sum over 5 minutes')
    metric_client_error: typing.Optional[list[LambdaRestApiDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.\nDefault: sum over 5 minutes')
    metric_count: typing.Optional[list[LambdaRestApiDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.\nDefault: sample count over 5 minutes')
    metric_integration_latency: typing.Optional[list[LambdaRestApiDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.\nDefault: average over 5 minutes.')
    metric_latency: typing.Optional[list[LambdaRestApiDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.\n\nDefault: average over 5 minutes.')
    metric_server_error: typing.Optional[list[LambdaRestApiDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.\nDefault: sum over 5 minutes')
    url_for_path: typing.Optional[list[LambdaRestApiDefUrlForPathParams]] = pydantic.Field(None, description='Returns the URL for an HTTP path.\nFails if ``deploymentStage`` is not set either by ``deploy`` or explicitly.')
    root_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)

class LambdaRestApiDefAddApiKeyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models._interface_methods.AwsApigatewayIApiKeyDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefAddDomainNameParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The construct id.\n')
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The reference to an AWS-managed certificate for use by the edge-optimized endpoint for the domain name. For "EDGE" domain names, the certificate needs to be in the US East (N. Virginia) region.\n')
    domain_name: str = pydantic.Field(..., description='The custom domain name for your API. Uppercase letters are not supported.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``).\n")
    endpoint_type: typing.Optional[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: REGIONAL\n')
    mtls: typing.Union[models.aws_apigateway.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    security_policy: typing.Optional[aws_cdk.aws_apigateway.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2')
    return_config: typing.Optional[list[models.aws_apigateway.DomainNameDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefAddGatewayResponseParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    type: models.aws_apigateway.ResponseTypeDef = pydantic.Field(..., description='Response type to associate with gateway response.\n')
    response_headers: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom headers parameters for response. Default: - no headers\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='Http status code for response. Default: - standard http status code for the response type.\n')
    templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom templates to get mapped as response. Default: - Response from api will be returned without applying any transformation.')
    return_config: typing.Optional[list[models.aws_apigateway.GatewayResponseDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefAddModelParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    schema_: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]] = pydantic.Field(..., description="The schema to use to transform data to one or more output formats. Specify null ({}) if you don't want to specify a schema.\n", alias='schema')
    content_type: typing.Optional[str] = pydantic.Field(None, description="The content type for the model. You can also force a content type in the request or response model mapping. Default: 'application/json'\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description that identifies this model. Default: None\n')
    model_name: typing.Optional[str] = pydantic.Field(None, description="A name for the model. Important If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. Default: If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the model name. For more information, see Name Type.")
    return_config: typing.Optional[list[models.aws_apigateway.ModelDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefAddRequestValidatorParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    request_validator_name: typing.Optional[str] = pydantic.Field(None, description='The name of this request validator. Default: None\n')
    validate_request_body: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate the request body according to the configured schema for the targeted API and method. Default: false\n')
    validate_request_parameters: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate request parameters. Default: false')
    return_config: typing.Optional[list[models.aws_apigateway.RequestValidatorDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefAddUsagePlanParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the usage plan. Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Represents usage plan purpose. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='Name for this usage plan. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none')
    return_config: typing.Optional[list[models.aws_apigateway.UsagePlanDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class LambdaRestApiDefArnForExecuteApiParams(pydantic.BaseModel):
    method: typing.Optional[str] = pydantic.Field(None, description='-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='-\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class LambdaRestApiDefFromRestApiAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    rest_api_id: str = pydantic.Field(..., description='The ID of the API Gateway RestApi.\n')
    root_resource_id: str = pydantic.Field(..., description='The resource ID of the root resource.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='The name of the API Gateway RestApi. Default: - ID of the RestApi construct.')
    ...

class LambdaRestApiDefFromRestApiIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    rest_api_id: str = pydantic.Field(..., description='-')
    ...

class LambdaRestApiDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefMetricCacheHitCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefMetricCacheMissCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class LambdaRestApiDefUrlForPathParams(pydantic.BaseModel):
    path: typing.Optional[str] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.Method
class MethodDef(BaseConstruct):
    http_method: str = pydantic.Field(..., description='The HTTP method ("GET", "POST", "PUT", ...) that clients use to call this method.\n')
    resource: typing.Union[models.aws_apigateway.ResourceBaseDef, models.aws_apigateway.ProxyResourceDef, models.aws_apigateway.ResourceDef] = pydantic.Field(..., description='The resource this method is associated with. For root resource methods, specify the ``RestApi`` object.\n')
    integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='The backend system that the method calls when it receives a request. Default: - a new ``MockIntegration``.\n')
    options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options. Default: - No options.')
    _init_params: typing.ClassVar[list[str]] = ['http_method', 'resource', 'integration', 'options']
    _method_names: typing.ClassVar[list[str]] = ['add_method_response', 'apply_removal_policy', 'grant_execute', 'metric', 'metric_cache_hit_count', 'metric_cache_miss_count', 'metric_client_error', 'metric_count', 'metric_integration_latency', 'metric_latency', 'metric_server_error']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.Method'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MethodDefConfig] = pydantic.Field(None)


class MethodDefConfig(pydantic.BaseModel):
    add_method_response: typing.Optional[list[MethodDefAddMethodResponseParams]] = pydantic.Field(None, description='Add a method response to this method.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_execute: typing.Optional[list[MethodDefGrantExecuteParams]] = pydantic.Field(None, description='Grants an IAM principal permission to invoke this method.')
    metric: typing.Optional[list[MethodDefMetricParams]] = pydantic.Field(None, description='Returns the given named metric for this API method.')
    metric_cache_hit_count: typing.Optional[list[MethodDefMetricCacheHitCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the API cache in a given period.')
    metric_cache_miss_count: typing.Optional[list[MethodDefMetricCacheMissCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the backend in a given period, when API caching is enabled.')
    metric_client_error: typing.Optional[list[MethodDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.')
    metric_count: typing.Optional[list[MethodDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.')
    metric_integration_latency: typing.Optional[list[MethodDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.')
    metric_latency: typing.Optional[list[MethodDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.')
    metric_server_error: typing.Optional[list[MethodDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.')
    api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)
    resource_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)

class MethodDefAddMethodResponseParams(pydantic.BaseModel):
    status_code: str = pydantic.Field(..., description="The method response's status code, which you map to an IntegrationResponse. Required.\n")
    response_models: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.ModelDef]]] = pydantic.Field(None, description="The resources used for the response's content type. Specify response models as key-value pairs (string-to-string maps), with a content type as the key and a Model resource name as the value. Default: None\n")
    response_parameters: typing.Optional[typing.Mapping[str, bool]] = pydantic.Field(None, description='Response parameters that API Gateway sends to the client that called a method. Specify response parameters as key-value pairs (string-to-Boolean maps), with a destination as the key and a Boolean as the value. Specify the destination using the following pattern: method.response.header.name, where the name is a valid, unique header name. The Boolean specifies whether a parameter is required. Default: None')
    ...

class MethodDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class MethodDefGrantExecuteParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='the principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class MethodDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class MethodDefMetricCacheHitCountParams(pydantic.BaseModel):
    stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class MethodDefMetricCacheMissCountParams(pydantic.BaseModel):
    stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class MethodDefMetricClientErrorParams(pydantic.BaseModel):
    stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class MethodDefMetricCountParams(pydantic.BaseModel):
    stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sample count over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class MethodDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - average over 5 minutes.\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class MethodDefMetricLatencyParams(pydantic.BaseModel):
    stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - average over 5 minutes.\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class MethodDefMetricServerErrorParams(pydantic.BaseModel):
    stage: typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef] = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.Model
class ModelDef(BaseConstruct):
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description="The rest API that this model is part of. The reason we need the RestApi object itself and not just the ID is because the model is being tracked by the top-level RestApi object for the purpose of calculating it's hash to determine the ID of the deployment. This allows us to automatically update the deployment when the model of the REST API changes.\n")
    schema_: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]] = pydantic.Field(..., description="The schema to use to transform data to one or more output formats. Specify null ({}) if you don't want to specify a schema.\n", alias='schema')
    content_type: typing.Optional[str] = pydantic.Field(None, description="The content type for the model. You can also force a content type in the request or response model mapping. Default: 'application/json'\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description that identifies this model. Default: None\n')
    model_name: typing.Optional[str] = pydantic.Field(None, description="A name for the model. Important If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. Default: If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the model name. For more information, see Name Type.")
    _init_params: typing.ClassVar[list[str]] = ['rest_api', 'schema', 'content_type', 'description', 'model_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_model_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.Model'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_model_name']
    ...


    from_model_name: typing.Optional[ModelDefFromModelNameParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[ModelDefConfig] = pydantic.Field(None)


class ModelDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ModelDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ModelDefFromModelNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    model_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.ProxyResource
class ProxyResourceDef(BaseConstruct):
    parent: typing.Union[models.aws_apigateway.ResourceBaseDef, models.aws_apigateway.ProxyResourceDef, models.aws_apigateway.ResourceDef] = pydantic.Field(..., description='The parent resource of this resource. You can either pass another ``Resource`` object or a ``RestApi`` object here.\n')
    any_method: typing.Optional[bool] = pydantic.Field(None, description='Adds an "ANY" method to this resource. If set to ``false``, you will have to explicitly add methods to this resource after it\'s created. Default: true\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    _init_params: typing.ClassVar[list[str]] = ['parent', 'any_method', 'default_cors_preflight_options', 'default_integration', 'default_method_options']
    _method_names: typing.ClassVar[list[str]] = ['add_cors_preflight', 'add_method', 'add_proxy', 'add_resource', 'apply_removal_policy', 'get_resource', 'resource_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_resource_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ProxyResource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_resource_attributes']
    ...


    from_resource_attributes: typing.Optional[ProxyResourceDefFromResourceAttributesParams] = pydantic.Field(None, description='Import an existing resource.')
    resource_config: typing.Optional[ProxyResourceDefConfig] = pydantic.Field(None)


class ProxyResourceDefConfig(pydantic.BaseModel):
    add_cors_preflight: typing.Optional[list[ProxyResourceDefAddCorsPreflightParams]] = pydantic.Field(None, description='Adds an OPTIONS method to this resource which responds to Cross-Origin Resource Sharing (CORS) preflight requests.\nCross-Origin Resource Sharing (CORS) is a mechanism that uses additional\nHTTP headers to tell browsers to give a web application running at one\norigin, access to selected resources from a different origin. A web\napplication executes a cross-origin HTTP request when it requests a\nresource that has a different origin (domain, protocol, or port) from its\nown.')
    add_method: typing.Optional[list[ProxyResourceDefAddMethodParams]] = pydantic.Field(None, description='Defines a new method for this resource.')
    add_proxy: typing.Optional[list[ProxyResourceDefAddProxyParams]] = pydantic.Field(None, description='Adds a greedy proxy resource ("{proxy+}") and an ANY method to this route.')
    add_resource: typing.Optional[list[ProxyResourceDefAddResourceParams]] = pydantic.Field(None, description='Defines a new child resource where this resource is the parent.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_resource: typing.Optional[list[ProxyResourceDefGetResourceParams]] = pydantic.Field(None, description='Retrieves a child resource by path part.')
    resource_for_path: typing.Optional[list[ProxyResourceDefResourceForPathParams]] = pydantic.Field(None, description='Gets or create all resources leading up to the specified path.\n- Path may only start with "/" if this method is called on the root resource.\n- All resources are created using default options.')
    api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)

class ProxyResourceDefAddCorsPreflightParams(pydantic.BaseModel):
    allow_origins: typing.Sequence[str] = pydantic.Field(..., description='Specifies the list of origins that are allowed to make requests to this resource. If you wish to allow all origins, specify ``Cors.ALL_ORIGINS`` or ``[ * ]``. Responses will include the ``Access-Control-Allow-Origin`` response header. If ``Cors.ALL_ORIGINS`` is specified, the ``Vary: Origin`` response header will also be included.\n')
    allow_credentials: typing.Optional[bool] = pydantic.Field(None, description='The Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request\'s credentials mode (Request.credentials) is "include". When a request\'s credentials mode (Request.credentials) is "include", browsers will only expose the response to frontend JavaScript code if the Access-Control-Allow-Credentials value is true. Credentials are cookies, authorization headers or TLS client certificates. Default: false\n')
    allow_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Allow-Headers response header is used in response to a preflight request which includes the Access-Control-Request-Headers to indicate which HTTP headers can be used during the actual request. Default: Cors.DEFAULT_HEADERS\n')
    allow_methods: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Allow-Methods response header specifies the method or methods allowed when accessing the resource in response to a preflight request. If ``ANY`` is specified, it will be expanded to ``Cors.ALL_METHODS``. Default: Cors.ALL_METHODS\n')
    disable_cache: typing.Optional[bool] = pydantic.Field(None, description='Sets Access-Control-Max-Age to -1, which means that caching is disabled. This option cannot be used with ``maxAge``. Default: - cache is enabled\n')
    expose_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Expose-Headers response header indicates which headers can be exposed as part of the response by listing their names. If you want clients to be able to access other headers, you have to list them using the Access-Control-Expose-Headers header. Default: - only the 6 CORS-safelisted response headers are exposed: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma\n')
    max_age: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The Access-Control-Max-Age response header indicates how long the results of a preflight request (that is the information contained in the Access-Control-Allow-Methods and Access-Control-Allow-Headers headers) can be cached. To disable caching altogether use ``disableCache: true``. Default: - browser-specific (see reference)\n')
    status_code: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the response status code returned from the OPTIONS method. Default: 204')
    return_config: typing.Optional[list[models.aws_apigateway.MethodDefConfig]] = pydantic.Field(None)
    ...

class ProxyResourceDefAddMethodParams(pydantic.BaseModel):
    http_method: str = pydantic.Field(..., description='-\n')
    integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='-\n')
    api_key_required: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the method requires clients to submit a valid API key. Default: false\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. Default: - no authorization scopes\n')
    authorization_type: typing.Optional[aws_cdk.aws_apigateway.AuthorizationType] = pydantic.Field(None, description="Method authorization. If the value is set of ``Custom``, an ``authorizer`` must also be specified. If you're using one of the authorizers that are available via the ``Authorizer`` class, such as ``Authorizer#token()``, it is recommended that this option not be specified. The authorizer will take care of setting the correct authorization type. However, specifying an authorization type using this property that conflicts with what is expected by the ``Authorizer`` will result in an error. Default: - open access unless ``authorizer`` is specified\n")
    authorizer: typing.Optional[typing.Union[models.aws_apigateway.AuthorizerDef, models.aws_apigateway.CognitoUserPoolsAuthorizerDef, models.aws_apigateway.CognitoUserPoolsAuthorizerDef, models.aws_apigateway.RequestAuthorizerDef, models.aws_apigateway.RequestAuthorizerDef, models.aws_apigateway.TokenAuthorizerDef, models.aws_apigateway.TokenAuthorizerDef]] = pydantic.Field(None, description='If ``authorizationType`` is ``Custom``, this specifies the ID of the method authorizer resource. If specified, the value of ``authorizationType`` must be set to ``Custom``\n')
    method_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.MethodResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The responses that can be sent to the client who calls the method. Default: None This property is not required, but if these are not supplied for a Lambda proxy integration, the Lambda function must return a value of the correct format, for the integration response to be correctly mapped to a response to the client.\n')
    operation_name: typing.Optional[str] = pydantic.Field(None, description='A friendly operation name for the method. For example, you can assign the OperationName of ListPets for the GET /pets method.\n')
    request_models: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.ModelDef]]] = pydantic.Field(None, description="The models which describe data structure of request payload. When combined with ``requestValidator`` or ``requestValidatorOptions``, the service will validate the API request payload before it reaches the API's Integration (including proxies). Specify ``requestModels`` as key-value pairs, with a content type (e.g. ``'application/json'``) as the key and an API Gateway Model as the value.\n")
    request_parameters: typing.Optional[typing.Mapping[str, bool]] = pydantic.Field(None, description='The request parameters that API Gateway accepts. Specify request parameters as key-value pairs (string-to-Boolean mapping), with a source as the key and a Boolean as the value. The Boolean specifies whether a parameter is required. A source must match the format method.request.location.name, where the location is querystring, path, or header, and name is a valid, unique parameter name. Default: None\n')
    request_validator: typing.Optional[typing.Union[models.aws_apigateway.RequestValidatorDef]] = pydantic.Field(None, description='The ID of the associated request validator. Only one of ``requestValidator`` or ``requestValidatorOptions`` must be specified. Works together with ``requestModels`` or ``requestParameters`` to validate the request before it reaches integration like Lambda Proxy Integration. Default: - No default validator\n')
    request_validator_options: typing.Union[models.aws_apigateway.RequestValidatorOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Request validator options to create new validator Only one of ``requestValidator`` or ``requestValidatorOptions`` must be specified. Works together with ``requestModels`` or ``requestParameters`` to validate the request before it reaches integration like Lambda Proxy Integration. Default: - No default validator')
    return_config: typing.Optional[list[models.aws_apigateway.MethodDefConfig]] = pydantic.Field(None)
    ...

class ProxyResourceDefAddProxyParams(pydantic.BaseModel):
    any_method: typing.Optional[bool] = pydantic.Field(None, description='Adds an "ANY" method to this resource. If set to ``false``, you will have to explicitly add methods to this resource after it\'s created. Default: true\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models.aws_apigateway.ProxyResourceDefConfig]] = pydantic.Field(None)
    ...

class ProxyResourceDefAddResourceParams(pydantic.BaseModel):
    path_part: str = pydantic.Field(..., description='-\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models.aws_apigateway.ResourceDefConfig]] = pydantic.Field(None)
    ...

class ProxyResourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ProxyResourceDefFromResourceAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    path: str = pydantic.Field(..., description='The full path of this resource.\n')
    resource_id: str = pydantic.Field(..., description='The ID of the resource.\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The rest API that this resource is part of.')
    ...

class ProxyResourceDefGetResourceParams(pydantic.BaseModel):
    path_part: str = pydantic.Field(..., description='-')
    ...

class ProxyResourceDefResourceForPathParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigateway.ResourceDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.RateLimitedApiKey
class RateLimitedApiKeyDef(BaseConstruct):
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the RateLimitedApiKey. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none\n')
    customer_id: typing.Optional[str] = pydantic.Field(None, description='An AWS Marketplace customer identifier to use when integrating with the AWS SaaS Marketplace. Default: none\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the API key can be used by clients. Default: true\n')
    generate_distinct_id: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the key identifier is distinct from the created API key value. Default: false\n')
    resources: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]]] = pydantic.Field(None, description='(deprecated) A list of resources this api key is associated with. Default: none\n')
    stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef]]] = pydantic.Field(None, description='A list of Stages this api key is associated with. Default: - the api key is not associated with any stages\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    _init_params: typing.ClassVar[list[str]] = ['api_stages', 'quota', 'throttle', 'customer_id', 'enabled', 'generate_distinct_id', 'resources', 'stages', 'api_key_name', 'description', 'value', 'default_cors_preflight_options', 'default_integration', 'default_method_options']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'grant_read', 'grant_read_write', 'grant_write']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RateLimitedApiKey'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RateLimitedApiKeyDefConfig] = pydantic.Field(None)


class RateLimitedApiKeyDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_read: typing.Optional[list[RateLimitedApiKeyDefGrantReadParams]] = pydantic.Field(None, description='Permits the IAM principal all read operations through this key.')
    grant_read_write: typing.Optional[list[RateLimitedApiKeyDefGrantReadWriteParams]] = pydantic.Field(None, description='Permits the IAM principal all read and write operations through this key.')
    grant_write: typing.Optional[list[RateLimitedApiKeyDefGrantWriteParams]] = pydantic.Field(None, description='Permits the IAM principal all write operations through this key.')

class RateLimitedApiKeyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class RateLimitedApiKeyDefGrantReadParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal to grant access to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RateLimitedApiKeyDefGrantReadWriteParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal to grant access to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RateLimitedApiKeyDefGrantWriteParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal to grant access to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.RequestAuthorizer
class RequestAuthorizerDef(BaseConstruct):
    identity_sources: typing.Sequence[str] = pydantic.Field(..., description="An array of request header mapping expressions for identities. Supported parameter types are Header, Query String, Stage Variable, and Context. For instance, extracting an authorization token from a header would use the identity source ``IdentitySource.header('Authorizer')``. Note: API Gateway uses the specified identity sources as the request authorizer caching key. When caching is enabled, API Gateway calls the authorizer's Lambda function only after successfully verifying that all the specified identity sources are present at runtime. If a specified identify source is missing, null, or empty, API Gateway returns a 401 Unauthorized response without calling the authorizer Lambda function.\n")
    handler: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description="The handler for the authorizer lambda function. The handler must follow a very specific protocol on the input it receives and the output it needs to produce. API Gateway has documented the handler's `input specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-input.html>`_ and `output specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-output.html>`_.\n")
    assume_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description="An optional IAM role for APIGateway to assume before calling the Lambda-based authorizer. The IAM role must be assumable by 'apigateway.amazonaws.com'. Default: - A resource policy is added to the Lambda function allowing apigateway.amazonaws.com to invoke the function.\n")
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='An optional human friendly name for the authorizer. Note that, this is not the primary identifier of the authorizer. Default: - the unique construct ID\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to 0. Default: Duration.minutes(5)')
    _init_params: typing.ClassVar[list[str]] = ['identity_sources', 'handler', 'assume_role', 'authorizer_name', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RequestAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RequestAuthorizerDefConfig] = pydantic.Field(None)


class RequestAuthorizerDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class RequestAuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.RequestValidator
class RequestValidatorDef(BaseConstruct):
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description="The rest API that this model is part of. The reason we need the RestApi object itself and not just the ID is because the model is being tracked by the top-level RestApi object for the purpose of calculating it's hash to determine the ID of the deployment. This allows us to automatically update the deployment when the model of the REST API changes.\n")
    request_validator_name: typing.Optional[str] = pydantic.Field(None, description='The name of this request validator. Default: None\n')
    validate_request_body: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate the request body according to the configured schema for the targeted API and method. Default: false\n')
    validate_request_parameters: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate request parameters. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['rest_api', 'request_validator_name', 'validate_request_body', 'validate_request_parameters']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_request_validator_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RequestValidator'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_request_validator_id']
    ...


    from_request_validator_id: typing.Optional[RequestValidatorDefFromRequestValidatorIdParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[RequestValidatorDefConfig] = pydantic.Field(None)


class RequestValidatorDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class RequestValidatorDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class RequestValidatorDefFromRequestValidatorIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    request_validator_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.Resource
class ResourceDef(BaseConstruct):
    parent: typing.Union[models.aws_apigateway.ResourceBaseDef, models.aws_apigateway.ProxyResourceDef, models.aws_apigateway.ResourceDef] = pydantic.Field(..., description='The parent resource of this resource. You can either pass another ``Resource`` object or a ``RestApi`` object here.\n')
    path_part: str = pydantic.Field(..., description='A path name for the resource.\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    _init_params: typing.ClassVar[list[str]] = ['parent', 'path_part', 'default_cors_preflight_options', 'default_integration', 'default_method_options']
    _method_names: typing.ClassVar[list[str]] = ['add_cors_preflight', 'add_method', 'add_proxy', 'add_resource', 'apply_removal_policy', 'get_resource', 'resource_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_resource_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.Resource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_resource_attributes']
    ...


    from_resource_attributes: typing.Optional[ResourceDefFromResourceAttributesParams] = pydantic.Field(None, description='Import an existing resource.')
    resource_config: typing.Optional[ResourceDefConfig] = pydantic.Field(None)


class ResourceDefConfig(pydantic.BaseModel):
    add_cors_preflight: typing.Optional[list[ResourceDefAddCorsPreflightParams]] = pydantic.Field(None, description='Adds an OPTIONS method to this resource which responds to Cross-Origin Resource Sharing (CORS) preflight requests.\nCross-Origin Resource Sharing (CORS) is a mechanism that uses additional\nHTTP headers to tell browsers to give a web application running at one\norigin, access to selected resources from a different origin. A web\napplication executes a cross-origin HTTP request when it requests a\nresource that has a different origin (domain, protocol, or port) from its\nown.')
    add_method: typing.Optional[list[ResourceDefAddMethodParams]] = pydantic.Field(None, description='Defines a new method for this resource.')
    add_proxy: typing.Optional[list[ResourceDefAddProxyParams]] = pydantic.Field(None, description='Adds a greedy proxy resource ("{proxy+}") and an ANY method to this route.')
    add_resource: typing.Optional[list[ResourceDefAddResourceParams]] = pydantic.Field(None, description='Defines a new child resource where this resource is the parent.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_resource: typing.Optional[list[ResourceDefGetResourceParams]] = pydantic.Field(None, description='Retrieves a child resource by path part.')
    resource_for_path: typing.Optional[list[ResourceDefResourceForPathParams]] = pydantic.Field(None, description='Gets or create all resources leading up to the specified path.\n- Path may only start with "/" if this method is called on the root resource.\n- All resources are created using default options.')
    api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)

class ResourceDefAddCorsPreflightParams(pydantic.BaseModel):
    allow_origins: typing.Sequence[str] = pydantic.Field(..., description='Specifies the list of origins that are allowed to make requests to this resource. If you wish to allow all origins, specify ``Cors.ALL_ORIGINS`` or ``[ * ]``. Responses will include the ``Access-Control-Allow-Origin`` response header. If ``Cors.ALL_ORIGINS`` is specified, the ``Vary: Origin`` response header will also be included.\n')
    allow_credentials: typing.Optional[bool] = pydantic.Field(None, description='The Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request\'s credentials mode (Request.credentials) is "include". When a request\'s credentials mode (Request.credentials) is "include", browsers will only expose the response to frontend JavaScript code if the Access-Control-Allow-Credentials value is true. Credentials are cookies, authorization headers or TLS client certificates. Default: false\n')
    allow_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Allow-Headers response header is used in response to a preflight request which includes the Access-Control-Request-Headers to indicate which HTTP headers can be used during the actual request. Default: Cors.DEFAULT_HEADERS\n')
    allow_methods: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Allow-Methods response header specifies the method or methods allowed when accessing the resource in response to a preflight request. If ``ANY`` is specified, it will be expanded to ``Cors.ALL_METHODS``. Default: Cors.ALL_METHODS\n')
    disable_cache: typing.Optional[bool] = pydantic.Field(None, description='Sets Access-Control-Max-Age to -1, which means that caching is disabled. This option cannot be used with ``maxAge``. Default: - cache is enabled\n')
    expose_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Expose-Headers response header indicates which headers can be exposed as part of the response by listing their names. If you want clients to be able to access other headers, you have to list them using the Access-Control-Expose-Headers header. Default: - only the 6 CORS-safelisted response headers are exposed: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma\n')
    max_age: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The Access-Control-Max-Age response header indicates how long the results of a preflight request (that is the information contained in the Access-Control-Allow-Methods and Access-Control-Allow-Headers headers) can be cached. To disable caching altogether use ``disableCache: true``. Default: - browser-specific (see reference)\n')
    status_code: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the response status code returned from the OPTIONS method. Default: 204')
    return_config: typing.Optional[list[models.aws_apigateway.MethodDefConfig]] = pydantic.Field(None)
    ...

class ResourceDefAddMethodParams(pydantic.BaseModel):
    http_method: str = pydantic.Field(..., description='-\n')
    integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='-\n')
    api_key_required: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the method requires clients to submit a valid API key. Default: false\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. Default: - no authorization scopes\n')
    authorization_type: typing.Optional[aws_cdk.aws_apigateway.AuthorizationType] = pydantic.Field(None, description="Method authorization. If the value is set of ``Custom``, an ``authorizer`` must also be specified. If you're using one of the authorizers that are available via the ``Authorizer`` class, such as ``Authorizer#token()``, it is recommended that this option not be specified. The authorizer will take care of setting the correct authorization type. However, specifying an authorization type using this property that conflicts with what is expected by the ``Authorizer`` will result in an error. Default: - open access unless ``authorizer`` is specified\n")
    authorizer: typing.Optional[typing.Union[models.aws_apigateway.AuthorizerDef, models.aws_apigateway.CognitoUserPoolsAuthorizerDef, models.aws_apigateway.CognitoUserPoolsAuthorizerDef, models.aws_apigateway.RequestAuthorizerDef, models.aws_apigateway.RequestAuthorizerDef, models.aws_apigateway.TokenAuthorizerDef, models.aws_apigateway.TokenAuthorizerDef]] = pydantic.Field(None, description='If ``authorizationType`` is ``Custom``, this specifies the ID of the method authorizer resource. If specified, the value of ``authorizationType`` must be set to ``Custom``\n')
    method_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.MethodResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The responses that can be sent to the client who calls the method. Default: None This property is not required, but if these are not supplied for a Lambda proxy integration, the Lambda function must return a value of the correct format, for the integration response to be correctly mapped to a response to the client.\n')
    operation_name: typing.Optional[str] = pydantic.Field(None, description='A friendly operation name for the method. For example, you can assign the OperationName of ListPets for the GET /pets method.\n')
    request_models: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.ModelDef]]] = pydantic.Field(None, description="The models which describe data structure of request payload. When combined with ``requestValidator`` or ``requestValidatorOptions``, the service will validate the API request payload before it reaches the API's Integration (including proxies). Specify ``requestModels`` as key-value pairs, with a content type (e.g. ``'application/json'``) as the key and an API Gateway Model as the value.\n")
    request_parameters: typing.Optional[typing.Mapping[str, bool]] = pydantic.Field(None, description='The request parameters that API Gateway accepts. Specify request parameters as key-value pairs (string-to-Boolean mapping), with a source as the key and a Boolean as the value. The Boolean specifies whether a parameter is required. A source must match the format method.request.location.name, where the location is querystring, path, or header, and name is a valid, unique parameter name. Default: None\n')
    request_validator: typing.Optional[typing.Union[models.aws_apigateway.RequestValidatorDef]] = pydantic.Field(None, description='The ID of the associated request validator. Only one of ``requestValidator`` or ``requestValidatorOptions`` must be specified. Works together with ``requestModels`` or ``requestParameters`` to validate the request before it reaches integration like Lambda Proxy Integration. Default: - No default validator\n')
    request_validator_options: typing.Union[models.aws_apigateway.RequestValidatorOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Request validator options to create new validator Only one of ``requestValidator`` or ``requestValidatorOptions`` must be specified. Works together with ``requestModels`` or ``requestParameters`` to validate the request before it reaches integration like Lambda Proxy Integration. Default: - No default validator')
    return_config: typing.Optional[list[models.aws_apigateway.MethodDefConfig]] = pydantic.Field(None)
    ...

class ResourceDefAddProxyParams(pydantic.BaseModel):
    any_method: typing.Optional[bool] = pydantic.Field(None, description='Adds an "ANY" method to this resource. If set to ``false``, you will have to explicitly add methods to this resource after it\'s created. Default: true\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models.aws_apigateway.ProxyResourceDefConfig]] = pydantic.Field(None)
    ...

class ResourceDefAddResourceParams(pydantic.BaseModel):
    path_part: str = pydantic.Field(..., description='-\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models.aws_apigateway.ResourceDefConfig]] = pydantic.Field(None)
    ...

class ResourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ResourceDefFromResourceAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    path: str = pydantic.Field(..., description='The full path of this resource.\n')
    resource_id: str = pydantic.Field(..., description='The ID of the resource.\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The rest API that this resource is part of.')
    ...

class ResourceDefGetResourceParams(pydantic.BaseModel):
    path_part: str = pydantic.Field(..., description='-')
    ...

class ResourceDefResourceForPathParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigateway.ResourceDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigateway.RestApi
class RestApiDef(BaseConstruct):
    api_key_source_type: typing.Optional[aws_cdk.aws_apigateway.ApiKeySourceType] = pydantic.Field(None, description='The source of the API key for metering requests according to a usage plan. Default: - Metering is disabled.\n')
    binary_media_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of binary media mime-types that are supported by the RestApi resource, such as "image/png" or "application/octet-stream". Default: - RestApi supports only UTF-8-encoded text payloads.\n')
    clone_from: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='The ID of the API Gateway RestApi resource that you want to clone. Default: - None.\n')
    endpoint_configuration: typing.Union[models.aws_apigateway.EndpointConfigurationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The EndpointConfiguration property type specifies the endpoint types of a REST API. Default: EndpointType.EDGE\n')
    min_compression_size: typing.Optional[models.SizeDef] = pydantic.Field(None, description='A Size(in bytes, kibibytes, mebibytes etc) that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    minimum_compression_size: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['api_key_source_type', 'binary_media_types', 'clone_from', 'endpoint_configuration', 'min_compression_size', 'minimum_compression_size', 'default_cors_preflight_options', 'default_integration', 'default_method_options', 'cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments']
    _method_names: typing.ClassVar[list[str]] = ['add_api_key', 'add_domain_name', 'add_gateway_response', 'add_model', 'add_request_validator', 'add_usage_plan', 'apply_removal_policy', 'arn_for_execute_api', 'metric', 'metric_cache_hit_count', 'metric_cache_miss_count', 'metric_client_error', 'metric_count', 'metric_integration_latency', 'metric_latency', 'metric_server_error', 'url_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_rest_api_attributes', 'from_rest_api_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RestApi'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_rest_api_attributes', 'from_rest_api_id']
    ...


    from_rest_api_attributes: typing.Optional[RestApiDefFromRestApiAttributesParams] = pydantic.Field(None, description='Import an existing RestApi that can be configured with additional Methods and Resources.')
    from_rest_api_id: typing.Optional[RestApiDefFromRestApiIdParams] = pydantic.Field(None, description='Import an existing RestApi.')
    resource_config: typing.Optional[RestApiDefConfig] = pydantic.Field(None)


class RestApiDefConfig(pydantic.BaseModel):
    add_api_key: typing.Optional[list[RestApiDefAddApiKeyParams]] = pydantic.Field(None, description='Add an ApiKey to the deploymentStage.')
    add_domain_name: typing.Optional[list[RestApiDefAddDomainNameParams]] = pydantic.Field(None, description='Defines an API Gateway domain name and maps it to this API.')
    add_gateway_response: typing.Optional[list[RestApiDefAddGatewayResponseParams]] = pydantic.Field(None, description='Adds a new gateway response.')
    add_model: typing.Optional[list[RestApiDefAddModelParams]] = pydantic.Field(None, description='Adds a new model.')
    add_request_validator: typing.Optional[list[RestApiDefAddRequestValidatorParams]] = pydantic.Field(None, description='Adds a new request validator.')
    add_usage_plan: typing.Optional[list[RestApiDefAddUsagePlanParams]] = pydantic.Field(None, description='Adds a usage plan.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    arn_for_execute_api: typing.Optional[list[RestApiDefArnForExecuteApiParams]] = pydantic.Field(None, description='Gets the "execute-api" ARN.')
    metric: typing.Optional[list[RestApiDefMetricParams]] = pydantic.Field(None, description='Returns the given named metric for this API.')
    metric_cache_hit_count: typing.Optional[list[RestApiDefMetricCacheHitCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the API cache in a given period.\nDefault: sum over 5 minutes')
    metric_cache_miss_count: typing.Optional[list[RestApiDefMetricCacheMissCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the backend in a given period, when API caching is enabled.\nDefault: sum over 5 minutes')
    metric_client_error: typing.Optional[list[RestApiDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.\nDefault: sum over 5 minutes')
    metric_count: typing.Optional[list[RestApiDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.\nDefault: sample count over 5 minutes')
    metric_integration_latency: typing.Optional[list[RestApiDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.\nDefault: average over 5 minutes.')
    metric_latency: typing.Optional[list[RestApiDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.\n\nDefault: average over 5 minutes.')
    metric_server_error: typing.Optional[list[RestApiDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.\nDefault: sum over 5 minutes')
    url_for_path: typing.Optional[list[RestApiDefUrlForPathParams]] = pydantic.Field(None, description='Returns the URL for an HTTP path.\nFails if ``deploymentStage`` is not set either by ``deploy`` or explicitly.')
    root_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)

class RestApiDefAddApiKeyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models._interface_methods.AwsApigatewayIApiKeyDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefAddDomainNameParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The construct id.\n')
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The reference to an AWS-managed certificate for use by the edge-optimized endpoint for the domain name. For "EDGE" domain names, the certificate needs to be in the US East (N. Virginia) region.\n')
    domain_name: str = pydantic.Field(..., description='The custom domain name for your API. Uppercase letters are not supported.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``).\n")
    endpoint_type: typing.Optional[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: REGIONAL\n')
    mtls: typing.Union[models.aws_apigateway.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    security_policy: typing.Optional[aws_cdk.aws_apigateway.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2')
    return_config: typing.Optional[list[models.aws_apigateway.DomainNameDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefAddGatewayResponseParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    type: models.aws_apigateway.ResponseTypeDef = pydantic.Field(..., description='Response type to associate with gateway response.\n')
    response_headers: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom headers parameters for response. Default: - no headers\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='Http status code for response. Default: - standard http status code for the response type.\n')
    templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom templates to get mapped as response. Default: - Response from api will be returned without applying any transformation.')
    return_config: typing.Optional[list[models.aws_apigateway.GatewayResponseDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefAddModelParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    schema_: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]] = pydantic.Field(..., description="The schema to use to transform data to one or more output formats. Specify null ({}) if you don't want to specify a schema.\n", alias='schema')
    content_type: typing.Optional[str] = pydantic.Field(None, description="The content type for the model. You can also force a content type in the request or response model mapping. Default: 'application/json'\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description that identifies this model. Default: None\n')
    model_name: typing.Optional[str] = pydantic.Field(None, description="A name for the model. Important If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. Default: If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the model name. For more information, see Name Type.")
    return_config: typing.Optional[list[models.aws_apigateway.ModelDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefAddRequestValidatorParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    request_validator_name: typing.Optional[str] = pydantic.Field(None, description='The name of this request validator. Default: None\n')
    validate_request_body: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate the request body according to the configured schema for the targeted API and method. Default: false\n')
    validate_request_parameters: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate request parameters. Default: false')
    return_config: typing.Optional[list[models.aws_apigateway.RequestValidatorDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefAddUsagePlanParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the usage plan. Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Represents usage plan purpose. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='Name for this usage plan. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none')
    return_config: typing.Optional[list[models.aws_apigateway.UsagePlanDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class RestApiDefArnForExecuteApiParams(pydantic.BaseModel):
    method: typing.Optional[str] = pydantic.Field(None, description='-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='-\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class RestApiDefFromRestApiAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    rest_api_id: str = pydantic.Field(..., description='The ID of the API Gateway RestApi.\n')
    root_resource_id: str = pydantic.Field(..., description='The resource ID of the root resource.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='The name of the API Gateway RestApi. Default: - ID of the RestApi construct.')
    ...

class RestApiDefFromRestApiIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    rest_api_id: str = pydantic.Field(..., description='-')
    ...

class RestApiDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefMetricCacheHitCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefMetricCacheMissCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class RestApiDefUrlForPathParams(pydantic.BaseModel):
    path: typing.Optional[str] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.SpecRestApi
class SpecRestApiDef(BaseConstruct):
    api_definition: models.aws_apigateway.ApiDefinitionDef = pydantic.Field(..., description='An OpenAPI definition compatible with API Gateway.\n')
    min_compression_size: typing.Optional[models.SizeDef] = pydantic.Field(None, description='A Size(in bytes, kibibytes, mebibytes etc) that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['api_definition', 'min_compression_size', 'cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments']
    _method_names: typing.ClassVar[list[str]] = ['add_api_key', 'add_domain_name', 'add_gateway_response', 'add_usage_plan', 'apply_removal_policy', 'arn_for_execute_api', 'metric', 'metric_cache_hit_count', 'metric_cache_miss_count', 'metric_client_error', 'metric_count', 'metric_integration_latency', 'metric_latency', 'metric_server_error', 'url_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.SpecRestApi'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SpecRestApiDefConfig] = pydantic.Field(None)


class SpecRestApiDefConfig(pydantic.BaseModel):
    add_api_key: typing.Optional[list[SpecRestApiDefAddApiKeyParams]] = pydantic.Field(None, description='Add an ApiKey to the deploymentStage.')
    add_domain_name: typing.Optional[list[SpecRestApiDefAddDomainNameParams]] = pydantic.Field(None, description='Defines an API Gateway domain name and maps it to this API.')
    add_gateway_response: typing.Optional[list[SpecRestApiDefAddGatewayResponseParams]] = pydantic.Field(None, description='Adds a new gateway response.')
    add_usage_plan: typing.Optional[list[SpecRestApiDefAddUsagePlanParams]] = pydantic.Field(None, description='Adds a usage plan.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    arn_for_execute_api: typing.Optional[list[SpecRestApiDefArnForExecuteApiParams]] = pydantic.Field(None, description='Gets the "execute-api" ARN.')
    metric: typing.Optional[list[SpecRestApiDefMetricParams]] = pydantic.Field(None, description='Returns the given named metric for this API.')
    metric_cache_hit_count: typing.Optional[list[SpecRestApiDefMetricCacheHitCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the API cache in a given period.\nDefault: sum over 5 minutes')
    metric_cache_miss_count: typing.Optional[list[SpecRestApiDefMetricCacheMissCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the backend in a given period, when API caching is enabled.\nDefault: sum over 5 minutes')
    metric_client_error: typing.Optional[list[SpecRestApiDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.\nDefault: sum over 5 minutes')
    metric_count: typing.Optional[list[SpecRestApiDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.\nDefault: sample count over 5 minutes')
    metric_integration_latency: typing.Optional[list[SpecRestApiDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.\nDefault: average over 5 minutes.')
    metric_latency: typing.Optional[list[SpecRestApiDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.\n\nDefault: average over 5 minutes.')
    metric_server_error: typing.Optional[list[SpecRestApiDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.\nDefault: sum over 5 minutes')
    url_for_path: typing.Optional[list[SpecRestApiDefUrlForPathParams]] = pydantic.Field(None, description='Returns the URL for an HTTP path.\nFails if ``deploymentStage`` is not set either by ``deploy`` or explicitly.')
    root_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)

class SpecRestApiDefAddApiKeyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models._interface_methods.AwsApigatewayIApiKeyDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefAddDomainNameParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The construct id.\n')
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The reference to an AWS-managed certificate for use by the edge-optimized endpoint for the domain name. For "EDGE" domain names, the certificate needs to be in the US East (N. Virginia) region.\n')
    domain_name: str = pydantic.Field(..., description='The custom domain name for your API. Uppercase letters are not supported.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``).\n")
    endpoint_type: typing.Optional[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: REGIONAL\n')
    mtls: typing.Union[models.aws_apigateway.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    security_policy: typing.Optional[aws_cdk.aws_apigateway.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2')
    return_config: typing.Optional[list[models.aws_apigateway.DomainNameDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefAddGatewayResponseParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    type: models.aws_apigateway.ResponseTypeDef = pydantic.Field(..., description='Response type to associate with gateway response.\n')
    response_headers: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom headers parameters for response. Default: - no headers\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='Http status code for response. Default: - standard http status code for the response type.\n')
    templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom templates to get mapped as response. Default: - Response from api will be returned without applying any transformation.')
    return_config: typing.Optional[list[models.aws_apigateway.GatewayResponseDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefAddUsagePlanParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the usage plan. Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Represents usage plan purpose. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='Name for this usage plan. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none')
    return_config: typing.Optional[list[models.aws_apigateway.UsagePlanDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class SpecRestApiDefArnForExecuteApiParams(pydantic.BaseModel):
    method: typing.Optional[str] = pydantic.Field(None, description='-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='-\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class SpecRestApiDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefMetricCacheHitCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefMetricCacheMissCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class SpecRestApiDefUrlForPathParams(pydantic.BaseModel):
    path: typing.Optional[str] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.Stage
class StageDef(BaseConstruct):
    deployment: models.aws_apigateway.DeploymentDef = pydantic.Field(..., description='The deployment that this stage points to [disable-awslint:ref-via-interface].\n')
    access_log_destination: typing.Optional[typing.Union[models.aws_apigateway.LogGroupLogDestinationDef]] = pydantic.Field(None, description='The CloudWatch Logs log group. Default: - No destination\n')
    access_log_format: typing.Optional[models.aws_apigateway.AccessLogFormatDef] = pydantic.Field(None, description='A single line format of access logs of data, as specified by selected $content variables. The format must include either ``AccessLogFormat.contextRequestId()`` or ``AccessLogFormat.contextExtendedRequestId()``. Default: - Common Log Format\n')
    cache_cluster_enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether cache clustering is enabled for the stage. Default: - Disabled for the stage.\n')
    cache_cluster_size: typing.Optional[str] = pydantic.Field(None, description="The stage's cache cluster size. Default: 0.5\n")
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the client certificate that API Gateway uses to call your integration endpoints in the stage. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the stage. Default: - No description.\n')
    documentation_version: typing.Optional[str] = pydantic.Field(None, description='The version identifier of the API documentation snapshot. Default: - No documentation version.\n')
    method_options: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.MethodDeploymentOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Method deployment options for specific resources/methods. These will override common options defined in ``StageOptions#methodOptions``. Default: - Common options will be used.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of the stage, which API Gateway uses as the first path segment in the invoked Uniform Resource Identifier (URI). Default: - "prod"\n')
    tracing_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether Amazon X-Ray tracing is enabled for this method. Default: false\n')
    variables: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map that defines the stage variables. Variable names must consist of alphanumeric characters, and the values must match the following regular expression: [A-Za-z0-9-._~:/?#&=,]+. Default: - No stage variables.\n')
    cache_data_encrypted: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the cached responses are encrypted. Default: false\n')
    cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached. Default: Duration.minutes(5)\n')
    caching_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached. Default: - Caching is Disabled.\n')
    data_trace_enabled: typing.Optional[bool] = pydantic.Field(None, description="Specifies whether data trace logging is enabled for this method. When enabled, API gateway will log the full API requests and responses. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this feature for production APIs. Default: false\n")
    logging_level: typing.Optional[aws_cdk.aws_apigateway.MethodLoggingLevel] = pydantic.Field(None, description='Specifies the logging level for this method, which effects the log entries pushed to Amazon CloudWatch Logs. Default: - Off\n')
    metrics_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether Amazon CloudWatch metrics are enabled for this method. Default: false\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling burst limit. The total rate of all requests in your AWS account is limited to 5,000 requests. Default: - No additional restriction.\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling rate limit. The total rate of all requests in your AWS account is limited to 10,000 requests per second (rps). Default: - No additional restriction.')
    _init_params: typing.ClassVar[list[str]] = ['deployment', 'access_log_destination', 'access_log_format', 'cache_cluster_enabled', 'cache_cluster_size', 'client_certificate_id', 'description', 'documentation_version', 'method_options', 'stage_name', 'tracing_enabled', 'variables', 'cache_data_encrypted', 'cache_ttl', 'caching_enabled', 'data_trace_enabled', 'logging_level', 'metrics_enabled', 'throttling_burst_limit', 'throttling_rate_limit']
    _method_names: typing.ClassVar[list[str]] = ['add_api_key', 'apply_removal_policy', 'metric', 'metric_cache_hit_count', 'metric_cache_miss_count', 'metric_client_error', 'metric_count', 'metric_integration_latency', 'metric_latency', 'metric_server_error', 'url_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_stage_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.Stage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_stage_attributes']
    ...


    from_stage_attributes: typing.Optional[StageDefFromStageAttributesParams] = pydantic.Field(None, description='Import a Stage by its attributes.')
    resource_config: typing.Optional[StageDefConfig] = pydantic.Field(None)


class StageDefConfig(pydantic.BaseModel):
    add_api_key: typing.Optional[list[StageDefAddApiKeyParams]] = pydantic.Field(None, description='Add an ApiKey to this stage.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    metric: typing.Optional[list[StageDefMetricParams]] = pydantic.Field(None, description='Returns the given named metric for this stage.')
    metric_cache_hit_count: typing.Optional[list[StageDefMetricCacheHitCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the API cache in a given period.')
    metric_cache_miss_count: typing.Optional[list[StageDefMetricCacheMissCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the backend in a given period, when API caching is enabled.')
    metric_client_error: typing.Optional[list[StageDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.')
    metric_count: typing.Optional[list[StageDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.')
    metric_integration_latency: typing.Optional[list[StageDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.')
    metric_latency: typing.Optional[list[StageDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.')
    metric_server_error: typing.Optional[list[StageDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.')
    url_for_path: typing.Optional[list[StageDefUrlForPathParams]] = pydantic.Field(None, description='Returns the invoke URL for a certain path.')
    rest_api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)

class StageDefAddApiKeyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models._interface_methods.AwsApigatewayIApiKeyDefConfig]] = pydantic.Field(None)
    ...

class StageDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class StageDefFromStageAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The RestApi that the stage belongs to.\n')
    stage_name: str = pydantic.Field(..., description='The name of the stage.')
    ...

class StageDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageDefMetricCacheHitCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageDefMetricCacheMissCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sample count over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - average over 5 minutes.\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - average over 5 minutes.\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: - sum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StageDefUrlForPathParams(pydantic.BaseModel):
    path: typing.Optional[str] = pydantic.Field(None, description='The resource path.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.StepFunctionsRestApi
class StepFunctionsRestApiDef(BaseConstruct):
    state_machine: typing.Union[models.aws_stepfunctions.StateMachineDef] = pydantic.Field(..., description='The default State Machine that handles all requests from this API. This stateMachine will be used as a the default integration for all methods in this API, unless specified otherwise in ``addMethod``.\n')
    authorizer: typing.Optional[bool] = pydantic.Field(None, description='If the whole authorizer object, including custom context values should be in the execution input. The execution input will include a new key ``authorizer``: { "body": {}, "authorizer": { "key": "value" } } Default: false\n')
    headers: typing.Optional[bool] = pydantic.Field(None, description='Check if header is to be included inside the execution input. The execution input will include a new key ``headers``: { "body": {}, "headers": { "header1": "value", "header2": "value" } } Default: false\n')
    path: typing.Optional[bool] = pydantic.Field(None, description='Check if path is to be included inside the execution input. The execution input will include a new key ``path``: { "body": {}, "path": { "resourceName": "resourceValue" } } Default: true\n')
    querystring: typing.Optional[bool] = pydantic.Field(None, description='Check if querystring is to be included inside the execution input. The execution input will include a new key ``queryString``: { "body": {}, "querystring": { "key": "value" } } Default: true\n')
    request_context: typing.Union[models.aws_apigateway.RequestContextDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which details of the incoming request must be passed onto the underlying state machine, such as, account id, user identity, request id, etc. The execution input will include a new key ``requestContext``: { "body": {}, "requestContext": { "key": "value" } } Default: - all parameters within request context will be set as false\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that API Gateway will assume to start the execution of the state machine. Default: - a new role is created\n')
    api_key_source_type: typing.Optional[aws_cdk.aws_apigateway.ApiKeySourceType] = pydantic.Field(None, description='The source of the API key for metering requests according to a usage plan. Default: - Metering is disabled.\n')
    binary_media_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of binary media mime-types that are supported by the RestApi resource, such as "image/png" or "application/octet-stream". Default: - RestApi supports only UTF-8-encoded text payloads.\n')
    clone_from: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='The ID of the API Gateway RestApi resource that you want to clone. Default: - None.\n')
    endpoint_configuration: typing.Union[models.aws_apigateway.EndpointConfigurationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The EndpointConfiguration property type specifies the endpoint types of a REST API. Default: EndpointType.EDGE\n')
    min_compression_size: typing.Optional[models.SizeDef] = pydantic.Field(None, description='A Size(in bytes, kibibytes, mebibytes etc) that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    minimum_compression_size: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['state_machine', 'authorizer', 'headers', 'path', 'querystring', 'request_context', 'role', 'api_key_source_type', 'binary_media_types', 'clone_from', 'endpoint_configuration', 'min_compression_size', 'minimum_compression_size', 'default_cors_preflight_options', 'default_integration', 'default_method_options', 'cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments']
    _method_names: typing.ClassVar[list[str]] = ['add_api_key', 'add_domain_name', 'add_gateway_response', 'add_model', 'add_request_validator', 'add_usage_plan', 'apply_removal_policy', 'arn_for_execute_api', 'metric', 'metric_cache_hit_count', 'metric_cache_miss_count', 'metric_client_error', 'metric_count', 'metric_integration_latency', 'metric_latency', 'metric_server_error', 'url_for_path']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_rest_api_attributes', 'from_rest_api_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.StepFunctionsRestApi'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_rest_api_attributes', 'from_rest_api_id']
    ...


    from_rest_api_attributes: typing.Optional[StepFunctionsRestApiDefFromRestApiAttributesParams] = pydantic.Field(None, description='Import an existing RestApi that can be configured with additional Methods and Resources.')
    from_rest_api_id: typing.Optional[StepFunctionsRestApiDefFromRestApiIdParams] = pydantic.Field(None, description='Import an existing RestApi.')
    resource_config: typing.Optional[StepFunctionsRestApiDefConfig] = pydantic.Field(None)


class StepFunctionsRestApiDefConfig(pydantic.BaseModel):
    add_api_key: typing.Optional[list[StepFunctionsRestApiDefAddApiKeyParams]] = pydantic.Field(None, description='Add an ApiKey to the deploymentStage.')
    add_domain_name: typing.Optional[list[StepFunctionsRestApiDefAddDomainNameParams]] = pydantic.Field(None, description='Defines an API Gateway domain name and maps it to this API.')
    add_gateway_response: typing.Optional[list[StepFunctionsRestApiDefAddGatewayResponseParams]] = pydantic.Field(None, description='Adds a new gateway response.')
    add_model: typing.Optional[list[StepFunctionsRestApiDefAddModelParams]] = pydantic.Field(None, description='Adds a new model.')
    add_request_validator: typing.Optional[list[StepFunctionsRestApiDefAddRequestValidatorParams]] = pydantic.Field(None, description='Adds a new request validator.')
    add_usage_plan: typing.Optional[list[StepFunctionsRestApiDefAddUsagePlanParams]] = pydantic.Field(None, description='Adds a usage plan.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    arn_for_execute_api: typing.Optional[list[StepFunctionsRestApiDefArnForExecuteApiParams]] = pydantic.Field(None, description='Gets the "execute-api" ARN.')
    metric: typing.Optional[list[StepFunctionsRestApiDefMetricParams]] = pydantic.Field(None, description='Returns the given named metric for this API.')
    metric_cache_hit_count: typing.Optional[list[StepFunctionsRestApiDefMetricCacheHitCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the API cache in a given period.\nDefault: sum over 5 minutes')
    metric_cache_miss_count: typing.Optional[list[StepFunctionsRestApiDefMetricCacheMissCountParams]] = pydantic.Field(None, description='Metric for the number of requests served from the backend in a given period, when API caching is enabled.\nDefault: sum over 5 minutes')
    metric_client_error: typing.Optional[list[StepFunctionsRestApiDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.\nDefault: sum over 5 minutes')
    metric_count: typing.Optional[list[StepFunctionsRestApiDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.\nDefault: sample count over 5 minutes')
    metric_integration_latency: typing.Optional[list[StepFunctionsRestApiDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.\nDefault: average over 5 minutes.')
    metric_latency: typing.Optional[list[StepFunctionsRestApiDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.\n\nDefault: average over 5 minutes.')
    metric_server_error: typing.Optional[list[StepFunctionsRestApiDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.\nDefault: sum over 5 minutes')
    url_for_path: typing.Optional[list[StepFunctionsRestApiDefUrlForPathParams]] = pydantic.Field(None, description='Returns the URL for an HTTP path.\nFails if ``deploymentStage`` is not set either by ``deploy`` or explicitly.')
    root_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)

class StepFunctionsRestApiDefAddApiKeyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.')
    return_config: typing.Optional[list[models._interface_methods.AwsApigatewayIApiKeyDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefAddDomainNameParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The construct id.\n')
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The reference to an AWS-managed certificate for use by the edge-optimized endpoint for the domain name. For "EDGE" domain names, the certificate needs to be in the US East (N. Virginia) region.\n')
    domain_name: str = pydantic.Field(..., description='The custom domain name for your API. Uppercase letters are not supported.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``).\n")
    endpoint_type: typing.Optional[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: REGIONAL\n')
    mtls: typing.Union[models.aws_apigateway.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    security_policy: typing.Optional[aws_cdk.aws_apigateway.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2')
    return_config: typing.Optional[list[models.aws_apigateway.DomainNameDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefAddGatewayResponseParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    type: models.aws_apigateway.ResponseTypeDef = pydantic.Field(..., description='Response type to associate with gateway response.\n')
    response_headers: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom headers parameters for response. Default: - no headers\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='Http status code for response. Default: - standard http status code for the response type.\n')
    templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom templates to get mapped as response. Default: - Response from api will be returned without applying any transformation.')
    return_config: typing.Optional[list[models.aws_apigateway.GatewayResponseDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefAddModelParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    schema_: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]] = pydantic.Field(..., description="The schema to use to transform data to one or more output formats. Specify null ({}) if you don't want to specify a schema.\n", alias='schema')
    content_type: typing.Optional[str] = pydantic.Field(None, description="The content type for the model. You can also force a content type in the request or response model mapping. Default: 'application/json'\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description that identifies this model. Default: None\n')
    model_name: typing.Optional[str] = pydantic.Field(None, description="A name for the model. Important If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. Default: If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the model name. For more information, see Name Type.")
    return_config: typing.Optional[list[models.aws_apigateway.ModelDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefAddRequestValidatorParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    request_validator_name: typing.Optional[str] = pydantic.Field(None, description='The name of this request validator. Default: None\n')
    validate_request_body: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate the request body according to the configured schema for the targeted API and method. Default: false\n')
    validate_request_parameters: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate request parameters. Default: false')
    return_config: typing.Optional[list[models.aws_apigateway.RequestValidatorDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefAddUsagePlanParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the usage plan. Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Represents usage plan purpose. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='Name for this usage plan. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none')
    return_config: typing.Optional[list[models.aws_apigateway.UsagePlanDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class StepFunctionsRestApiDefArnForExecuteApiParams(pydantic.BaseModel):
    method: typing.Optional[str] = pydantic.Field(None, description='-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='-\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class StepFunctionsRestApiDefFromRestApiAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    rest_api_id: str = pydantic.Field(..., description='The ID of the API Gateway RestApi.\n')
    root_resource_id: str = pydantic.Field(..., description='The resource ID of the root resource.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='The name of the API Gateway RestApi. Default: - ID of the RestApi construct.')
    ...

class StepFunctionsRestApiDefFromRestApiIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    rest_api_id: str = pydantic.Field(..., description='-')
    ...

class StepFunctionsRestApiDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefMetricCacheHitCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefMetricCacheMissCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class StepFunctionsRestApiDefUrlForPathParams(pydantic.BaseModel):
    path: typing.Optional[str] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.TokenAuthorizer
class TokenAuthorizerDef(BaseConstruct):
    identity_source: typing.Optional[str] = pydantic.Field(None, description="The request header mapping expression for the bearer token. This is typically passed as part of the header, in which case this should be ``method.request.header.Authorizer`` where Authorizer is the header containing the bearer token. Default: ``IdentitySource.header('Authorization')``\n")
    validation_regex: typing.Optional[str] = pydantic.Field(None, description='An optional regex to be matched against the authorization token. When matched the authorizer lambda is invoked, otherwise a 401 Unauthorized is returned to the client. Default: - no regex filter will be applied.\n')
    handler: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description="The handler for the authorizer lambda function. The handler must follow a very specific protocol on the input it receives and the output it needs to produce. API Gateway has documented the handler's `input specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-input.html>`_ and `output specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-output.html>`_.\n")
    assume_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description="An optional IAM role for APIGateway to assume before calling the Lambda-based authorizer. The IAM role must be assumable by 'apigateway.amazonaws.com'. Default: - A resource policy is added to the Lambda function allowing apigateway.amazonaws.com to invoke the function.\n")
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='An optional human friendly name for the authorizer. Note that, this is not the primary identifier of the authorizer. Default: - the unique construct ID\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to 0. Default: Duration.minutes(5)')
    _init_params: typing.ClassVar[list[str]] = ['identity_source', 'validation_regex', 'handler', 'assume_role', 'authorizer_name', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.TokenAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[TokenAuthorizerDefConfig] = pydantic.Field(None)


class TokenAuthorizerDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class TokenAuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.UsagePlan
class UsagePlanDef(BaseConstruct):
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the usage plan. Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Represents usage plan purpose. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='Name for this usage plan. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none')
    _init_params: typing.ClassVar[list[str]] = ['api_stages', 'description', 'name', 'quota', 'throttle']
    _method_names: typing.ClassVar[list[str]] = ['add_api_key', 'add_api_stage', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_usage_plan_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.UsagePlan'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_usage_plan_id']
    ...


    from_usage_plan_id: typing.Optional[UsagePlanDefFromUsagePlanIdParams] = pydantic.Field(None, description='Import an externally defined usage plan using its ARN.')
    resource_config: typing.Optional[UsagePlanDefConfig] = pydantic.Field(None)


class UsagePlanDefConfig(pydantic.BaseModel):
    add_api_key: typing.Optional[list[UsagePlanDefAddApiKeyParams]] = pydantic.Field(None, description='Adds an ApiKey.')
    add_api_stage: typing.Optional[list[UsagePlanDefAddApiStageParams]] = pydantic.Field(None, description='Adds an apiStage.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class UsagePlanDefAddApiKeyParams(pydantic.BaseModel):
    api_key: typing.Union[models.aws_apigateway.ApiKeyDef, models.aws_apigateway.RateLimitedApiKeyDef] = pydantic.Field(..., description='the api key to associate with this usage plan.\n')
    override_logical_id: typing.Optional[str] = pydantic.Field(None, description='Override the CloudFormation logical id of the AWS::ApiGateway::UsagePlanKey resource. Default: - autogenerated by the CDK')
    ...

class UsagePlanDefAddApiStageParams(pydantic.BaseModel):
    api: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='Default: none\n')
    stage: typing.Optional[models.aws_apigateway.StageDef] = pydantic.Field(None, description='[disable-awslint:ref-via-interface]. Default: none\n')
    throttle: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.ThrottlingPerMethodDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Default: none')
    ...

class UsagePlanDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class UsagePlanDefFromUsagePlanIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the construct that will "own" the imported usage plan.\n')
    id: str = pydantic.Field(..., description='the id of the imported usage plan in the construct tree.\n')
    usage_plan_id: str = pydantic.Field(..., description='the id of an existing usage plan.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.VpcLink
class VpcLinkDef(BaseConstruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the VPC link. Default: no description\n')
    targets: typing.Optional[typing.Sequence[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]]] = pydantic.Field(None, description='The network load balancers of the VPC targeted by the VPC link. The network load balancers must be owned by the same AWS account of the API owner. Default: - no targets. Use ``addTargets`` to add targets\n')
    vpc_link_name: typing.Optional[str] = pydantic.Field(None, description='The name used to label and identify the VPC link. Default: - automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['description', 'targets', 'vpc_link_name']
    _method_names: typing.ClassVar[list[str]] = ['add_targets', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_vpc_link_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.VpcLink'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_vpc_link_id']
    ...


    from_vpc_link_id: typing.Optional[VpcLinkDefFromVpcLinkIdParams] = pydantic.Field(None, description='Import a VPC Link by its Id.')
    resource_config: typing.Optional[VpcLinkDefConfig] = pydantic.Field(None)


class VpcLinkDefConfig(pydantic.BaseModel):
    add_targets: typing.Optional[list[VpcLinkDefAddTargetsParams]] = pydantic.Field(None, description='')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class VpcLinkDefAddTargetsParams(pydantic.BaseModel):
    targets: list[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]] = pydantic.Field(...)
    ...

class VpcLinkDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VpcLinkDefFromVpcLinkIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    vpc_link_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigateway.AccessLogDestinationConfig
class AccessLogDestinationConfigDef(BaseStruct):
    destination_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the destination resource.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    access_log_destination_config = apigateway.AccessLogDestinationConfig(\n        destination_arn="destinationArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.AccessLogDestinationConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.AddApiKeyOptions
class AddApiKeyOptionsDef(BaseStruct):
    override_logical_id: typing.Optional[str] = pydantic.Field(None, description='Override the CloudFormation logical id of the AWS::ApiGateway::UsagePlanKey resource. Default: - autogenerated by the CDK\n\n:exampleMetadata: infused\n\nExample::\n\n    # usageplan: apigateway.UsagePlan\n    # api_key: apigateway.ApiKey\n\n\n    usageplan.add_api_key(api_key,\n        override_logical_id="..."\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['override_logical_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.AddApiKeyOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ApiDefinitionConfig
class ApiDefinitionConfigDef(BaseStruct):
    inline_definition: typing.Any = pydantic.Field(None, description='Inline specification (mutually exclusive with ``s3Location``). Default: - API definition is not defined inline\n')
    s3_location: typing.Union[models.aws_apigateway.ApiDefinitionS3LocationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The location of the specification in S3 (mutually exclusive with ``inlineDefinition``). Default: - API definition is not an S3 location\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # inline_definition: Any\n\n    api_definition_config = apigateway.ApiDefinitionConfig(\n        inline_definition=inline_definition,\n        s3_location=apigateway.ApiDefinitionS3Location(\n            bucket="bucket",\n            key="key",\n\n            # the properties below are optional\n            version="version"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['inline_definition', 's3_location']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ApiDefinitionConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ApiDefinitionS3Location
class ApiDefinitionS3LocationDef(BaseStruct):
    bucket: str = pydantic.Field(..., description='The S3 bucket.\n')
    key: str = pydantic.Field(..., description='The S3 key.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='An optional version. Default: - latest version\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    api_definition_s3_location = apigateway.ApiDefinitionS3Location(\n        bucket="bucket",\n        key="key",\n\n        # the properties below are optional\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'key', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ApiDefinitionS3Location'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ApiKeyOptions
class ApiKeyOptionsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigateway.RestApi\n\n    key = api.add_api_key("ApiKey",\n        api_key_name="myApiKey1",\n        value="MyApiKeyThatIsAtLeast20Characters"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'api_key_name', 'description', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ApiKeyOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ApiKeyProps
class ApiKeyPropsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    customer_id: typing.Optional[str] = pydantic.Field(None, description='An AWS Marketplace customer identifier to use when integrating with the AWS SaaS Marketplace. Default: none\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the API key can be used by clients. Default: true\n')
    generate_distinct_id: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the key identifier is distinct from the created API key value. Default: false\n')
    resources: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]]] = pydantic.Field(None, description='(deprecated) A list of resources this api key is associated with. Default: none\n')
    stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef]]] = pydantic.Field(None, description='A list of Stages this api key is associated with. Default: - the api key is not associated with any stages\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigateway as apigateway\n\n    # authorizer: apigateway.Authorizer\n    # integration: apigateway.Integration\n    # model: apigateway.Model\n    # request_validator: apigateway.RequestValidator\n    # rest_api: apigateway.RestApi\n    # stage: apigateway.Stage\n\n    api_key_props = apigateway.ApiKeyProps(\n        api_key_name="apiKeyName",\n        customer_id="customerId",\n        default_cors_preflight_options=apigateway.CorsOptions(\n            allow_origins=["allowOrigins"],\n\n            # the properties below are optional\n            allow_credentials=False,\n            allow_headers=["allowHeaders"],\n            allow_methods=["allowMethods"],\n            disable_cache=False,\n            expose_headers=["exposeHeaders"],\n            max_age=cdk.Duration.minutes(30),\n            status_code=123\n        ),\n        default_integration=integration,\n        default_method_options=apigateway.MethodOptions(\n            api_key_required=False,\n            authorization_scopes=["authorizationScopes"],\n            authorization_type=apigateway.AuthorizationType.NONE,\n            authorizer=authorizer,\n            method_responses=[apigateway.MethodResponse(\n                status_code="statusCode",\n\n                # the properties below are optional\n                response_models={\n                    "response_models_key": model\n                },\n                response_parameters={\n                    "response_parameters_key": False\n                }\n            )],\n            operation_name="operationName",\n            request_models={\n                "request_models_key": model\n            },\n            request_parameters={\n                "request_parameters_key": False\n            },\n            request_validator=request_validator,\n            request_validator_options=apigateway.RequestValidatorOptions(\n                request_validator_name="requestValidatorName",\n                validate_request_body=False,\n                validate_request_parameters=False\n            )\n        ),\n        description="description",\n        enabled=False,\n        generate_distinct_id=False,\n        resources=[rest_api],\n        stages=[stage],\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'api_key_name', 'description', 'value', 'customer_id', 'enabled', 'generate_distinct_id', 'resources', 'stages']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ApiKeyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ApiMappingOptions
class ApiMappingOptionsDef(BaseStruct):
    base_path: typing.Optional[str] = pydantic.Field(None, description='The api path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can\'t be an empty string. If this is undefined, a mapping will be added for the empty path. Any request that does not match a mapping will get sent to the API that has been mapped to the empty path. Default: - map requests from the domain root (e.g. ``example.com``).\n\n:exampleMetadata: infused\n\nExample::\n\n    # acm_certificate_for_example_com: Any\n    # rest_api: apigateway.RestApi\n    # second_rest_api: apigateway.RestApi\n\n\n    domain = apigateway.DomainName(self, "custom-domain",\n        domain_name="example.com",\n        certificate=acm_certificate_for_example_com,\n        mapping=rest_api\n    )\n\n    domain.add_api_mapping(second_rest_api.deployment_stage,\n        base_path="orders/v2/api"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ApiMappingOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.AwsIntegrationProps
class AwsIntegrationPropsDef(BaseStruct):
    service: str = pydantic.Field(..., description='The name of the integrated AWS service (e.g. ``s3``).')
    action: typing.Optional[str] = pydantic.Field(None, description='The AWS action to perform in the integration. Use ``actionParams`` to specify key-value params for the action. Mutually exclusive with ``path``.\n')
    action_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Parameters for the action. ``action`` must be set, and ``path`` must be undefined. The action params will be URL encoded.\n')
    integration_http_method: typing.Optional[str] = pydantic.Field(None, description="The integration's HTTP method type. Default: POST\n")
    options: typing.Union[models.aws_apigateway.IntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Integration options, such as content handling, request/response mapping, etc.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to use for path-base APIs. For example, for S3 GET, you can set path to ``bucket/key``. For lambda, you can set path to ``2015-03-31/functions/${function-arn}/invocations`` Mutually exclusive with the ``action`` options.\n')
    proxy: typing.Optional[bool] = pydantic.Field(None, description='Use AWS_PROXY integration. Default: false\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region of the integrated AWS service. Default: - same region as the stack\n')
    subdomain: typing.Optional[str] = pydantic.Field(None, description='A designated subdomain supported by certain AWS service for fast host-name lookup.\n\n:exampleMetadata: infused\n\nExample::\n\n    get_message_integration = apigateway.AwsIntegration(\n        service="sqs",\n        path="queueName",\n        region="eu-west-1"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service', 'action', 'action_parameters', 'integration_http_method', 'options', 'path', 'proxy', 'region', 'subdomain']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.AwsIntegrationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.BasePathMappingOptions
class BasePathMappingOptionsDef(BaseStruct):
    attach_to_stage: typing.Optional[bool] = pydantic.Field(None, description='Whether to attach the base path mapping to a stage. Use this property to create a base path mapping without attaching it to the Rest API default stage. This property is ignored if ``stage`` is provided. Default: - true')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``). If this is undefined, no additional mappings will be allowed on this domain name.\n")
    stage: typing.Optional[models.aws_apigateway.StageDef] = pydantic.Field(None, description='The Deployment stage of API [disable-awslint:ref-via-interface]. Default: - map to deploymentStage of restApi otherwise stage needs to pass in URL\n\n:exampleMetadata: infused\n\nExample::\n\n    # domain: apigateway.DomainName\n    # api1: apigateway.RestApi\n    # api2: apigateway.RestApi\n\n\n    domain.add_base_path_mapping(api1, base_path="go-to-api1")\n    domain.add_base_path_mapping(api2, base_path="boom")\n')
    _init_params: typing.ClassVar[list[str]] = ['attach_to_stage', 'base_path', 'stage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.BasePathMappingOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.BasePathMappingProps
class BasePathMappingPropsDef(BaseStruct):
    attach_to_stage: typing.Optional[bool] = pydantic.Field(None, description='Whether to attach the base path mapping to a stage. Use this property to create a base path mapping without attaching it to the Rest API default stage. This property is ignored if ``stage`` is provided. Default: - true')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``). If this is undefined, no additional mappings will be allowed on this domain name.\n")
    stage: typing.Optional[models.aws_apigateway.StageDef] = pydantic.Field(None, description='The Deployment stage of API [disable-awslint:ref-via-interface]. Default: - map to deploymentStage of restApi otherwise stage needs to pass in URL\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameDef] = pydantic.Field(..., description='The DomainName to associate with this base path mapping.\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The RestApi resource to target.\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigateway.RestApi\n\n\n    domain_name = apigateway.DomainName.from_domain_name_attributes(self, "DomainName",\n        domain_name="domainName",\n        domain_name_alias_hosted_zone_id="domainNameAliasHostedZoneId",\n        domain_name_alias_target="domainNameAliasTarget"\n    )\n\n    apigateway.BasePathMapping(self, "BasePathMapping",\n        domain_name=domain_name,\n        rest_api=api\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attach_to_stage', 'base_path', 'stage', 'domain_name', 'rest_api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.BasePathMappingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnApiKey.StageKeyProperty
class CfnApiKey_StageKeyPropertyDef(BaseStruct):
    rest_api_id: typing.Optional[str] = pydantic.Field(None, description='The string identifier of the associated RestApi.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The stage name associated with the stage key.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-apikey-stagekey.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    stage_key_property = apigateway.CfnApiKey.StageKeyProperty(\n        rest_api_id="restApiId",\n        stage_name="stageName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'stage_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnApiKey.StageKeyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDeployment.AccessLogSettingProperty
class CfnDeployment_AccessLogSettingPropertyDef(BaseStruct):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with ``amazon-apigateway-`` .\n')
    format: typing.Optional[str] = pydantic.Field(None, description='A single line format of the access logs of data, as specified by selected $context variables. The format must include at least ``$context.requestId`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-deployment-accesslogsetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    access_log_setting_property = apigateway.CfnDeployment.AccessLogSettingProperty(\n        destination_arn="destinationArn",\n        format="format"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_arn', 'format']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDeployment.AccessLogSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDeployment.CanarySettingProperty
class CfnDeployment_CanarySettingPropertyDef(BaseStruct):
    percent_traffic: typing.Union[int, float, None] = pydantic.Field(None, description='The percent (0-100) of traffic diverted to a canary deployment.\n')
    stage_variable_overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.\n')
    use_stage_cache: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean flag to indicate whether the canary deployment uses the stage cache or not.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-deployment-canarysetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    canary_setting_property = apigateway.CfnDeployment.CanarySettingProperty(\n        percent_traffic=123,\n        stage_variable_overrides={\n            "stage_variable_overrides_key": "stageVariableOverrides"\n        },\n        use_stage_cache=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['percent_traffic', 'stage_variable_overrides', 'use_stage_cache']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDeployment.CanarySettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDeployment.DeploymentCanarySettingsProperty
class CfnDeployment_DeploymentCanarySettingsPropertyDef(BaseStruct):
    percent_traffic: typing.Union[int, float, None] = pydantic.Field(None, description='The percentage (0.0-100.0) of traffic routed to the canary deployment.\n')
    stage_variable_overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='A stage variable overrides used for the canary release deployment. They can override existing stage variables or add new stage variables for the canary release deployment. These stage variables are represented as a string-to-string map between stage variable names and their values.\n')
    use_stage_cache: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean flag to indicate whether the canary release deployment uses the stage cache or not.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-deployment-deploymentcanarysettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    deployment_canary_settings_property = apigateway.CfnDeployment.DeploymentCanarySettingsProperty(\n        percent_traffic=123,\n        stage_variable_overrides={\n            "stage_variable_overrides_key": "stageVariableOverrides"\n        },\n        use_stage_cache=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['percent_traffic', 'stage_variable_overrides', 'use_stage_cache']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDeployment.DeploymentCanarySettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDeployment.MethodSettingProperty
class CfnDeployment_MethodSettingPropertyDef(BaseStruct):
    cache_data_encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether the cached responses are encrypted.\n')
    cache_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.\n')
    caching_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.\n')
    data_trace_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs.\n')
    http_method: typing.Optional[str] = pydantic.Field(None, description='The HTTP method.\n')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are ``OFF`` , ``ERROR`` , and ``INFO`` . Choose ``ERROR`` to write only error-level entries to CloudWatch Logs, or choose ``INFO`` to include all ``ERROR`` events as well as extra informational events.\n')
    metrics_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether Amazon CloudWatch metrics are enabled for this method.\n')
    resource_path: typing.Optional[str] = pydantic.Field(None, description='The resource path for this method. Forward slashes ( ``/`` ) are encoded as ``~1`` and the initial slash must include a forward slash. For example, the path value ``/resource/subresource`` must be encoded as ``/~1resource~1subresource`` . To specify the root path, use only a slash ( ``/`` ).\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling burst limit.\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling rate limit.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-deployment-methodsetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    method_setting_property = apigateway.CfnDeployment.MethodSettingProperty(\n        cache_data_encrypted=False,\n        cache_ttl_in_seconds=123,\n        caching_enabled=False,\n        data_trace_enabled=False,\n        http_method="httpMethod",\n        logging_level="loggingLevel",\n        metrics_enabled=False,\n        resource_path="resourcePath",\n        throttling_burst_limit=123,\n        throttling_rate_limit=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_data_encrypted', 'cache_ttl_in_seconds', 'caching_enabled', 'data_trace_enabled', 'http_method', 'logging_level', 'metrics_enabled', 'resource_path', 'throttling_burst_limit', 'throttling_rate_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDeployment.MethodSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDeployment.StageDescriptionProperty
class CfnDeployment_StageDescriptionPropertyDef(BaseStruct):
    access_log_setting: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_AccessLogSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies settings for logging access in this stage.\n')
    cache_cluster_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether a cache cluster is enabled for the stage.\n')
    cache_cluster_size: typing.Optional[str] = pydantic.Field(None, description="The size of the stage's cache cluster. For more information, see `cacheClusterSize <https://docs.aws.amazon.com/apigateway/latest/api/API_CreateStage.html#apigw-CreateStage-request-cacheClusterSize>`_ in the *API Gateway API Reference* .\n")
    cache_data_encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the cached responses are encrypted.\n')
    cache_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses.\n')
    caching_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether responses are cached and returned for requests. You must enable a cache cluster on the stage to cache responses. For more information, see `Enable API Gateway Caching in a Stage to Enhance API Performance <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html>`_ in the *API Gateway Developer Guide* .\n')
    canary_setting: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_CanarySettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies settings for the canary deployment in this stage.\n')
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the client certificate that API Gateway uses to call your integration endpoints in the stage.\n')
    data_trace_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether data trace logging is enabled for methods in the stage. API Gateway pushes these logs to Amazon CloudWatch Logs.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the stage.\n')
    documentation_version: typing.Optional[str] = pydantic.Field(None, description='The version identifier of the API documentation snapshot.\n')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='The logging level for this method. For valid values, see the ``loggingLevel`` property of the `MethodSetting <https://docs.aws.amazon.com/apigateway/latest/api/API_MethodSetting.html>`_ resource in the *Amazon API Gateway API Reference* .\n')
    method_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_MethodSettingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Configures settings for all of the stage's methods.\n")
    metrics_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether Amazon CloudWatch metrics are enabled for methods in the stage.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of arbitrary tags (key-value pairs) to associate with the stage.\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The target request burst rate limit. This allows more requests through for a period of time than the target rate limit. For more information, see `Manage API Request Throttling <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html>`_ in the *API Gateway Developer Guide* .\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The target request steady-state rate limit. For more information, see `Manage API Request Throttling <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html>`_ in the *API Gateway Developer Guide* .\n')
    tracing_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether active tracing with X-ray is enabled for this stage. For more information, see `Trace API Gateway API Execution with AWS X-Ray <https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-xray.html>`_ in the *API Gateway Developer Guide* .\n')
    variables: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='A map that defines the stage variables. Variable names must consist of alphanumeric characters, and the values must match the following regular expression: ``[A-Za-z0-9-._~:/?#&=,]+`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-deployment-stagedescription.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    stage_description_property = apigateway.CfnDeployment.StageDescriptionProperty(\n        access_log_setting=apigateway.CfnDeployment.AccessLogSettingProperty(\n            destination_arn="destinationArn",\n            format="format"\n        ),\n        cache_cluster_enabled=False,\n        cache_cluster_size="cacheClusterSize",\n        cache_data_encrypted=False,\n        cache_ttl_in_seconds=123,\n        caching_enabled=False,\n        canary_setting=apigateway.CfnDeployment.CanarySettingProperty(\n            percent_traffic=123,\n            stage_variable_overrides={\n                "stage_variable_overrides_key": "stageVariableOverrides"\n            },\n            use_stage_cache=False\n        ),\n        client_certificate_id="clientCertificateId",\n        data_trace_enabled=False,\n        description="description",\n        documentation_version="documentationVersion",\n        logging_level="loggingLevel",\n        method_settings=[apigateway.CfnDeployment.MethodSettingProperty(\n            cache_data_encrypted=False,\n            cache_ttl_in_seconds=123,\n            caching_enabled=False,\n            data_trace_enabled=False,\n            http_method="httpMethod",\n            logging_level="loggingLevel",\n            metrics_enabled=False,\n            resource_path="resourcePath",\n            throttling_burst_limit=123,\n            throttling_rate_limit=123\n        )],\n        metrics_enabled=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        throttling_burst_limit=123,\n        throttling_rate_limit=123,\n        tracing_enabled=False,\n        variables={\n            "variables_key": "variables"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_log_setting', 'cache_cluster_enabled', 'cache_cluster_size', 'cache_data_encrypted', 'cache_ttl_in_seconds', 'caching_enabled', 'canary_setting', 'client_certificate_id', 'data_trace_enabled', 'description', 'documentation_version', 'logging_level', 'method_settings', 'metrics_enabled', 'tags', 'throttling_burst_limit', 'throttling_rate_limit', 'tracing_enabled', 'variables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDeployment.StageDescriptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDocumentationPart.LocationProperty
class CfnDocumentationPart_LocationPropertyDef(BaseStruct):
    method: typing.Optional[str] = pydantic.Field(None, description="The HTTP verb of a method. It is a valid field for the API entity types of ``METHOD`` , ``PATH_PARAMETER`` , ``QUERY_PARAMETER`` , ``REQUEST_HEADER`` , ``REQUEST_BODY`` , ``RESPONSE`` , ``RESPONSE_HEADER`` , and ``RESPONSE_BODY`` . The default value is ``*`` for any method. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other ``location`` attributes, the child entity's ``method`` attribute must match that of the parent entity exactly.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the targeted API entity. It is a valid and required field for the API entity types of ``AUTHORIZER`` , ``MODEL`` , ``PATH_PARAMETER`` , ``QUERY_PARAMETER`` , ``REQUEST_HEADER`` , ``REQUEST_BODY`` and ``RESPONSE_HEADER`` . It is an invalid field for any other entity type.\n')
    path: typing.Optional[str] = pydantic.Field(None, description="The URL path of the target. It is a valid field for the API entity types of ``RESOURCE`` , ``METHOD`` , ``PATH_PARAMETER`` , ``QUERY_PARAMETER`` , ``REQUEST_HEADER`` , ``REQUEST_BODY`` , ``RESPONSE`` , ``RESPONSE_HEADER`` , and ``RESPONSE_BODY`` . The default value is ``/`` for the root resource. When an applicable child entity inherits the content of another entity of the same type with more general specifications of the other ``location`` attributes, the child entity's ``path`` attribute must match that of the parent entity as a prefix.\n")
    status_code: typing.Optional[str] = pydantic.Field(None, description="The HTTP status code of a response. It is a valid field for the API entity types of ``RESPONSE`` , ``RESPONSE_HEADER`` , and ``RESPONSE_BODY`` . The default value is ``*`` for any status code. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other ``location`` attributes, the child entity's ``statusCode`` attribute must match that of the parent entity exactly.\n")
    type: typing.Optional[str] = pydantic.Field(None, description='The type of API entity to which the documentation content applies. Valid values are ``API`` , ``AUTHORIZER`` , ``MODEL`` , ``RESOURCE`` , ``METHOD`` , ``PATH_PARAMETER`` , ``QUERY_PARAMETER`` , ``REQUEST_HEADER`` , ``REQUEST_BODY`` , ``RESPONSE`` , ``RESPONSE_HEADER`` , and ``RESPONSE_BODY`` . Content inheritance does not apply to any entity of the ``API`` , ``AUTHORIZER`` , ``METHOD`` , ``MODEL`` , ``REQUEST_BODY`` , or ``RESOURCE`` type.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-documentationpart-location.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    location_property = apigateway.CfnDocumentationPart.LocationProperty(\n        method="method",\n        name="name",\n        path="path",\n        status_code="statusCode",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['method', 'name', 'path', 'status_code', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDocumentationPart.LocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDomainName.EndpointConfigurationProperty
class CfnDomainName_EndpointConfigurationPropertyDef(BaseStruct):
    types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of endpoint types of an API (RestApi) or its custom domain name (DomainName). For an edge-optimized API and its custom domain name, the endpoint type is ``"EDGE"`` . For a regional API and its custom domain name, the endpoint type is ``REGIONAL`` . For a private API, the endpoint type is ``PRIVATE`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-domainname-endpointconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    endpoint_configuration_property = apigateway.CfnDomainName.EndpointConfigurationProperty(\n        types=["types"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['types']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDomainName.EndpointConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDomainName.MutualTlsAuthenticationProperty
class CfnDomainName_MutualTlsAuthenticationPropertyDef(BaseStruct):
    truststore_uri: typing.Optional[str] = pydantic.Field(None, description='An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example ``s3://bucket-name/key-name`` . The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.\n')
    truststore_version: typing.Optional[str] = pydantic.Field(None, description='The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-domainname-mutualtlsauthentication.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    mutual_tls_authentication_property = apigateway.CfnDomainName.MutualTlsAuthenticationProperty(\n        truststore_uri="truststoreUri",\n        truststore_version="truststoreVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['truststore_uri', 'truststore_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDomainName.MutualTlsAuthenticationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnMethod.IntegrationProperty
class CfnMethod_IntegrationPropertyDef(BaseStruct):
    cache_key_parameters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of request parameters whose values API Gateway caches. To be valid values for ``cacheKeyParameters`` , these parameters must also be specified for Method ``requestParameters`` .\n')
    cache_namespace: typing.Optional[str] = pydantic.Field(None, description='Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the ``cacheNamespace`` . You can specify the same ``cacheNamespace`` across resources to return the same cached data for requests to different resources.\n')
    connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VpcLink used for the integration when ``connectionType=VPC_LINK`` and undefined, otherwise.\n')
    connection_type: typing.Optional[str] = pydantic.Field(None, description='The type of the network connection to the integration endpoint. The valid value is ``INTERNET`` for connections through the public routable internet or ``VPC_LINK`` for private connections between API Gateway and a network load balancer in a VPC. The default value is ``INTERNET`` .\n')
    content_handling: typing.Optional[str] = pydantic.Field(None, description='Specifies how to handle request payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT`` , with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the ``passthroughBehavior`` is configured to support payload pass-through.\n')
    credentials: typing.Optional[str] = pydantic.Field(None, description="Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string ``arn:aws:iam::\\*:user/\\*`` . To use resource-based permissions on supported AWS services, specify null.\n")
    integration_http_method: typing.Optional[str] = pydantic.Field(None, description="Specifies the integration's HTTP method type. For the Type property, if you specify ``MOCK`` , this property is optional. For Lambda integrations, you must set the integration method to ``POST`` . For all other types, you must specify this property.\n")
    integration_responses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnMethod_IntegrationResponsePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Specifies the integration's responses.\n")
    passthrough_behavior: typing.Optional[str] = pydantic.Field(None, description='Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in ``requestTemplates`` . The valid value is one of the following: ``WHEN_NO_MATCH`` : passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. ``WHEN_NO_TEMPLATES`` : passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. ``NEVER`` : rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.\n')
    request_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of ``method.request.{location}.{name}`` , where ``location`` is ``querystring`` , ``path`` , or ``header`` and ``name`` must be a valid and unique method request parameter name.\n')
    request_templates: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.\n')
    timeout_in_millis: typing.Union[int, float, None] = pydantic.Field(None, description='Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='Specifies an API method integration type. The valid value is one of the following:. For the HTTP and HTTP proxy integrations, each integration can specify a protocol ( ``http/https`` ), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a ``connectionType`` of ``VPC_LINK`` is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='Specifies Uniform Resource Identifier (URI) of the integration endpoint. For ``HTTP`` or ``HTTP_PROXY`` integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If ``connectionType`` is ``VPC_LINK`` specify the Network Load Balancer DNS name. For ``AWS`` or ``AWS_PROXY`` integrations, the URI is of the form ``arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}`` . Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS service for fast host-name lookup. action can be used for an AWS service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an AWS service path-based API. The ensuing service_api refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either ``arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}`` or ``arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apitgateway-method-integration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    integration_property = apigateway.CfnMethod.IntegrationProperty(\n        cache_key_parameters=["cacheKeyParameters"],\n        cache_namespace="cacheNamespace",\n        connection_id="connectionId",\n        connection_type="connectionType",\n        content_handling="contentHandling",\n        credentials="credentials",\n        integration_http_method="integrationHttpMethod",\n        integration_responses=[apigateway.CfnMethod.IntegrationResponseProperty(\n            status_code="statusCode",\n\n            # the properties below are optional\n            content_handling="contentHandling",\n            response_parameters={\n                "response_parameters_key": "responseParameters"\n            },\n            response_templates={\n                "response_templates_key": "responseTemplates"\n            },\n            selection_pattern="selectionPattern"\n        )],\n        passthrough_behavior="passthroughBehavior",\n        request_parameters={\n            "request_parameters_key": "requestParameters"\n        },\n        request_templates={\n            "request_templates_key": "requestTemplates"\n        },\n        timeout_in_millis=123,\n        type="type",\n        uri="uri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_key_parameters', 'cache_namespace', 'connection_id', 'connection_type', 'content_handling', 'credentials', 'integration_http_method', 'integration_responses', 'passthrough_behavior', 'request_parameters', 'request_templates', 'timeout_in_millis', 'type', 'uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnMethod.IntegrationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnMethod.IntegrationResponseProperty
class CfnMethod_IntegrationResponsePropertyDef(BaseStruct):
    status_code: str = pydantic.Field(..., description='Specifies the status code that is used to map the integration response to an existing MethodResponse.\n')
    content_handling: typing.Optional[str] = pydantic.Field(None, description='Specifies how to handle response payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT`` , with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.\n')
    response_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of ``method.response.header.{name}`` , where ``name`` is a valid and unique header name. The mapped non-static value must match the pattern of ``integration.response.header.{name}`` or ``integration.response.body.{JSON-expression}`` , where ``name`` is a valid and unique response header name and ``JSON-expression`` is a valid JSON expression without the ``$`` prefix.\n')
    response_templates: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.\n')
    selection_pattern: typing.Optional[str] = pydantic.Field(None, description='Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the ``.+`` regex to match error response. However, make sure that the error response does not contain any newline ( ``\\n`` ) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apitgateway-method-integration-integrationresponse.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    integration_response_property = apigateway.CfnMethod.IntegrationResponseProperty(\n        status_code="statusCode",\n\n        # the properties below are optional\n        content_handling="contentHandling",\n        response_parameters={\n            "response_parameters_key": "responseParameters"\n        },\n        response_templates={\n            "response_templates_key": "responseTemplates"\n        },\n        selection_pattern="selectionPattern"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['status_code', 'content_handling', 'response_parameters', 'response_templates', 'selection_pattern']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnMethod.IntegrationResponseProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnMethod.MethodResponseProperty
class CfnMethod_MethodResponsePropertyDef(BaseStruct):
    status_code: str = pydantic.Field(..., description="The method response's status code.\n")
    response_models: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description="Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.\n")
    response_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]]], None] = pydantic.Field(None, description='A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern ``method.response.header.{name}`` , where ``name`` is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API\'s IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in ``integration.response.header.{name}`` , a static value enclosed within a pair of single quotes (e.g., ``\'application/json\'`` ), or a JSON expression from the back-end response payload in the form of ``integration.response.body.{JSON-expression}`` , where ``JSON-expression`` is a valid JSON expression without the ``$`` prefix.)\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apitgateway-method-methodresponse.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    method_response_property = apigateway.CfnMethod.MethodResponseProperty(\n        status_code="statusCode",\n\n        # the properties below are optional\n        response_models={\n            "response_models_key": "responseModels"\n        },\n        response_parameters={\n            "response_parameters_key": False\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['status_code', 'response_models', 'response_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnMethod.MethodResponseProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnRestApi.EndpointConfigurationProperty
class CfnRestApi_EndpointConfigurationPropertyDef(BaseStruct):
    types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of endpoint types of an API (RestApi) or its custom domain name (DomainName). For an edge-optimized API and its custom domain name, the endpoint type is ``"EDGE"`` . For a regional API and its custom domain name, the endpoint type is ``REGIONAL`` . For a private API, the endpoint type is ``PRIVATE`` .\n')
    vpc_endpoint_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of VpcEndpointIds of an API (RestApi) against which to create Route53 ALIASes. It is only supported for ``PRIVATE`` endpoint type.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-endpointconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    endpoint_configuration_property = apigateway.CfnRestApi.EndpointConfigurationProperty(\n        types=["types"],\n        vpc_endpoint_ids=["vpcEndpointIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['types', 'vpc_endpoint_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnRestApi.EndpointConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnRestApi.S3LocationProperty
class CfnRestApi_S3LocationPropertyDef(BaseStruct):
    bucket: typing.Optional[str] = pydantic.Field(None, description='The name of the S3 bucket where the OpenAPI file is stored.\n')
    e_tag: typing.Optional[str] = pydantic.Field(None, description="The Amazon S3 ETag (a file checksum) of the OpenAPI file. If you don't specify a value, API Gateway skips ETag validation of your OpenAPI file.\n")
    key: typing.Optional[str] = pydantic.Field(None, description='The file name of the OpenAPI file (Amazon S3 object name).\n')
    version: typing.Optional[str] = pydantic.Field(None, description='For versioning-enabled buckets, a specific version of the OpenAPI file.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-restapi-s3location.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    s3_location_property = apigateway.CfnRestApi.S3LocationProperty(\n        bucket="bucket",\n        e_tag="eTag",\n        key="key",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'e_tag', 'key', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnRestApi.S3LocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnStage.AccessLogSettingProperty
class CfnStage_AccessLogSettingPropertyDef(BaseStruct):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with ``amazon-apigateway-`` . This parameter is required to enable access logging.\n')
    format: typing.Optional[str] = pydantic.Field(None, description='A single line format of the access logs of data, as specified by selected `$context variables <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference>`_ . The format must include at least ``$context.requestId`` . This parameter is required to enable access logging.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-stage-accesslogsetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    access_log_setting_property = apigateway.CfnStage.AccessLogSettingProperty(\n        destination_arn="destinationArn",\n        format="format"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_arn', 'format']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnStage.AccessLogSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnStage.CanarySettingProperty
class CfnStage_CanarySettingPropertyDef(BaseStruct):
    deployment_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the canary deployment.\n')
    percent_traffic: typing.Union[int, float, None] = pydantic.Field(None, description='The percent (0-100) of traffic diverted to a canary deployment.\n')
    stage_variable_overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.\n')
    use_stage_cache: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean flag to indicate whether the canary deployment uses the stage cache or not.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-stage-canarysetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    canary_setting_property = apigateway.CfnStage.CanarySettingProperty(\n        deployment_id="deploymentId",\n        percent_traffic=123,\n        stage_variable_overrides={\n            "stage_variable_overrides_key": "stageVariableOverrides"\n        },\n        use_stage_cache=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_id', 'percent_traffic', 'stage_variable_overrides', 'use_stage_cache']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnStage.CanarySettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnStage.MethodSettingProperty
class CfnStage_MethodSettingPropertyDef(BaseStruct):
    cache_data_encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether the cached responses are encrypted.\n')
    cache_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.\n')
    caching_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.\n')
    data_trace_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs.\n')
    http_method: typing.Optional[str] = pydantic.Field(None, description='The HTTP method. To apply settings to multiple resources and methods, specify an asterisk ( ``*`` ) for the ``HttpMethod`` and ``/*`` for the ``ResourcePath`` . This parameter is required when you specify a ``MethodSetting`` .\n')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are ``OFF`` , ``ERROR`` , and ``INFO`` . Choose ``ERROR`` to write only error-level entries to CloudWatch Logs, or choose ``INFO`` to include all ``ERROR`` events as well as extra informational events.\n')
    metrics_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether Amazon CloudWatch metrics are enabled for this method.\n')
    resource_path: typing.Optional[str] = pydantic.Field(None, description='The resource path for this method. Forward slashes ( ``/`` ) are encoded as ``~1`` and the initial slash must include a forward slash. For example, the path value ``/resource/subresource`` must be encoded as ``/~1resource~1subresource`` . To specify the root path, use only a slash ( ``/`` ). To apply settings to multiple resources and methods, specify an asterisk ( ``*`` ) for the ``HttpMethod`` and ``/*`` for the ``ResourcePath`` . This parameter is required when you specify a ``MethodSetting`` .\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling burst limit.\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling rate limit.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-stage-methodsetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    method_setting_property = apigateway.CfnStage.MethodSettingProperty(\n        cache_data_encrypted=False,\n        cache_ttl_in_seconds=123,\n        caching_enabled=False,\n        data_trace_enabled=False,\n        http_method="httpMethod",\n        logging_level="loggingLevel",\n        metrics_enabled=False,\n        resource_path="resourcePath",\n        throttling_burst_limit=123,\n        throttling_rate_limit=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_data_encrypted', 'cache_ttl_in_seconds', 'caching_enabled', 'data_trace_enabled', 'http_method', 'logging_level', 'metrics_enabled', 'resource_path', 'throttling_burst_limit', 'throttling_rate_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnStage.MethodSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnUsagePlan.ApiStageProperty
class CfnUsagePlan_ApiStagePropertyDef(BaseStruct):
    api_id: typing.Optional[str] = pydantic.Field(None, description='API Id of the associated API stage in a usage plan.\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='API stage name of the associated API stage in a usage plan.\n')
    throttle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnUsagePlan_ThrottleSettingsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Map containing method level throttling information for API stage in a usage plan.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-usageplan-apistage.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    api_stage_property = apigateway.CfnUsagePlan.ApiStageProperty(\n        api_id="apiId",\n        stage="stage",\n        throttle={\n            "throttle_key": apigateway.CfnUsagePlan.ThrottleSettingsProperty(\n                burst_limit=123,\n                rate_limit=123\n            )\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'stage', 'throttle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnUsagePlan.ApiStageProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnUsagePlan.QuotaSettingsProperty
class CfnUsagePlan_QuotaSettingsPropertyDef(BaseStruct):
    limit: typing.Union[int, float, None] = pydantic.Field(None, description='The target maximum number of requests that can be made in a given time period.\n')
    offset: typing.Union[int, float, None] = pydantic.Field(None, description='The number of requests subtracted from the given limit in the initial time period.\n')
    period: typing.Optional[str] = pydantic.Field(None, description='The time period in which the limit applies. Valid values are "DAY", "WEEK" or "MONTH".\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-usageplan-quotasettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    quota_settings_property = apigateway.CfnUsagePlan.QuotaSettingsProperty(\n        limit=123,\n        offset=123,\n        period="period"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['limit', 'offset', 'period']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnUsagePlan.QuotaSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnUsagePlan.ThrottleSettingsProperty
class CfnUsagePlan_ThrottleSettingsPropertyDef(BaseStruct):
    burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The API target request burst rate limit. This allows more requests through for a period of time than the target rate limit.\n')
    rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The API target request rate limit.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-usageplan-throttlesettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    throttle_settings_property = apigateway.CfnUsagePlan.ThrottleSettingsProperty(\n        burst_limit=123,\n        rate_limit=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['burst_limit', 'rate_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnUsagePlan.ThrottleSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CognitoUserPoolsAuthorizerProps
class CognitoUserPoolsAuthorizerPropsDef(BaseStruct):
    cognito_user_pools: typing.Sequence[typing.Union[models.aws_cognito.UserPoolDef]] = pydantic.Field(..., description='The user pools to associate with this authorizer.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='An optional human friendly name for the authorizer. Note that, this is not the primary identifier of the authorizer. Default: - the unique construct ID\n')
    identity_source: typing.Optional[str] = pydantic.Field(None, description="The request header mapping expression for the bearer token. This is typically passed as part of the header, in which case this should be ``method.request.header.Authorizer`` where Authorizer is the header containing the bearer token. Default: ``IdentitySource.header('Authorization')``\n")
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to 0. Default: Duration.minutes(5)\n\n:exampleMetadata: infused\n\nExample::\n\n    # books: apigateway.Resource\n    user_pool = cognito.UserPool(self, "UserPool")\n\n    auth = apigateway.CognitoUserPoolsAuthorizer(self, "booksAuthorizer",\n        cognito_user_pools=[user_pool]\n    )\n    books.add_method("GET", apigateway.HttpIntegration("http://amazon.com"),\n        authorizer=auth,\n        authorization_type=apigateway.AuthorizationType.COGNITO\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cognito_user_pools', 'authorizer_name', 'identity_source', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CognitoUserPoolsAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CorsOptions
class CorsOptionsDef(BaseStruct):
    allow_origins: typing.Sequence[str] = pydantic.Field(..., description='Specifies the list of origins that are allowed to make requests to this resource. If you wish to allow all origins, specify ``Cors.ALL_ORIGINS`` or ``[ * ]``. Responses will include the ``Access-Control-Allow-Origin`` response header. If ``Cors.ALL_ORIGINS`` is specified, the ``Vary: Origin`` response header will also be included.')
    allow_credentials: typing.Optional[bool] = pydantic.Field(None, description='The Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request\'s credentials mode (Request.credentials) is "include". When a request\'s credentials mode (Request.credentials) is "include", browsers will only expose the response to frontend JavaScript code if the Access-Control-Allow-Credentials value is true. Credentials are cookies, authorization headers or TLS client certificates. Default: false\n')
    allow_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Allow-Headers response header is used in response to a preflight request which includes the Access-Control-Request-Headers to indicate which HTTP headers can be used during the actual request. Default: Cors.DEFAULT_HEADERS\n')
    allow_methods: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Allow-Methods response header specifies the method or methods allowed when accessing the resource in response to a preflight request. If ``ANY`` is specified, it will be expanded to ``Cors.ALL_METHODS``. Default: Cors.ALL_METHODS\n')
    disable_cache: typing.Optional[bool] = pydantic.Field(None, description='Sets Access-Control-Max-Age to -1, which means that caching is disabled. This option cannot be used with ``maxAge``. Default: - cache is enabled\n')
    expose_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Access-Control-Expose-Headers response header indicates which headers can be exposed as part of the response by listing their names. If you want clients to be able to access other headers, you have to list them using the Access-Control-Expose-Headers header. Default: - only the 6 CORS-safelisted response headers are exposed: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma\n')
    max_age: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The Access-Control-Max-Age response header indicates how long the results of a preflight request (that is the information contained in the Access-Control-Allow-Methods and Access-Control-Allow-Headers headers) can be cached. To disable caching altogether use ``disableCache: true``. Default: - browser-specific (see reference)\n')
    status_code: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the response status code returned from the OPTIONS method. Default: 204\n\n:exampleMetadata: infused\n\nExample::\n\n    apigateway.RestApi(self, "api",\n        default_cors_preflight_options=apigateway.CorsOptions(\n            allow_origins=apigateway.Cors.ALL_ORIGINS,\n            allow_methods=apigateway.Cors.ALL_METHODS\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_origins', 'allow_credentials', 'allow_headers', 'allow_methods', 'disable_cache', 'expose_headers', 'max_age', 'status_code']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CorsOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.DeploymentProps
class DeploymentPropsDef(BaseStruct):
    api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The Rest API to deploy.')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API Gateway deployment. Default: - No description.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='When an API Gateway model is updated, a new deployment will automatically be created. If this is true, the old API Gateway Deployment resource will not be deleted. This will allow manually reverting back to a previous deployment in case for example Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    # production stage\n    prd_log_group = logs.LogGroup(self, "PrdLogs")\n    api = apigateway.RestApi(self, "books",\n        deploy_options=apigateway.StageOptions(\n            access_log_destination=apigateway.LogGroupLogDestination(prd_log_group),\n            access_log_format=apigateway.AccessLogFormat.json_with_standard_fields()\n        )\n    )\n    deployment = apigateway.Deployment(self, "Deployment", api=api)\n\n    # development stage\n    dev_log_group = logs.LogGroup(self, "DevLogs")\n    apigateway.Stage(self, "dev",\n        deployment=deployment,\n        access_log_destination=apigateway.LogGroupLogDestination(dev_log_group),\n        access_log_format=apigateway.AccessLogFormat.json_with_standard_fields(\n            caller=False,\n            http_method=True,\n            ip=True,\n            protocol=True,\n            request_time=True,\n            resource_path=True,\n            response_length=True,\n            status=True,\n            user=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api', 'description', 'retain_deployments']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.DeploymentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.DomainNameAttributes
class DomainNameAttributesDef(BaseStruct):
    domain_name: str = pydantic.Field(..., description='The domain name (e.g. ``example.com``).')
    domain_name_alias_hosted_zone_id: str = pydantic.Field(..., description='The Route53 hosted zone ID to use in order to connect a record set to this domain through an alias.\n')
    domain_name_alias_target: str = pydantic.Field(..., description='The Route53 alias target to use in order to connect a record set to this domain through an alias.\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigateway.RestApi\n\n\n    domain_name = apigateway.DomainName.from_domain_name_attributes(self, "DomainName",\n        domain_name="domainName",\n        domain_name_alias_hosted_zone_id="domainNameAliasHostedZoneId",\n        domain_name_alias_target="domainNameAliasTarget"\n    )\n\n    apigateway.BasePathMapping(self, "BasePathMapping",\n        domain_name=domain_name,\n        rest_api=api\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'domain_name_alias_hosted_zone_id', 'domain_name_alias_target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.DomainNameAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.DomainNameOptions
class DomainNameOptionsDef(BaseStruct):
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The reference to an AWS-managed certificate for use by the edge-optimized endpoint for the domain name. For "EDGE" domain names, the certificate needs to be in the US East (N. Virginia) region.')
    domain_name: str = pydantic.Field(..., description='The custom domain name for your API. Uppercase letters are not supported.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``).\n")
    endpoint_type: typing.Optional[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: REGIONAL\n')
    mtls: typing.Union[models.aws_apigateway.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    security_policy: typing.Optional[aws_cdk.aws_apigateway.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2\n\n:exampleMetadata: infused\n\nExample::\n\n    # acm_certificate_for_example_com: Any\n\n\n    api = apigateway.RestApi(self, "MyDomain",\n        domain_name=apigateway.DomainNameOptions(\n            domain_name="example.com",\n            certificate=acm_certificate_for_example_com\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate', 'domain_name', 'base_path', 'endpoint_type', 'mtls', 'security_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.DomainNameOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[DomainNameOptionsDefConfig] = pydantic.Field(None)


class DomainNameOptionsDefConfig(pydantic.BaseModel):
    certificate_config: typing.Optional[models._interface_methods.AwsCertificatemanagerICertificateDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.DomainNameProps
class DomainNamePropsDef(BaseStruct):
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The reference to an AWS-managed certificate for use by the edge-optimized endpoint for the domain name. For "EDGE" domain names, the certificate needs to be in the US East (N. Virginia) region.')
    domain_name: str = pydantic.Field(..., description='The custom domain name for your API. Uppercase letters are not supported.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description="The base path name that callers of the API must provide in the URL after the domain name (e.g. ``example.com/base-path``). If you specify this property, it can't be an empty string. Default: - map requests from the domain root (e.g. ``example.com``).\n")
    endpoint_type: typing.Optional[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: REGIONAL\n')
    mtls: typing.Union[models.aws_apigateway.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    security_policy: typing.Optional[aws_cdk.aws_apigateway.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2\n')
    mapping: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='If specified, all requests to this domain will be mapped to the production deployment of this API. If you wish to map this domain to multiple APIs with different base paths, use ``addBasePathMapping`` or ``addApiMapping``. Default: - you will have to call ``addBasePathMapping`` to map this domain to API endpoints.\n\n:exampleMetadata: infused\n\nExample::\n\n    # acm_certificate_for_example_com: Any\n    # rest_api: apigateway.RestApi\n\n\n    apigateway.DomainName(self, "custom-domain",\n        domain_name="example.com",\n        certificate=acm_certificate_for_example_com,\n        mapping=rest_api,\n        base_path="orders/v1/api"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate', 'domain_name', 'base_path', 'endpoint_type', 'mtls', 'security_policy', 'mapping']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.DomainNameProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[DomainNamePropsDefConfig] = pydantic.Field(None)


class DomainNamePropsDefConfig(pydantic.BaseModel):
    certificate_config: typing.Optional[models._interface_methods.AwsCertificatemanagerICertificateDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.EndpointConfiguration
class EndpointConfigurationDef(BaseStruct):
    types: typing.Sequence[aws_cdk.aws_apigateway.EndpointType] = pydantic.Field(..., description='A list of endpoint types of an API or its custom domain name. Default: EndpointType.EDGE\n')
    vpc_endpoints: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.VpcEndpointDef, models.aws_ec2.GatewayVpcEndpointDef, models.aws_ec2.InterfaceVpcEndpointDef]]] = pydantic.Field(None, description='A list of VPC Endpoints against which to create Route53 ALIASes. Default: - no ALIASes are created for the endpoint.\n\n:exampleMetadata: infused\n\nExample::\n\n    api = apigateway.RestApi(self, "api",\n        endpoint_configuration=apigateway.EndpointConfiguration(\n            types=[apigateway.EndpointType.EDGE]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['types', 'vpc_endpoints']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.EndpointConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.GatewayResponseOptions
class GatewayResponseOptionsDef(BaseStruct):
    type: models.aws_apigateway.ResponseTypeDef = pydantic.Field(..., description='Response type to associate with gateway response.\n')
    response_headers: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom headers parameters for response. Default: - no headers\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='Http status code for response. Default: - standard http status code for the response type.\n')
    templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom templates to get mapped as response. Default: - Response from api will be returned without applying any transformation.\n\n:exampleMetadata: infused\n\nExample::\n\n    api = apigateway.RestApi(self, "books-api")\n    api.add_gateway_response("test-response",\n        type=apigateway.ResponseType.ACCESS_DENIED,\n        status_code="500",\n        response_headers={\n            # Note that values must be enclosed within a pair of single quotes\n            "Access-Control-Allow-Origin": "\'test.com\'",\n            "test-key": "\'test-value\'"\n        },\n        templates={\n            "application/json": "{ "message": $context.error.messageString, "statusCode": "488", "type": "$context.error.responseType" }"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'response_headers', 'status_code', 'templates']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.GatewayResponseOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.GatewayResponseProps
class GatewayResponsePropsDef(BaseStruct):
    type: models.aws_apigateway.ResponseTypeDef = pydantic.Field(..., description='Response type to associate with gateway response.\n')
    response_headers: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom headers parameters for response. Default: - no headers\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='Http status code for response. Default: - standard http status code for the response type.\n')
    templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom templates to get mapped as response. Default: - Response from api will be returned without applying any transformation.\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='Rest api resource to target.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # response_type: apigateway.ResponseType\n    # rest_api: apigateway.RestApi\n\n    gateway_response_props = apigateway.GatewayResponseProps(\n        rest_api=rest_api,\n        type=response_type,\n\n        # the properties below are optional\n        response_headers={\n            "response_headers_key": "responseHeaders"\n        },\n        status_code="statusCode",\n        templates={\n            "templates_key": "templates"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'response_headers', 'status_code', 'templates', 'rest_api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.GatewayResponseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.HttpIntegrationProps
class HttpIntegrationPropsDef(BaseStruct):
    http_method: typing.Optional[str] = pydantic.Field(None, description='HTTP method to use when invoking the backend URL. Default: GET')
    options: typing.Union[models.aws_apigateway.IntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Integration options, such as request/resopnse mapping, content handling, etc. Default: defaults based on ``IntegrationOptions`` defaults\n')
    proxy: typing.Optional[bool] = pydantic.Field(None, description='Determines whether to use proxy integration or custom integration. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigateway as apigateway\n    from aws_cdk import aws_iam as iam\n\n    # role: iam.Role\n    # vpc_link: apigateway.VpcLink\n\n    http_integration_props = apigateway.HttpIntegrationProps(\n        http_method="httpMethod",\n        options=apigateway.IntegrationOptions(\n            cache_key_parameters=["cacheKeyParameters"],\n            cache_namespace="cacheNamespace",\n            connection_type=apigateway.ConnectionType.INTERNET,\n            content_handling=apigateway.ContentHandling.CONVERT_TO_BINARY,\n            credentials_passthrough=False,\n            credentials_role=role,\n            integration_responses=[apigateway.IntegrationResponse(\n                status_code="statusCode",\n\n                # the properties below are optional\n                content_handling=apigateway.ContentHandling.CONVERT_TO_BINARY,\n                response_parameters={\n                    "response_parameters_key": "responseParameters"\n                },\n                response_templates={\n                    "response_templates_key": "responseTemplates"\n                },\n                selection_pattern="selectionPattern"\n            )],\n            passthrough_behavior=apigateway.PassthroughBehavior.WHEN_NO_MATCH,\n            request_parameters={\n                "request_parameters_key": "requestParameters"\n            },\n            request_templates={\n                "request_templates_key": "requestTemplates"\n            },\n            timeout=cdk.Duration.minutes(30),\n            vpc_link=vpc_link\n        ),\n        proxy=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_method', 'options', 'proxy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.HttpIntegrationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.IntegrationConfig
class IntegrationConfigDef(BaseStruct):
    type: aws_cdk.aws_apigateway.IntegrationType = pydantic.Field(..., description='Specifies an API method integration type.\n')
    deployment_token: typing.Optional[str] = pydantic.Field(None, description="This value is included in computing the Deployment's fingerprint. When the fingerprint changes, a new deployment is triggered. This property should contain values associated with the Integration that upon changing should trigger a fresh the Deployment needs to be refreshed. Default: undefined deployments are not triggered for any change to this integration.\n")
    integration_http_method: typing.Optional[str] = pydantic.Field(None, description="The integration's HTTP method type. Default: - no integration method specified.\n")
    options: typing.Union[models.aws_apigateway.IntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Integration options. Default: - no integration options\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='The Uniform Resource Identifier (URI) for the integration. Default: - no URI. Usually applies to MOCK integration\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigateway as apigateway\n    from aws_cdk import aws_iam as iam\n\n    # role: iam.Role\n    # vpc_link: apigateway.VpcLink\n\n    integration_config = apigateway.IntegrationConfig(\n        type=apigateway.IntegrationType.AWS,\n\n        # the properties below are optional\n        deployment_token="deploymentToken",\n        integration_http_method="integrationHttpMethod",\n        options=apigateway.IntegrationOptions(\n            cache_key_parameters=["cacheKeyParameters"],\n            cache_namespace="cacheNamespace",\n            connection_type=apigateway.ConnectionType.INTERNET,\n            content_handling=apigateway.ContentHandling.CONVERT_TO_BINARY,\n            credentials_passthrough=False,\n            credentials_role=role,\n            integration_responses=[apigateway.IntegrationResponse(\n                status_code="statusCode",\n\n                # the properties below are optional\n                content_handling=apigateway.ContentHandling.CONVERT_TO_BINARY,\n                response_parameters={\n                    "response_parameters_key": "responseParameters"\n                },\n                response_templates={\n                    "response_templates_key": "responseTemplates"\n                },\n                selection_pattern="selectionPattern"\n            )],\n            passthrough_behavior=apigateway.PassthroughBehavior.WHEN_NO_MATCH,\n            request_parameters={\n                "request_parameters_key": "requestParameters"\n            },\n            request_templates={\n                "request_templates_key": "requestTemplates"\n            },\n            timeout=cdk.Duration.minutes(30),\n            vpc_link=vpc_link\n        ),\n        uri="uri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'deployment_token', 'integration_http_method', 'options', 'uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.IntegrationConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.IntegrationOptions
class IntegrationOptionsDef(BaseStruct):
    cache_key_parameters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of request parameters whose values are to be cached. It determines request parameters that will make it into the cache key.')
    cache_namespace: typing.Optional[str] = pydantic.Field(None, description='An API-specific tag group of related cached parameters.\n')
    connection_type: typing.Optional[aws_cdk.aws_apigateway.ConnectionType] = pydantic.Field(None, description='The type of network connection to the integration endpoint. Default: - ConnectionType.VPC_LINK if ``vpcLink`` property is configured; ConnectionType.Internet otherwise.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigateway.ContentHandling] = pydantic.Field(None, description="Specifies how to handle request payload content type conversions. Default: none if this property isn't defined, the request payload is passed through from the method request to the integration request without modification, provided that the ``passthroughBehaviors`` property is configured to support payload pass-through.\n")
    credentials_passthrough: typing.Optional[bool] = pydantic.Field(None, description="Requires that the caller's identity be passed through from the request. Default: Caller identity is not passed through\n")
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that API Gateway assumes. Mutually exclusive with ``credentialsPassThrough``. Default: A role is not assumed\n')
    integration_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.IntegrationResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The response that API Gateway provides after a method's backend completes processing a request. API Gateway intercepts the response from the backend so that you can control how API Gateway surfaces backend responses. For example, you can map the backend status codes to codes that you define.\n")
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigateway.PassthroughBehavior] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The request parameters that API Gateway sends with the backend request. Specify request parameters as key-value pairs (string-to-string mappings), with a destination as the key and a source as the value. Specify the destination by using the following pattern integration.request.location.name, where location is querystring, path, or header, and name is a valid, unique parameter name. The source must be an existing method request parameter or a static value. You must enclose static values in single quotation marks and pre-encode these values based on their destination in the request.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map of Apache Velocity templates that are applied on the request payload. The template that API Gateway uses is based on the value of the Content-Type header that\'s sent by the client. The content type value is the key, and the template is the value (specified as a string), such as the following snippet:: { "application/json": "{ \\"statusCode\\": 200 }" }\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n')
    vpc_link: typing.Optional[typing.Union[models.aws_apigateway.VpcLinkDef]] = pydantic.Field(None, description='The VpcLink used for the integration. Required if connectionType is VPC_LINK\n\n:exampleMetadata: lit=aws-apigateway/test/authorizers/integ.request-authorizer.lit.ts infused\n\nExample::\n\n    from aws_cdk.aws_apigateway import IntegrationResponse, MethodResponse, IntegrationResponse, MethodResponse\n    import path as path\n    import aws_cdk.aws_lambda as lambda_\n    from aws_cdk import App, Stack\n    from aws_cdk.aws_apigateway import MockIntegration, PassthroughBehavior, RestApi, RequestAuthorizer, IdentitySource\n\n    # Against the RestApi endpoint from the stack output, run\n    # `curl -s -o /dev/null -w "%{http_code}" <url>` should return 401\n    # `curl -s -o /dev/null -w "%{http_code}" -H \'Authorization: deny\' <url>?allow=yes` should return 403\n    # `curl -s -o /dev/null -w "%{http_code}" -H \'Authorization: allow\' <url>?allow=yes` should return 200\n\n    app = App()\n    stack = Stack(app, "RequestAuthorizerInteg")\n\n    authorizer_fn = lambda_.Function(stack, "MyAuthorizerFunction",\n        runtime=lambda_.Runtime.NODEJS_14_X,\n        handler="index.handler",\n        code=lambda_.AssetCode.from_asset(path.join(__dirname, "integ.request-authorizer.handler"))\n    )\n\n    restapi = RestApi(stack, "MyRestApi", cloud_watch_role=True)\n\n    authorizer = RequestAuthorizer(stack, "MyAuthorizer",\n        handler=authorizer_fn,\n        identity_sources=[IdentitySource.header("Authorization"), IdentitySource.query_string("allow")]\n    )\n\n    second_authorizer = RequestAuthorizer(stack, "MySecondAuthorizer",\n        handler=authorizer_fn,\n        identity_sources=[IdentitySource.header("Authorization"), IdentitySource.query_string("allow")]\n    )\n\n    restapi.root.add_method("ANY", MockIntegration(\n        integration_responses=[IntegrationResponse(status_code="200")\n        ],\n        passthrough_behavior=PassthroughBehavior.NEVER,\n        request_templates={\n            "application/json": "{ "statusCode": 200 }"\n        }\n    ),\n        method_responses=[MethodResponse(status_code="200")\n        ],\n        authorizer=authorizer\n    )\n\n    restapi.root.resource_for_path("auth").add_method("ANY", MockIntegration(\n        integration_responses=[IntegrationResponse(status_code="200")\n        ],\n        passthrough_behavior=PassthroughBehavior.NEVER,\n        request_templates={\n            "application/json": "{ "statusCode": 200 }"\n        }\n    ),\n        method_responses=[MethodResponse(status_code="200")\n        ],\n        authorizer=second_authorizer\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_key_parameters', 'cache_namespace', 'connection_type', 'content_handling', 'credentials_passthrough', 'credentials_role', 'integration_responses', 'passthrough_behavior', 'request_parameters', 'request_templates', 'timeout', 'vpc_link']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.IntegrationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.IntegrationProps
class IntegrationPropsDef(BaseStruct):
    type: aws_cdk.aws_apigateway.IntegrationType = pydantic.Field(..., description='Specifies an API method integration type.')
    integration_http_method: typing.Optional[str] = pydantic.Field(None, description="The integration's HTTP method type. Required unless you use a MOCK integration.\n")
    options: typing.Union[models.aws_apigateway.IntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Integration options.\n')
    uri: typing.Any = pydantic.Field(None, description='The Uniform Resource Identifier (URI) for the integration. - If you specify HTTP for the ``type`` property, specify the API endpoint URL. - If you specify MOCK for the ``type`` property, don\'t specify this property. - If you specify AWS for the ``type`` property, specify an AWS service that follows this form: ``arn:partition:apigateway:region:subdomain.service|service:path|action/service_api.`` For example, a Lambda function URI follows this form: arn:partition:apigateway:region:lambda:path/path. The path is usually in the form /2015-03-31/functions/LambdaFunctionARN/invocations.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_elasticloadbalancingv2 as elbv2\n\n\n    vpc = ec2.Vpc(self, "VPC")\n    nlb = elbv2.NetworkLoadBalancer(self, "NLB",\n        vpc=vpc\n    )\n    link = apigateway.VpcLink(self, "link",\n        targets=[nlb]\n    )\n\n    integration = apigateway.Integration(\n        type=apigateway.IntegrationType.HTTP_PROXY,\n        options=apigateway.IntegrationOptions(\n            connection_type=apigateway.ConnectionType.VPC_LINK,\n            vpc_link=link\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'integration_http_method', 'options', 'uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.IntegrationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.IntegrationResponse
class IntegrationResponseDef(BaseStruct):
    status_code: str = pydantic.Field(..., description='The status code that API Gateway uses to map the integration response to a MethodResponse status code.')
    content_handling: typing.Optional[aws_cdk.aws_apigateway.ContentHandling] = pydantic.Field(None, description='Specifies how to handle request payload content type conversions. Default: none the request payload is passed through from the method request to the integration request without modification.\n')
    response_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The response parameters from the backend response that API Gateway sends to the method response. Use the destination as the key and the source as the value: - The destination must be an existing response parameter in the MethodResponse property. - The source must be an existing method request parameter or a static value. You must enclose static values in single quotation marks and pre-encode these values based on the destination specified in the request.\n')
    response_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The templates that are used to transform the integration response body. Specify templates as key-value pairs, with a content type as the key and a template as the value.\n')
    selection_pattern: typing.Optional[str] = pydantic.Field(None, description='Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the ``.+`` regex to match error response. However, make sure that the error response does not contain any newline (``\\n``) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    integration_response = apigateway.IntegrationResponse(\n        status_code="statusCode",\n\n        # the properties below are optional\n        content_handling=apigateway.ContentHandling.CONVERT_TO_BINARY,\n        response_parameters={\n            "response_parameters_key": "responseParameters"\n        },\n        response_templates={\n            "response_templates_key": "responseTemplates"\n        },\n        selection_pattern="selectionPattern"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['status_code', 'content_handling', 'response_parameters', 'response_templates', 'selection_pattern']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.IntegrationResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.JsonSchema
class JsonSchemaDef(BaseStruct):
    additional_items: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    additional_properties: typing.Union[bool, models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    all_of: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    any_of: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    contains: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any], typing.Sequence[typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    default: typing.Any = pydantic.Field(None, description='The default value if you use an enum. Default: - not set\n')
    definitions: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    dependencies: typing.Optional[typing.Mapping[str, typing.Union[typing.Sequence[str], models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    enum: typing.Optional[typing.Sequence[typing.Any]] = pydantic.Field(None, description='')
    exclusive_maximum: typing.Optional[bool] = pydantic.Field(None, description='')
    exclusive_minimum: typing.Optional[bool] = pydantic.Field(None, description='')
    format: typing.Optional[str] = pydantic.Field(None, description='')
    items: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any], typing.Sequence[typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    maximum: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_items: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_length: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_properties: typing.Union[int, float, None] = pydantic.Field(None, description='')
    minimum: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min_items: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min_length: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min_properties: typing.Union[int, float, None] = pydantic.Field(None, description='')
    multiple_of: typing.Union[int, float, None] = pydantic.Field(None, description='')
    not_: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    one_of: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    pattern: typing.Optional[str] = pydantic.Field(None, description='')
    pattern_properties: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    properties: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    property_names: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ref: typing.Optional[str] = pydantic.Field(None, description='')
    required: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    schema_: typing.Optional[aws_cdk.aws_apigateway.JsonSchemaVersion] = pydantic.Field(None, description='', alias='schema')
    title: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Union[aws_cdk.aws_apigateway.JsonSchemaType, typing.Sequence[aws_cdk.aws_apigateway.JsonSchemaType], None] = pydantic.Field(None, description='')
    unique_items: typing.Optional[bool] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['additional_items', 'additional_properties', 'all_of', 'any_of', 'contains', 'default', 'definitions', 'dependencies', 'description', 'enum', 'exclusive_maximum', 'exclusive_minimum', 'format', 'items', 'maximum', 'max_items', 'max_length', 'max_properties', 'minimum', 'min_items', 'min_length', 'min_properties', 'multiple_of', 'not_', 'one_of', 'pattern', 'pattern_properties', 'properties', 'property_names', 'ref', 'required', 'schema', 'title', 'type', 'unique_items']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.JsonSchema'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.JsonWithStandardFieldProps
class JsonWithStandardFieldPropsDef(BaseStruct):
    caller: bool = pydantic.Field(..., description='If this flag is enabled, the principal identifier of the caller will be output to the log.\n')
    http_method: bool = pydantic.Field(..., description='If this flag is enabled, the http method will be output to the log.\n')
    ip: bool = pydantic.Field(..., description='If this flag is enabled, the source IP of request will be output to the log.\n')
    protocol: bool = pydantic.Field(..., description='If this flag is enabled, the request protocol will be output to the log.\n')
    request_time: bool = pydantic.Field(..., description='If this flag is enabled, the CLF-formatted request time((dd/MMM/yyyy:HH:mm:ss +-hhmm) will be output to the log.\n')
    resource_path: bool = pydantic.Field(..., description='If this flag is enabled, the path to your resource will be output to the log.\n')
    response_length: bool = pydantic.Field(..., description='If this flag is enabled, the response payload length will be output to the log.\n')
    status: bool = pydantic.Field(..., description='If this flag is enabled, the method response status will be output to the log.\n')
    user: bool = pydantic.Field(..., description='If this flag is enabled, the principal identifier of the user will be output to the log.\n\n:exampleMetadata: infused\n\nExample::\n\n    # production stage\n    prd_log_group = logs.LogGroup(self, "PrdLogs")\n    api = apigateway.RestApi(self, "books",\n        deploy_options=apigateway.StageOptions(\n            access_log_destination=apigateway.LogGroupLogDestination(prd_log_group),\n            access_log_format=apigateway.AccessLogFormat.json_with_standard_fields()\n        )\n    )\n    deployment = apigateway.Deployment(self, "Deployment", api=api)\n\n    # development stage\n    dev_log_group = logs.LogGroup(self, "DevLogs")\n    apigateway.Stage(self, "dev",\n        deployment=deployment,\n        access_log_destination=apigateway.LogGroupLogDestination(dev_log_group),\n        access_log_format=apigateway.AccessLogFormat.json_with_standard_fields(\n            caller=False,\n            http_method=True,\n            ip=True,\n            protocol=True,\n            request_time=True,\n            resource_path=True,\n            response_length=True,\n            status=True,\n            user=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['caller', 'http_method', 'ip', 'protocol', 'request_time', 'resource_path', 'response_length', 'status', 'user']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.JsonWithStandardFieldProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.LambdaAuthorizerProps
class LambdaAuthorizerPropsDef(BaseStruct):
    handler: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description="The handler for the authorizer lambda function. The handler must follow a very specific protocol on the input it receives and the output it needs to produce. API Gateway has documented the handler's `input specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-input.html>`_ and `output specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-output.html>`_.\n")
    assume_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description="An optional IAM role for APIGateway to assume before calling the Lambda-based authorizer. The IAM role must be assumable by 'apigateway.amazonaws.com'. Default: - A resource policy is added to the Lambda function allowing apigateway.amazonaws.com to invoke the function.\n")
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='An optional human friendly name for the authorizer. Note that, this is not the primary identifier of the authorizer. Default: - the unique construct ID\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to 0. Default: Duration.minutes(5)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigateway as apigateway\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_lambda as lambda_\n\n    # function_: lambda.Function\n    # role: iam.Role\n\n    lambda_authorizer_props = apigateway.LambdaAuthorizerProps(\n        handler=function_,\n\n        # the properties below are optional\n        assume_role=role,\n        authorizer_name="authorizerName",\n        results_cache_ttl=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['handler', 'assume_role', 'authorizer_name', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.LambdaAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LambdaAuthorizerPropsDefConfig] = pydantic.Field(None)


class LambdaAuthorizerPropsDefConfig(pydantic.BaseModel):
    handler_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.LambdaIntegrationOptions
class LambdaIntegrationOptionsDef(BaseStruct):
    cache_key_parameters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of request parameters whose values are to be cached. It determines request parameters that will make it into the cache key.')
    cache_namespace: typing.Optional[str] = pydantic.Field(None, description='An API-specific tag group of related cached parameters.\n')
    connection_type: typing.Optional[aws_cdk.aws_apigateway.ConnectionType] = pydantic.Field(None, description='The type of network connection to the integration endpoint. Default: - ConnectionType.VPC_LINK if ``vpcLink`` property is configured; ConnectionType.Internet otherwise.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigateway.ContentHandling] = pydantic.Field(None, description="Specifies how to handle request payload content type conversions. Default: none if this property isn't defined, the request payload is passed through from the method request to the integration request without modification, provided that the ``passthroughBehaviors`` property is configured to support payload pass-through.\n")
    credentials_passthrough: typing.Optional[bool] = pydantic.Field(None, description="Requires that the caller's identity be passed through from the request. Default: Caller identity is not passed through\n")
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that API Gateway assumes. Mutually exclusive with ``credentialsPassThrough``. Default: A role is not assumed\n')
    integration_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.IntegrationResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The response that API Gateway provides after a method's backend completes processing a request. API Gateway intercepts the response from the backend so that you can control how API Gateway surfaces backend responses. For example, you can map the backend status codes to codes that you define.\n")
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigateway.PassthroughBehavior] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The request parameters that API Gateway sends with the backend request. Specify request parameters as key-value pairs (string-to-string mappings), with a destination as the key and a source as the value. Specify the destination by using the following pattern integration.request.location.name, where location is querystring, path, or header, and name is a valid, unique parameter name. The source must be an existing method request parameter or a static value. You must enclose static values in single quotation marks and pre-encode these values based on their destination in the request.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map of Apache Velocity templates that are applied on the request payload. The template that API Gateway uses is based on the value of the Content-Type header that\'s sent by the client. The content type value is the key, and the template is the value (specified as a string), such as the following snippet:: { "application/json": "{ \\"statusCode\\": 200 }" }\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n')
    vpc_link: typing.Optional[typing.Union[models.aws_apigateway.VpcLinkDef]] = pydantic.Field(None, description='The VpcLink used for the integration. Required if connectionType is VPC_LINK\n')
    allow_test_invoke: typing.Optional[bool] = pydantic.Field(None, description='Allow invoking method from AWS Console UI (for testing purposes). This will add another permission to the AWS Lambda resource policy which will allow the ``test-invoke-stage`` stage to invoke this handler. If this is set to ``false``, the function will only be usable from the deployment endpoint. Default: true\n')
    proxy: typing.Optional[bool] = pydantic.Field(None, description='Use proxy integration or normal (request/response mapping) integration. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # backend: lambda.Function\n\n\n    api = apigateway.LambdaRestApi(self, "myapi",\n        handler=backend,\n        integration_options=apigateway.LambdaIntegrationOptions(\n            allow_test_invoke=False,\n            timeout=Duration.seconds(1)\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_key_parameters', 'cache_namespace', 'connection_type', 'content_handling', 'credentials_passthrough', 'credentials_role', 'integration_responses', 'passthrough_behavior', 'request_parameters', 'request_templates', 'timeout', 'vpc_link', 'allow_test_invoke', 'proxy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.LambdaIntegrationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.LambdaRestApiProps
class LambdaRestApiPropsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false\n')
    api_key_source_type: typing.Optional[aws_cdk.aws_apigateway.ApiKeySourceType] = pydantic.Field(None, description='The source of the API key for metering requests according to a usage plan. Default: - Metering is disabled.\n')
    binary_media_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of binary media mime-types that are supported by the RestApi resource, such as "image/png" or "application/octet-stream". Default: - RestApi supports only UTF-8-encoded text payloads.\n')
    clone_from: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='The ID of the API Gateway RestApi resource that you want to clone. Default: - None.\n')
    endpoint_configuration: typing.Union[models.aws_apigateway.EndpointConfigurationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The EndpointConfiguration property type specifies the endpoint types of a REST API. Default: EndpointType.EDGE\n')
    min_compression_size: typing.Optional[models.SizeDef] = pydantic.Field(None, description='A Size(in bytes, kibibytes, mebibytes etc) that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    minimum_compression_size: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    handler: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description='The default Lambda function that handles all requests from this API. This handler will be used as a the default integration for all methods in this API, unless specified otherwise in ``addMethod``.\n')
    integration_options: typing.Union[models.aws_apigateway.LambdaIntegrationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specific Lambda integration options. Default: see defaults defined in ``LambdaIntegrationOptions``.\n')
    proxy: typing.Optional[bool] = pydantic.Field(None, description='If true, route all requests to the Lambda Function. If set to false, you will need to explicitly define the API model using ``addResource`` and ``addMethod`` (or ``addProxy``). Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # backend: lambda.Function\n\n    api = apigateway.LambdaRestApi(self, "myapi",\n        handler=backend,\n        proxy=False\n    )\n\n    items = api.root.add_resource("items")\n    items.add_method("GET") # GET /items\n    items.add_method("POST") # POST /items\n\n    item = items.add_resource("{item}")\n    item.add_method("GET") # GET /items/{item}\n\n    # the default integration for methods is "handler", but one can\n    # customize this behavior per method or even a sub path.\n    item.add_method("DELETE", apigateway.HttpIntegration("http://amazon.com"))\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments', 'api_key_source_type', 'binary_media_types', 'clone_from', 'endpoint_configuration', 'min_compression_size', 'minimum_compression_size', 'handler', 'integration_options', 'proxy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.LambdaRestApiProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LambdaRestApiPropsDefConfig] = pydantic.Field(None)


class LambdaRestApiPropsDefConfig(pydantic.BaseModel):
    handler_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.MethodDeploymentOptions
class MethodDeploymentOptionsDef(BaseStruct):
    cache_data_encrypted: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the cached responses are encrypted. Default: false')
    cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached. Default: Duration.minutes(5)\n')
    caching_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached. Default: - Caching is Disabled.\n')
    data_trace_enabled: typing.Optional[bool] = pydantic.Field(None, description="Specifies whether data trace logging is enabled for this method. When enabled, API gateway will log the full API requests and responses. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this feature for production APIs. Default: false\n")
    logging_level: typing.Optional[aws_cdk.aws_apigateway.MethodLoggingLevel] = pydantic.Field(None, description='Specifies the logging level for this method, which effects the log entries pushed to Amazon CloudWatch Logs. Default: - Off\n')
    metrics_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether Amazon CloudWatch metrics are enabled for this method. Default: false\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling burst limit. The total rate of all requests in your AWS account is limited to 5,000 requests. Default: - No additional restriction.\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling rate limit. The total rate of all requests in your AWS account is limited to 10,000 requests per second (rps). Default: - No additional restriction.\n\n:exampleMetadata: infused\n\nExample::\n\n    api = apigateway.RestApi(self, "books")\n    deployment = apigateway.Deployment(self, "my-deployment", api=api)\n    stage = apigateway.Stage(self, "my-stage",\n        deployment=deployment,\n        method_options={\n            "/*/*": apigateway.MethodDeploymentOptions( # This special path applies to all resource paths and all HTTP methods\n                throttling_rate_limit=100,\n                throttling_burst_limit=200)\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_data_encrypted', 'cache_ttl', 'caching_enabled', 'data_trace_enabled', 'logging_level', 'metrics_enabled', 'throttling_burst_limit', 'throttling_rate_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.MethodDeploymentOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.MethodOptions
class MethodOptionsDef(BaseStruct):
    api_key_required: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the method requires clients to submit a valid API key. Default: false')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. Default: - no authorization scopes\n')
    authorization_type: typing.Optional[aws_cdk.aws_apigateway.AuthorizationType] = pydantic.Field(None, description="Method authorization. If the value is set of ``Custom``, an ``authorizer`` must also be specified. If you're using one of the authorizers that are available via the ``Authorizer`` class, such as ``Authorizer#token()``, it is recommended that this option not be specified. The authorizer will take care of setting the correct authorization type. However, specifying an authorization type using this property that conflicts with what is expected by the ``Authorizer`` will result in an error. Default: - open access unless ``authorizer`` is specified\n")
    authorizer: typing.Optional[typing.Union[models.aws_apigateway.AuthorizerDef, models.aws_apigateway.CognitoUserPoolsAuthorizerDef, models.aws_apigateway.CognitoUserPoolsAuthorizerDef, models.aws_apigateway.RequestAuthorizerDef, models.aws_apigateway.RequestAuthorizerDef, models.aws_apigateway.TokenAuthorizerDef, models.aws_apigateway.TokenAuthorizerDef]] = pydantic.Field(None, description='If ``authorizationType`` is ``Custom``, this specifies the ID of the method authorizer resource. If specified, the value of ``authorizationType`` must be set to ``Custom``\n')
    method_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.MethodResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The responses that can be sent to the client who calls the method. Default: None This property is not required, but if these are not supplied for a Lambda proxy integration, the Lambda function must return a value of the correct format, for the integration response to be correctly mapped to a response to the client.\n')
    operation_name: typing.Optional[str] = pydantic.Field(None, description='A friendly operation name for the method. For example, you can assign the OperationName of ListPets for the GET /pets method.\n')
    request_models: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.ModelDef]]] = pydantic.Field(None, description="The models which describe data structure of request payload. When combined with ``requestValidator`` or ``requestValidatorOptions``, the service will validate the API request payload before it reaches the API's Integration (including proxies). Specify ``requestModels`` as key-value pairs, with a content type (e.g. ``'application/json'``) as the key and an API Gateway Model as the value.\n")
    request_parameters: typing.Optional[typing.Mapping[str, bool]] = pydantic.Field(None, description='The request parameters that API Gateway accepts. Specify request parameters as key-value pairs (string-to-Boolean mapping), with a source as the key and a Boolean as the value. The Boolean specifies whether a parameter is required. A source must match the format method.request.location.name, where the location is querystring, path, or header, and name is a valid, unique parameter name. Default: None\n')
    request_validator: typing.Optional[typing.Union[models.aws_apigateway.RequestValidatorDef]] = pydantic.Field(None, description='The ID of the associated request validator. Only one of ``requestValidator`` or ``requestValidatorOptions`` must be specified. Works together with ``requestModels`` or ``requestParameters`` to validate the request before it reaches integration like Lambda Proxy Integration. Default: - No default validator\n')
    request_validator_options: typing.Union[models.aws_apigateway.RequestValidatorOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Request validator options to create new validator Only one of ``requestValidator`` or ``requestValidatorOptions`` must be specified. Works together with ``requestModels`` or ``requestParameters`` to validate the request before it reaches integration like Lambda Proxy Integration. Default: - No default validator\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigateway.RestApi\n    # user_lambda: lambda.Function\n\n\n    user_model = api.add_model("UserModel",\n        schema=apigateway.JsonSchema(\n            type=apigateway.JsonSchemaType.OBJECT,\n            properties={\n                "user_id": apigateway.JsonSchema(\n                    type=apigateway.JsonSchemaType.STRING\n                ),\n                "name": apigateway.JsonSchema(\n                    type=apigateway.JsonSchemaType.STRING\n                )\n            },\n            required=["userId"]\n        )\n    )\n    api.root.add_resource("user").add_method("POST",\n        apigateway.LambdaIntegration(user_lambda),\n            request_models={\n                "application/json": user_model\n            }\n        )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_key_required', 'authorization_scopes', 'authorization_type', 'authorizer', 'method_responses', 'operation_name', 'request_models', 'request_parameters', 'request_validator', 'request_validator_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.MethodOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.MethodProps
class MethodPropsDef(BaseStruct):
    http_method: str = pydantic.Field(..., description='The HTTP method ("GET", "POST", "PUT", ...) that clients use to call this method.')
    resource: typing.Union[models.aws_apigateway.ResourceBaseDef, models.aws_apigateway.ProxyResourceDef, models.aws_apigateway.ResourceDef] = pydantic.Field(..., description='The resource this method is associated with. For root resource methods, specify the ``RestApi`` object.\n')
    integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='The backend system that the method calls when it receives a request. Default: - a new ``MockIntegration``.\n')
    options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options. Default: - No options.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # authorizer: apigateway.Authorizer\n    # integration: apigateway.Integration\n    # model: apigateway.Model\n    # request_validator: apigateway.RequestValidator\n    # resource: apigateway.Resource\n\n    method_props = apigateway.MethodProps(\n        http_method="httpMethod",\n        resource=resource,\n\n        # the properties below are optional\n        integration=integration,\n        options=apigateway.MethodOptions(\n            api_key_required=False,\n            authorization_scopes=["authorizationScopes"],\n            authorization_type=apigateway.AuthorizationType.NONE,\n            authorizer=authorizer,\n            method_responses=[apigateway.MethodResponse(\n                status_code="statusCode",\n\n                # the properties below are optional\n                response_models={\n                    "response_models_key": model\n                },\n                response_parameters={\n                    "response_parameters_key": False\n                }\n            )],\n            operation_name="operationName",\n            request_models={\n                "request_models_key": model\n            },\n            request_parameters={\n                "request_parameters_key": False\n            },\n            request_validator=request_validator,\n            request_validator_options=apigateway.RequestValidatorOptions(\n                request_validator_name="requestValidatorName",\n                validate_request_body=False,\n                validate_request_parameters=False\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_method', 'resource', 'integration', 'options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.MethodProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MethodPropsDefConfig] = pydantic.Field(None)


class MethodPropsDefConfig(pydantic.BaseModel):
    resource_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.MethodResponse
class MethodResponseDef(BaseStruct):
    status_code: str = pydantic.Field(..., description="The method response's status code, which you map to an IntegrationResponse. Required.")
    response_models: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.ModelDef]]] = pydantic.Field(None, description="The resources used for the response's content type. Specify response models as key-value pairs (string-to-string maps), with a content type as the key and a Model resource name as the value. Default: None\n")
    response_parameters: typing.Optional[typing.Mapping[str, bool]] = pydantic.Field(None, description='Response parameters that API Gateway sends to the client that called a method. Specify response parameters as key-value pairs (string-to-Boolean maps), with a destination as the key and a Boolean as the value. Specify the destination using the following pattern: method.response.header.name, where the name is a valid, unique header name. The Boolean specifies whether a parameter is required. Default: None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # model: apigateway.Model\n\n    method_response = apigateway.MethodResponse(\n        status_code="statusCode",\n\n        # the properties below are optional\n        response_models={\n            "response_models_key": model\n        },\n        response_parameters={\n            "response_parameters_key": False\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['status_code', 'response_models', 'response_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.MethodResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ModelOptions
class ModelOptionsDef(BaseStruct):
    schema_: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]] = pydantic.Field(..., description="The schema to use to transform data to one or more output formats. Specify null ({}) if you don't want to specify a schema.", alias='schema')
    content_type: typing.Optional[str] = pydantic.Field(None, description="The content type for the model. You can also force a content type in the request or response model mapping. Default: 'application/json'\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description that identifies this model. Default: None\n')
    model_name: typing.Optional[str] = pydantic.Field(None, description='A name for the model. Important If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. Default: If you don\'t specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the model name. For more information, see Name Type.\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigateway.RestApi\n\n\n    # We define the JSON Schema for the transformed valid response\n    response_model = api.add_model("ResponseModel",\n        content_type="application/json",\n        model_name="ResponseModel",\n        schema=apigateway.JsonSchema(\n            schema=apigateway.JsonSchemaVersion.DRAFT4,\n            title="pollResponse",\n            type=apigateway.JsonSchemaType.OBJECT,\n            properties={\n                "state": apigateway.JsonSchema(type=apigateway.JsonSchemaType.STRING),\n                "greeting": apigateway.JsonSchema(type=apigateway.JsonSchemaType.STRING)\n            }\n        )\n    )\n\n    # We define the JSON Schema for the transformed error response\n    error_response_model = api.add_model("ErrorResponseModel",\n        content_type="application/json",\n        model_name="ErrorResponseModel",\n        schema=apigateway.JsonSchema(\n            schema=apigateway.JsonSchemaVersion.DRAFT4,\n            title="errorResponse",\n            type=apigateway.JsonSchemaType.OBJECT,\n            properties={\n                "state": apigateway.JsonSchema(type=apigateway.JsonSchemaType.STRING),\n                "message": apigateway.JsonSchema(type=apigateway.JsonSchemaType.STRING)\n            }\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schema', 'content_type', 'description', 'model_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ModelOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ModelProps
class ModelPropsDef(BaseStruct):
    schema_: typing.Union[models.aws_apigateway.JsonSchemaDef, dict[str, typing.Any]] = pydantic.Field(..., description="The schema to use to transform data to one or more output formats. Specify null ({}) if you don't want to specify a schema.", alias='schema')
    content_type: typing.Optional[str] = pydantic.Field(None, description="The content type for the model. You can also force a content type in the request or response model mapping. Default: 'application/json'\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description that identifies this model. Default: None\n')
    model_name: typing.Optional[str] = pydantic.Field(None, description="A name for the model. Important If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. Default: If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the model name. For more information, see Name Type.\n")
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The rest API that this model is part of. The reason we need the RestApi object itself and not just the ID is because the model is being tracked by the top-level RestApi object for the purpose of calculating it\'s hash to determine the ID of the deployment. This allows us to automatically update the deployment when the model of the REST API changes.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # default_: Any\n    # enum_: Any\n    # json_schema_: apigateway.JsonSchema\n    # rest_api: apigateway.RestApi\n\n    model_props = apigateway.ModelProps(\n        rest_api=rest_api,\n        schema=apigateway.JsonSchema(\n            additional_items=[json_schema_],\n            additional_properties=False,\n            all_of=[json_schema_],\n            any_of=[json_schema_],\n            contains=json_schema_,\n            default=default_,\n            definitions={\n                "definitions_key": json_schema_\n            },\n            dependencies={\n                "dependencies_key": ["dependencies"]\n            },\n            description="description",\n            enum=[enum_],\n            exclusive_maximum=False,\n            exclusive_minimum=False,\n            format="format",\n            id="id",\n            items=json_schema_,\n            maximum=123,\n            max_items=123,\n            max_length=123,\n            max_properties=123,\n            minimum=123,\n            min_items=123,\n            min_length=123,\n            min_properties=123,\n            multiple_of=123,\n            not=json_schema_,\n            one_of=[json_schema_],\n            pattern="pattern",\n            pattern_properties={\n                "pattern_properties_key": json_schema_\n            },\n            properties={\n                "properties_key": json_schema_\n            },\n            property_names=json_schema_,\n            ref="ref",\n            required=["required"],\n            schema=apigateway.JsonSchemaVersion.DRAFT4,\n            title="title",\n            type=apigateway.JsonSchemaType.NULL,\n            unique_items=False\n        ),\n\n        # the properties below are optional\n        content_type="contentType",\n        description="description",\n        model_name="modelName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schema', 'content_type', 'description', 'model_name', 'rest_api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ModelProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ModelPropsDefConfig] = pydantic.Field(None)


class ModelPropsDefConfig(pydantic.BaseModel):
    rest_api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.MTLSConfig
class MTLSConfigDef(BaseStruct):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='The bucket that the trust store is hosted in.\n')
    key: str = pydantic.Field(..., description='The key in S3 to look at for the trust store.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket. Default: - latest version\n\n:exampleMetadata: infused\n\nExample::\n\n    # acm: Any\n\n\n    apigateway.DomainName(self, "domain-name",\n        domain_name="example.com",\n        certificate=acm.Certificate.from_certificate_arn(self, "cert", "arn:aws:acm:us-east-1:1111111:certificate/11-3336f1-44483d-adc7-9cd375c5169d"),\n        mtls=apigateway.MTLSConfig(\n            bucket=s3.Bucket(self, "bucket"),\n            key="truststore.pem",\n            version="version"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'key', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.MTLSConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MTLSConfigDefConfig] = pydantic.Field(None)


class MTLSConfigDefConfig(pydantic.BaseModel):
    bucket_config: typing.Optional[models._interface_methods.AwsS3IBucketDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.ProxyResourceOptions
class ProxyResourceOptionsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    any_method: typing.Optional[bool] = pydantic.Field(None, description='Adds an "ANY" method to this resource. If set to ``false``, you will have to explicitly add methods to this resource after it\'s created. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # resource: apigateway.Resource\n    # handler: lambda.Function\n\n    proxy = resource.add_proxy(\n        default_integration=apigateway.LambdaIntegration(handler),\n\n        # "false" will require explicitly adding methods on the `proxy` resource\n        any_method=True\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'any_method']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ProxyResourceOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ProxyResourceProps
class ProxyResourcePropsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    any_method: typing.Optional[bool] = pydantic.Field(None, description='Adds an "ANY" method to this resource. If set to ``false``, you will have to explicitly add methods to this resource after it\'s created. Default: true\n')
    parent: typing.Union[models.aws_apigateway.ResourceBaseDef, models.aws_apigateway.ProxyResourceDef, models.aws_apigateway.ResourceDef] = pydantic.Field(..., description='The parent resource of this resource. You can either pass another ``Resource`` object or a ``RestApi`` object here.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigateway as apigateway\n\n    # authorizer: apigateway.Authorizer\n    # integration: apigateway.Integration\n    # model: apigateway.Model\n    # request_validator: apigateway.RequestValidator\n    # resource: apigateway.Resource\n\n    proxy_resource_props = apigateway.ProxyResourceProps(\n        parent=resource,\n\n        # the properties below are optional\n        any_method=False,\n        default_cors_preflight_options=apigateway.CorsOptions(\n            allow_origins=["allowOrigins"],\n\n            # the properties below are optional\n            allow_credentials=False,\n            allow_headers=["allowHeaders"],\n            allow_methods=["allowMethods"],\n            disable_cache=False,\n            expose_headers=["exposeHeaders"],\n            max_age=cdk.Duration.minutes(30),\n            status_code=123\n        ),\n        default_integration=integration,\n        default_method_options=apigateway.MethodOptions(\n            api_key_required=False,\n            authorization_scopes=["authorizationScopes"],\n            authorization_type=apigateway.AuthorizationType.NONE,\n            authorizer=authorizer,\n            method_responses=[apigateway.MethodResponse(\n                status_code="statusCode",\n\n                # the properties below are optional\n                response_models={\n                    "response_models_key": model\n                },\n                response_parameters={\n                    "response_parameters_key": False\n                }\n            )],\n            operation_name="operationName",\n            request_models={\n                "request_models_key": model\n            },\n            request_parameters={\n                "request_parameters_key": False\n            },\n            request_validator=request_validator,\n            request_validator_options=apigateway.RequestValidatorOptions(\n                request_validator_name="requestValidatorName",\n                validate_request_body=False,\n                validate_request_parameters=False\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'any_method', 'parent']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ProxyResourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ProxyResourcePropsDefConfig] = pydantic.Field(None)


class ProxyResourcePropsDefConfig(pydantic.BaseModel):
    parent_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.QuotaSettings
class QuotaSettingsDef(BaseStruct):
    limit: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of requests that users can make within the specified time period. Default: none\n')
    offset: typing.Union[int, float, None] = pydantic.Field(None, description='For the initial time period, the number of requests to subtract from the specified limit. Default: none\n')
    period: typing.Optional[aws_cdk.aws_apigateway.Period] = pydantic.Field(None, description='The time period for which the maximum limit of requests applies. Default: none\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigateway.RestApi\n\n\n    key = apigateway.RateLimitedApiKey(self, "rate-limited-api-key",\n        customer_id="hello-customer",\n        stages=[api.deployment_stage],\n        quota=apigateway.QuotaSettings(\n            limit=10000,\n            period=apigateway.Period.MONTH\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['limit', 'offset', 'period']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.QuotaSettings'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.RateLimitedApiKeyProps
class RateLimitedApiKeyPropsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    api_key_name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. Default: automically generated name\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the API key. Default: none\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the API key. Must be at least 20 characters long. Default: none\n')
    customer_id: typing.Optional[str] = pydantic.Field(None, description='An AWS Marketplace customer identifier to use when integrating with the AWS SaaS Marketplace. Default: none\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the API key can be used by clients. Default: true\n')
    generate_distinct_id: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the key identifier is distinct from the created API key value. Default: false\n')
    resources: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]]] = pydantic.Field(None, description='(deprecated) A list of resources this api key is associated with. Default: none\n')
    stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.StageBaseDef, models.aws_apigateway.StageDef]]] = pydantic.Field(None, description='A list of Stages this api key is associated with. Default: - the api key is not associated with any stages\n')
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the RateLimitedApiKey. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigateway.RestApi\n\n\n    key = apigateway.RateLimitedApiKey(self, "rate-limited-api-key",\n        customer_id="hello-customer",\n        stages=[api.deployment_stage],\n        quota=apigateway.QuotaSettings(\n            limit=10000,\n            period=apigateway.Period.MONTH\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'api_key_name', 'description', 'value', 'customer_id', 'enabled', 'generate_distinct_id', 'resources', 'stages', 'api_stages', 'quota', 'throttle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RateLimitedApiKeyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.RequestAuthorizerProps
class RequestAuthorizerPropsDef(BaseStruct):
    handler: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description="The handler for the authorizer lambda function. The handler must follow a very specific protocol on the input it receives and the output it needs to produce. API Gateway has documented the handler's `input specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-input.html>`_ and `output specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-output.html>`_.\n")
    assume_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description="An optional IAM role for APIGateway to assume before calling the Lambda-based authorizer. The IAM role must be assumable by 'apigateway.amazonaws.com'. Default: - A resource policy is added to the Lambda function allowing apigateway.amazonaws.com to invoke the function.\n")
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='An optional human friendly name for the authorizer. Note that, this is not the primary identifier of the authorizer. Default: - the unique construct ID\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to 0. Default: Duration.minutes(5)\n')
    identity_sources: typing.Sequence[str] = pydantic.Field(..., description='An array of request header mapping expressions for identities. Supported parameter types are Header, Query String, Stage Variable, and Context. For instance, extracting an authorization token from a header would use the identity source ``IdentitySource.header(\'Authorizer\')``. Note: API Gateway uses the specified identity sources as the request authorizer caching key. When caching is enabled, API Gateway calls the authorizer\'s Lambda function only after successfully verifying that all the specified identity sources are present at runtime. If a specified identify source is missing, null, or empty, API Gateway returns a 401 Unauthorized response without calling the authorizer Lambda function.\n\n:exampleMetadata: infused\n\nExample::\n\n    # auth_fn: lambda.Function\n    # books: apigateway.Resource\n\n\n    auth = apigateway.RequestAuthorizer(self, "booksAuthorizer",\n        handler=auth_fn,\n        identity_sources=[apigateway.IdentitySource.header("Authorization")]\n    )\n\n    books.add_method("GET", apigateway.HttpIntegration("http://amazon.com"),\n        authorizer=auth\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['handler', 'assume_role', 'authorizer_name', 'results_cache_ttl', 'identity_sources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RequestAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RequestAuthorizerPropsDefConfig] = pydantic.Field(None)


class RequestAuthorizerPropsDefConfig(pydantic.BaseModel):
    handler_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.RequestContext
class RequestContextDef(BaseStruct):
    account_id: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.accountId. Whether the AWS account of the API owner should be included in the request context Default: false\n')
    api_id: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.apiId. Whether the identifier API Gateway assigns to your API should be included in the request context. Default: false\n')
    api_key: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.apiKey. Whether the API key associated with the request should be included in request context. Default: false\n')
    authorizer_principal_id: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.authorizer.principalId. Whether the principal user identifier associated with the token sent by the client and returned from an API Gateway Lambda authorizer should be included in the request context. Default: false\n')
    caller: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.caller. Whether the principal identifier of the caller that signed the request should be included in the request context. Supported for resources that use IAM authorization. Default: false\n')
    cognito_authentication_provider: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.cognitoAuthenticationProvider. Whether the list of the Amazon Cognito authentication providers used by the caller making the request should be included in the request context. Available only if the request was signed with Amazon Cognito credentials. Default: false\n')
    cognito_authentication_type: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.cognitoAuthenticationType. Whether the Amazon Cognito authentication type of the caller making the request should be included in the request context. Available only if the request was signed with Amazon Cognito credentials. Possible values include authenticated for authenticated identities and unauthenticated for unauthenticated identities. Default: false\n')
    cognito_identity_id: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.cognitoIdentityId. Whether the Amazon Cognito identity ID of the caller making the request should be included in the request context. Available only if the request was signed with Amazon Cognito credentials. Default: false\n')
    cognito_identity_pool_id: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.cognitoIdentityPoolId. Whether the Amazon Cognito identity pool ID of the caller making the request should be included in the request context. Available only if the request was signed with Amazon Cognito credentials. Default: false\n')
    http_method: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.httpMethod. Whether the HTTP method used should be included in the request context. Valid values include: DELETE, GET, HEAD, OPTIONS, PATCH, POST, and PUT. Default: false\n')
    request_id: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.requestId. Whether the ID for the request should be included in the request context. Default: false\n')
    resource_id: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.resourceId. Whether the identifier that API Gateway assigns to your resource should be included in the request context. Default: false\n')
    resource_path: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.resourcePath. Whether the path to the resource should be included in the request context. Default: false\n')
    source_ip: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.sourceIp. Whether the source IP address of the immediate TCP connection making the request to API Gateway endpoint should be included in the request context. Default: false\n')
    stage: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.stage. Whether the deployment stage of the API request should be included in the request context. Default: false\n')
    user: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.user. Whether the principal identifier of the user that will be authorized should be included in the request context. Supported for resources that use IAM authorization. Default: false\n')
    user_agent: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.userAgent. Whether the User-Agent header of the API caller should be included in the request context. Default: false\n')
    user_arn: typing.Optional[bool] = pydantic.Field(None, description='Represents the information of $context.identity.userArn. Whether the Amazon Resource Name (ARN) of the effective user identified after authentication should be included in the request context. Default: false\n\n:see: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html\n:exampleMetadata: fixture=stepfunctions infused\n\nExample::\n\n    apigateway.StepFunctionsRestApi(self, "StepFunctionsRestApi",\n        state_machine=machine,\n        headers=True,\n        path=False,\n        querystring=False,\n        authorizer=False,\n        request_context=apigateway.RequestContext(\n            caller=True,\n            user=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'api_id', 'api_key', 'authorizer_principal_id', 'caller', 'cognito_authentication_provider', 'cognito_authentication_type', 'cognito_identity_id', 'cognito_identity_pool_id', 'http_method', 'request_id', 'resource_id', 'resource_path', 'source_ip', 'stage', 'user', 'user_agent', 'user_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RequestContext'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.RequestValidatorOptions
class RequestValidatorOptionsDef(BaseStruct):
    request_validator_name: typing.Optional[str] = pydantic.Field(None, description='The name of this request validator. Default: None')
    validate_request_body: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate the request body according to the configured schema for the targeted API and method. Default: false\n')
    validate_request_parameters: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate request parameters. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    # integration: apigateway.LambdaIntegration\n    # resource: apigateway.Resource\n    # response_model: apigateway.Model\n    # error_response_model: apigateway.Model\n\n\n    resource.add_method("GET", integration,\n        # We can mark the parameters as required\n        request_parameters={\n            "method.request.querystring.who": True\n        },\n        # we can set request validator options like below\n        request_validator_options=apigateway.RequestValidatorOptions(\n            request_validator_name="test-validator",\n            validate_request_body=True,\n            validate_request_parameters=False\n        ),\n        method_responses=[apigateway.MethodResponse(\n            # Successful response from the integration\n            status_code="200",\n            # Define what parameters are allowed or not\n            response_parameters={\n                "method.response.header.Content-Type": True,\n                "method.response.header.Access-Control-Allow-Origin": True,\n                "method.response.header.Access-Control-Allow-Credentials": True\n            },\n            # Validate the schema on the response\n            response_models={\n                "application/json": response_model\n            }\n        ), apigateway.MethodResponse(\n            # Same thing for the error responses\n            status_code="400",\n            response_parameters={\n                "method.response.header.Content-Type": True,\n                "method.response.header.Access-Control-Allow-Origin": True,\n                "method.response.header.Access-Control-Allow-Credentials": True\n            },\n            response_models={\n                "application/json": error_response_model\n            }\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['request_validator_name', 'validate_request_body', 'validate_request_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RequestValidatorOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.RequestValidatorProps
class RequestValidatorPropsDef(BaseStruct):
    request_validator_name: typing.Optional[str] = pydantic.Field(None, description='The name of this request validator. Default: None')
    validate_request_body: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate the request body according to the configured schema for the targeted API and method. Default: false\n')
    validate_request_parameters: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to validate request parameters. Default: false\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The rest API that this model is part of. The reason we need the RestApi object itself and not just the ID is because the model is being tracked by the top-level RestApi object for the purpose of calculating it\'s hash to determine the ID of the deployment. This allows us to automatically update the deployment when the model of the REST API changes.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # rest_api: apigateway.RestApi\n\n    request_validator_props = apigateway.RequestValidatorProps(\n        rest_api=rest_api,\n\n        # the properties below are optional\n        request_validator_name="requestValidatorName",\n        validate_request_body=False,\n        validate_request_parameters=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['request_validator_name', 'validate_request_body', 'validate_request_parameters', 'rest_api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RequestValidatorProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RequestValidatorPropsDefConfig] = pydantic.Field(None)


class RequestValidatorPropsDefConfig(pydantic.BaseModel):
    rest_api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.ResourceAttributes
class ResourceAttributesDef(BaseStruct):
    path: str = pydantic.Field(..., description='The full path of this resource.\n')
    resource_id: str = pydantic.Field(..., description='The ID of the resource.\n')
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The rest API that this resource is part of.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # rest_api: apigateway.RestApi\n\n    resource_attributes = apigateway.ResourceAttributes(\n        path="path",\n        resource_id="resourceId",\n        rest_api=rest_api\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['path', 'resource_id', 'rest_api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ResourceAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ResourceAttributesDefConfig] = pydantic.Field(None)


class ResourceAttributesDefConfig(pydantic.BaseModel):
    rest_api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.ResourceOptions
class ResourceOptionsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n\n:exampleMetadata: infused\n\nExample::\n\n    # resource: apigateway.Resource\n\n\n    subtree = resource.add_resource("subtree",\n        default_cors_preflight_options=apigateway.CorsOptions(\n            allow_origins=["https://amazon.com"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ResourceOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ResourceProps
class ResourcePropsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    parent: typing.Union[models.aws_apigateway.ResourceBaseDef, models.aws_apigateway.ProxyResourceDef, models.aws_apigateway.ResourceDef] = pydantic.Field(..., description='The parent resource of this resource. You can either pass another ``Resource`` object or a ``RestApi`` object here.\n')
    path_part: str = pydantic.Field(..., description='A path name for the resource.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigateway as apigateway\n\n    # authorizer: apigateway.Authorizer\n    # integration: apigateway.Integration\n    # model: apigateway.Model\n    # request_validator: apigateway.RequestValidator\n    # resource: apigateway.Resource\n\n    resource_props = apigateway.ResourceProps(\n        parent=resource,\n        path_part="pathPart",\n\n        # the properties below are optional\n        default_cors_preflight_options=apigateway.CorsOptions(\n            allow_origins=["allowOrigins"],\n\n            # the properties below are optional\n            allow_credentials=False,\n            allow_headers=["allowHeaders"],\n            allow_methods=["allowMethods"],\n            disable_cache=False,\n            expose_headers=["exposeHeaders"],\n            max_age=cdk.Duration.minutes(30),\n            status_code=123\n        ),\n        default_integration=integration,\n        default_method_options=apigateway.MethodOptions(\n            api_key_required=False,\n            authorization_scopes=["authorizationScopes"],\n            authorization_type=apigateway.AuthorizationType.NONE,\n            authorizer=authorizer,\n            method_responses=[apigateway.MethodResponse(\n                status_code="statusCode",\n\n                # the properties below are optional\n                response_models={\n                    "response_models_key": model\n                },\n                response_parameters={\n                    "response_parameters_key": False\n                }\n            )],\n            operation_name="operationName",\n            request_models={\n                "request_models_key": model\n            },\n            request_parameters={\n                "request_parameters_key": False\n            },\n            request_validator=request_validator,\n            request_validator_options=apigateway.RequestValidatorOptions(\n                request_validator_name="requestValidatorName",\n                validate_request_body=False,\n                validate_request_parameters=False\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'parent', 'path_part']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ResourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ResourcePropsDefConfig] = pydantic.Field(None)


class ResourcePropsDefConfig(pydantic.BaseModel):
    parent_config: typing.Optional[models._interface_methods.AwsApigatewayIResourceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.RestApiAttributes
class RestApiAttributesDef(BaseStruct):
    rest_api_id: str = pydantic.Field(..., description='The ID of the API Gateway RestApi.\n')
    root_resource_id: str = pydantic.Field(..., description='The resource ID of the root resource.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='The name of the API Gateway RestApi. Default: - ID of the RestApi construct.\n\n:exampleMetadata: lit=aws-apigateway/test/integ.restapi-import.lit.ts infused\n\nExample::\n\n    from aws_cdk.aws_apigateway import IntegrationResponse, MethodResponse, IntegrationResponse, MethodResponse\n    from constructs import Construct\n    from aws_cdk import App, CfnOutput, NestedStack, NestedStackProps, Stack\n    from aws_cdk.aws_apigateway import Deployment, Method, MockIntegration, PassthroughBehavior, RestApi, Stage\n\n    #\n    # This file showcases how to split up a RestApi\'s Resources and Methods across nested stacks.\n    #\n    # The root stack \'RootStack\' first defines a RestApi.\n    # Two nested stacks BooksStack and PetsStack, create corresponding Resources \'/books\' and \'/pets\'.\n    # They are then deployed to a \'prod\' Stage via a third nested stack - DeployStack.\n    #\n    # To verify this worked, go to the APIGateway\n    #\n\n    class RootStack(Stack):\n        def __init__(self, scope):\n            super().__init__(scope, "integ-restapi-import-RootStack")\n\n            rest_api = RestApi(self, "RestApi",\n                cloud_watch_role=True,\n                deploy=False\n            )\n            rest_api.root.add_method("ANY")\n\n            pets_stack = PetsStack(self,\n                rest_api_id=rest_api.rest_api_id,\n                root_resource_id=rest_api.rest_api_root_resource_id\n            )\n            books_stack = BooksStack(self,\n                rest_api_id=rest_api.rest_api_id,\n                root_resource_id=rest_api.rest_api_root_resource_id\n            )\n            DeployStack(self,\n                rest_api_id=rest_api.rest_api_id,\n                methods=pets_stack.methods.concat(books_stack.methods)\n            )\n\n            CfnOutput(self, "PetsURL",\n                value=f"https://{restApi.restApiId}.execute-api.{this.region}.amazonaws.com/prod/pets"\n            )\n\n            CfnOutput(self, "BooksURL",\n                value=f"https://{restApi.restApiId}.execute-api.{this.region}.amazonaws.com/prod/books"\n            )\n\n    class PetsStack(NestedStack):\n\n        def __init__(self, scope, *, restApiId, rootResourceId, parameters=None, timeout=None, notificationArns=None, removalPolicy=None, description=None):\n            super().__init__(scope, "integ-restapi-import-PetsStack", restApiId=restApiId, rootResourceId=rootResourceId, parameters=parameters, timeout=timeout, notificationArns=notificationArns, removalPolicy=removalPolicy, description=description)\n\n            api = RestApi.from_rest_api_attributes(self, "RestApi",\n                rest_api_id=rest_api_id,\n                root_resource_id=root_resource_id\n            )\n\n            method = api.root.add_resource("pets").add_method("GET", MockIntegration(\n                integration_responses=[IntegrationResponse(\n                    status_code="200"\n                )],\n                passthrough_behavior=PassthroughBehavior.NEVER,\n                request_templates={\n                    "application/json": "{ "statusCode": 200 }"\n                }\n            ),\n                method_responses=[MethodResponse(status_code="200")]\n            )\n\n            self.methods.push(method)\n\n    class BooksStack(NestedStack):\n\n        def __init__(self, scope, *, restApiId, rootResourceId, parameters=None, timeout=None, notificationArns=None, removalPolicy=None, description=None):\n            super().__init__(scope, "integ-restapi-import-BooksStack", restApiId=restApiId, rootResourceId=rootResourceId, parameters=parameters, timeout=timeout, notificationArns=notificationArns, removalPolicy=removalPolicy, description=description)\n\n            api = RestApi.from_rest_api_attributes(self, "RestApi",\n                rest_api_id=rest_api_id,\n                root_resource_id=root_resource_id\n            )\n\n            method = api.root.add_resource("books").add_method("GET", MockIntegration(\n                integration_responses=[IntegrationResponse(\n                    status_code="200"\n                )],\n                passthrough_behavior=PassthroughBehavior.NEVER,\n                request_templates={\n                    "application/json": "{ "statusCode": 200 }"\n                }\n            ),\n                method_responses=[MethodResponse(status_code="200")]\n            )\n\n            self.methods.push(method)\n\n    class DeployStack(NestedStack):\n        def __init__(self, scope, *, restApiId, methods=None, parameters=None, timeout=None, notificationArns=None, removalPolicy=None, description=None):\n            super().__init__(scope, "integ-restapi-import-DeployStack", restApiId=restApiId, methods=methods, parameters=parameters, timeout=timeout, notificationArns=notificationArns, removalPolicy=removalPolicy, description=description)\n\n            deployment = Deployment(self, "Deployment",\n                api=RestApi.from_rest_api_id(self, "RestApi", rest_api_id)\n            )\n            if methods:\n                for method in methods:\n                    deployment.node.add_dependency(method)\n            Stage(self, "Stage", deployment=deployment)\n\n    RootStack(App())\n')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'root_resource_id', 'rest_api_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RestApiAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.RestApiBaseProps
class RestApiBasePropsDef(BaseStruct):
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigateway as apigateway\n    from aws_cdk import aws_certificatemanager as certificatemanager\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_s3 as s3\n\n    # access_log_destination: apigateway.IAccessLogDestination\n    # access_log_format: apigateway.AccessLogFormat\n    # bucket: s3.Bucket\n    # certificate: certificatemanager.Certificate\n    # policy_document: iam.PolicyDocument\n\n    rest_api_base_props = apigateway.RestApiBaseProps(\n        cloud_watch_role=False,\n        deploy=False,\n        deploy_options=apigateway.StageOptions(\n            access_log_destination=access_log_destination,\n            access_log_format=access_log_format,\n            cache_cluster_enabled=False,\n            cache_cluster_size="cacheClusterSize",\n            cache_data_encrypted=False,\n            cache_ttl=cdk.Duration.minutes(30),\n            caching_enabled=False,\n            client_certificate_id="clientCertificateId",\n            data_trace_enabled=False,\n            description="description",\n            documentation_version="documentationVersion",\n            logging_level=apigateway.MethodLoggingLevel.OFF,\n            method_options={\n                "method_options_key": apigateway.MethodDeploymentOptions(\n                    cache_data_encrypted=False,\n                    cache_ttl=cdk.Duration.minutes(30),\n                    caching_enabled=False,\n                    data_trace_enabled=False,\n                    logging_level=apigateway.MethodLoggingLevel.OFF,\n                    metrics_enabled=False,\n                    throttling_burst_limit=123,\n                    throttling_rate_limit=123\n                )\n            },\n            metrics_enabled=False,\n            stage_name="stageName",\n            throttling_burst_limit=123,\n            throttling_rate_limit=123,\n            tracing_enabled=False,\n            variables={\n                "variables_key": "variables"\n            }\n        ),\n        description="description",\n        disable_execute_api_endpoint=False,\n        domain_name=apigateway.DomainNameOptions(\n            certificate=certificate,\n            domain_name="domainName",\n\n            # the properties below are optional\n            base_path="basePath",\n            endpoint_type=apigateway.EndpointType.EDGE,\n            mtls=apigateway.MTLSConfig(\n                bucket=bucket,\n                key="key",\n\n                # the properties below are optional\n                version="version"\n            ),\n            security_policy=apigateway.SecurityPolicy.TLS_1_0\n        ),\n        endpoint_export_name="endpointExportName",\n        endpoint_types=[apigateway.EndpointType.EDGE],\n        fail_on_warnings=False,\n        parameters={\n            "parameters_key": "parameters"\n        },\n        policy=policy_document,\n        rest_api_name="restApiName",\n        retain_deployments=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RestApiBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.RestApiProps
class RestApiPropsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false\n')
    api_key_source_type: typing.Optional[aws_cdk.aws_apigateway.ApiKeySourceType] = pydantic.Field(None, description='The source of the API key for metering requests according to a usage plan. Default: - Metering is disabled.\n')
    binary_media_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of binary media mime-types that are supported by the RestApi resource, such as "image/png" or "application/octet-stream". Default: - RestApi supports only UTF-8-encoded text payloads.\n')
    clone_from: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='The ID of the API Gateway RestApi resource that you want to clone. Default: - None.\n')
    endpoint_configuration: typing.Union[models.aws_apigateway.EndpointConfigurationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The EndpointConfiguration property type specifies the endpoint types of a REST API. Default: EndpointType.EDGE\n')
    min_compression_size: typing.Optional[models.SizeDef] = pydantic.Field(None, description='A Size(in bytes, kibibytes, mebibytes etc) that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    minimum_compression_size: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n\n:exampleMetadata: infused\n\nExample::\n\n    state_machine = stepfunctions.StateMachine(self, "MyStateMachine",\n        state_machine_type=stepfunctions.StateMachineType.EXPRESS,\n        definition=stepfunctions.Chain.start(stepfunctions.Pass(self, "Pass"))\n    )\n\n    api = apigateway.RestApi(self, "Api",\n        rest_api_name="MyApi"\n    )\n    api.root.add_method("GET", apigateway.StepFunctionsIntegration.start_execution(state_machine))\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments', 'api_key_source_type', 'binary_media_types', 'clone_from', 'endpoint_configuration', 'min_compression_size', 'minimum_compression_size']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.RestApiProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.SpecRestApiProps
class SpecRestApiPropsDef(BaseStruct):
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false\n')
    api_definition: models.aws_apigateway.ApiDefinitionDef = pydantic.Field(..., description='An OpenAPI definition compatible with API Gateway.\n')
    min_compression_size: typing.Optional[models.SizeDef] = pydantic.Field(None, description='A Size(in bytes, kibibytes, mebibytes etc) that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n\n:exampleMetadata: infused\n\nExample::\n\n    # integration: apigateway.Integration\n\n\n    api = apigateway.SpecRestApi(self, "books-api",\n        api_definition=apigateway.ApiDefinition.from_asset("path-to-file.json")\n    )\n\n    books_resource = api.root.add_resource("books")\n    books_resource.add_method("GET", integration)\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments', 'api_definition', 'min_compression_size']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.SpecRestApiProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SpecRestApiPropsDefConfig] = pydantic.Field(None)


class SpecRestApiPropsDefConfig(pydantic.BaseModel):
    api_definition_config: typing.Optional[models.aws_apigateway.ApiDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.StageAttributes
class StageAttributesDef(BaseStruct):
    rest_api: typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef] = pydantic.Field(..., description='The RestApi that the stage belongs to.\n')
    stage_name: str = pydantic.Field(..., description='The name of the stage.\n\n:exampleMetadata: infused\n\nExample::\n\n    # rest_api: apigateway.IRestApi\n\n    imported_stage = apigateway.Stage.from_stage_attributes(self, "imported-stage",\n        stage_name="myStageName",\n        rest_api=rest_api\n    )\n\n    imported_stage.add_api_key("MyApiKey")\n')
    _init_params: typing.ClassVar[list[str]] = ['rest_api', 'stage_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.StageAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[StageAttributesDefConfig] = pydantic.Field(None)


class StageAttributesDefConfig(pydantic.BaseModel):
    rest_api_config: typing.Optional[models._interface_methods.AwsApigatewayIRestApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.StageOptions
class StageOptionsDef(BaseStruct):
    cache_data_encrypted: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the cached responses are encrypted. Default: false')
    cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached. Default: Duration.minutes(5)\n')
    caching_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached. Default: - Caching is Disabled.\n')
    data_trace_enabled: typing.Optional[bool] = pydantic.Field(None, description="Specifies whether data trace logging is enabled for this method. When enabled, API gateway will log the full API requests and responses. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this feature for production APIs. Default: false\n")
    logging_level: typing.Optional[aws_cdk.aws_apigateway.MethodLoggingLevel] = pydantic.Field(None, description='Specifies the logging level for this method, which effects the log entries pushed to Amazon CloudWatch Logs. Default: - Off\n')
    metrics_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether Amazon CloudWatch metrics are enabled for this method. Default: false\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling burst limit. The total rate of all requests in your AWS account is limited to 5,000 requests. Default: - No additional restriction.\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling rate limit. The total rate of all requests in your AWS account is limited to 10,000 requests per second (rps). Default: - No additional restriction.\n')
    access_log_destination: typing.Optional[typing.Union[models.aws_apigateway.LogGroupLogDestinationDef]] = pydantic.Field(None, description='The CloudWatch Logs log group. Default: - No destination\n')
    access_log_format: typing.Optional[models.aws_apigateway.AccessLogFormatDef] = pydantic.Field(None, description='A single line format of access logs of data, as specified by selected $content variables. The format must include either ``AccessLogFormat.contextRequestId()`` or ``AccessLogFormat.contextExtendedRequestId()``. Default: - Common Log Format\n')
    cache_cluster_enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether cache clustering is enabled for the stage. Default: - Disabled for the stage.\n')
    cache_cluster_size: typing.Optional[str] = pydantic.Field(None, description="The stage's cache cluster size. Default: 0.5\n")
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the client certificate that API Gateway uses to call your integration endpoints in the stage. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the stage. Default: - No description.\n')
    documentation_version: typing.Optional[str] = pydantic.Field(None, description='The version identifier of the API documentation snapshot. Default: - No documentation version.\n')
    method_options: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.MethodDeploymentOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Method deployment options for specific resources/methods. These will override common options defined in ``StageOptions#methodOptions``. Default: - Common options will be used.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of the stage, which API Gateway uses as the first path segment in the invoked Uniform Resource Identifier (URI). Default: - "prod"\n')
    tracing_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether Amazon X-Ray tracing is enabled for this method. Default: false\n')
    variables: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map that defines the stage variables. Variable names must consist of alphanumeric characters, and the values must match the following regular expression: [A-Za-z0-9-._~:/?#&=,]+. Default: - No stage variables.\n\n:exampleMetadata: infused\n\nExample::\n\n    log_group = logs.LogGroup(self, "ApiGatewayAccessLogs")\n    api = apigateway.RestApi(self, "books",\n        deploy_options=apigateway.StageOptions(\n            access_log_destination=apigateway.LogGroupLogDestination(log_group),\n            access_log_format=apigateway.AccessLogFormat.clf()\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_data_encrypted', 'cache_ttl', 'caching_enabled', 'data_trace_enabled', 'logging_level', 'metrics_enabled', 'throttling_burst_limit', 'throttling_rate_limit', 'access_log_destination', 'access_log_format', 'cache_cluster_enabled', 'cache_cluster_size', 'client_certificate_id', 'description', 'documentation_version', 'method_options', 'stage_name', 'tracing_enabled', 'variables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.StageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.StageProps
class StagePropsDef(BaseStruct):
    cache_data_encrypted: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the cached responses are encrypted. Default: false')
    cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached. Default: Duration.minutes(5)\n')
    caching_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached. Default: - Caching is Disabled.\n')
    data_trace_enabled: typing.Optional[bool] = pydantic.Field(None, description="Specifies whether data trace logging is enabled for this method. When enabled, API gateway will log the full API requests and responses. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this feature for production APIs. Default: false\n")
    logging_level: typing.Optional[aws_cdk.aws_apigateway.MethodLoggingLevel] = pydantic.Field(None, description='Specifies the logging level for this method, which effects the log entries pushed to Amazon CloudWatch Logs. Default: - Off\n')
    metrics_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether Amazon CloudWatch metrics are enabled for this method. Default: false\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling burst limit. The total rate of all requests in your AWS account is limited to 5,000 requests. Default: - No additional restriction.\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling rate limit. The total rate of all requests in your AWS account is limited to 10,000 requests per second (rps). Default: - No additional restriction.\n')
    access_log_destination: typing.Optional[typing.Union[models.aws_apigateway.LogGroupLogDestinationDef]] = pydantic.Field(None, description='The CloudWatch Logs log group. Default: - No destination\n')
    access_log_format: typing.Optional[models.aws_apigateway.AccessLogFormatDef] = pydantic.Field(None, description='A single line format of access logs of data, as specified by selected $content variables. The format must include either ``AccessLogFormat.contextRequestId()`` or ``AccessLogFormat.contextExtendedRequestId()``. Default: - Common Log Format\n')
    cache_cluster_enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether cache clustering is enabled for the stage. Default: - Disabled for the stage.\n')
    cache_cluster_size: typing.Optional[str] = pydantic.Field(None, description="The stage's cache cluster size. Default: 0.5\n")
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the client certificate that API Gateway uses to call your integration endpoints in the stage. Default: - None.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the purpose of the stage. Default: - No description.\n')
    documentation_version: typing.Optional[str] = pydantic.Field(None, description='The version identifier of the API documentation snapshot. Default: - No documentation version.\n')
    method_options: typing.Optional[typing.Mapping[str, typing.Union[models.aws_apigateway.MethodDeploymentOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Method deployment options for specific resources/methods. These will override common options defined in ``StageOptions#methodOptions``. Default: - Common options will be used.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of the stage, which API Gateway uses as the first path segment in the invoked Uniform Resource Identifier (URI). Default: - "prod"\n')
    tracing_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether Amazon X-Ray tracing is enabled for this method. Default: false\n')
    variables: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map that defines the stage variables. Variable names must consist of alphanumeric characters, and the values must match the following regular expression: [A-Za-z0-9-._~:/?#&=,]+. Default: - No stage variables.\n')
    deployment: models.aws_apigateway.DeploymentDef = pydantic.Field(..., description='The deployment that this stage points to [disable-awslint:ref-via-interface].\n\n:exampleMetadata: infused\n\nExample::\n\n    # production stage\n    prd_log_group = logs.LogGroup(self, "PrdLogs")\n    api = apigateway.RestApi(self, "books",\n        deploy_options=apigateway.StageOptions(\n            access_log_destination=apigateway.LogGroupLogDestination(prd_log_group),\n            access_log_format=apigateway.AccessLogFormat.json_with_standard_fields()\n        )\n    )\n    deployment = apigateway.Deployment(self, "Deployment", api=api)\n\n    # development stage\n    dev_log_group = logs.LogGroup(self, "DevLogs")\n    apigateway.Stage(self, "dev",\n        deployment=deployment,\n        access_log_destination=apigateway.LogGroupLogDestination(dev_log_group),\n        access_log_format=apigateway.AccessLogFormat.json_with_standard_fields(\n            caller=False,\n            http_method=True,\n            ip=True,\n            protocol=True,\n            request_time=True,\n            resource_path=True,\n            response_length=True,\n            status=True,\n            user=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_data_encrypted', 'cache_ttl', 'caching_enabled', 'data_trace_enabled', 'logging_level', 'metrics_enabled', 'throttling_burst_limit', 'throttling_rate_limit', 'access_log_destination', 'access_log_format', 'cache_cluster_enabled', 'cache_cluster_size', 'client_certificate_id', 'description', 'documentation_version', 'method_options', 'stage_name', 'tracing_enabled', 'variables', 'deployment']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.StageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[StagePropsDefConfig] = pydantic.Field(None)


class StagePropsDefConfig(pydantic.BaseModel):
    deployment_config: typing.Optional[models.aws_apigateway.DeploymentDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.StepFunctionsExecutionIntegrationOptions
class StepFunctionsExecutionIntegrationOptionsDef(BaseStruct):
    cache_key_parameters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of request parameters whose values are to be cached. It determines request parameters that will make it into the cache key.\n')
    cache_namespace: typing.Optional[str] = pydantic.Field(None, description='An API-specific tag group of related cached parameters.\n')
    connection_type: typing.Optional[aws_cdk.aws_apigateway.ConnectionType] = pydantic.Field(None, description='The type of network connection to the integration endpoint. Default: - ConnectionType.VPC_LINK if ``vpcLink`` property is configured; ConnectionType.Internet otherwise.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigateway.ContentHandling] = pydantic.Field(None, description="Specifies how to handle request payload content type conversions. Default: none if this property isn't defined, the request payload is passed through from the method request to the integration request without modification, provided that the ``passthroughBehaviors`` property is configured to support payload pass-through.\n")
    credentials_passthrough: typing.Optional[bool] = pydantic.Field(None, description="Requires that the caller's identity be passed through from the request. Default: Caller identity is not passed through\n")
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that API Gateway assumes. Mutually exclusive with ``credentialsPassThrough``. Default: A role is not assumed\n')
    integration_responses: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.IntegrationResponseDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The response that API Gateway provides after a method's backend completes processing a request. API Gateway intercepts the response from the backend so that you can control how API Gateway surfaces backend responses. For example, you can map the backend status codes to codes that you define.\n")
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigateway.PassthroughBehavior] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The request parameters that API Gateway sends with the backend request. Specify request parameters as key-value pairs (string-to-string mappings), with a destination as the key and a source as the value. Specify the destination by using the following pattern integration.request.location.name, where location is querystring, path, or header, and name is a valid, unique parameter name. The source must be an existing method request parameter or a static value. You must enclose static values in single quotation marks and pre-encode these values based on their destination in the request.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map of Apache Velocity templates that are applied on the request payload. The template that API Gateway uses is based on the value of the Content-Type header that\'s sent by the client. The content type value is the key, and the template is the value (specified as a string), such as the following snippet:: { "application/json": "{ \\"statusCode\\": 200 }" }\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n')
    vpc_link: typing.Optional[typing.Union[models.aws_apigateway.VpcLinkDef]] = pydantic.Field(None, description='The VpcLink used for the integration. Required if connectionType is VPC_LINK\n')
    authorizer: typing.Optional[bool] = pydantic.Field(None, description='If the whole authorizer object, including custom context values should be in the execution input. The execution input will include a new key ``authorizer``: { "body": {}, "authorizer": { "key": "value" } } Default: false\n')
    headers: typing.Optional[bool] = pydantic.Field(None, description='Check if header is to be included inside the execution input. The execution input will include a new key ``headers``: { "body": {}, "headers": { "header1": "value", "header2": "value" } } Default: false\n')
    path: typing.Optional[bool] = pydantic.Field(None, description='Check if path is to be included inside the execution input. The execution input will include a new key ``path``: { "body": {}, "path": { "resourceName": "resourceValue" } } Default: true\n')
    querystring: typing.Optional[bool] = pydantic.Field(None, description='Check if querystring is to be included inside the execution input. The execution input will include a new key ``queryString``: { "body": {}, "querystring": { "key": "value" } } Default: true\n')
    request_context: typing.Union[models.aws_apigateway.RequestContextDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which details of the incoming request must be passed onto the underlying state machine, such as, account id, user identity, request id, etc. The execution input will include a new key ``requestContext``: { "body": {}, "requestContext": { "key": "value" } } Default: - all parameters within request context will be set as false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigateway as apigateway\n    from aws_cdk import aws_iam as iam\n\n    # role: iam.Role\n    # vpc_link: apigateway.VpcLink\n\n    step_functions_execution_integration_options = apigateway.StepFunctionsExecutionIntegrationOptions(\n        authorizer=False,\n        cache_key_parameters=["cacheKeyParameters"],\n        cache_namespace="cacheNamespace",\n        connection_type=apigateway.ConnectionType.INTERNET,\n        content_handling=apigateway.ContentHandling.CONVERT_TO_BINARY,\n        credentials_passthrough=False,\n        credentials_role=role,\n        headers=False,\n        integration_responses=[apigateway.IntegrationResponse(\n            status_code="statusCode",\n\n            # the properties below are optional\n            content_handling=apigateway.ContentHandling.CONVERT_TO_BINARY,\n            response_parameters={\n                "response_parameters_key": "responseParameters"\n            },\n            response_templates={\n                "response_templates_key": "responseTemplates"\n            },\n            selection_pattern="selectionPattern"\n        )],\n        passthrough_behavior=apigateway.PassthroughBehavior.WHEN_NO_MATCH,\n        path=False,\n        querystring=False,\n        request_context=apigateway.RequestContext(\n            account_id=False,\n            api_id=False,\n            api_key=False,\n            authorizer_principal_id=False,\n            caller=False,\n            cognito_authentication_provider=False,\n            cognito_authentication_type=False,\n            cognito_identity_id=False,\n            cognito_identity_pool_id=False,\n            http_method=False,\n            request_id=False,\n            resource_id=False,\n            resource_path=False,\n            source_ip=False,\n            stage=False,\n            user=False,\n            user_agent=False,\n            user_arn=False\n        ),\n        request_parameters={\n            "request_parameters_key": "requestParameters"\n        },\n        request_templates={\n            "request_templates_key": "requestTemplates"\n        },\n        timeout=cdk.Duration.minutes(30),\n        vpc_link=vpc_link\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_key_parameters', 'cache_namespace', 'connection_type', 'content_handling', 'credentials_passthrough', 'credentials_role', 'integration_responses', 'passthrough_behavior', 'request_parameters', 'request_templates', 'timeout', 'vpc_link', 'authorizer', 'headers', 'path', 'querystring', 'request_context']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.StepFunctionsExecutionIntegrationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.StepFunctionsRestApiProps
class StepFunctionsRestApiPropsDef(BaseStruct):
    default_cors_preflight_options: typing.Union[models.aws_apigateway.CorsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Adds a CORS preflight OPTIONS method to this resource and all child resources. You can add CORS at the resource-level using ``addCorsPreflight``. Default: - CORS is disabled\n')
    default_integration: typing.Optional[models.aws_apigateway.IntegrationDef] = pydantic.Field(None, description='An integration to use as a default for all methods created within this API unless an integration is specified. Default: - Inherited from parent.\n')
    default_method_options: typing.Union[models.aws_apigateway.MethodOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Method options to use as a default for all methods created within this API unless custom options are specified. Default: - Inherited from parent.\n')
    cloud_watch_role: typing.Optional[bool] = pydantic.Field(None, description='Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise\n')
    deploy: typing.Optional[bool] = pydantic.Field(None, description='Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true\n')
    deploy_options: typing.Union[models.aws_apigateway.StageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'\n")
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false\n')
    domain_name: typing.Union[models.aws_apigateway.DomainNameOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.\n')
    endpoint_export_name: typing.Optional[str] = pydantic.Field(None, description='Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export\n')
    endpoint_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigateway.EndpointType]] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE\n')
    fail_on_warnings: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom header parameters for the request. Default: - No parameters.\n')
    policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='A policy document that contains the permissions for this RestApi. Default: - No policy.\n')
    rest_api_name: typing.Optional[str] = pydantic.Field(None, description='A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.\n')
    retain_deployments: typing.Optional[bool] = pydantic.Field(None, description='Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false\n')
    api_key_source_type: typing.Optional[aws_cdk.aws_apigateway.ApiKeySourceType] = pydantic.Field(None, description='The source of the API key for metering requests according to a usage plan. Default: - Metering is disabled.\n')
    binary_media_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of binary media mime-types that are supported by the RestApi resource, such as "image/png" or "application/octet-stream". Default: - RestApi supports only UTF-8-encoded text payloads.\n')
    clone_from: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='The ID of the API Gateway RestApi resource that you want to clone. Default: - None.\n')
    endpoint_configuration: typing.Union[models.aws_apigateway.EndpointConfigurationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The EndpointConfiguration property type specifies the endpoint types of a REST API. Default: EndpointType.EDGE\n')
    min_compression_size: typing.Optional[models.SizeDef] = pydantic.Field(None, description='A Size(in bytes, kibibytes, mebibytes etc) that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    minimum_compression_size: typing.Union[int, float, None] = pydantic.Field(None, description='(deprecated) A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (when undefined) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size. Default: - Compression is disabled.\n')
    state_machine: typing.Union[models.aws_stepfunctions.StateMachineDef] = pydantic.Field(..., description='The default State Machine that handles all requests from this API. This stateMachine will be used as a the default integration for all methods in this API, unless specified otherwise in ``addMethod``.\n')
    authorizer: typing.Optional[bool] = pydantic.Field(None, description='If the whole authorizer object, including custom context values should be in the execution input. The execution input will include a new key ``authorizer``: { "body": {}, "authorizer": { "key": "value" } } Default: false\n')
    headers: typing.Optional[bool] = pydantic.Field(None, description='Check if header is to be included inside the execution input. The execution input will include a new key ``headers``: { "body": {}, "headers": { "header1": "value", "header2": "value" } } Default: false\n')
    path: typing.Optional[bool] = pydantic.Field(None, description='Check if path is to be included inside the execution input. The execution input will include a new key ``path``: { "body": {}, "path": { "resourceName": "resourceValue" } } Default: true\n')
    querystring: typing.Optional[bool] = pydantic.Field(None, description='Check if querystring is to be included inside the execution input. The execution input will include a new key ``queryString``: { "body": {}, "querystring": { "key": "value" } } Default: true\n')
    request_context: typing.Union[models.aws_apigateway.RequestContextDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which details of the incoming request must be passed onto the underlying state machine, such as, account id, user identity, request id, etc. The execution input will include a new key ``requestContext``: { "body": {}, "requestContext": { "key": "value" } } Default: - all parameters within request context will be set as false\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that API Gateway will assume to start the execution of the state machine. Default: - a new role is created\n\n:exampleMetadata: infused\n\nExample::\n\n    state_machine_definition = stepfunctions.Pass(self, "PassState")\n\n    state_machine = stepfunctions.StateMachine(self, "StateMachine",\n        definition=state_machine_definition,\n        state_machine_type=stepfunctions.StateMachineType.EXPRESS\n    )\n\n    apigateway.StepFunctionsRestApi(self, "StepFunctionsRestApi",\n        deploy=True,\n        state_machine=state_machine\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_cors_preflight_options', 'default_integration', 'default_method_options', 'cloud_watch_role', 'deploy', 'deploy_options', 'description', 'disable_execute_api_endpoint', 'domain_name', 'endpoint_export_name', 'endpoint_types', 'fail_on_warnings', 'parameters', 'policy', 'rest_api_name', 'retain_deployments', 'api_key_source_type', 'binary_media_types', 'clone_from', 'endpoint_configuration', 'min_compression_size', 'minimum_compression_size', 'state_machine', 'authorizer', 'headers', 'path', 'querystring', 'request_context', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.StepFunctionsRestApiProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[StepFunctionsRestApiPropsDefConfig] = pydantic.Field(None)


class StepFunctionsRestApiPropsDefConfig(pydantic.BaseModel):
    state_machine_config: typing.Optional[models._interface_methods.AwsStepfunctionsIStateMachineDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.ThrottleSettings
class ThrottleSettingsDef(BaseStruct):
    burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum API request rate limit over a time ranging from one to a few seconds. Default: none\n')
    rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The API request steady-state rate limit (average requests per second over an extended period of time). Default: none\n\n:link: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html\n:exampleMetadata: infused\n\nExample::\n\n    # integration: apigateway.LambdaIntegration\n\n\n    api = apigateway.RestApi(self, "hello-api")\n\n    v1 = api.root.add_resource("v1")\n    echo = v1.add_resource("echo")\n    echo_method = echo.add_method("GET", integration, api_key_required=True)\n\n    plan = api.add_usage_plan("UsagePlan",\n        name="Easy",\n        throttle=apigateway.ThrottleSettings(\n            rate_limit=10,\n            burst_limit=2\n        )\n    )\n\n    key = api.add_api_key("ApiKey")\n    plan.add_api_key(key)\n')
    _init_params: typing.ClassVar[list[str]] = ['burst_limit', 'rate_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ThrottleSettings'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ThrottlingPerMethod
class ThrottlingPerMethodDef(BaseStruct):
    method: models.aws_apigateway.MethodDef = pydantic.Field(..., description='[disable-awslint:ref-via-interface] The method for which you specify the throttling settings. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any]] = pydantic.Field(..., description='Specifies the overall request rate (average requests per second) and burst capacity. Default: none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # method: apigateway.Method\n\n    throttling_per_method = apigateway.ThrottlingPerMethod(\n        method=method,\n        throttle=apigateway.ThrottleSettings(\n            burst_limit=123,\n            rate_limit=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['method', 'throttle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.ThrottlingPerMethod'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ThrottlingPerMethodDefConfig] = pydantic.Field(None)


class ThrottlingPerMethodDefConfig(pydantic.BaseModel):
    method_config: typing.Optional[models.aws_apigateway.MethodDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.TokenAuthorizerProps
class TokenAuthorizerPropsDef(BaseStruct):
    handler: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description="The handler for the authorizer lambda function. The handler must follow a very specific protocol on the input it receives and the output it needs to produce. API Gateway has documented the handler's `input specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-input.html>`_ and `output specification <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-output.html>`_.\n")
    assume_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description="An optional IAM role for APIGateway to assume before calling the Lambda-based authorizer. The IAM role must be assumable by 'apigateway.amazonaws.com'. Default: - A resource policy is added to the Lambda function allowing apigateway.amazonaws.com to invoke the function.\n")
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='An optional human friendly name for the authorizer. Note that, this is not the primary identifier of the authorizer. Default: - the unique construct ID\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to 0. Default: Duration.minutes(5)\n')
    identity_source: typing.Optional[str] = pydantic.Field(None, description="The request header mapping expression for the bearer token. This is typically passed as part of the header, in which case this should be ``method.request.header.Authorizer`` where Authorizer is the header containing the bearer token. Default: ``IdentitySource.header('Authorization')``\n")
    validation_regex: typing.Optional[str] = pydantic.Field(None, description='An optional regex to be matched against the authorization token. When matched the authorizer lambda is invoked, otherwise a 401 Unauthorized is returned to the client. Default: - no regex filter will be applied.\n\n:exampleMetadata: infused\n\nExample::\n\n    # auth_fn: lambda.Function\n    # books: apigateway.Resource\n\n\n    auth = apigateway.TokenAuthorizer(self, "booksAuthorizer",\n        handler=auth_fn\n    )\n\n    books.add_method("GET", apigateway.HttpIntegration("http://amazon.com"),\n        authorizer=auth\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['handler', 'assume_role', 'authorizer_name', 'results_cache_ttl', 'identity_source', 'validation_regex']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.TokenAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[TokenAuthorizerPropsDefConfig] = pydantic.Field(None)


class TokenAuthorizerPropsDefConfig(pydantic.BaseModel):
    handler_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigateway.UsagePlanPerApiStage
class UsagePlanPerApiStageDef(BaseStruct):
    api: typing.Optional[typing.Union[models.aws_apigateway.RestApiBaseDef, models.aws_apigateway.LambdaRestApiDef, models.aws_apigateway.RestApiDef, models.aws_apigateway.SpecRestApiDef, models.aws_apigateway.StepFunctionsRestApiDef]] = pydantic.Field(None, description='Default: none\n')
    stage: typing.Optional[models.aws_apigateway.StageDef] = pydantic.Field(None, description='[disable-awslint:ref-via-interface]. Default: none\n')
    throttle: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.ThrottlingPerMethodDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Default: none\n\n:exampleMetadata: infused\n\nExample::\n\n    # plan: apigateway.UsagePlan\n    # api: apigateway.RestApi\n    # echo_method: apigateway.Method\n\n\n    plan.add_api_stage(\n        stage=api.deployment_stage,\n        throttle=[apigateway.ThrottlingPerMethod(\n            method=echo_method,\n            throttle=apigateway.ThrottleSettings(\n                rate_limit=10,\n                burst_limit=2\n            )\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api', 'stage', 'throttle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.UsagePlanPerApiStage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.UsagePlanProps
class UsagePlanPropsDef(BaseStruct):
    api_stages: typing.Optional[typing.Sequence[typing.Union[models.aws_apigateway.UsagePlanPerApiStageDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='API Stages to be associated with the usage plan. Default: none')
    description: typing.Optional[str] = pydantic.Field(None, description='Represents usage plan purpose. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='Name for this usage plan. Default: none\n')
    quota: typing.Union[models.aws_apigateway.QuotaSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Number of requests clients can make in a given time period. Default: none\n')
    throttle: typing.Union[models.aws_apigateway.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overall throttle settings for the API. Default: none\n\n:exampleMetadata: infused\n\nExample::\n\n    # integration: apigateway.LambdaIntegration\n\n\n    api = apigateway.RestApi(self, "hello-api")\n\n    v1 = api.root.add_resource("v1")\n    echo = v1.add_resource("echo")\n    echo_method = echo.add_method("GET", integration, api_key_required=True)\n\n    plan = api.add_usage_plan("UsagePlan",\n        name="Easy",\n        throttle=apigateway.ThrottleSettings(\n            rate_limit=10,\n            burst_limit=2\n        )\n    )\n\n    key = api.add_api_key("ApiKey")\n    plan.add_api_key(key)\n')
    _init_params: typing.ClassVar[list[str]] = ['api_stages', 'description', 'name', 'quota', 'throttle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.UsagePlanProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.VpcLinkProps
class VpcLinkPropsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the VPC link. Default: no description\n')
    targets: typing.Optional[typing.Sequence[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]]] = pydantic.Field(None, description='The network load balancers of the VPC targeted by the VPC link. The network load balancers must be owned by the same AWS account of the API owner. Default: - no targets. Use ``addTargets`` to add targets\n')
    vpc_link_name: typing.Optional[str] = pydantic.Field(None, description='The name used to label and identify the VPC link. Default: - automatically generated name\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_elasticloadbalancingv2 as elbv2\n\n\n    vpc = ec2.Vpc(self, "VPC")\n    nlb = elbv2.NetworkLoadBalancer(self, "NLB",\n        vpc=vpc\n    )\n    link = apigateway.VpcLink(self, "link",\n        targets=[nlb]\n    )\n\n    integration = apigateway.Integration(\n        type=apigateway.IntegrationType.HTTP_PROXY,\n        options=apigateway.IntegrationOptions(\n            connection_type=apigateway.ConnectionType.VPC_LINK,\n            vpc_link=link\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'targets', 'vpc_link_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.VpcLinkProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.ApiKeySourceType
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.AuthorizationType
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.ConnectionType
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.ContentHandling
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.EndpointType
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.IntegrationType
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.JsonSchemaType
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.JsonSchemaVersion
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.MethodLoggingLevel
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.PassthroughBehavior
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.Period
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.SecurityPolicy
# skipping emum

#  autogenerated from aws_cdk.aws_apigateway.IAccessLogDestination
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IApiKey
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IAuthorizer
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IDomainName
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IGatewayResponse
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IModel
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IRequestValidator
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IResource
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IRestApi
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IStage
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IUsagePlan
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.IVpcLink
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigateway.CfnAccount
class CfnAccountDef(BaseCfnResource):
    cloud_watch_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an Amazon CloudWatch role for the current Account.')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_role_arn']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnAccount'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnAccountDefConfig] = pydantic.Field(None)


class CfnAccountDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnAccountDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnAccountDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnAccountDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnAccountDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnAccountDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnAccountDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnAccountDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnAccountDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnAccountDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnAccountDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnAccountDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnAccountDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnAccountDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAccountDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAccountDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccountDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAccountDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccountDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAccountDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAccountDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAccountDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAccountDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAccountDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccountDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnAccountDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAccountDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccountDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnApiKey
class CfnApiKeyDef(BaseCfnResource):
    customer_id: typing.Optional[str] = pydantic.Field(None, description='An AWS Marketplace customer identifier, when integrating with the AWS SaaS Marketplace.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the ApiKey.\n')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether the ApiKey can be used by callers.\n')
    generate_distinct_id: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether ( ``true`` ) or not ( ``false`` ) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    stage_keys: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnApiKey_StageKeyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with ``aws:`` . The tag value can be up to 256 characters.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='Specifies a value of the API key.')
    _init_params: typing.ClassVar[list[str]] = ['customer_id', 'description', 'enabled', 'generate_distinct_id', 'name', 'stage_keys', 'tags', 'value']
    _method_names: typing.ClassVar[list[str]] = ['StageKeyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnApiKey'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnApiKeyDefConfig] = pydantic.Field(None)


class CfnApiKeyDefConfig(pydantic.BaseModel):
    StageKeyProperty: typing.Optional[list[CfnApiKeyDefStagekeypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnApiKeyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnApiKeyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnApiKeyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnApiKeyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnApiKeyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnApiKeyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnApiKeyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnApiKeyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnApiKeyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnApiKeyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnApiKeyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnApiKeyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnApiKeyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnApiKeyDefStagekeypropertyParams(pydantic.BaseModel):
    rest_api_id: typing.Optional[str] = pydantic.Field(None, description='')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnApiKeyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnApiKeyDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiKeyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnApiKeyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiKeyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnApiKeyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnApiKeyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnApiKeyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnApiKeyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnApiKeyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiKeyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnApiKeyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnApiKeyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiKeyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnAuthorizer
class CfnAuthorizerDef(BaseCfnResource):
    name: str = pydantic.Field(..., description='The name of the authorizer.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    type: str = pydantic.Field(..., description='The authorizer type. Valid values are ``TOKEN`` for a Lambda function using a single authorization token submitted in a custom header, ``REQUEST`` for a Lambda function using incoming request parameters, and ``COGNITO_USER_POOLS`` for using an Amazon Cognito user pool.\n')
    authorizer_credentials: typing.Optional[str] = pydantic.Field(None, description="Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.\n")
    authorizer_result_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.\n')
    authorizer_uri: typing.Optional[str] = pydantic.Field(None, description="Specifies the authorizer's Uniform Resource Identifier (URI). For ``TOKEN`` or ``REQUEST`` authorizers, this must be a well-formed Lambda function URI, for example, ``arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations`` . In general, the URI has this form ``arn:aws:apigateway:{region}:lambda:path/{service_api}`` , where ``{region}`` is the same as the region hosting the Lambda function, ``path`` indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial ``/`` . For Lambda functions, this is usually of the form ``/2015-03-31/functions/[FunctionARN]/invocations`` .\n")
    auth_type: typing.Optional[str] = pydantic.Field(None, description='Optional customer-defined field, used in OpenAPI imports and exports without functional impact.\n')
    identity_source: typing.Optional[str] = pydantic.Field(None, description='The identity source for which authorization is requested. For a ``TOKEN`` or ``COGNITO_USER_POOLS`` authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is ``Auth`` , the header mapping expression is ``method.request.header.Auth`` . For the ``REQUEST`` authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an ``Auth`` header, a ``Name`` query string parameter are defined as identity sources, this value is ``method.request.header.Auth, method.request.querystring.Name`` . These parameters will be used to derive the authorization caching key and to perform runtime validation of the ``REQUEST`` authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.\n')
    identity_validation_expression: typing.Optional[str] = pydantic.Field(None, description="A validation expression for the incoming identity token. For ``TOKEN`` authorizers, this value is a regular expression. For ``COGNITO_USER_POOLS`` authorizers, API Gateway will match the ``aud`` field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the ``REQUEST`` authorizer.\n")
    provider_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the Amazon Cognito user pool ARNs for the ``COGNITO_USER_POOLS`` authorizer. Each element is of this format: ``arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}`` . For a ``TOKEN`` or ``REQUEST`` authorizer, this is not defined.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'rest_api_id', 'type', 'authorizer_credentials', 'authorizer_result_ttl_in_seconds', 'authorizer_uri', 'auth_type', 'identity_source', 'identity_validation_expression', 'provider_arns']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnAuthorizerDefConfig] = pydantic.Field(None)


class CfnAuthorizerDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnAuthorizerDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnAuthorizerDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnAuthorizerDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnAuthorizerDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnAuthorizerDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnAuthorizerDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnAuthorizerDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnAuthorizerDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnAuthorizerDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnAuthorizerDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnAuthorizerDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnAuthorizerDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnAuthorizerDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAuthorizerDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAuthorizerDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAuthorizerDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAuthorizerDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAuthorizerDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAuthorizerDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAuthorizerDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAuthorizerDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAuthorizerDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAuthorizerDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnAuthorizerDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAuthorizerDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAuthorizerDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnBasePathMapping
class CfnBasePathMappingDef(BaseCfnResource):
    id_: str = pydantic.Field(..., description='- scoped id of the resource.\n')
    domain_name: str = pydantic.Field(..., description='The domain name of the BasePathMapping resource to be described.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description='The base path name that callers of the API must provide as part of the URL after the domain name.\n')
    rest_api_id: typing.Optional[str] = pydantic.Field(None, description='The string identifier of the associated RestApi.\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='The name of the associated stage.')
    _init_params: typing.ClassVar[list[str]] = ['id_', 'domain_name', 'base_path', 'rest_api_id', 'stage']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnBasePathMapping'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnBasePathMappingDefConfig] = pydantic.Field(None)


class CfnBasePathMappingDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnBasePathMappingDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnBasePathMappingDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnBasePathMappingDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnBasePathMappingDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnBasePathMappingDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnBasePathMappingDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnBasePathMappingDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnBasePathMappingDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnBasePathMappingDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnBasePathMappingDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnBasePathMappingDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnBasePathMappingDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnBasePathMappingDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnBasePathMappingDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnBasePathMappingDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBasePathMappingDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnBasePathMappingDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBasePathMappingDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnBasePathMappingDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnBasePathMappingDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnBasePathMappingDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnBasePathMappingDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnBasePathMappingDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBasePathMappingDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnBasePathMappingDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnBasePathMappingDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBasePathMappingDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnClientCertificate
class CfnClientCertificateDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the client certificate.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnClientCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnClientCertificateDefConfig] = pydantic.Field(None)


class CfnClientCertificateDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnClientCertificateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnClientCertificateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnClientCertificateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnClientCertificateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnClientCertificateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnClientCertificateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnClientCertificateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnClientCertificateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnClientCertificateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnClientCertificateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnClientCertificateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnClientCertificateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnClientCertificateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnClientCertificateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnClientCertificateDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientCertificateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnClientCertificateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientCertificateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnClientCertificateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnClientCertificateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnClientCertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnClientCertificateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnClientCertificateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientCertificateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnClientCertificateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnClientCertificateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientCertificateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnDeployment
class CfnDeploymentDef(BaseCfnResource):
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    deployment_canary_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_DeploymentCanarySettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The input configuration for a canary deployment.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the Deployment resource to create.\n')
    stage_description: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_StageDescriptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The description of the Stage resource for the Deployment resource to create. To specify a stage description, you must also provide a stage name.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Stage resource for the Deployment resource to create.')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'deployment_canary_settings', 'description', 'stage_description', 'stage_name']
    _method_names: typing.ClassVar[list[str]] = ['AccessLogSettingProperty', 'CanarySettingProperty', 'DeploymentCanarySettingsProperty', 'MethodSettingProperty', 'StageDescriptionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDeployment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDeploymentDefConfig] = pydantic.Field(None)


class CfnDeploymentDefConfig(pydantic.BaseModel):
    AccessLogSettingProperty: typing.Optional[list[CfnDeploymentDefAccesslogsettingpropertyParams]] = pydantic.Field(None, description='')
    CanarySettingProperty: typing.Optional[list[CfnDeploymentDefCanarysettingpropertyParams]] = pydantic.Field(None, description='')
    DeploymentCanarySettingsProperty: typing.Optional[list[CfnDeploymentDefDeploymentcanarysettingspropertyParams]] = pydantic.Field(None, description='')
    MethodSettingProperty: typing.Optional[list[CfnDeploymentDefMethodsettingpropertyParams]] = pydantic.Field(None, description='')
    StageDescriptionProperty: typing.Optional[list[CfnDeploymentDefStagedescriptionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDeploymentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDeploymentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDeploymentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDeploymentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDeploymentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDeploymentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDeploymentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDeploymentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDeploymentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDeploymentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDeploymentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDeploymentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDeploymentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDeploymentDefAccesslogsettingpropertyParams(pydantic.BaseModel):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='')
    format: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentDefCanarysettingpropertyParams(pydantic.BaseModel):
    percent_traffic: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stage_variable_overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    use_stage_cache: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentDefDeploymentcanarysettingspropertyParams(pydantic.BaseModel):
    percent_traffic: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stage_variable_overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    use_stage_cache: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentDefMethodsettingpropertyParams(pydantic.BaseModel):
    cache_data_encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    cache_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    caching_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    data_trace_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    http_method: typing.Optional[str] = pydantic.Field(None, description='')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='')
    metrics_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    resource_path: typing.Optional[str] = pydantic.Field(None, description='')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentDefStagedescriptionpropertyParams(pydantic.BaseModel):
    access_log_setting: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_AccessLogSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    cache_cluster_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    cache_cluster_size: typing.Optional[str] = pydantic.Field(None, description='')
    cache_data_encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    cache_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    caching_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    canary_setting: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_CanarySettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='')
    data_trace_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    documentation_version: typing.Optional[str] = pydantic.Field(None, description='')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='')
    method_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_MethodSettingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    metrics_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    tracing_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    variables: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeploymentDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeploymentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeploymentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeploymentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeploymentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeploymentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeploymentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDeploymentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeploymentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnDocumentationPart
class CfnDocumentationPartDef(BaseCfnResource):
    location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDocumentationPart_LocationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The location of the targeted API entity of the to-be-created documentation part.\n')
    properties: str = pydantic.Field(..., description='The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.')
    _init_params: typing.ClassVar[list[str]] = ['location', 'properties', 'rest_api_id']
    _method_names: typing.ClassVar[list[str]] = ['LocationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDocumentationPart'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDocumentationPartDefConfig] = pydantic.Field(None)


class CfnDocumentationPartDefConfig(pydantic.BaseModel):
    LocationProperty: typing.Optional[list[CfnDocumentationPartDefLocationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDocumentationPartDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDocumentationPartDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDocumentationPartDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDocumentationPartDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDocumentationPartDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDocumentationPartDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDocumentationPartDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDocumentationPartDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDocumentationPartDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDocumentationPartDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDocumentationPartDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDocumentationPartDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDocumentationPartDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDocumentationPartDefLocationpropertyParams(pydantic.BaseModel):
    method: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    status_code: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDocumentationPartDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDocumentationPartDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDocumentationPartDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDocumentationPartDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDocumentationPartDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDocumentationPartDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDocumentationPartDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDocumentationPartDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDocumentationPartDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDocumentationPartDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDocumentationPartDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDocumentationPartDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDocumentationPartDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDocumentationPartDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnDocumentationVersion
class CfnDocumentationVersionDef(BaseCfnResource):
    documentation_version: str = pydantic.Field(..., description='The version identifier of the to-be-updated documentation version.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about the new documentation snapshot.')
    _init_params: typing.ClassVar[list[str]] = ['documentation_version', 'rest_api_id', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDocumentationVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDocumentationVersionDefConfig] = pydantic.Field(None)


class CfnDocumentationVersionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnDocumentationVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDocumentationVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDocumentationVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDocumentationVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDocumentationVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDocumentationVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDocumentationVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDocumentationVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDocumentationVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDocumentationVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDocumentationVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDocumentationVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDocumentationVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDocumentationVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDocumentationVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDocumentationVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDocumentationVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDocumentationVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDocumentationVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDocumentationVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDocumentationVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDocumentationVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDocumentationVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDocumentationVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDocumentationVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDocumentationVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDocumentationVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnDomainName
class CfnDomainNameDef(BaseCfnResource):
    certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The reference to an AWS -managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The custom domain name as an API host name, for example, ``my-api.example.com`` .\n')
    endpoint_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDomainName_EndpointConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The endpoint configuration of this DomainName showing the endpoint types of the domain name.\n')
    mutual_tls_authentication: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDomainName_MutualTlsAuthenticationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.\n')
    ownership_verification_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the RegionalCertificateArn.\n')
    regional_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The reference to an AWS -managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.\n')
    security_policy: typing.Optional[str] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are ``TLS_1_0`` and ``TLS_1_2`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'domain_name', 'endpoint_configuration', 'mutual_tls_authentication', 'ownership_verification_certificate_arn', 'regional_certificate_arn', 'security_policy', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['EndpointConfigurationProperty', 'MutualTlsAuthenticationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDomainName'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDomainNameDefConfig] = pydantic.Field(None)


class CfnDomainNameDefConfig(pydantic.BaseModel):
    EndpointConfigurationProperty: typing.Optional[list[CfnDomainNameDefEndpointconfigurationpropertyParams]] = pydantic.Field(None, description='')
    MutualTlsAuthenticationProperty: typing.Optional[list[CfnDomainNameDefMutualtlsauthenticationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDomainNameDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDomainNameDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDomainNameDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDomainNameDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDomainNameDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDomainNameDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDomainNameDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDomainNameDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDomainNameDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDomainNameDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDomainNameDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDomainNameDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDomainNameDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDomainNameDefEndpointconfigurationpropertyParams(pydantic.BaseModel):
    types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDomainNameDefMutualtlsauthenticationpropertyParams(pydantic.BaseModel):
    truststore_uri: typing.Optional[str] = pydantic.Field(None, description='')
    truststore_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainNameDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDomainNameDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainNameDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDomainNameDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainNameDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDomainNameDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDomainNameDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDomainNameDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDomainNameDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDomainNameDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainNameDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDomainNameDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDomainNameDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainNameDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnGatewayResponse
class CfnGatewayResponseDef(BaseCfnResource):
    response_type: str = pydantic.Field(..., description='The response type of the associated GatewayResponse.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    response_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.\n')
    response_templates: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Response templates of the GatewayResponse as a string-to-string map of key-value pairs.\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='The HTTP status code for this GatewayResponse.')
    _init_params: typing.ClassVar[list[str]] = ['response_type', 'rest_api_id', 'response_parameters', 'response_templates', 'status_code']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnGatewayResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnGatewayResponseDefConfig] = pydantic.Field(None)


class CfnGatewayResponseDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnGatewayResponseDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnGatewayResponseDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnGatewayResponseDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnGatewayResponseDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnGatewayResponseDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnGatewayResponseDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnGatewayResponseDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnGatewayResponseDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnGatewayResponseDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnGatewayResponseDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnGatewayResponseDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnGatewayResponseDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnGatewayResponseDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnGatewayResponseDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGatewayResponseDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGatewayResponseDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGatewayResponseDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGatewayResponseDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGatewayResponseDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGatewayResponseDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGatewayResponseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGatewayResponseDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGatewayResponseDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGatewayResponseDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnGatewayResponseDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGatewayResponseDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGatewayResponseDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnMethod
class CfnMethodDef(BaseCfnResource):
    http_method: str = pydantic.Field(..., description="The method's HTTP verb.\n")
    resource_id: str = pydantic.Field(..., description='The Resource identifier for the MethodResponse resource.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    api_key_required: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A boolean flag specifying whether a valid ApiKey is required to invoke this method.\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of authorization scopes configured on the method. The scopes are used with a ``COGNITO_USER_POOLS`` authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.\n')
    authorization_type: typing.Optional[str] = pydantic.Field(None, description="The method's authorization type. This parameter is required. For valid values, see `Method <https://docs.aws.amazon.com/apigateway/latest/api/API_Method.html>`_ in the *API Gateway API Reference* . .. epigraph:: If you specify the ``AuthorizerId`` property, specify ``CUSTOM`` or ``COGNITO_USER_POOLS`` for this property.\n")
    authorizer_id: typing.Optional[str] = pydantic.Field(None, description="The identifier of an authorizer to use on this method. The method's authorization type must be ``CUSTOM`` or ``COGNITO_USER_POOLS`` .\n")
    integration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnMethod_IntegrationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents an ``HTTP`` , ``HTTP_PROXY`` , ``AWS`` , ``AWS_PROXY`` , or Mock integration.\n')
    method_responses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnMethod_MethodResponsePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Gets a method response associated with a given HTTP status code.\n')
    operation_name: typing.Optional[str] = pydantic.Field(None, description='A human-friendly operation identifier for the method. For example, you can assign the ``operationName`` of ``ListPets`` for the ``GET /pets`` method in the ``PetStore`` example.\n')
    request_models: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).\n')
    request_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]]], None] = pydantic.Field(None, description='A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of ``method.request.{location}.{name}`` , where ``location`` is ``querystring`` , ``path`` , or ``header`` and ``name`` is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required ( ``true`` ) or optional ( ``false`` ). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.\n')
    request_validator_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of a RequestValidator for request validation.')
    _init_params: typing.ClassVar[list[str]] = ['http_method', 'resource_id', 'rest_api_id', 'api_key_required', 'authorization_scopes', 'authorization_type', 'authorizer_id', 'integration', 'method_responses', 'operation_name', 'request_models', 'request_parameters', 'request_validator_id']
    _method_names: typing.ClassVar[list[str]] = ['IntegrationProperty', 'IntegrationResponseProperty', 'MethodResponseProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnMethod'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnMethodDefConfig] = pydantic.Field(None)


class CfnMethodDefConfig(pydantic.BaseModel):
    IntegrationProperty: typing.Optional[list[CfnMethodDefIntegrationpropertyParams]] = pydantic.Field(None, description='')
    IntegrationResponseProperty: typing.Optional[list[CfnMethodDefIntegrationresponsepropertyParams]] = pydantic.Field(None, description='')
    MethodResponseProperty: typing.Optional[list[CfnMethodDefMethodresponsepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnMethodDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnMethodDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnMethodDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnMethodDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnMethodDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnMethodDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnMethodDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnMethodDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnMethodDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnMethodDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnMethodDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnMethodDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnMethodDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnMethodDefIntegrationpropertyParams(pydantic.BaseModel):
    cache_key_parameters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    cache_namespace: typing.Optional[str] = pydantic.Field(None, description='')
    connection_id: typing.Optional[str] = pydantic.Field(None, description='')
    connection_type: typing.Optional[str] = pydantic.Field(None, description='')
    content_handling: typing.Optional[str] = pydantic.Field(None, description='')
    credentials: typing.Optional[str] = pydantic.Field(None, description='')
    integration_http_method: typing.Optional[str] = pydantic.Field(None, description='')
    integration_responses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnMethod_IntegrationResponsePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    passthrough_behavior: typing.Optional[str] = pydantic.Field(None, description='')
    request_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    request_templates: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    timeout_in_millis: typing.Union[int, float, None] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    uri: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMethodDefIntegrationresponsepropertyParams(pydantic.BaseModel):
    status_code: str = pydantic.Field(..., description='')
    content_handling: typing.Optional[str] = pydantic.Field(None, description='')
    response_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    response_templates: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    selection_pattern: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMethodDefMethodresponsepropertyParams(pydantic.BaseModel):
    status_code: str = pydantic.Field(..., description='')
    response_models: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    response_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]]], None] = pydantic.Field(None, description='')
    ...

class CfnMethodDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMethodDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMethodDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMethodDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMethodDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMethodDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMethodDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMethodDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMethodDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMethodDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMethodDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnMethodDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMethodDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMethodDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnModel
class CfnModelDef(BaseCfnResource):
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    content_type: typing.Optional[str] = pydantic.Field(None, description='The content-type for the model.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the model.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="A name for the model. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the model name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    schema_: typing.Any = pydantic.Field(None, description='The schema for the model. For ``application/json`` models, this should be JSON schema draft 4 model. Do not include "* /" characters in the description of any properties because such "* /" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API\'s SDK generated by API Gateway to fail.', alias='schema')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'content_type', 'description', 'name', 'schema']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnModel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnModelDefConfig] = pydantic.Field(None)


class CfnModelDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnModelDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnModelDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnModelDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnModelDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnModelDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnModelDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnModelDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnModelDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnModelDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnModelDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnModelDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnModelDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnModelDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnModelDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnModelDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnModelDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnModelDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnModelDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnModelDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnModelDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnModelDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnModelDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnModelDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnModelDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnModelDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnModelDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnModelDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnRequestValidator
class CfnRequestValidatorDef(BaseCfnResource):
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of this RequestValidator.\n')
    validate_request_body: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean flag to indicate whether to validate a request body according to the configured Model schema.\n')
    validate_request_parameters: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean flag to indicate whether to validate request parameters ( ``true`` ) or not ( ``false`` ).')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'name', 'validate_request_body', 'validate_request_parameters']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnRequestValidator'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRequestValidatorDefConfig] = pydantic.Field(None)


class CfnRequestValidatorDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnRequestValidatorDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRequestValidatorDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRequestValidatorDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRequestValidatorDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRequestValidatorDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRequestValidatorDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRequestValidatorDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRequestValidatorDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRequestValidatorDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRequestValidatorDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRequestValidatorDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRequestValidatorDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRequestValidatorDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnRequestValidatorDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRequestValidatorDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRequestValidatorDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRequestValidatorDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRequestValidatorDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRequestValidatorDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRequestValidatorDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRequestValidatorDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRequestValidatorDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRequestValidatorDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRequestValidatorDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnRequestValidatorDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRequestValidatorDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRequestValidatorDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnResource
class CfnResourceDef(BaseCfnResource):
    parent_id: str = pydantic.Field(..., description="The parent resource's identifier.\n")
    path_part: str = pydantic.Field(..., description='The last path segment for this resource.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.')
    _init_params: typing.ClassVar[list[str]] = ['parent_id', 'path_part', 'rest_api_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnResource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnResourceDefConfig] = pydantic.Field(None)


class CfnResourceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnResourceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnResourceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnResourceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnResourceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnResourceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnResourceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnResourceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnResourceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnResourceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnResourceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnResourceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnResourceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnResourceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnResourceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourceDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnResourceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnRestApi
class CfnRestApiDef(BaseCfnResource):
    api_key_source_type: typing.Optional[str] = pydantic.Field(None, description='The source of the API key for metering requests according to a usage plan. Valid values are: ``HEADER`` to read the API key from the ``X-API-Key`` header of a request. ``AUTHORIZER`` to read the API key from the ``UsageIdentifierKey`` from a custom authorizer.\n')
    binary_media_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.\n')
    body: typing.Any = pydantic.Field(None, description='An OpenAPI specification that defines a set of RESTful APIs in JSON format. For YAML templates, you can also provide the specification in YAML format.\n')
    body_s3_location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnRestApi_S3LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Amazon Simple Storage Service (Amazon S3) location that points to an OpenAPI file, which defines a set of RESTful APIs in JSON or YAML format.\n')
    clone_from: typing.Optional[str] = pydantic.Field(None, description='The ID of the RestApi that you want to clone from.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the RestApi.\n')
    disable_execute_api_endpoint: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether clients can invoke your API by using the default ``execute-api`` endpoint. By default, clients can invoke your API with the default ``https://{api_id}.execute-api.{region}.amazonaws.com`` endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint\n')
    endpoint_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnRestApi_EndpointConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. When importing an existing API, specify the endpoint configuration types using the ``Parameters`` property.\n')
    fail_on_warnings: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A query parameter to indicate whether to rollback the API update ( ``true`` ) or not ( ``false`` ) when a warning is encountered. The default value is ``false`` .\n')
    minimum_compression_size: typing.Union[int, float, None] = pydantic.Field(None, description='A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.\n')
    mode: typing.Optional[str] = pydantic.Field(None, description="This property applies only when you use OpenAPI to define your REST API. The ``Mode`` determines how API Gateway handles resource updates. Valid values are ``overwrite`` or ``merge`` . For ``overwrite`` , the new API definition replaces the existing one. The existing API identifier remains unchanged. For ``merge`` , the new API definition is merged with the existing API. If you don't specify this property, a default value is chosen. For REST APIs created before March 29, 2021, the default is ``overwrite`` . For REST APIs created after March 29, 2021, the new API definition takes precedence, but any container types such as endpoint configurations and binary media types are merged with the existing API. Use the default mode to define top-level ``RestApi`` properties in addition to using OpenAPI. Generally, it's preferred to use API Gateway's OpenAPI extensions to model these properties.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the RestApi. A name is required if the REST API is not based on an OpenAPI specification.\n')
    parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description="Custom header parameters as part of the request. For example, to exclude DocumentationParts from an imported API, set ``ignore=documentation`` as a ``parameters`` value, as in the AWS CLI command of ``aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'`` .\n")
    policy: typing.Any = pydantic.Field(None, description='A policy document that contains the permissions for the ``RestApi`` resource. To set the ARN for the policy, use the ``!Join`` intrinsic function with ``""`` as delimiter and values of ``"execute-api:/"`` and ``"*"`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with ``aws:`` . The tag value can be up to 256 characters.')
    _init_params: typing.ClassVar[list[str]] = ['api_key_source_type', 'binary_media_types', 'body', 'body_s3_location', 'clone_from', 'description', 'disable_execute_api_endpoint', 'endpoint_configuration', 'fail_on_warnings', 'minimum_compression_size', 'mode', 'name', 'parameters', 'policy', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['EndpointConfigurationProperty', 'S3LocationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnRestApi'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRestApiDefConfig] = pydantic.Field(None)


class CfnRestApiDefConfig(pydantic.BaseModel):
    EndpointConfigurationProperty: typing.Optional[list[CfnRestApiDefEndpointconfigurationpropertyParams]] = pydantic.Field(None, description='')
    S3LocationProperty: typing.Optional[list[CfnRestApiDefS3LocationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnRestApiDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRestApiDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRestApiDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRestApiDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRestApiDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRestApiDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRestApiDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRestApiDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRestApiDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRestApiDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRestApiDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRestApiDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRestApiDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRestApiDefEndpointconfigurationpropertyParams(pydantic.BaseModel):
    types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    vpc_endpoint_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnRestApiDefS3LocationpropertyParams(pydantic.BaseModel):
    bucket: typing.Optional[str] = pydantic.Field(None, description='')
    e_tag: typing.Optional[str] = pydantic.Field(None, description='')
    key: typing.Optional[str] = pydantic.Field(None, description='')
    version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRestApiDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRestApiDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRestApiDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRestApiDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRestApiDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRestApiDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRestApiDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRestApiDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRestApiDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRestApiDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRestApiDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnRestApiDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRestApiDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRestApiDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnStage
class CfnStageDef(BaseCfnResource):
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    access_log_setting: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnStage_AccessLogSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Access log settings, including the access log format and access log destination ARN.\n')
    cache_cluster_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether a cache cluster is enabled for the stage.\n')
    cache_cluster_size: typing.Optional[str] = pydantic.Field(None, description="The stage's cache capacity in GB. For more information about choosing a cache size, see `Enabling API caching to enhance responsiveness <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html>`_ .\n")
    canary_setting: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnStage_CanarySettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for the canary deployment in this stage.\n')
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of a client certificate for an API stage.\n')
    deployment_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the Deployment that the stage points to.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="The stage's description.\n")
    documentation_version: typing.Optional[str] = pydantic.Field(None, description='The version of the associated API documentation.\n')
    method_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnStage_MethodSettingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A map that defines the method settings for a Stage resource. Keys (designated as ``/{method_setting_key`` below) are method paths defined as ``{resource_path}/{http_method}`` for an individual method override, or ``/\\* /\\*`` for overriding all methods in the stage.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n')
    tracing_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether active tracing with X-ray is enabled for the Stage.\n')
    variables: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='A map (string-to-string map) that defines the stage variables, where the variable name is the key and the variable value is the value. Variable names are limited to alphanumeric characters. Values must match the following regular expression: ``[A-Za-z0-9-._~:/?#&=,]+`` .')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'access_log_setting', 'cache_cluster_enabled', 'cache_cluster_size', 'canary_setting', 'client_certificate_id', 'deployment_id', 'description', 'documentation_version', 'method_settings', 'stage_name', 'tags', 'tracing_enabled', 'variables']
    _method_names: typing.ClassVar[list[str]] = ['AccessLogSettingProperty', 'CanarySettingProperty', 'MethodSettingProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnStage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnStageDefConfig] = pydantic.Field(None)


class CfnStageDefConfig(pydantic.BaseModel):
    AccessLogSettingProperty: typing.Optional[list[CfnStageDefAccesslogsettingpropertyParams]] = pydantic.Field(None, description='')
    CanarySettingProperty: typing.Optional[list[CfnStageDefCanarysettingpropertyParams]] = pydantic.Field(None, description='')
    MethodSettingProperty: typing.Optional[list[CfnStageDefMethodsettingpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnStageDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnStageDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnStageDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnStageDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnStageDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnStageDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnStageDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnStageDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnStageDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnStageDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnStageDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnStageDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnStageDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnStageDefAccesslogsettingpropertyParams(pydantic.BaseModel):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='')
    format: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnStageDefCanarysettingpropertyParams(pydantic.BaseModel):
    deployment_id: typing.Optional[str] = pydantic.Field(None, description='')
    percent_traffic: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stage_variable_overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    use_stage_cache: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnStageDefMethodsettingpropertyParams(pydantic.BaseModel):
    cache_data_encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    cache_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    caching_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    data_trace_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    http_method: typing.Optional[str] = pydantic.Field(None, description='')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='')
    metrics_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    resource_path: typing.Optional[str] = pydantic.Field(None, description='')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnStageDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnStageDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStageDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnStageDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStageDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnStageDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnStageDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnStageDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnStageDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnStageDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStageDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnStageDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnStageDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStageDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnUsagePlan
class CfnUsagePlanDef(BaseCfnResource):
    api_stages: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnUsagePlan_ApiStagePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The associated API stages of a usage plan.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of a usage plan.\n')
    quota: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnUsagePlan_QuotaSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The target maximum number of permitted requests per a given unit time interval.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n')
    throttle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnUsagePlan_ThrottleSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A map containing method level throttling information for API stage in a usage plan.\n')
    usage_plan_name: typing.Optional[str] = pydantic.Field(None, description='The name of a usage plan.')
    _init_params: typing.ClassVar[list[str]] = ['api_stages', 'description', 'quota', 'tags', 'throttle', 'usage_plan_name']
    _method_names: typing.ClassVar[list[str]] = ['ApiStageProperty', 'QuotaSettingsProperty', 'ThrottleSettingsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnUsagePlan'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnUsagePlanDefConfig] = pydantic.Field(None)


class CfnUsagePlanDefConfig(pydantic.BaseModel):
    ApiStageProperty: typing.Optional[list[CfnUsagePlanDefApistagepropertyParams]] = pydantic.Field(None, description='')
    QuotaSettingsProperty: typing.Optional[list[CfnUsagePlanDefQuotasettingspropertyParams]] = pydantic.Field(None, description='')
    ThrottleSettingsProperty: typing.Optional[list[CfnUsagePlanDefThrottlesettingspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnUsagePlanDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnUsagePlanDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnUsagePlanDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnUsagePlanDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnUsagePlanDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnUsagePlanDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnUsagePlanDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnUsagePlanDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnUsagePlanDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnUsagePlanDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnUsagePlanDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnUsagePlanDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnUsagePlanDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnUsagePlanDefApistagepropertyParams(pydantic.BaseModel):
    api_id: typing.Optional[str] = pydantic.Field(None, description='')
    stage: typing.Optional[str] = pydantic.Field(None, description='')
    throttle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnUsagePlan_ThrottleSettingsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnUsagePlanDefQuotasettingspropertyParams(pydantic.BaseModel):
    limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    offset: typing.Union[int, float, None] = pydantic.Field(None, description='')
    period: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnUsagePlanDefThrottlesettingspropertyParams(pydantic.BaseModel):
    burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnUsagePlanDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnUsagePlanDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUsagePlanDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnUsagePlanDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUsagePlanDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnUsagePlanDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnUsagePlanDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnUsagePlanDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnUsagePlanDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnUsagePlanDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUsagePlanDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnUsagePlanDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnUsagePlanDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUsagePlanDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnUsagePlanKey
class CfnUsagePlanKeyDef(BaseCfnResource):
    key_id: str = pydantic.Field(..., description='The Id of the UsagePlanKey resource to be deleted.\n')
    key_type: str = pydantic.Field(..., description='The type of a UsagePlanKey resource for a plan customer.\n')
    usage_plan_id: str = pydantic.Field(..., description='The Id of the UsagePlan resource representing the usage plan containing the to-be-deleted UsagePlanKey resource representing a plan customer.')
    _init_params: typing.ClassVar[list[str]] = ['key_id', 'key_type', 'usage_plan_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnUsagePlanKey'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnUsagePlanKeyDefConfig] = pydantic.Field(None)


class CfnUsagePlanKeyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnUsagePlanKeyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnUsagePlanKeyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnUsagePlanKeyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnUsagePlanKeyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnUsagePlanKeyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnUsagePlanKeyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnUsagePlanKeyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnUsagePlanKeyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnUsagePlanKeyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnUsagePlanKeyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnUsagePlanKeyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnUsagePlanKeyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnUsagePlanKeyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnUsagePlanKeyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnUsagePlanKeyDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUsagePlanKeyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnUsagePlanKeyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUsagePlanKeyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnUsagePlanKeyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnUsagePlanKeyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnUsagePlanKeyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnUsagePlanKeyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnUsagePlanKeyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUsagePlanKeyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnUsagePlanKeyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnUsagePlanKeyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUsagePlanKeyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnVpcLink
class CfnVpcLinkDef(BaseCfnResource):
    name: str = pydantic.Field(..., description='The name used to label and identify the VPC link.\n')
    target_arns: typing.Sequence[str] = pydantic.Field(..., description='The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the VPC link.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of arbitrary tags (key-value pairs) to associate with the VPC link.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'target_arns', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnVpcLink'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVpcLinkDefConfig] = pydantic.Field(None)


class CfnVpcLinkDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVpcLinkDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVpcLinkDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVpcLinkDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVpcLinkDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVpcLinkDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVpcLinkDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVpcLinkDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVpcLinkDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVpcLinkDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVpcLinkDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVpcLinkDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVpcLinkDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVpcLinkDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVpcLinkDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVpcLinkDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVpcLinkDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVpcLinkDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVpcLinkDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVpcLinkDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVpcLinkDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVpcLinkDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVpcLinkDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVpcLinkDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVpcLinkDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVpcLinkDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVpcLinkDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVpcLinkDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_apigateway.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigateway.CfnAccountProps
class CfnAccountPropsDef(BaseCfnProperty):
    cloud_watch_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an Amazon CloudWatch role for the current Account.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-account.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_account_props = apigateway.CfnAccountProps(\n        cloud_watch_role_arn="cloudWatchRoleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnAccountProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnApiKeyProps
class CfnApiKeyPropsDef(BaseCfnProperty):
    customer_id: typing.Optional[str] = pydantic.Field(None, description='An AWS Marketplace customer identifier, when integrating with the AWS SaaS Marketplace.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the ApiKey.\n')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether the ApiKey can be used by callers.\n')
    generate_distinct_id: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether ( ``true`` ) or not ( ``false`` ) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="A name for the API key. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the API key name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    stage_keys: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnApiKey_StageKeyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with ``aws:`` . The tag value can be up to 256 characters.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='Specifies a value of the API key.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-apikey.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_api_key_props = apigateway.CfnApiKeyProps(\n        customer_id="customerId",\n        description="description",\n        enabled=False,\n        generate_distinct_id=False,\n        name="name",\n        stage_keys=[apigateway.CfnApiKey.StageKeyProperty(\n            rest_api_id="restApiId",\n            stage_name="stageName"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['customer_id', 'description', 'enabled', 'generate_distinct_id', 'name', 'stage_keys', 'tags', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnApiKeyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnAuthorizerProps
class CfnAuthorizerPropsDef(BaseCfnProperty):
    name: str = pydantic.Field(..., description='The name of the authorizer.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    type: str = pydantic.Field(..., description='The authorizer type. Valid values are ``TOKEN`` for a Lambda function using a single authorization token submitted in a custom header, ``REQUEST`` for a Lambda function using incoming request parameters, and ``COGNITO_USER_POOLS`` for using an Amazon Cognito user pool.\n')
    authorizer_credentials: typing.Optional[str] = pydantic.Field(None, description="Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.\n")
    authorizer_result_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.\n')
    authorizer_uri: typing.Optional[str] = pydantic.Field(None, description="Specifies the authorizer's Uniform Resource Identifier (URI). For ``TOKEN`` or ``REQUEST`` authorizers, this must be a well-formed Lambda function URI, for example, ``arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations`` . In general, the URI has this form ``arn:aws:apigateway:{region}:lambda:path/{service_api}`` , where ``{region}`` is the same as the region hosting the Lambda function, ``path`` indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial ``/`` . For Lambda functions, this is usually of the form ``/2015-03-31/functions/[FunctionARN]/invocations`` .\n")
    auth_type: typing.Optional[str] = pydantic.Field(None, description='Optional customer-defined field, used in OpenAPI imports and exports without functional impact.\n')
    identity_source: typing.Optional[str] = pydantic.Field(None, description='The identity source for which authorization is requested. For a ``TOKEN`` or ``COGNITO_USER_POOLS`` authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is ``Auth`` , the header mapping expression is ``method.request.header.Auth`` . For the ``REQUEST`` authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an ``Auth`` header, a ``Name`` query string parameter are defined as identity sources, this value is ``method.request.header.Auth, method.request.querystring.Name`` . These parameters will be used to derive the authorization caching key and to perform runtime validation of the ``REQUEST`` authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.\n')
    identity_validation_expression: typing.Optional[str] = pydantic.Field(None, description="A validation expression for the incoming identity token. For ``TOKEN`` authorizers, this value is a regular expression. For ``COGNITO_USER_POOLS`` authorizers, API Gateway will match the ``aud`` field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the ``REQUEST`` authorizer.\n")
    provider_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the Amazon Cognito user pool ARNs for the ``COGNITO_USER_POOLS`` authorizer. Each element is of this format: ``arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}`` . For a ``TOKEN`` or ``REQUEST`` authorizer, this is not defined.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-authorizer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_authorizer_props = apigateway.CfnAuthorizerProps(\n        name="name",\n        rest_api_id="restApiId",\n        type="type",\n\n        # the properties below are optional\n        authorizer_credentials="authorizerCredentials",\n        authorizer_result_ttl_in_seconds=123,\n        authorizer_uri="authorizerUri",\n        auth_type="authType",\n        identity_source="identitySource",\n        identity_validation_expression="identityValidationExpression",\n        provider_arns=["providerArns"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'rest_api_id', 'type', 'authorizer_credentials', 'authorizer_result_ttl_in_seconds', 'authorizer_uri', 'auth_type', 'identity_source', 'identity_validation_expression', 'provider_arns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnBasePathMappingProps
class CfnBasePathMappingPropsDef(BaseCfnProperty):
    domain_name: str = pydantic.Field(..., description='The domain name of the BasePathMapping resource to be described.\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description='The base path name that callers of the API must provide as part of the URL after the domain name.\n')
    rest_api_id: typing.Optional[str] = pydantic.Field(None, description='The string identifier of the associated RestApi.\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='The name of the associated stage.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-basepathmapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_base_path_mapping_props = apigateway.CfnBasePathMappingProps(\n        domain_name="domainName",\n\n        # the properties below are optional\n        base_path="basePath",\n        id="id",\n        rest_api_id="restApiId",\n        stage="stage"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'base_path', 'rest_api_id', 'stage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnBasePathMappingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnClientCertificateProps
class CfnClientCertificatePropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the client certificate.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-clientcertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_client_certificate_props = apigateway.CfnClientCertificateProps(\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnClientCertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDeploymentProps
class CfnDeploymentPropsDef(BaseCfnProperty):
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    deployment_canary_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_DeploymentCanarySettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The input configuration for a canary deployment.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the Deployment resource to create.\n')
    stage_description: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDeployment_StageDescriptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The description of the Stage resource for the Deployment resource to create. To specify a stage description, you must also provide a stage name.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Stage resource for the Deployment resource to create.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-deployment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_deployment_props = apigateway.CfnDeploymentProps(\n        rest_api_id="restApiId",\n\n        # the properties below are optional\n        deployment_canary_settings=apigateway.CfnDeployment.DeploymentCanarySettingsProperty(\n            percent_traffic=123,\n            stage_variable_overrides={\n                "stage_variable_overrides_key": "stageVariableOverrides"\n            },\n            use_stage_cache=False\n        ),\n        description="description",\n        stage_description=apigateway.CfnDeployment.StageDescriptionProperty(\n            access_log_setting=apigateway.CfnDeployment.AccessLogSettingProperty(\n                destination_arn="destinationArn",\n                format="format"\n            ),\n            cache_cluster_enabled=False,\n            cache_cluster_size="cacheClusterSize",\n            cache_data_encrypted=False,\n            cache_ttl_in_seconds=123,\n            caching_enabled=False,\n            canary_setting=apigateway.CfnDeployment.CanarySettingProperty(\n                percent_traffic=123,\n                stage_variable_overrides={\n                    "stage_variable_overrides_key": "stageVariableOverrides"\n                },\n                use_stage_cache=False\n            ),\n            client_certificate_id="clientCertificateId",\n            data_trace_enabled=False,\n            description="description",\n            documentation_version="documentationVersion",\n            logging_level="loggingLevel",\n            method_settings=[apigateway.CfnDeployment.MethodSettingProperty(\n                cache_data_encrypted=False,\n                cache_ttl_in_seconds=123,\n                caching_enabled=False,\n                data_trace_enabled=False,\n                http_method="httpMethod",\n                logging_level="loggingLevel",\n                metrics_enabled=False,\n                resource_path="resourcePath",\n                throttling_burst_limit=123,\n                throttling_rate_limit=123\n            )],\n            metrics_enabled=False,\n            tags=[CfnTag(\n                key="key",\n                value="value"\n            )],\n            throttling_burst_limit=123,\n            throttling_rate_limit=123,\n            tracing_enabled=False,\n            variables={\n                "variables_key": "variables"\n            }\n        ),\n        stage_name="stageName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'deployment_canary_settings', 'description', 'stage_description', 'stage_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDeploymentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDocumentationPartProps
class CfnDocumentationPartPropsDef(BaseCfnProperty):
    location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDocumentationPart_LocationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The location of the targeted API entity of the to-be-created documentation part.\n')
    properties: str = pydantic.Field(..., description='The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-documentationpart.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_documentation_part_props = apigateway.CfnDocumentationPartProps(\n        location=apigateway.CfnDocumentationPart.LocationProperty(\n            method="method",\n            name="name",\n            path="path",\n            status_code="statusCode",\n            type="type"\n        ),\n        properties="properties",\n        rest_api_id="restApiId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['location', 'properties', 'rest_api_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDocumentationPartProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDocumentationVersionProps
class CfnDocumentationVersionPropsDef(BaseCfnProperty):
    documentation_version: str = pydantic.Field(..., description='The version identifier of the to-be-updated documentation version.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about the new documentation snapshot.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-documentationversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_documentation_version_props = apigateway.CfnDocumentationVersionProps(\n        documentation_version="documentationVersion",\n        rest_api_id="restApiId",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['documentation_version', 'rest_api_id', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDocumentationVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnDomainNameProps
class CfnDomainNamePropsDef(BaseCfnProperty):
    certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The reference to an AWS -managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The custom domain name as an API host name, for example, ``my-api.example.com`` .\n')
    endpoint_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDomainName_EndpointConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The endpoint configuration of this DomainName showing the endpoint types of the domain name.\n')
    mutual_tls_authentication: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnDomainName_MutualTlsAuthenticationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.\n')
    ownership_verification_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the RegionalCertificateArn.\n')
    regional_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The reference to an AWS -managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.\n')
    security_policy: typing.Optional[str] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are ``TLS_1_0`` and ``TLS_1_2`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-domainname.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_domain_name_props = apigateway.CfnDomainNameProps(\n        certificate_arn="certificateArn",\n        domain_name="domainName",\n        endpoint_configuration=apigateway.CfnDomainName.EndpointConfigurationProperty(\n            types=["types"]\n        ),\n        mutual_tls_authentication=apigateway.CfnDomainName.MutualTlsAuthenticationProperty(\n            truststore_uri="truststoreUri",\n            truststore_version="truststoreVersion"\n        ),\n        ownership_verification_certificate_arn="ownershipVerificationCertificateArn",\n        regional_certificate_arn="regionalCertificateArn",\n        security_policy="securityPolicy",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'domain_name', 'endpoint_configuration', 'mutual_tls_authentication', 'ownership_verification_certificate_arn', 'regional_certificate_arn', 'security_policy', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnDomainNameProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnGatewayResponseProps
class CfnGatewayResponsePropsDef(BaseCfnProperty):
    response_type: str = pydantic.Field(..., description='The response type of the associated GatewayResponse.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    response_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.\n')
    response_templates: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Response templates of the GatewayResponse as a string-to-string map of key-value pairs.\n')
    status_code: typing.Optional[str] = pydantic.Field(None, description='The HTTP status code for this GatewayResponse.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-gatewayresponse.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_gateway_response_props = apigateway.CfnGatewayResponseProps(\n        response_type="responseType",\n        rest_api_id="restApiId",\n\n        # the properties below are optional\n        response_parameters={\n            "response_parameters_key": "responseParameters"\n        },\n        response_templates={\n            "response_templates_key": "responseTemplates"\n        },\n        status_code="statusCode"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['response_type', 'rest_api_id', 'response_parameters', 'response_templates', 'status_code']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnGatewayResponseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnMethodProps
class CfnMethodPropsDef(BaseCfnProperty):
    http_method: str = pydantic.Field(..., description="The method's HTTP verb.\n")
    resource_id: str = pydantic.Field(..., description='The Resource identifier for the MethodResponse resource.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    api_key_required: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A boolean flag specifying whether a valid ApiKey is required to invoke this method.\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of authorization scopes configured on the method. The scopes are used with a ``COGNITO_USER_POOLS`` authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.\n')
    authorization_type: typing.Optional[str] = pydantic.Field(None, description="The method's authorization type. This parameter is required. For valid values, see `Method <https://docs.aws.amazon.com/apigateway/latest/api/API_Method.html>`_ in the *API Gateway API Reference* . .. epigraph:: If you specify the ``AuthorizerId`` property, specify ``CUSTOM`` or ``COGNITO_USER_POOLS`` for this property.\n")
    authorizer_id: typing.Optional[str] = pydantic.Field(None, description="The identifier of an authorizer to use on this method. The method's authorization type must be ``CUSTOM`` or ``COGNITO_USER_POOLS`` .\n")
    integration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnMethod_IntegrationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents an ``HTTP`` , ``HTTP_PROXY`` , ``AWS`` , ``AWS_PROXY`` , or Mock integration.\n')
    method_responses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnMethod_MethodResponsePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Gets a method response associated with a given HTTP status code.\n')
    operation_name: typing.Optional[str] = pydantic.Field(None, description='A human-friendly operation identifier for the method. For example, you can assign the ``operationName`` of ``ListPets`` for the ``GET /pets`` method in the ``PetStore`` example.\n')
    request_models: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).\n')
    request_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]]], None] = pydantic.Field(None, description='A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of ``method.request.{location}.{name}`` , where ``location`` is ``querystring`` , ``path`` , or ``header`` and ``name`` is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required ( ``true`` ) or optional ( ``false`` ). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.\n')
    request_validator_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of a RequestValidator for request validation.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-method.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_method_props = apigateway.CfnMethodProps(\n        http_method="httpMethod",\n        resource_id="resourceId",\n        rest_api_id="restApiId",\n\n        # the properties below are optional\n        api_key_required=False,\n        authorization_scopes=["authorizationScopes"],\n        authorization_type="authorizationType",\n        authorizer_id="authorizerId",\n        integration=apigateway.CfnMethod.IntegrationProperty(\n            cache_key_parameters=["cacheKeyParameters"],\n            cache_namespace="cacheNamespace",\n            connection_id="connectionId",\n            connection_type="connectionType",\n            content_handling="contentHandling",\n            credentials="credentials",\n            integration_http_method="integrationHttpMethod",\n            integration_responses=[apigateway.CfnMethod.IntegrationResponseProperty(\n                status_code="statusCode",\n\n                # the properties below are optional\n                content_handling="contentHandling",\n                response_parameters={\n                    "response_parameters_key": "responseParameters"\n                },\n                response_templates={\n                    "response_templates_key": "responseTemplates"\n                },\n                selection_pattern="selectionPattern"\n            )],\n            passthrough_behavior="passthroughBehavior",\n            request_parameters={\n                "request_parameters_key": "requestParameters"\n            },\n            request_templates={\n                "request_templates_key": "requestTemplates"\n            },\n            timeout_in_millis=123,\n            type="type",\n            uri="uri"\n        ),\n        method_responses=[apigateway.CfnMethod.MethodResponseProperty(\n            status_code="statusCode",\n\n            # the properties below are optional\n            response_models={\n                "response_models_key": "responseModels"\n            },\n            response_parameters={\n                "response_parameters_key": False\n            }\n        )],\n        operation_name="operationName",\n        request_models={\n            "request_models_key": "requestModels"\n        },\n        request_parameters={\n            "request_parameters_key": False\n        },\n        request_validator_id="requestValidatorId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_method', 'resource_id', 'rest_api_id', 'api_key_required', 'authorization_scopes', 'authorization_type', 'authorizer_id', 'integration', 'method_responses', 'operation_name', 'request_models', 'request_parameters', 'request_validator_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnMethodProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnModelProps
class CfnModelPropsDef(BaseCfnProperty):
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    content_type: typing.Optional[str] = pydantic.Field(None, description='The content-type for the model.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the model.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="A name for the model. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the model name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    schema_: typing.Any = pydantic.Field(None, description='The schema for the model. For ``application/json`` models, this should be JSON schema draft 4 model. Do not include "* /" characters in the description of any properties because such "* /" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API\'s SDK generated by API Gateway to fail.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-model.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # schema: Any\n\n    cfn_model_props = apigateway.CfnModelProps(\n        rest_api_id="restApiId",\n\n        # the properties below are optional\n        content_type="contentType",\n        description="description",\n        name="name",\n        schema=schema\n    )\n', alias='schema')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'content_type', 'description', 'name', 'schema']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnModelProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnRequestValidatorProps
class CfnRequestValidatorPropsDef(BaseCfnProperty):
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of this RequestValidator.\n')
    validate_request_body: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean flag to indicate whether to validate a request body according to the configured Model schema.\n')
    validate_request_parameters: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A Boolean flag to indicate whether to validate request parameters ( ``true`` ) or not ( ``false`` ).\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-requestvalidator.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_request_validator_props = apigateway.CfnRequestValidatorProps(\n        rest_api_id="restApiId",\n\n        # the properties below are optional\n        name="name",\n        validate_request_body=False,\n        validate_request_parameters=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'name', 'validate_request_body', 'validate_request_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnRequestValidatorProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnResourceProps
class CfnResourcePropsDef(BaseCfnProperty):
    parent_id: str = pydantic.Field(..., description="The parent resource's identifier.\n")
    path_part: str = pydantic.Field(..., description='The last path segment for this resource.\n')
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-resource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_resource_props = apigateway.CfnResourceProps(\n        parent_id="parentId",\n        path_part="pathPart",\n        rest_api_id="restApiId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parent_id', 'path_part', 'rest_api_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnResourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnRestApiProps
class CfnRestApiPropsDef(BaseCfnProperty):
    api_key_source_type: typing.Optional[str] = pydantic.Field(None, description='The source of the API key for metering requests according to a usage plan. Valid values are: ``HEADER`` to read the API key from the ``X-API-Key`` header of a request. ``AUTHORIZER`` to read the API key from the ``UsageIdentifierKey`` from a custom authorizer.\n')
    binary_media_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.\n')
    body: typing.Any = pydantic.Field(None, description='An OpenAPI specification that defines a set of RESTful APIs in JSON format. For YAML templates, you can also provide the specification in YAML format.\n')
    body_s3_location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnRestApi_S3LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Amazon Simple Storage Service (Amazon S3) location that points to an OpenAPI file, which defines a set of RESTful APIs in JSON or YAML format.\n')
    clone_from: typing.Optional[str] = pydantic.Field(None, description='The ID of the RestApi that you want to clone from.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the RestApi.\n')
    disable_execute_api_endpoint: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether clients can invoke your API by using the default ``execute-api`` endpoint. By default, clients can invoke your API with the default ``https://{api_id}.execute-api.{region}.amazonaws.com`` endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint\n')
    endpoint_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnRestApi_EndpointConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A list of the endpoint types of the API. Use this property when creating an API. When importing an existing API, specify the endpoint configuration types using the ``Parameters`` property.\n')
    fail_on_warnings: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='A query parameter to indicate whether to rollback the API update ( ``true`` ) or not ( ``false`` ) when a warning is encountered. The default value is ``false`` .\n')
    minimum_compression_size: typing.Union[int, float, None] = pydantic.Field(None, description='A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.\n')
    mode: typing.Optional[str] = pydantic.Field(None, description="This property applies only when you use OpenAPI to define your REST API. The ``Mode`` determines how API Gateway handles resource updates. Valid values are ``overwrite`` or ``merge`` . For ``overwrite`` , the new API definition replaces the existing one. The existing API identifier remains unchanged. For ``merge`` , the new API definition is merged with the existing API. If you don't specify this property, a default value is chosen. For REST APIs created before March 29, 2021, the default is ``overwrite`` . For REST APIs created after March 29, 2021, the new API definition takes precedence, but any container types such as endpoint configurations and binary media types are merged with the existing API. Use the default mode to define top-level ``RestApi`` properties in addition to using OpenAPI. Generally, it's preferred to use API Gateway's OpenAPI extensions to model these properties.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the RestApi. A name is required if the REST API is not based on an OpenAPI specification.\n')
    parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description="Custom header parameters as part of the request. For example, to exclude DocumentationParts from an imported API, set ``ignore=documentation`` as a ``parameters`` value, as in the AWS CLI command of ``aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'`` .\n")
    policy: typing.Any = pydantic.Field(None, description='A policy document that contains the permissions for the ``RestApi`` resource. To set the ARN for the policy, use the ``!Join`` intrinsic function with ``""`` as delimiter and values of ``"execute-api:/"`` and ``"*"`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with ``aws:`` . The tag value can be up to 256 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    # body: Any\n    # policy: Any\n\n    cfn_rest_api_props = apigateway.CfnRestApiProps(\n        api_key_source_type="apiKeySourceType",\n        binary_media_types=["binaryMediaTypes"],\n        body=body,\n        body_s3_location=apigateway.CfnRestApi.S3LocationProperty(\n            bucket="bucket",\n            e_tag="eTag",\n            key="key",\n            version="version"\n        ),\n        clone_from="cloneFrom",\n        description="description",\n        disable_execute_api_endpoint=False,\n        endpoint_configuration=apigateway.CfnRestApi.EndpointConfigurationProperty(\n            types=["types"],\n            vpc_endpoint_ids=["vpcEndpointIds"]\n        ),\n        fail_on_warnings=False,\n        minimum_compression_size=123,\n        mode="mode",\n        name="name",\n        parameters={\n            "parameters_key": "parameters"\n        },\n        policy=policy,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_key_source_type', 'binary_media_types', 'body', 'body_s3_location', 'clone_from', 'description', 'disable_execute_api_endpoint', 'endpoint_configuration', 'fail_on_warnings', 'minimum_compression_size', 'mode', 'name', 'parameters', 'policy', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnRestApiProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnStageProps
class CfnStagePropsDef(BaseCfnProperty):
    rest_api_id: str = pydantic.Field(..., description='The string identifier of the associated RestApi.\n')
    access_log_setting: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnStage_AccessLogSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Access log settings, including the access log format and access log destination ARN.\n')
    cache_cluster_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether a cache cluster is enabled for the stage.\n')
    cache_cluster_size: typing.Optional[str] = pydantic.Field(None, description="The stage's cache capacity in GB. For more information about choosing a cache size, see `Enabling API caching to enhance responsiveness <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html>`_ .\n")
    canary_setting: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnStage_CanarySettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for the canary deployment in this stage.\n')
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of a client certificate for an API stage.\n')
    deployment_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the Deployment that the stage points to.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="The stage's description.\n")
    documentation_version: typing.Optional[str] = pydantic.Field(None, description='The version of the associated API documentation.\n')
    method_settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnStage_MethodSettingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A map that defines the method settings for a Stage resource. Keys (designated as ``/{method_setting_key`` below) are method paths defined as ``{resource_path}/{http_method}`` for an individual method override, or ``/\\* /\\*`` for overriding all methods in the stage.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n')
    tracing_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether active tracing with X-ray is enabled for the Stage.\n')
    variables: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='A map (string-to-string map) that defines the stage variables, where the variable name is the key and the variable value is the value. Variable names are limited to alphanumeric characters. Values must match the following regular expression: ``[A-Za-z0-9-._~:/?#&=,]+`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-stage.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_stage_props = apigateway.CfnStageProps(\n        rest_api_id="restApiId",\n\n        # the properties below are optional\n        access_log_setting=apigateway.CfnStage.AccessLogSettingProperty(\n            destination_arn="destinationArn",\n            format="format"\n        ),\n        cache_cluster_enabled=False,\n        cache_cluster_size="cacheClusterSize",\n        canary_setting=apigateway.CfnStage.CanarySettingProperty(\n            deployment_id="deploymentId",\n            percent_traffic=123,\n            stage_variable_overrides={\n                "stage_variable_overrides_key": "stageVariableOverrides"\n            },\n            use_stage_cache=False\n        ),\n        client_certificate_id="clientCertificateId",\n        deployment_id="deploymentId",\n        description="description",\n        documentation_version="documentationVersion",\n        method_settings=[apigateway.CfnStage.MethodSettingProperty(\n            cache_data_encrypted=False,\n            cache_ttl_in_seconds=123,\n            caching_enabled=False,\n            data_trace_enabled=False,\n            http_method="httpMethod",\n            logging_level="loggingLevel",\n            metrics_enabled=False,\n            resource_path="resourcePath",\n            throttling_burst_limit=123,\n            throttling_rate_limit=123\n        )],\n        stage_name="stageName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        tracing_enabled=False,\n        variables={\n            "variables_key": "variables"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rest_api_id', 'access_log_setting', 'cache_cluster_enabled', 'cache_cluster_size', 'canary_setting', 'client_certificate_id', 'deployment_id', 'description', 'documentation_version', 'method_settings', 'stage_name', 'tags', 'tracing_enabled', 'variables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnStageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnUsagePlanKeyProps
class CfnUsagePlanKeyPropsDef(BaseCfnProperty):
    key_id: str = pydantic.Field(..., description='The Id of the UsagePlanKey resource to be deleted.\n')
    key_type: str = pydantic.Field(..., description='The type of a UsagePlanKey resource for a plan customer.\n')
    usage_plan_id: str = pydantic.Field(..., description='The Id of the UsagePlan resource representing the usage plan containing the to-be-deleted UsagePlanKey resource representing a plan customer.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-usageplankey.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_usage_plan_key_props = apigateway.CfnUsagePlanKeyProps(\n        key_id="keyId",\n        key_type="keyType",\n        usage_plan_id="usagePlanId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key_id', 'key_type', 'usage_plan_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnUsagePlanKeyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnUsagePlanProps
class CfnUsagePlanPropsDef(BaseCfnProperty):
    api_stages: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnUsagePlan_ApiStagePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The associated API stages of a usage plan.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of a usage plan.\n')
    quota: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnUsagePlan_QuotaSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The target maximum number of permitted requests per a given unit time interval.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n')
    throttle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apigateway.CfnUsagePlan_ThrottleSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A map containing method level throttling information for API stage in a usage plan.\n')
    usage_plan_name: typing.Optional[str] = pydantic.Field(None, description='The name of a usage plan.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-usageplan.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_usage_plan_props = apigateway.CfnUsagePlanProps(\n        api_stages=[apigateway.CfnUsagePlan.ApiStageProperty(\n            api_id="apiId",\n            stage="stage",\n            throttle={\n                "throttle_key": apigateway.CfnUsagePlan.ThrottleSettingsProperty(\n                    burst_limit=123,\n                    rate_limit=123\n                )\n            }\n        )],\n        description="description",\n        quota=apigateway.CfnUsagePlan.QuotaSettingsProperty(\n            limit=123,\n            offset=123,\n            period="period"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        throttle=apigateway.CfnUsagePlan.ThrottleSettingsProperty(\n            burst_limit=123,\n            rate_limit=123\n        ),\n        usage_plan_name="usagePlanName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_stages', 'description', 'quota', 'tags', 'throttle', 'usage_plan_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnUsagePlanProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigateway.CfnVpcLinkProps
class CfnVpcLinkPropsDef(BaseCfnProperty):
    name: str = pydantic.Field(..., description='The name used to label and identify the VPC link.\n')
    target_arns: typing.Sequence[str] = pydantic.Field(..., description='The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the VPC link.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of arbitrary tags (key-value pairs) to associate with the VPC link.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-vpclink.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigateway as apigateway\n\n    cfn_vpc_link_props = apigateway.CfnVpcLinkProps(\n        name="name",\n        target_arns=["targetArns"],\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'target_arns', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigateway.CfnVpcLinkProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    AccessLogField: typing.Optional[dict[str, AccessLogFieldDef]] = pydantic.Field(None)
    AccessLogFormat: typing.Optional[dict[str, AccessLogFormatDef]] = pydantic.Field(None)
    ApiDefinition: typing.Optional[dict[str, ApiDefinitionDef]] = pydantic.Field(None)
    AssetApiDefinition: typing.Optional[dict[str, AssetApiDefinitionDef]] = pydantic.Field(None)
    Authorizer: typing.Optional[dict[str, AuthorizerDef]] = pydantic.Field(None)
    AwsIntegration: typing.Optional[dict[str, AwsIntegrationDef]] = pydantic.Field(None)
    Cors: typing.Optional[dict[str, CorsDef]] = pydantic.Field(None)
    HttpIntegration: typing.Optional[dict[str, HttpIntegrationDef]] = pydantic.Field(None)
    IdentitySource: typing.Optional[dict[str, IdentitySourceDef]] = pydantic.Field(None)
    InlineApiDefinition: typing.Optional[dict[str, InlineApiDefinitionDef]] = pydantic.Field(None)
    Integration: typing.Optional[dict[str, IntegrationDef]] = pydantic.Field(None)
    LambdaIntegration: typing.Optional[dict[str, LambdaIntegrationDef]] = pydantic.Field(None)
    LogGroupLogDestination: typing.Optional[dict[str, LogGroupLogDestinationDef]] = pydantic.Field(None)
    MockIntegration: typing.Optional[dict[str, MockIntegrationDef]] = pydantic.Field(None)
    ResourceBase: typing.Optional[dict[str, ResourceBaseDef]] = pydantic.Field(None)
    ResponseType: typing.Optional[dict[str, ResponseTypeDef]] = pydantic.Field(None)
    RestApiBase: typing.Optional[dict[str, RestApiBaseDef]] = pydantic.Field(None)
    S3ApiDefinition: typing.Optional[dict[str, S3ApiDefinitionDef]] = pydantic.Field(None)
    StageBase: typing.Optional[dict[str, StageBaseDef]] = pydantic.Field(None)
    StepFunctionsIntegration: typing.Optional[dict[str, StepFunctionsIntegrationDef]] = pydantic.Field(None)
    ApiKey: typing.Optional[dict[str, ApiKeyDef]] = pydantic.Field(None)
    BasePathMapping: typing.Optional[dict[str, BasePathMappingDef]] = pydantic.Field(None)
    CognitoUserPoolsAuthorizer: typing.Optional[dict[str, CognitoUserPoolsAuthorizerDef]] = pydantic.Field(None)
    Deployment: typing.Optional[dict[str, DeploymentDef]] = pydantic.Field(None)
    DomainName: typing.Optional[dict[str, DomainNameDef]] = pydantic.Field(None)
    GatewayResponse: typing.Optional[dict[str, GatewayResponseDef]] = pydantic.Field(None)
    LambdaRestApi: typing.Optional[dict[str, LambdaRestApiDef]] = pydantic.Field(None)
    Method: typing.Optional[dict[str, MethodDef]] = pydantic.Field(None)
    Model: typing.Optional[dict[str, ModelDef]] = pydantic.Field(None)
    ProxyResource: typing.Optional[dict[str, ProxyResourceDef]] = pydantic.Field(None)
    RateLimitedApiKey: typing.Optional[dict[str, RateLimitedApiKeyDef]] = pydantic.Field(None)
    RequestAuthorizer: typing.Optional[dict[str, RequestAuthorizerDef]] = pydantic.Field(None)
    RequestValidator: typing.Optional[dict[str, RequestValidatorDef]] = pydantic.Field(None)
    Resource: typing.Optional[dict[str, ResourceDef]] = pydantic.Field(None)
    RestApi: typing.Optional[dict[str, RestApiDef]] = pydantic.Field(None)
    SpecRestApi: typing.Optional[dict[str, SpecRestApiDef]] = pydantic.Field(None)
    Stage: typing.Optional[dict[str, StageDef]] = pydantic.Field(None)
    StepFunctionsRestApi: typing.Optional[dict[str, StepFunctionsRestApiDef]] = pydantic.Field(None)
    TokenAuthorizer: typing.Optional[dict[str, TokenAuthorizerDef]] = pydantic.Field(None)
    UsagePlan: typing.Optional[dict[str, UsagePlanDef]] = pydantic.Field(None)
    VpcLink: typing.Optional[dict[str, VpcLinkDef]] = pydantic.Field(None)
    AccessLogDestinationConfig: typing.Optional[dict[str, AccessLogDestinationConfigDef]] = pydantic.Field(None)
    AddApiKeyOptions: typing.Optional[dict[str, AddApiKeyOptionsDef]] = pydantic.Field(None)
    ApiDefinitionConfig: typing.Optional[dict[str, ApiDefinitionConfigDef]] = pydantic.Field(None)
    ApiDefinitionS3Location: typing.Optional[dict[str, ApiDefinitionS3LocationDef]] = pydantic.Field(None)
    ApiKeyOptions: typing.Optional[dict[str, ApiKeyOptionsDef]] = pydantic.Field(None)
    ApiKeyProps: typing.Optional[dict[str, ApiKeyPropsDef]] = pydantic.Field(None)
    ApiMappingOptions: typing.Optional[dict[str, ApiMappingOptionsDef]] = pydantic.Field(None)
    AwsIntegrationProps: typing.Optional[dict[str, AwsIntegrationPropsDef]] = pydantic.Field(None)
    BasePathMappingOptions: typing.Optional[dict[str, BasePathMappingOptionsDef]] = pydantic.Field(None)
    BasePathMappingProps: typing.Optional[dict[str, BasePathMappingPropsDef]] = pydantic.Field(None)
    CfnApiKey_StageKeyProperty: typing.Optional[dict[str, CfnApiKey_StageKeyPropertyDef]] = pydantic.Field(None)
    CfnDeployment_AccessLogSettingProperty: typing.Optional[dict[str, CfnDeployment_AccessLogSettingPropertyDef]] = pydantic.Field(None)
    CfnDeployment_CanarySettingProperty: typing.Optional[dict[str, CfnDeployment_CanarySettingPropertyDef]] = pydantic.Field(None)
    CfnDeployment_DeploymentCanarySettingsProperty: typing.Optional[dict[str, CfnDeployment_DeploymentCanarySettingsPropertyDef]] = pydantic.Field(None)
    CfnDeployment_MethodSettingProperty: typing.Optional[dict[str, CfnDeployment_MethodSettingPropertyDef]] = pydantic.Field(None)
    CfnDeployment_StageDescriptionProperty: typing.Optional[dict[str, CfnDeployment_StageDescriptionPropertyDef]] = pydantic.Field(None)
    CfnDocumentationPart_LocationProperty: typing.Optional[dict[str, CfnDocumentationPart_LocationPropertyDef]] = pydantic.Field(None)
    CfnDomainName_EndpointConfigurationProperty: typing.Optional[dict[str, CfnDomainName_EndpointConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDomainName_MutualTlsAuthenticationProperty: typing.Optional[dict[str, CfnDomainName_MutualTlsAuthenticationPropertyDef]] = pydantic.Field(None)
    CfnMethod_IntegrationProperty: typing.Optional[dict[str, CfnMethod_IntegrationPropertyDef]] = pydantic.Field(None)
    CfnMethod_IntegrationResponseProperty: typing.Optional[dict[str, CfnMethod_IntegrationResponsePropertyDef]] = pydantic.Field(None)
    CfnMethod_MethodResponseProperty: typing.Optional[dict[str, CfnMethod_MethodResponsePropertyDef]] = pydantic.Field(None)
    CfnRestApi_EndpointConfigurationProperty: typing.Optional[dict[str, CfnRestApi_EndpointConfigurationPropertyDef]] = pydantic.Field(None)
    CfnRestApi_S3LocationProperty: typing.Optional[dict[str, CfnRestApi_S3LocationPropertyDef]] = pydantic.Field(None)
    CfnStage_AccessLogSettingProperty: typing.Optional[dict[str, CfnStage_AccessLogSettingPropertyDef]] = pydantic.Field(None)
    CfnStage_CanarySettingProperty: typing.Optional[dict[str, CfnStage_CanarySettingPropertyDef]] = pydantic.Field(None)
    CfnStage_MethodSettingProperty: typing.Optional[dict[str, CfnStage_MethodSettingPropertyDef]] = pydantic.Field(None)
    CfnUsagePlan_ApiStageProperty: typing.Optional[dict[str, CfnUsagePlan_ApiStagePropertyDef]] = pydantic.Field(None)
    CfnUsagePlan_QuotaSettingsProperty: typing.Optional[dict[str, CfnUsagePlan_QuotaSettingsPropertyDef]] = pydantic.Field(None)
    CfnUsagePlan_ThrottleSettingsProperty: typing.Optional[dict[str, CfnUsagePlan_ThrottleSettingsPropertyDef]] = pydantic.Field(None)
    CognitoUserPoolsAuthorizerProps: typing.Optional[dict[str, CognitoUserPoolsAuthorizerPropsDef]] = pydantic.Field(None)
    CorsOptions: typing.Optional[dict[str, CorsOptionsDef]] = pydantic.Field(None)
    DeploymentProps: typing.Optional[dict[str, DeploymentPropsDef]] = pydantic.Field(None)
    DomainNameAttributes: typing.Optional[dict[str, DomainNameAttributesDef]] = pydantic.Field(None)
    DomainNameOptions: typing.Optional[dict[str, DomainNameOptionsDef]] = pydantic.Field(None)
    DomainNameProps: typing.Optional[dict[str, DomainNamePropsDef]] = pydantic.Field(None)
    EndpointConfiguration: typing.Optional[dict[str, EndpointConfigurationDef]] = pydantic.Field(None)
    GatewayResponseOptions: typing.Optional[dict[str, GatewayResponseOptionsDef]] = pydantic.Field(None)
    GatewayResponseProps: typing.Optional[dict[str, GatewayResponsePropsDef]] = pydantic.Field(None)
    HttpIntegrationProps: typing.Optional[dict[str, HttpIntegrationPropsDef]] = pydantic.Field(None)
    IntegrationConfig: typing.Optional[dict[str, IntegrationConfigDef]] = pydantic.Field(None)
    IntegrationOptions: typing.Optional[dict[str, IntegrationOptionsDef]] = pydantic.Field(None)
    IntegrationProps: typing.Optional[dict[str, IntegrationPropsDef]] = pydantic.Field(None)
    IntegrationResponse: typing.Optional[dict[str, IntegrationResponseDef]] = pydantic.Field(None)
    JsonSchema: typing.Optional[dict[str, JsonSchemaDef]] = pydantic.Field(None)
    JsonWithStandardFieldProps: typing.Optional[dict[str, JsonWithStandardFieldPropsDef]] = pydantic.Field(None)
    LambdaAuthorizerProps: typing.Optional[dict[str, LambdaAuthorizerPropsDef]] = pydantic.Field(None)
    LambdaIntegrationOptions: typing.Optional[dict[str, LambdaIntegrationOptionsDef]] = pydantic.Field(None)
    LambdaRestApiProps: typing.Optional[dict[str, LambdaRestApiPropsDef]] = pydantic.Field(None)
    MethodDeploymentOptions: typing.Optional[dict[str, MethodDeploymentOptionsDef]] = pydantic.Field(None)
    MethodOptions: typing.Optional[dict[str, MethodOptionsDef]] = pydantic.Field(None)
    MethodProps: typing.Optional[dict[str, MethodPropsDef]] = pydantic.Field(None)
    MethodResponse: typing.Optional[dict[str, MethodResponseDef]] = pydantic.Field(None)
    ModelOptions: typing.Optional[dict[str, ModelOptionsDef]] = pydantic.Field(None)
    ModelProps: typing.Optional[dict[str, ModelPropsDef]] = pydantic.Field(None)
    MTLSConfig: typing.Optional[dict[str, MTLSConfigDef]] = pydantic.Field(None)
    ProxyResourceOptions: typing.Optional[dict[str, ProxyResourceOptionsDef]] = pydantic.Field(None)
    ProxyResourceProps: typing.Optional[dict[str, ProxyResourcePropsDef]] = pydantic.Field(None)
    QuotaSettings: typing.Optional[dict[str, QuotaSettingsDef]] = pydantic.Field(None)
    RateLimitedApiKeyProps: typing.Optional[dict[str, RateLimitedApiKeyPropsDef]] = pydantic.Field(None)
    RequestAuthorizerProps: typing.Optional[dict[str, RequestAuthorizerPropsDef]] = pydantic.Field(None)
    RequestContext: typing.Optional[dict[str, RequestContextDef]] = pydantic.Field(None)
    RequestValidatorOptions: typing.Optional[dict[str, RequestValidatorOptionsDef]] = pydantic.Field(None)
    RequestValidatorProps: typing.Optional[dict[str, RequestValidatorPropsDef]] = pydantic.Field(None)
    ResourceAttributes: typing.Optional[dict[str, ResourceAttributesDef]] = pydantic.Field(None)
    ResourceOptions: typing.Optional[dict[str, ResourceOptionsDef]] = pydantic.Field(None)
    ResourceProps: typing.Optional[dict[str, ResourcePropsDef]] = pydantic.Field(None)
    RestApiAttributes: typing.Optional[dict[str, RestApiAttributesDef]] = pydantic.Field(None)
    RestApiBaseProps: typing.Optional[dict[str, RestApiBasePropsDef]] = pydantic.Field(None)
    RestApiProps: typing.Optional[dict[str, RestApiPropsDef]] = pydantic.Field(None)
    SpecRestApiProps: typing.Optional[dict[str, SpecRestApiPropsDef]] = pydantic.Field(None)
    StageAttributes: typing.Optional[dict[str, StageAttributesDef]] = pydantic.Field(None)
    StageOptions: typing.Optional[dict[str, StageOptionsDef]] = pydantic.Field(None)
    StageProps: typing.Optional[dict[str, StagePropsDef]] = pydantic.Field(None)
    StepFunctionsExecutionIntegrationOptions: typing.Optional[dict[str, StepFunctionsExecutionIntegrationOptionsDef]] = pydantic.Field(None)
    StepFunctionsRestApiProps: typing.Optional[dict[str, StepFunctionsRestApiPropsDef]] = pydantic.Field(None)
    ThrottleSettings: typing.Optional[dict[str, ThrottleSettingsDef]] = pydantic.Field(None)
    ThrottlingPerMethod: typing.Optional[dict[str, ThrottlingPerMethodDef]] = pydantic.Field(None)
    TokenAuthorizerProps: typing.Optional[dict[str, TokenAuthorizerPropsDef]] = pydantic.Field(None)
    UsagePlanPerApiStage: typing.Optional[dict[str, UsagePlanPerApiStageDef]] = pydantic.Field(None)
    UsagePlanProps: typing.Optional[dict[str, UsagePlanPropsDef]] = pydantic.Field(None)
    VpcLinkProps: typing.Optional[dict[str, VpcLinkPropsDef]] = pydantic.Field(None)
    CfnAccount: typing.Optional[dict[str, CfnAccountDef]] = pydantic.Field(None)
    CfnApiKey: typing.Optional[dict[str, CfnApiKeyDef]] = pydantic.Field(None)
    CfnAuthorizer: typing.Optional[dict[str, CfnAuthorizerDef]] = pydantic.Field(None)
    CfnBasePathMapping: typing.Optional[dict[str, CfnBasePathMappingDef]] = pydantic.Field(None)
    CfnClientCertificate: typing.Optional[dict[str, CfnClientCertificateDef]] = pydantic.Field(None)
    CfnDeployment: typing.Optional[dict[str, CfnDeploymentDef]] = pydantic.Field(None)
    CfnDocumentationPart: typing.Optional[dict[str, CfnDocumentationPartDef]] = pydantic.Field(None)
    CfnDocumentationVersion: typing.Optional[dict[str, CfnDocumentationVersionDef]] = pydantic.Field(None)
    CfnDomainName: typing.Optional[dict[str, CfnDomainNameDef]] = pydantic.Field(None)
    CfnGatewayResponse: typing.Optional[dict[str, CfnGatewayResponseDef]] = pydantic.Field(None)
    CfnMethod: typing.Optional[dict[str, CfnMethodDef]] = pydantic.Field(None)
    CfnModel: typing.Optional[dict[str, CfnModelDef]] = pydantic.Field(None)
    CfnRequestValidator: typing.Optional[dict[str, CfnRequestValidatorDef]] = pydantic.Field(None)
    CfnResource: typing.Optional[dict[str, CfnResourceDef]] = pydantic.Field(None)
    CfnRestApi: typing.Optional[dict[str, CfnRestApiDef]] = pydantic.Field(None)
    CfnStage: typing.Optional[dict[str, CfnStageDef]] = pydantic.Field(None)
    CfnUsagePlan: typing.Optional[dict[str, CfnUsagePlanDef]] = pydantic.Field(None)
    CfnUsagePlanKey: typing.Optional[dict[str, CfnUsagePlanKeyDef]] = pydantic.Field(None)
    CfnVpcLink: typing.Optional[dict[str, CfnVpcLinkDef]] = pydantic.Field(None)
    CfnAccountProps: typing.Optional[dict[str, CfnAccountPropsDef]] = pydantic.Field(None)
    CfnApiKeyProps: typing.Optional[dict[str, CfnApiKeyPropsDef]] = pydantic.Field(None)
    CfnAuthorizerProps: typing.Optional[dict[str, CfnAuthorizerPropsDef]] = pydantic.Field(None)
    CfnBasePathMappingProps: typing.Optional[dict[str, CfnBasePathMappingPropsDef]] = pydantic.Field(None)
    CfnClientCertificateProps: typing.Optional[dict[str, CfnClientCertificatePropsDef]] = pydantic.Field(None)
    CfnDeploymentProps: typing.Optional[dict[str, CfnDeploymentPropsDef]] = pydantic.Field(None)
    CfnDocumentationPartProps: typing.Optional[dict[str, CfnDocumentationPartPropsDef]] = pydantic.Field(None)
    CfnDocumentationVersionProps: typing.Optional[dict[str, CfnDocumentationVersionPropsDef]] = pydantic.Field(None)
    CfnDomainNameProps: typing.Optional[dict[str, CfnDomainNamePropsDef]] = pydantic.Field(None)
    CfnGatewayResponseProps: typing.Optional[dict[str, CfnGatewayResponsePropsDef]] = pydantic.Field(None)
    CfnMethodProps: typing.Optional[dict[str, CfnMethodPropsDef]] = pydantic.Field(None)
    CfnModelProps: typing.Optional[dict[str, CfnModelPropsDef]] = pydantic.Field(None)
    CfnRequestValidatorProps: typing.Optional[dict[str, CfnRequestValidatorPropsDef]] = pydantic.Field(None)
    CfnResourceProps: typing.Optional[dict[str, CfnResourcePropsDef]] = pydantic.Field(None)
    CfnRestApiProps: typing.Optional[dict[str, CfnRestApiPropsDef]] = pydantic.Field(None)
    CfnStageProps: typing.Optional[dict[str, CfnStagePropsDef]] = pydantic.Field(None)
    CfnUsagePlanKeyProps: typing.Optional[dict[str, CfnUsagePlanKeyPropsDef]] = pydantic.Field(None)
    CfnUsagePlanProps: typing.Optional[dict[str, CfnUsagePlanPropsDef]] = pydantic.Field(None)
    CfnVpcLinkProps: typing.Optional[dict[str, CfnVpcLinkPropsDef]] = pydantic.Field(None)
    ...
