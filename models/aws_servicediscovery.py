from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_servicediscovery.InstanceBase
class InstanceBaseDef(BaseClass):
    account: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to\n')
    environment_from_arn: typing.Optional[str] = pydantic.Field(None, description='ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.\n')
    physical_name: typing.Optional[str] = pydantic.Field(None, description='The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to')
    _init_params: typing.ClassVar[list[str]] = ['account', 'environment_from_arn', 'physical_name', 'region']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.InstanceBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InstanceBaseDefConfig] = pydantic.Field(None)


class InstanceBaseDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    service_config: typing.Optional[models._interface_methods.AwsServicediscoveryIServiceDefConfig] = pydantic.Field(None)

class InstanceBaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.AliasTargetInstance
class AliasTargetInstanceDef(BaseConstruct):
    dns_name: str = pydantic.Field(..., description='DNS name of the target.\n')
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The Cloudmap service this resource is registered to.\n')
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['dns_name', 'service', 'custom_attributes', 'instance_id']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.AliasTargetInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AliasTargetInstanceDefConfig] = pydantic.Field(None)


class AliasTargetInstanceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    service_config: typing.Optional[models._interface_methods.AwsServicediscoveryIServiceDefConfig] = pydantic.Field(None)

class AliasTargetInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.CnameInstance
class CnameInstanceDef(BaseConstruct):
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The Cloudmap service this resource is registered to.\n')
    instance_cname: str = pydantic.Field(..., description='If the service configuration includes a CNAME record, the domain name that you want Route 53 to return in response to DNS queries, for example, example.com. This value is required if the service specified by ServiceId includes settings for an CNAME record.\n')
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['service', 'instance_cname', 'custom_attributes', 'instance_id']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CnameInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CnameInstanceDefConfig] = pydantic.Field(None)


class CnameInstanceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    service_config: typing.Optional[models._interface_methods.AwsServicediscoveryIServiceDefConfig] = pydantic.Field(None)

class CnameInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.HttpNamespace
class HttpNamespaceDef(BaseConstruct):
    name: str = pydantic.Field(..., description='A name for the Namespace.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the Namespace. Default: none')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'create_service']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_http_namespace_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.HttpNamespace'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_http_namespace_attributes']
    ...


    from_http_namespace_attributes: typing.Optional[HttpNamespaceDefFromHttpNamespaceAttributesParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[HttpNamespaceDefConfig] = pydantic.Field(None)


class HttpNamespaceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    create_service: typing.Optional[list[HttpNamespaceDefCreateServiceParams]] = pydantic.Field(None, description='Creates a service within the namespace.')

class HttpNamespaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class HttpNamespaceDefCreateServiceParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    custom_health_check: typing.Union[models.aws_servicediscovery.HealthCheckCustomConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Structure containing failure threshold for a custom health checker. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. See: https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the service. Default: none\n')
    health_check: typing.Union[models.aws_servicediscovery.HealthCheckConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for an optional health check. If you specify health check settings, AWS Cloud Map associates the health check with the records that you specify in DnsConfig. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. Not valid for PrivateDnsNamespaces. If you use healthCheck, you can only register IP instances to this service. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the Service. Default: CloudFormation-generated name')
    return_config: typing.Optional[list[models.aws_servicediscovery.ServiceDefConfig]] = pydantic.Field(None)
    ...

class HttpNamespaceDefFromHttpNamespaceAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    namespace_arn: str = pydantic.Field(..., description='Namespace ARN for the Namespace.\n')
    namespace_id: str = pydantic.Field(..., description='Namespace Id for the Namespace.\n')
    namespace_name: str = pydantic.Field(..., description='A name for the Namespace.')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.IpInstance
class IpInstanceDef(BaseConstruct):
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The Cloudmap service this resource is registered to.\n')
    ipv4: typing.Optional[str] = pydantic.Field(None, description='If the service that you specify contains a template for an A record, the IPv4 address that you want AWS Cloud Map to use for the value of the A record. Default: none\n')
    ipv6: typing.Optional[str] = pydantic.Field(None, description='If the service that you specify contains a template for an AAAA record, the IPv6 address that you want AWS Cloud Map to use for the value of the AAAA record. Default: none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port on the endpoint that you want AWS Cloud Map to perform health checks on. This value is also used for the port value in an SRV record if the service that you specify includes an SRV record. You can also specify a default port that is applied to all instances in the Service configuration. Default: 80\n')
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['service', 'ipv4', 'ipv6', 'port', 'custom_attributes', 'instance_id']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.IpInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[IpInstanceDefConfig] = pydantic.Field(None)


class IpInstanceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    service_config: typing.Optional[models._interface_methods.AwsServicediscoveryIServiceDefConfig] = pydantic.Field(None)

class IpInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.NonIpInstance
class NonIpInstanceDef(BaseConstruct):
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The Cloudmap service this resource is registered to.\n')
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['service', 'custom_attributes', 'instance_id']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.NonIpInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NonIpInstanceDefConfig] = pydantic.Field(None)


class NonIpInstanceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    service_config: typing.Optional[models._interface_methods.AwsServicediscoveryIServiceDefConfig] = pydantic.Field(None)

class NonIpInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.PrivateDnsNamespace
class PrivateDnsNamespaceDef(BaseConstruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The Amazon VPC that you want to associate the namespace with.\n')
    name: str = pydantic.Field(..., description='A name for the Namespace.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the Namespace. Default: none')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'name', 'description']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'create_service']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_private_dns_namespace_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.PrivateDnsNamespace'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_private_dns_namespace_attributes']
    ...


    from_private_dns_namespace_attributes: typing.Optional[PrivateDnsNamespaceDefFromPrivateDnsNamespaceAttributesParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[PrivateDnsNamespaceDefConfig] = pydantic.Field(None)


class PrivateDnsNamespaceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    create_service: typing.Optional[list[PrivateDnsNamespaceDefCreateServiceParams]] = pydantic.Field(None, description='Creates a service within the namespace.')

class PrivateDnsNamespaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PrivateDnsNamespaceDefCreateServiceParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    discovery_type: typing.Optional[aws_cdk.aws_servicediscovery.DiscoveryType] = pydantic.Field(None, description='Controls how instances within this service can be discovered. Default: DNS_AND_API\n')
    dns_record_type: typing.Optional[aws_cdk.aws_servicediscovery.DnsRecordType] = pydantic.Field(None, description='The DNS type of the record that you want AWS Cloud Map to create. Supported record types include A, AAAA, A and AAAA (A_AAAA), CNAME, and SRV. Default: A\n')
    dns_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record. Default: Duration.minutes(1)\n')
    load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Whether or not this service will have an Elastic LoadBalancer registered to it as an AliasTargetInstance. Setting this to ``true`` correctly configures the ``routingPolicy`` and performs some additional validation. Default: false\n')
    routing_policy: typing.Optional[aws_cdk.aws_servicediscovery.RoutingPolicy] = pydantic.Field(None, description='The routing policy that you want to apply to all DNS records that AWS Cloud Map creates when you register an instance and specify this service. Default: WEIGHTED for CNAME records and when loadBalancer is true, MULTIVALUE otherwise\n')
    custom_health_check: typing.Union[models.aws_servicediscovery.HealthCheckCustomConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Structure containing failure threshold for a custom health checker. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. See: https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the service. Default: none\n')
    health_check: typing.Union[models.aws_servicediscovery.HealthCheckConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for an optional health check. If you specify health check settings, AWS Cloud Map associates the health check with the records that you specify in DnsConfig. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. Not valid for PrivateDnsNamespaces. If you use healthCheck, you can only register IP instances to this service. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the Service. Default: CloudFormation-generated name')
    return_config: typing.Optional[list[models.aws_servicediscovery.ServiceDefConfig]] = pydantic.Field(None)
    ...

class PrivateDnsNamespaceDefFromPrivateDnsNamespaceAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    namespace_arn: str = pydantic.Field(..., description='Namespace ARN for the Namespace.\n')
    namespace_id: str = pydantic.Field(..., description='Namespace Id for the Namespace.\n')
    namespace_name: str = pydantic.Field(..., description='A name for the Namespace.')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.PublicDnsNamespace
class PublicDnsNamespaceDef(BaseConstruct):
    name: str = pydantic.Field(..., description='A name for the Namespace.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the Namespace. Default: none')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'create_service']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_public_dns_namespace_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.PublicDnsNamespace'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_public_dns_namespace_attributes']
    ...


    from_public_dns_namespace_attributes: typing.Optional[PublicDnsNamespaceDefFromPublicDnsNamespaceAttributesParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[PublicDnsNamespaceDefConfig] = pydantic.Field(None)


class PublicDnsNamespaceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    create_service: typing.Optional[list[PublicDnsNamespaceDefCreateServiceParams]] = pydantic.Field(None, description='Creates a service within the namespace.')

class PublicDnsNamespaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PublicDnsNamespaceDefCreateServiceParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    discovery_type: typing.Optional[aws_cdk.aws_servicediscovery.DiscoveryType] = pydantic.Field(None, description='Controls how instances within this service can be discovered. Default: DNS_AND_API\n')
    dns_record_type: typing.Optional[aws_cdk.aws_servicediscovery.DnsRecordType] = pydantic.Field(None, description='The DNS type of the record that you want AWS Cloud Map to create. Supported record types include A, AAAA, A and AAAA (A_AAAA), CNAME, and SRV. Default: A\n')
    dns_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record. Default: Duration.minutes(1)\n')
    load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Whether or not this service will have an Elastic LoadBalancer registered to it as an AliasTargetInstance. Setting this to ``true`` correctly configures the ``routingPolicy`` and performs some additional validation. Default: false\n')
    routing_policy: typing.Optional[aws_cdk.aws_servicediscovery.RoutingPolicy] = pydantic.Field(None, description='The routing policy that you want to apply to all DNS records that AWS Cloud Map creates when you register an instance and specify this service. Default: WEIGHTED for CNAME records and when loadBalancer is true, MULTIVALUE otherwise\n')
    custom_health_check: typing.Union[models.aws_servicediscovery.HealthCheckCustomConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Structure containing failure threshold for a custom health checker. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. See: https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the service. Default: none\n')
    health_check: typing.Union[models.aws_servicediscovery.HealthCheckConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for an optional health check. If you specify health check settings, AWS Cloud Map associates the health check with the records that you specify in DnsConfig. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. Not valid for PrivateDnsNamespaces. If you use healthCheck, you can only register IP instances to this service. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the Service. Default: CloudFormation-generated name')
    return_config: typing.Optional[list[models.aws_servicediscovery.ServiceDefConfig]] = pydantic.Field(None)
    ...

class PublicDnsNamespaceDefFromPublicDnsNamespaceAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    namespace_arn: str = pydantic.Field(..., description='Namespace ARN for the Namespace.\n')
    namespace_id: str = pydantic.Field(..., description='Namespace Id for the Namespace.\n')
    namespace_name: str = pydantic.Field(..., description='A name for the Namespace.')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.Service
class ServiceDef(BaseConstruct):
    namespace: models.UnsupportedResource = pydantic.Field(..., description='The namespace that you want to use for DNS configuration.\n')
    discovery_type: typing.Optional[aws_cdk.aws_servicediscovery.DiscoveryType] = pydantic.Field(None, description='Controls how instances within this service can be discovered. Default: DNS_AND_API\n')
    dns_record_type: typing.Optional[aws_cdk.aws_servicediscovery.DnsRecordType] = pydantic.Field(None, description='The DNS type of the record that you want AWS Cloud Map to create. Supported record types include A, AAAA, A and AAAA (A_AAAA), CNAME, and SRV. Default: A\n')
    dns_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record. Default: Duration.minutes(1)\n')
    load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Whether or not this service will have an Elastic LoadBalancer registered to it as an AliasTargetInstance. Setting this to ``true`` correctly configures the ``routingPolicy`` and performs some additional validation. Default: false\n')
    routing_policy: typing.Optional[aws_cdk.aws_servicediscovery.RoutingPolicy] = pydantic.Field(None, description='The routing policy that you want to apply to all DNS records that AWS Cloud Map creates when you register an instance and specify this service. Default: WEIGHTED for CNAME records and when loadBalancer is true, MULTIVALUE otherwise\n')
    custom_health_check: typing.Union[models.aws_servicediscovery.HealthCheckCustomConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Structure containing failure threshold for a custom health checker. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. See: https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the service. Default: none\n')
    health_check: typing.Union[models.aws_servicediscovery.HealthCheckConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for an optional health check. If you specify health check settings, AWS Cloud Map associates the health check with the records that you specify in DnsConfig. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. Not valid for PrivateDnsNamespaces. If you use healthCheck, you can only register IP instances to this service. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the Service. Default: CloudFormation-generated name')
    _init_params: typing.ClassVar[list[str]] = ['namespace', 'discovery_type', 'dns_record_type', 'dns_ttl', 'load_balancer', 'routing_policy', 'custom_health_check', 'description', 'health_check', 'name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'register_cname_instance', 'register_ip_instance', 'register_load_balancer', 'register_non_ip_instance']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_service_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.Service'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_service_attributes']
    ...


    from_service_attributes: typing.Optional[ServiceDefFromServiceAttributesParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[ServiceDefConfig] = pydantic.Field(None)


class ServiceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    register_cname_instance: typing.Optional[list[ServiceDefRegisterCnameInstanceParams]] = pydantic.Field(None, description='Registers a resource that is accessible using a CNAME.')
    register_ip_instance: typing.Optional[list[ServiceDefRegisterIpInstanceParams]] = pydantic.Field(None, description='Registers a resource that is accessible using an IP address.')
    register_load_balancer: typing.Optional[list[ServiceDefRegisterLoadBalancerParams]] = pydantic.Field(None, description='Registers an ELB as a new instance with unique name instanceId in this service.')
    register_non_ip_instance: typing.Optional[list[ServiceDefRegisterNonIpInstanceParams]] = pydantic.Field(None, description='Registers a resource that is accessible using values other than an IP address or a domain name (CNAME).')
    namespace_config: typing.Optional[models._interface_methods.AwsServicediscoveryINamespaceDefConfig] = pydantic.Field(None)

class ServiceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ServiceDefFromServiceAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    dns_record_type: aws_cdk.aws_servicediscovery.DnsRecordType = pydantic.Field(..., description='')
    namespace: models.UnsupportedResource = pydantic.Field(..., description='')
    routing_policy: aws_cdk.aws_servicediscovery.RoutingPolicy = pydantic.Field(..., description='')
    service_arn: str = pydantic.Field(..., description='')
    service_id: str = pydantic.Field(..., description='')
    service_name: str = pydantic.Field(..., description='')
    discovery_type: typing.Optional[aws_cdk.aws_servicediscovery.DiscoveryType] = pydantic.Field(None, description='')
    ...

class ServiceDefRegisterCnameInstanceParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    instance_cname: str = pydantic.Field(..., description='If the service configuration includes a CNAME record, the domain name that you want Route 53 to return in response to DNS queries, for example, example.com. This value is required if the service specified by ServiceId includes settings for an CNAME record.\n')
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name')
    return_config: typing.Optional[list[models._interface_methods.AwsServicediscoveryIInstanceDefConfig]] = pydantic.Field(None)
    ...

class ServiceDefRegisterIpInstanceParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    ipv4: typing.Optional[str] = pydantic.Field(None, description='If the service that you specify contains a template for an A record, the IPv4 address that you want AWS Cloud Map to use for the value of the A record. Default: none\n')
    ipv6: typing.Optional[str] = pydantic.Field(None, description='If the service that you specify contains a template for an AAAA record, the IPv6 address that you want AWS Cloud Map to use for the value of the AAAA record. Default: none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port on the endpoint that you want AWS Cloud Map to perform health checks on. This value is also used for the port value in an SRV record if the service that you specify includes an SRV record. You can also specify a default port that is applied to all instances in the Service configuration. Default: 80\n')
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name')
    return_config: typing.Optional[list[models._interface_methods.AwsServicediscoveryIInstanceDefConfig]] = pydantic.Field(None)
    ...

class ServiceDefRegisterLoadBalancerParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    load_balancer: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models._interface_methods.AwsServicediscoveryIInstanceDefConfig]] = pydantic.Field(None)
    ...

class ServiceDefRegisterNonIpInstanceParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name')
    return_config: typing.Optional[list[models._interface_methods.AwsServicediscoveryIInstanceDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.AliasTargetInstanceProps
class AliasTargetInstancePropsDef(BaseStruct):
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name\n')
    dns_name: str = pydantic.Field(..., description='DNS name of the target.\n')
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The Cloudmap service this resource is registered to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # service: servicediscovery.Service\n\n    alias_target_instance_props = servicediscovery.AliasTargetInstanceProps(\n        dns_name="dnsName",\n        service=service,\n\n        # the properties below are optional\n        custom_attributes={\n            "custom_attributes_key": "customAttributes"\n        },\n        instance_id="instanceId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_attributes', 'instance_id', 'dns_name', 'service']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.AliasTargetInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AliasTargetInstancePropsDefConfig] = pydantic.Field(None)


class AliasTargetInstancePropsDefConfig(pydantic.BaseModel):
    service_config: typing.Optional[models._interface_methods.AwsServicediscoveryIServiceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicediscovery.BaseInstanceProps
class BaseInstancePropsDef(BaseStruct):
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    base_instance_props = servicediscovery.BaseInstanceProps(\n        custom_attributes={\n            "custom_attributes_key": "customAttributes"\n        },\n        instance_id="instanceId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_attributes', 'instance_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.BaseInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.BaseNamespaceProps
class BaseNamespacePropsDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the Namespace.')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the Namespace. Default: none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    base_namespace_props = servicediscovery.BaseNamespaceProps(\n        name="name",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.BaseNamespaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.BaseServiceProps
class BaseServicePropsDef(BaseStruct):
    custom_health_check: typing.Union[models.aws_servicediscovery.HealthCheckCustomConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Structure containing failure threshold for a custom health checker. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. See: https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the service. Default: none\n')
    health_check: typing.Union[models.aws_servicediscovery.HealthCheckConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for an optional health check. If you specify health check settings, AWS Cloud Map associates the health check with the records that you specify in DnsConfig. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. Not valid for PrivateDnsNamespaces. If you use healthCheck, you can only register IP instances to this service. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the Service. Default: CloudFormation-generated name\n\n:exampleMetadata: lit=aws-servicediscovery/test/integ.service-with-http-namespace.lit.ts infused\n\nExample::\n\n    import aws_cdk as cdk\n    import aws_cdk as servicediscovery\n\n    app = cdk.App()\n    stack = cdk.Stack(app, "aws-servicediscovery-integ")\n\n    namespace = servicediscovery.HttpNamespace(stack, "MyNamespace",\n        name="MyHTTPNamespace"\n    )\n\n    service1 = namespace.create_service("NonIpService",\n        description="service registering non-ip instances"\n    )\n\n    service1.register_non_ip_instance("NonIpInstance",\n        custom_attributes={"arn": "arn:aws:s3:::mybucket"}\n    )\n\n    service2 = namespace.create_service("IpService",\n        description="service registering ip instances",\n        health_check=cdk.aws_servicediscovery.HealthCheckConfig(\n            type=servicediscovery.HealthCheckType.HTTP,\n            resource_path="/check"\n        )\n    )\n\n    service2.register_ip_instance("IpInstance",\n        ipv4="54.239.25.192"\n    )\n\n    app.synth()\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_health_check', 'description', 'health_check', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.BaseServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespace.PrivateDnsPropertiesMutableProperty
class CfnPrivateDnsNamespace_PrivateDnsPropertiesMutablePropertyDef(BaseStruct):
    soa: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPrivateDnsNamespace_SOAPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Fields for the Start of Authority (SOA) record for the hosted zone for the private DNS namespace.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-privatednsnamespace-privatednspropertiesmutable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    private_dns_properties_mutable_property = servicediscovery.CfnPrivateDnsNamespace.PrivateDnsPropertiesMutableProperty(\n        soa=servicediscovery.CfnPrivateDnsNamespace.SOAProperty(\n            ttl=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['soa']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespace.PrivateDnsPropertiesMutableProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespace.PropertiesProperty
class CfnPrivateDnsNamespace_PropertiesPropertyDef(BaseStruct):
    dns_properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPrivateDnsNamespace_PrivateDnsPropertiesMutablePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='DNS properties for the private DNS namespace.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-privatednsnamespace-properties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    properties_property = servicediscovery.CfnPrivateDnsNamespace.PropertiesProperty(\n        dns_properties=servicediscovery.CfnPrivateDnsNamespace.PrivateDnsPropertiesMutableProperty(\n            soa=servicediscovery.CfnPrivateDnsNamespace.SOAProperty(\n                ttl=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dns_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespace.PropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespace.SOAProperty
class CfnPrivateDnsNamespace_SOAPropertyDef(BaseStruct):
    ttl: typing.Union[int, float, None] = pydantic.Field(None, description='The time to live (TTL) for purposes of negative caching.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-privatednsnamespace-soa.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    s_oAProperty = servicediscovery.CfnPrivateDnsNamespace.SOAProperty(\n        ttl=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ttl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespace.SOAProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnPublicDnsNamespace.PropertiesProperty
class CfnPublicDnsNamespace_PropertiesPropertyDef(BaseStruct):
    dns_properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPublicDnsNamespace_PublicDnsPropertiesMutablePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='DNS properties for the public DNS namespace.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-publicdnsnamespace-properties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    properties_property = servicediscovery.CfnPublicDnsNamespace.PropertiesProperty(\n        dns_properties=servicediscovery.CfnPublicDnsNamespace.PublicDnsPropertiesMutableProperty(\n            soa=servicediscovery.CfnPublicDnsNamespace.SOAProperty(\n                ttl=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dns_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPublicDnsNamespace.PropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnPublicDnsNamespace.PublicDnsPropertiesMutableProperty
class CfnPublicDnsNamespace_PublicDnsPropertiesMutablePropertyDef(BaseStruct):
    soa: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPublicDnsNamespace_SOAPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Start of Authority (SOA) record for the hosted zone for the public DNS namespace.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-publicdnsnamespace-publicdnspropertiesmutable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    public_dns_properties_mutable_property = servicediscovery.CfnPublicDnsNamespace.PublicDnsPropertiesMutableProperty(\n        soa=servicediscovery.CfnPublicDnsNamespace.SOAProperty(\n            ttl=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['soa']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPublicDnsNamespace.PublicDnsPropertiesMutableProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnPublicDnsNamespace.SOAProperty
class CfnPublicDnsNamespace_SOAPropertyDef(BaseStruct):
    ttl: typing.Union[int, float, None] = pydantic.Field(None, description='The time to live (TTL) for purposes of negative caching.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-publicdnsnamespace-soa.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    s_oAProperty = servicediscovery.CfnPublicDnsNamespace.SOAProperty(\n        ttl=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ttl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPublicDnsNamespace.SOAProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnService.DnsConfigProperty
class CfnService_DnsConfigPropertyDef(BaseStruct):
    dns_records: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnService_DnsRecordPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='An array that contains one ``DnsRecord`` object for each Route 53 DNS record that you want AWS Cloud Map to create when you register an instance.\n')
    namespace_id: typing.Optional[str] = pydantic.Field(None, description="The ID of the namespace to use for DNS configuration. .. epigraph:: You must specify a value for ``NamespaceId`` either for ``DnsConfig`` or for the `service properties <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-service.html>`_ . Don't specify a value in both places.\n")
    routing_policy: typing.Optional[str] = pydantic.Field(None, description='The routing policy that you want to apply to all Route 53 DNS records that AWS Cloud Map creates when you register an instance and specify this service. .. epigraph:: If you want to use this service to register instances that create alias records, specify ``WEIGHTED`` for the routing policy. You can specify the following values: - **MULTIVALUE** - If you define a health check for the service and the health check is healthy, Route 53 returns the applicable value for up to eight instances. For example, suppose that the service includes configurations for one ``A`` record and a health check. You use the service to register 10 instances. Route 53 responds to DNS queries with IP addresses for up to eight healthy instances. If fewer than eight instances are healthy, Route 53 responds to every DNS query with the IP addresses for all of the healthy instances. If you don\'t define a health check for the service, Route 53 assumes that all instances are healthy and returns the values for up to eight instances. For more information about the multivalue routing policy, see `Multivalue Answer Routing <https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-multivalue>`_ in the *Route 53 Developer Guide* . - **WEIGHTED** - Route 53 returns the applicable value from one randomly selected instance from among the instances that you registered using the same service. Currently, all records have the same weight, so you can\'t route more or less traffic to any instances. For example, suppose that the service includes configurations for one ``A`` record and a health check. You use the service to register 10 instances. Route 53 responds to DNS queries with the IP address for one randomly selected instance from among the healthy instances. If no instances are healthy, Route 53 responds to DNS queries as if all of the instances were healthy. If you don\'t define a health check for the service, Route 53 assumes that all instances are healthy and returns the applicable value for one randomly selected instance. For more information about the weighted routing policy, see `Weighted Routing <https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted>`_ in the *Route 53 Developer Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-service-dnsconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    dns_config_property = servicediscovery.CfnService.DnsConfigProperty(\n        dns_records=[servicediscovery.CfnService.DnsRecordProperty(\n            ttl=123,\n            type="type"\n        )],\n\n        # the properties below are optional\n        namespace_id="namespaceId",\n        routing_policy="routingPolicy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dns_records', 'namespace_id', 'routing_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnService.DnsConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnService.DnsRecordProperty
class CfnService_DnsRecordPropertyDef(BaseStruct):
    ttl: typing.Union[int, float] = pydantic.Field(..., description="The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record. .. epigraph:: Alias records don't include a TTL because Route 53 uses the TTL for the AWS resource that an alias record routes traffic to. If you include the ``AWS_ALIAS_DNS_NAME`` attribute when you submit a `RegisterInstance <https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html>`_ request, the ``TTL`` value is ignored. Always specify a TTL for the service; you can use a service to register instances that create either alias or non-alias records.\n")
    type: str = pydantic.Field(..., description='The type of the resource, which indicates the type of value that Route 53 returns in response to DNS queries. You can specify values for ``Type`` in the following combinations: - ``A`` - ``AAAA`` - ``A`` and ``AAAA`` - ``SRV`` - ``CNAME`` If you want AWS Cloud Map to create a Route 53 alias record when you register an instance, specify ``A`` or ``AAAA`` for ``Type`` . You specify other settings, such as the IP address for ``A`` and ``AAAA`` records, when you register an instance. For more information, see `RegisterInstance <https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html>`_ . The following values are supported: - **A** - Route 53 returns the IP address of the resource in IPv4 format, such as 192.0.2.44. - **AAAA** - Route 53 returns the IP address of the resource in IPv6 format, such as 2001:0db8:85a3:0000:0000:abcd:0001:2345. - **CNAME** - Route 53 returns the domain name of the resource, such as www.example.com. Note the following: - You specify the domain name that you want to route traffic to when you register an instance. For more information, see `Attributes <https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html#cloudmap-RegisterInstance-request-Attributes>`_ in the topic `RegisterInstance <https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html>`_ . - You must specify ``WEIGHTED`` for the value of ``RoutingPolicy`` . - You can\'t specify both ``CNAME`` for ``Type`` and settings for ``HealthCheckConfig`` . If you do, the request will fail with an ``InvalidInput`` error. - **SRV** - Route 53 returns the value for an ``SRV`` record. The value for an ``SRV`` record uses the following values: ``priority weight port service-hostname`` Note the following about the values: - The values of ``priority`` and ``weight`` are both set to ``1`` and can\'t be changed. - The value of ``port`` comes from the value that you specify for the ``AWS_INSTANCE_PORT`` attribute when you submit a `RegisterInstance <https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html>`_ request. - The value of ``service-hostname`` is a concatenation of the following values: - The value that you specify for ``InstanceId`` when you register an instance. - The name of the service. - The name of the namespace. For example, if the value of ``InstanceId`` is ``test`` , the name of the service is ``backend`` , and the name of the namespace is ``example.com`` , the value of ``service-hostname`` is: ``test.backend.example.com`` If you specify settings for an ``SRV`` record and if you specify values for ``AWS_INSTANCE_IPV4`` , ``AWS_INSTANCE_IPV6`` , or both in the ``RegisterInstance`` request, AWS Cloud Map automatically creates ``A`` and/or ``AAAA`` records that have the same name as the value of ``service-hostname`` in the ``SRV`` record. You can ignore these records.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-service-dnsrecord.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    dns_record_property = servicediscovery.CfnService.DnsRecordProperty(\n        ttl=123,\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ttl', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnService.DnsRecordProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnService.HealthCheckConfigProperty
class CfnService_HealthCheckConfigPropertyDef(BaseStruct):
    type: str = pydantic.Field(..., description="The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. .. epigraph:: You can't change the value of ``Type`` after you create a health check. You can create the following types of health checks: - *HTTP* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and waits for an HTTP status code of 200 or greater and less than 400. - *HTTPS* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400. .. epigraph:: If you specify HTTPS for the value of ``Type`` , the endpoint must support TLS v1.0 or later. - *TCP* : Route 53 tries to establish a TCP connection. If you specify ``TCP`` for ``Type`` , don't specify a value for ``ResourcePath`` . For more information, see `How Route 53 Determines Whether an Endpoint Is Healthy <https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html>`_ in the *Route 53 Developer Guide* .\n")
    failure_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current status of the endpoint from unhealthy to healthy or the other way around. For more information, see `How Route 53 Determines Whether an Endpoint Is Healthy <https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html>`_ in the *Route 53 Developer Guide* .\n')
    resource_path: typing.Optional[str] = pydantic.Field(None, description='The path that you want Route 53 to request when performing health checks. The path can be any value that your endpoint returns an HTTP status code of a 2xx or 3xx format for when the endpoint is healthy. An example file is ``/docs/route53-health-check.html`` . Route 53 automatically adds the DNS name for the service. If you don\'t specify a value for ``ResourcePath`` , the default value is ``/`` . If you specify ``TCP`` for ``Type`` , you must *not* specify a value for ``ResourcePath`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-service-healthcheckconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    health_check_config_property = servicediscovery.CfnService.HealthCheckConfigProperty(\n        type="type",\n\n        # the properties below are optional\n        failure_threshold=123,\n        resource_path="resourcePath"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'failure_threshold', 'resource_path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnService.HealthCheckConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnService.HealthCheckCustomConfigProperty
class CfnService_HealthCheckCustomConfigPropertyDef(BaseStruct):
    failure_threshold: typing.Union[int, float, None] = pydantic.Field(None, description=".. epigraph:: This parameter is no longer supported and is always set to 1. AWS Cloud Map waits for approximately 30 seconds after receiving an ``UpdateInstanceCustomHealthStatus`` request before changing the status of the service instance. The number of 30-second intervals that you want AWS Cloud Map to wait after receiving an ``UpdateInstanceCustomHealthStatus`` request before it changes the health status of a service instance. Sending a second or subsequent ``UpdateInstanceCustomHealthStatus`` request with the same value before 30 seconds has passed doesn't accelerate the change. AWS Cloud Map still waits ``30`` seconds after the first request to make the change.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-service-healthcheckcustomconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    health_check_custom_config_property = servicediscovery.CfnService.HealthCheckCustomConfigProperty(\n        failure_threshold=123\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['failure_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnService.HealthCheckCustomConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CnameInstanceBaseProps
class CnameInstanceBasePropsDef(BaseStruct):
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name\n')
    instance_cname: str = pydantic.Field(..., description='If the service configuration includes a CNAME record, the domain name that you want Route 53 to return in response to DNS queries, for example, example.com. This value is required if the service specified by ServiceId includes settings for an CNAME record.\n\n:exampleMetadata: lit=aws-servicediscovery/test/integ.service-with-cname-record.lit.ts infused\n\nExample::\n\n    import aws_cdk as cdk\n    import aws_cdk as servicediscovery\n\n    app = cdk.App()\n    stack = cdk.Stack(app, "aws-servicediscovery-integ")\n\n    namespace = servicediscovery.PublicDnsNamespace(stack, "Namespace",\n        name="foobar.com"\n    )\n\n    service = namespace.create_service("Service",\n        name="foo",\n        dns_record_type=servicediscovery.DnsRecordType.CNAME,\n        dns_ttl=cdk.Duration.seconds(30)\n    )\n\n    service.register_cname_instance("CnameInstance",\n        instance_cname="service.pizza"\n    )\n\n    app.synth()\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_attributes', 'instance_id', 'instance_cname']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CnameInstanceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CnameInstanceProps
class CnameInstancePropsDef(BaseStruct):
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name\n')
    instance_cname: str = pydantic.Field(..., description='If the service configuration includes a CNAME record, the domain name that you want Route 53 to return in response to DNS queries, for example, example.com. This value is required if the service specified by ServiceId includes settings for an CNAME record.\n')
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The Cloudmap service this resource is registered to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # service: servicediscovery.Service\n\n    cname_instance_props = servicediscovery.CnameInstanceProps(\n        instance_cname="instanceCname",\n        service=service,\n\n        # the properties below are optional\n        custom_attributes={\n            "custom_attributes_key": "customAttributes"\n        },\n        instance_id="instanceId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_attributes', 'instance_id', 'instance_cname', 'service']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CnameInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.DnsServiceProps
class DnsServicePropsDef(BaseStruct):
    custom_health_check: typing.Union[models.aws_servicediscovery.HealthCheckCustomConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Structure containing failure threshold for a custom health checker. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. See: https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html Default: none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the service. Default: none\n')
    health_check: typing.Union[models.aws_servicediscovery.HealthCheckConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for an optional health check. If you specify health check settings, AWS Cloud Map associates the health check with the records that you specify in DnsConfig. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. Not valid for PrivateDnsNamespaces. If you use healthCheck, you can only register IP instances to this service. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the Service. Default: CloudFormation-generated name\n')
    discovery_type: typing.Optional[aws_cdk.aws_servicediscovery.DiscoveryType] = pydantic.Field(None, description='Controls how instances within this service can be discovered. Default: DNS_AND_API\n')
    dns_record_type: typing.Optional[aws_cdk.aws_servicediscovery.DnsRecordType] = pydantic.Field(None, description='The DNS type of the record that you want AWS Cloud Map to create. Supported record types include A, AAAA, A and AAAA (A_AAAA), CNAME, and SRV. Default: A\n')
    dns_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record. Default: Duration.minutes(1)\n')
    load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Whether or not this service will have an Elastic LoadBalancer registered to it as an AliasTargetInstance. Setting this to ``true`` correctly configures the ``routingPolicy`` and performs some additional validation. Default: false\n')
    routing_policy: typing.Optional[aws_cdk.aws_servicediscovery.RoutingPolicy] = pydantic.Field(None, description='The routing policy that you want to apply to all DNS records that AWS Cloud Map creates when you register an instance and specify this service. Default: WEIGHTED for CNAME records and when loadBalancer is true, MULTIVALUE otherwise\n\n:exampleMetadata: lit=aws-servicediscovery/test/integ.service-with-public-dns-namespace.lit.ts infused\n\nExample::\n\n    import aws_cdk as cdk\n    import aws_cdk as servicediscovery\n\n    app = cdk.App()\n    stack = cdk.Stack(app, "aws-servicediscovery-integ")\n\n    namespace = servicediscovery.PublicDnsNamespace(stack, "Namespace",\n        name="foobar.com"\n    )\n\n    service = namespace.create_service("Service",\n        name="foo",\n        dns_record_type=servicediscovery.DnsRecordType.A,\n        dns_ttl=cdk.Duration.seconds(30),\n        health_check=cdk.aws_servicediscovery.HealthCheckConfig(\n            type=servicediscovery.HealthCheckType.HTTPS,\n            resource_path="/healthcheck",\n            failure_threshold=2\n        )\n    )\n\n    service.register_ip_instance("IpInstance",\n        ipv4="54.239.25.192",\n        port=443\n    )\n\n    app.synth()\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_health_check', 'description', 'health_check', 'name', 'discovery_type', 'dns_record_type', 'dns_ttl', 'load_balancer', 'routing_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.DnsServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.HealthCheckConfig
class HealthCheckConfigDef(BaseStruct):
    failure_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. Default: 1\n')
    resource_path: typing.Optional[str] = pydantic.Field(None, description="The path that you want Route 53 to request when performing health checks. Do not use when health check type is TCP. Default: '/'\n")
    type: typing.Optional[aws_cdk.aws_servicediscovery.HealthCheckType] = pydantic.Field(None, description='The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Cannot be modified once created. Supported values are HTTP, HTTPS, and TCP. Default: HTTP\n\n:exampleMetadata: lit=aws-servicediscovery/test/integ.service-with-http-namespace.lit.ts infused\n\nExample::\n\n    import aws_cdk as cdk\n    import aws_cdk as servicediscovery\n\n    app = cdk.App()\n    stack = cdk.Stack(app, "aws-servicediscovery-integ")\n\n    namespace = servicediscovery.HttpNamespace(stack, "MyNamespace",\n        name="MyHTTPNamespace"\n    )\n\n    service1 = namespace.create_service("NonIpService",\n        description="service registering non-ip instances"\n    )\n\n    service1.register_non_ip_instance("NonIpInstance",\n        custom_attributes={"arn": "arn:aws:s3:::mybucket"}\n    )\n\n    service2 = namespace.create_service("IpService",\n        description="service registering ip instances",\n        health_check=cdk.aws_servicediscovery.HealthCheckConfig(\n            type=servicediscovery.HealthCheckType.HTTP,\n            resource_path="/check"\n        )\n    )\n\n    service2.register_ip_instance("IpInstance",\n        ipv4="54.239.25.192"\n    )\n\n    app.synth()\n')
    _init_params: typing.ClassVar[list[str]] = ['failure_threshold', 'resource_path', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.HealthCheckConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.HealthCheckCustomConfig
class HealthCheckCustomConfigDef(BaseStruct):
    failure_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of 30-second intervals that you want Cloud Map to wait after receiving an UpdateInstanceCustomHealthStatus request before it changes the health status of a service instance. Default: 1\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    health_check_custom_config = servicediscovery.HealthCheckCustomConfig(\n        failure_threshold=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['failure_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.HealthCheckCustomConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.HttpNamespaceAttributes
class HttpNamespaceAttributesDef(BaseStruct):
    namespace_arn: str = pydantic.Field(..., description='Namespace ARN for the Namespace.')
    namespace_id: str = pydantic.Field(..., description='Namespace Id for the Namespace.\n')
    namespace_name: str = pydantic.Field(..., description='A name for the Namespace.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    http_namespace_attributes = servicediscovery.HttpNamespaceAttributes(\n        namespace_arn="namespaceArn",\n        namespace_id="namespaceId",\n        namespace_name="namespaceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace_arn', 'namespace_id', 'namespace_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.HttpNamespaceAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.HttpNamespaceProps
class HttpNamespacePropsDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the Namespace.')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the Namespace. Default: none\n\n:exampleMetadata: lit=aws-servicediscovery/test/integ.service-with-http-namespace.lit.ts infused\n\nExample::\n\n    import aws_cdk as cdk\n    import aws_cdk as servicediscovery\n\n    app = cdk.App()\n    stack = cdk.Stack(app, "aws-servicediscovery-integ")\n\n    namespace = servicediscovery.HttpNamespace(stack, "MyNamespace",\n        name="MyHTTPNamespace"\n    )\n\n    service1 = namespace.create_service("NonIpService",\n        description="service registering non-ip instances"\n    )\n\n    service1.register_non_ip_instance("NonIpInstance",\n        custom_attributes={"arn": "arn:aws:s3:::mybucket"}\n    )\n\n    service2 = namespace.create_service("IpService",\n        description="service registering ip instances",\n        health_check=cdk.aws_servicediscovery.HealthCheckConfig(\n            type=servicediscovery.HealthCheckType.HTTP,\n            resource_path="/check"\n        )\n    )\n\n    service2.register_ip_instance("IpInstance",\n        ipv4="54.239.25.192"\n    )\n\n    app.synth()\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.HttpNamespaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.IpInstanceBaseProps
class IpInstanceBasePropsDef(BaseStruct):
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name\n')
    ipv4: typing.Optional[str] = pydantic.Field(None, description='If the service that you specify contains a template for an A record, the IPv4 address that you want AWS Cloud Map to use for the value of the A record. Default: none\n')
    ipv6: typing.Optional[str] = pydantic.Field(None, description='If the service that you specify contains a template for an AAAA record, the IPv6 address that you want AWS Cloud Map to use for the value of the AAAA record. Default: none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port on the endpoint that you want AWS Cloud Map to perform health checks on. This value is also used for the port value in an SRV record if the service that you specify includes an SRV record. You can also specify a default port that is applied to all instances in the Service configuration. Default: 80\n\n:exampleMetadata: lit=aws-servicediscovery/test/integ.service-with-http-namespace.lit.ts infused\n\nExample::\n\n    import aws_cdk as cdk\n    import aws_cdk as servicediscovery\n\n    app = cdk.App()\n    stack = cdk.Stack(app, "aws-servicediscovery-integ")\n\n    namespace = servicediscovery.HttpNamespace(stack, "MyNamespace",\n        name="MyHTTPNamespace"\n    )\n\n    service1 = namespace.create_service("NonIpService",\n        description="service registering non-ip instances"\n    )\n\n    service1.register_non_ip_instance("NonIpInstance",\n        custom_attributes={"arn": "arn:aws:s3:::mybucket"}\n    )\n\n    service2 = namespace.create_service("IpService",\n        description="service registering ip instances",\n        health_check=cdk.aws_servicediscovery.HealthCheckConfig(\n            type=servicediscovery.HealthCheckType.HTTP,\n            resource_path="/check"\n        )\n    )\n\n    service2.register_ip_instance("IpInstance",\n        ipv4="54.239.25.192"\n    )\n\n    app.synth()\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_attributes', 'instance_id', 'ipv4', 'ipv6', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.IpInstanceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.IpInstanceProps
class IpInstancePropsDef(BaseStruct):
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name\n')
    ipv4: typing.Optional[str] = pydantic.Field(None, description='If the service that you specify contains a template for an A record, the IPv4 address that you want AWS Cloud Map to use for the value of the A record. Default: none\n')
    ipv6: typing.Optional[str] = pydantic.Field(None, description='If the service that you specify contains a template for an AAAA record, the IPv6 address that you want AWS Cloud Map to use for the value of the AAAA record. Default: none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port on the endpoint that you want AWS Cloud Map to perform health checks on. This value is also used for the port value in an SRV record if the service that you specify includes an SRV record. You can also specify a default port that is applied to all instances in the Service configuration. Default: 80\n')
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The Cloudmap service this resource is registered to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # service: servicediscovery.Service\n\n    ip_instance_props = servicediscovery.IpInstanceProps(\n        service=service,\n\n        # the properties below are optional\n        custom_attributes={\n            "custom_attributes_key": "customAttributes"\n        },\n        instance_id="instanceId",\n        ipv4="ipv4",\n        ipv6="ipv6",\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_attributes', 'instance_id', 'ipv4', 'ipv6', 'port', 'service']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.IpInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[IpInstancePropsDefConfig] = pydantic.Field(None)


class IpInstancePropsDefConfig(pydantic.BaseModel):
    service_config: typing.Optional[models._interface_methods.AwsServicediscoveryIServiceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicediscovery.NonIpInstanceBaseProps
class NonIpInstanceBasePropsDef(BaseStruct):
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name\n\n:exampleMetadata: lit=aws-servicediscovery/test/integ.service-with-http-namespace.lit.ts infused\n\nExample::\n\n    import aws_cdk as cdk\n    import aws_cdk as servicediscovery\n\n    app = cdk.App()\n    stack = cdk.Stack(app, "aws-servicediscovery-integ")\n\n    namespace = servicediscovery.HttpNamespace(stack, "MyNamespace",\n        name="MyHTTPNamespace"\n    )\n\n    service1 = namespace.create_service("NonIpService",\n        description="service registering non-ip instances"\n    )\n\n    service1.register_non_ip_instance("NonIpInstance",\n        custom_attributes={"arn": "arn:aws:s3:::mybucket"}\n    )\n\n    service2 = namespace.create_service("IpService",\n        description="service registering ip instances",\n        health_check=cdk.aws_servicediscovery.HealthCheckConfig(\n            type=servicediscovery.HealthCheckType.HTTP,\n            resource_path="/check"\n        )\n    )\n\n    service2.register_ip_instance("IpInstance",\n        ipv4="54.239.25.192"\n    )\n\n    app.synth()\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_attributes', 'instance_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.NonIpInstanceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.NonIpInstanceProps
class NonIpInstancePropsDef(BaseStruct):
    custom_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom attributes of the instance. Default: none')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The id of the instance resource. Default: Automatically generated name\n')
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The Cloudmap service this resource is registered to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # service: servicediscovery.Service\n\n    non_ip_instance_props = servicediscovery.NonIpInstanceProps(\n        service=service,\n\n        # the properties below are optional\n        custom_attributes={\n            "custom_attributes_key": "customAttributes"\n        },\n        instance_id="instanceId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_attributes', 'instance_id', 'service']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.NonIpInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NonIpInstancePropsDefConfig] = pydantic.Field(None)


class NonIpInstancePropsDefConfig(pydantic.BaseModel):
    service_config: typing.Optional[models._interface_methods.AwsServicediscoveryIServiceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicediscovery.PrivateDnsNamespaceAttributes
class PrivateDnsNamespaceAttributesDef(BaseStruct):
    namespace_arn: str = pydantic.Field(..., description='Namespace ARN for the Namespace.')
    namespace_id: str = pydantic.Field(..., description='Namespace Id for the Namespace.\n')
    namespace_name: str = pydantic.Field(..., description='A name for the Namespace.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    private_dns_namespace_attributes = servicediscovery.PrivateDnsNamespaceAttributes(\n        namespace_arn="namespaceArn",\n        namespace_id="namespaceId",\n        namespace_name="namespaceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace_arn', 'namespace_id', 'namespace_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.PrivateDnsNamespaceAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.PrivateDnsNamespaceProps
class PrivateDnsNamespacePropsDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the Namespace.')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the Namespace. Default: none\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The Amazon VPC that you want to associate the namespace with.\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    # Cloud Map service discovery is currently required for host ejection by outlier detection\n    vpc = ec2.Vpc(self, "vpc")\n    namespace = cloudmap.PrivateDnsNamespace(self, "test-namespace",\n        vpc=vpc,\n        name="domain.local"\n    )\n    service = namespace.create_service("Svc")\n    node = mesh.add_virtual_node("virtual-node",\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            outlier_detection=appmesh.OutlierDetection(\n                base_ejection_duration=Duration.seconds(10),\n                interval=Duration.seconds(30),\n                max_ejection_percent=50,\n                max_server_errors=5\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.PrivateDnsNamespaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[PrivateDnsNamespacePropsDefConfig] = pydantic.Field(None)


class PrivateDnsNamespacePropsDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicediscovery.PublicDnsNamespaceAttributes
class PublicDnsNamespaceAttributesDef(BaseStruct):
    namespace_arn: str = pydantic.Field(..., description='Namespace ARN for the Namespace.')
    namespace_id: str = pydantic.Field(..., description='Namespace Id for the Namespace.\n')
    namespace_name: str = pydantic.Field(..., description='A name for the Namespace.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    public_dns_namespace_attributes = servicediscovery.PublicDnsNamespaceAttributes(\n        namespace_arn="namespaceArn",\n        namespace_id="namespaceId",\n        namespace_name="namespaceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace_arn', 'namespace_id', 'namespace_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.PublicDnsNamespaceAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.PublicDnsNamespaceProps
class PublicDnsNamespacePropsDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the Namespace.')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the Namespace. Default: none\n\n:exampleMetadata: lit=aws-servicediscovery/test/integ.service-with-public-dns-namespace.lit.ts infused\n\nExample::\n\n    import aws_cdk as cdk\n    import aws_cdk as servicediscovery\n\n    app = cdk.App()\n    stack = cdk.Stack(app, "aws-servicediscovery-integ")\n\n    namespace = servicediscovery.PublicDnsNamespace(stack, "Namespace",\n        name="foobar.com"\n    )\n\n    service = namespace.create_service("Service",\n        name="foo",\n        dns_record_type=servicediscovery.DnsRecordType.A,\n        dns_ttl=cdk.Duration.seconds(30),\n        health_check=cdk.aws_servicediscovery.HealthCheckConfig(\n            type=servicediscovery.HealthCheckType.HTTPS,\n            resource_path="/healthcheck",\n            failure_threshold=2\n        )\n    )\n\n    service.register_ip_instance("IpInstance",\n        ipv4="54.239.25.192",\n        port=443\n    )\n\n    app.synth()\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.PublicDnsNamespaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.ServiceAttributes
class ServiceAttributesDef(BaseStruct):
    dns_record_type: aws_cdk.aws_servicediscovery.DnsRecordType = pydantic.Field(..., description='')
    namespace: models.UnsupportedResource = pydantic.Field(..., description='')
    routing_policy: aws_cdk.aws_servicediscovery.RoutingPolicy = pydantic.Field(..., description='')
    service_arn: str = pydantic.Field(..., description='')
    service_id: str = pydantic.Field(..., description='')
    service_name: str = pydantic.Field(..., description='')
    discovery_type: typing.Optional[aws_cdk.aws_servicediscovery.DiscoveryType] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['dns_record_type', 'namespace', 'routing_policy', 'service_arn', 'service_id', 'service_name', 'discovery_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.ServiceAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ServiceAttributesDefConfig] = pydantic.Field(None)


class ServiceAttributesDefConfig(pydantic.BaseModel):
    namespace_config: typing.Optional[models._interface_methods.AwsServicediscoveryINamespaceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicediscovery.ServiceProps
class ServicePropsDef(BaseStruct):
    custom_health_check: typing.Union[models.aws_servicediscovery.HealthCheckCustomConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Structure containing failure threshold for a custom health checker. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. See: https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html Default: none')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the service. Default: none\n')
    health_check: typing.Union[models.aws_servicediscovery.HealthCheckConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for an optional health check. If you specify health check settings, AWS Cloud Map associates the health check with the records that you specify in DnsConfig. Only one of healthCheckConfig or healthCheckCustomConfig can be specified. Not valid for PrivateDnsNamespaces. If you use healthCheck, you can only register IP instances to this service. Default: none\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the Service. Default: CloudFormation-generated name\n')
    discovery_type: typing.Optional[aws_cdk.aws_servicediscovery.DiscoveryType] = pydantic.Field(None, description='Controls how instances within this service can be discovered. Default: DNS_AND_API\n')
    dns_record_type: typing.Optional[aws_cdk.aws_servicediscovery.DnsRecordType] = pydantic.Field(None, description='The DNS type of the record that you want AWS Cloud Map to create. Supported record types include A, AAAA, A and AAAA (A_AAAA), CNAME, and SRV. Default: A\n')
    dns_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record. Default: Duration.minutes(1)\n')
    load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Whether or not this service will have an Elastic LoadBalancer registered to it as an AliasTargetInstance. Setting this to ``true`` correctly configures the ``routingPolicy`` and performs some additional validation. Default: false\n')
    routing_policy: typing.Optional[aws_cdk.aws_servicediscovery.RoutingPolicy] = pydantic.Field(None, description='The routing policy that you want to apply to all DNS records that AWS Cloud Map creates when you register an instance and specify this service. Default: WEIGHTED for CNAME records and when loadBalancer is true, MULTIVALUE otherwise\n')
    namespace: models.UnsupportedResource = pydantic.Field(..., description='The namespace that you want to use for DNS configuration.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # namespace: servicediscovery.INamespace\n\n    service_props = servicediscovery.ServiceProps(\n        namespace=namespace,\n\n        # the properties below are optional\n        custom_health_check=servicediscovery.HealthCheckCustomConfig(\n            failure_threshold=123\n        ),\n        description="description",\n        discovery_type=servicediscovery.DiscoveryType.API,\n        dns_record_type=servicediscovery.DnsRecordType.A,\n        dns_ttl=cdk.Duration.minutes(30),\n        health_check=servicediscovery.HealthCheckConfig(\n            failure_threshold=123,\n            resource_path="resourcePath",\n            type=servicediscovery.HealthCheckType.HTTP\n        ),\n        load_balancer=False,\n        name="name",\n        routing_policy=servicediscovery.RoutingPolicy.WEIGHTED\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_health_check', 'description', 'health_check', 'name', 'discovery_type', 'dns_record_type', 'dns_ttl', 'load_balancer', 'routing_policy', 'namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.ServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ServicePropsDefConfig] = pydantic.Field(None)


class ServicePropsDefConfig(pydantic.BaseModel):
    namespace_config: typing.Optional[models._interface_methods.AwsServicediscoveryINamespaceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_servicediscovery.DiscoveryType
# skipping emum

#  autogenerated from aws_cdk.aws_servicediscovery.DnsRecordType
# skipping emum

#  autogenerated from aws_cdk.aws_servicediscovery.HealthCheckType
# skipping emum

#  autogenerated from aws_cdk.aws_servicediscovery.NamespaceType
# skipping emum

#  autogenerated from aws_cdk.aws_servicediscovery.RoutingPolicy
# skipping emum

#  autogenerated from aws_cdk.aws_servicediscovery.IHttpNamespace
#  skipping Interface

#  autogenerated from aws_cdk.aws_servicediscovery.IInstance
#  skipping Interface

#  autogenerated from aws_cdk.aws_servicediscovery.INamespace
#  skipping Interface

#  autogenerated from aws_cdk.aws_servicediscovery.IPrivateDnsNamespace
#  skipping Interface

#  autogenerated from aws_cdk.aws_servicediscovery.IPublicDnsNamespace
#  skipping Interface

#  autogenerated from aws_cdk.aws_servicediscovery.IService
#  skipping Interface

#  autogenerated from aws_cdk.aws_servicediscovery.CfnHttpNamespace
class CfnHttpNamespaceDef(BaseCfnResource):
    name: str = pydantic.Field(..., description='The name that you want to assign to this namespace.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the namespace.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the namespace. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnHttpNamespace'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnHttpNamespaceDefConfig] = pydantic.Field(None)


class CfnHttpNamespaceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnHttpNamespaceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnHttpNamespaceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnHttpNamespaceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnHttpNamespaceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnHttpNamespaceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnHttpNamespaceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnHttpNamespaceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnHttpNamespaceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnHttpNamespaceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnHttpNamespaceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnHttpNamespaceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnHttpNamespaceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnHttpNamespaceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnHttpNamespaceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnHttpNamespaceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnHttpNamespaceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnHttpNamespaceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnHttpNamespaceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnHttpNamespaceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnHttpNamespaceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnHttpNamespaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnHttpNamespaceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnHttpNamespaceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnHttpNamespaceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnHttpNamespaceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnHttpNamespaceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnHttpNamespaceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.CfnInstance
class CfnInstanceDef(BaseCfnResource):
    instance_attributes: typing.Any = pydantic.Field(..., description="A string map that contains the following information for the service that you specify in ``ServiceId`` :. - The attributes that apply to the records that are defined in the service. - For each attribute, the applicable value. Supported attribute keys include the following: - **AWS_ALIAS_DNS_NAME** - If you want AWS Cloud Map to create a Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify the DNS name that is associated with the load balancer. For information about how to get the DNS name, see `AliasTarget->DNSName <https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-DNSName>`_ in the *Route 53 API Reference* . Note the following: - The configuration for the service that is specified by ``ServiceId`` must include settings for an ``A`` record, an ``AAAA`` record, or both. - In the service that is specified by ``ServiceId`` , the value of ``RoutingPolicy`` must be ``WEIGHTED`` . - If the service that is specified by ``ServiceId`` includes ``HealthCheckConfig`` settings, AWS Cloud Map will create the health check, but it won't associate the health check with the alias record. - Auto naming currently doesn't support creating alias records that route traffic to AWS resources other than ELB load balancers. - If you specify a value for ``AWS_ALIAS_DNS_NAME`` , don't specify values for any of the ``AWS_INSTANCE`` attributes. - **AWS_EC2_INSTANCE_ID** - *HTTP namespaces only.* The Amazon EC2 instance ID for the instance. The ``AWS_INSTANCE_IPV4`` attribute contains the primary private IPv4 address. When creating resources with a type of `AWS::ServiceDiscovery::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-instance.html>`_ , if the ``AWS_EC2_INSTANCE_ID`` attribute is specified, the only other attribute that can be specified is ``AWS_INIT_HEALTH_STATUS`` . After the resource has been created, the ``AWS_INSTANCE_IPV4`` attribute contains the primary private IPv4 address. - **AWS_INIT_HEALTH_STATUS** - If the service configuration includes ``HealthCheckCustomConfig`` , when creating resources with a type of `AWS::ServiceDiscovery::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-instance.html>`_ you can optionally use ``AWS_INIT_HEALTH_STATUS`` to specify the initial status of the custom health check, ``HEALTHY`` or ``UNHEALTHY`` . If you don't specify a value for ``AWS_INIT_HEALTH_STATUS`` , the initial status is ``HEALTHY`` . This attribute can only be used when creating resources and will not be seen on existing resources. - **AWS_INSTANCE_CNAME** - If the service configuration includes a ``CNAME`` record, the domain name that you want Route 53 to return in response to DNS queries, for example, ``example.com`` . This value is required if the service specified by ``ServiceId`` includes settings for an ``CNAME`` record. - **AWS_INSTANCE_IPV4** - If the service configuration includes an ``A`` record, the IPv4 address that you want Route 53 to return in response to DNS queries, for example, ``192.0.2.44`` . This value is required if the service specified by ``ServiceId`` includes settings for an ``A`` record. If the service includes settings for an ``SRV`` record, you must specify a value for ``AWS_INSTANCE_IPV4`` , ``AWS_INSTANCE_IPV6`` , or both. - **AWS_INSTANCE_IPV6** - If the service configuration includes an ``AAAA`` record, the IPv6 address that you want Route 53 to return in response to DNS queries, for example, ``2001:0db8:85a3:0000:0000:abcd:0001:2345`` . This value is required if the service specified by ``ServiceId`` includes settings for an ``AAAA`` record. If the service includes settings for an ``SRV`` record, you must specify a value for ``AWS_INSTANCE_IPV4`` , ``AWS_INSTANCE_IPV6`` , or both. - **AWS_INSTANCE_PORT** - If the service includes an ``SRV`` record, the value that you want Route 53 to return for the port. If the service includes ``HealthCheckConfig`` , the port on the endpoint that you want Route 53 to send requests to. This value is required if you specified settings for an ``SRV`` record or a Route 53 health check when you created the service.\n")
    service_id: str = pydantic.Field(..., description='The ID of the service that you want to use for settings for the instance.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description="An identifier that you want to associate with the instance. Note the following:. - If the service that's specified by ``ServiceId`` includes settings for an ``SRV`` record, the value of ``InstanceId`` is automatically included as part of the value for the ``SRV`` record. For more information, see `DnsRecord > Type <https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type>`_ . - You can use this value to update an existing instance. - To register a new instance, you must specify a value that's unique among instances that you register by using the same service. - If you specify an existing ``InstanceId`` and ``ServiceId`` , AWS Cloud Map updates the existing DNS records, if any. If there's also an existing health check, AWS Cloud Map deletes the old health check and creates a new one. .. epigraph:: The health check isn't deleted immediately, so it will still appear for a while if you submit a ``ListHealthChecks`` request, for example. .. epigraph:: Do not include sensitive information in ``InstanceId`` if the namespace is discoverable by public DNS queries and any ``Type`` member of ``DnsRecord`` for the service contains ``SRV`` because the ``InstanceId`` is discoverable by public DNS queries.")
    _init_params: typing.ClassVar[list[str]] = ['instance_attributes', 'service_id', 'instance_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnInstanceDefConfig] = pydantic.Field(None)


class CfnInstanceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnInstanceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnInstanceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnInstanceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnInstanceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnInstanceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnInstanceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnInstanceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnInstanceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnInstanceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnInstanceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnInstanceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnInstanceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnInstanceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnInstanceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInstanceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInstanceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInstanceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInstanceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInstanceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInstanceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnInstanceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInstanceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespace
class CfnPrivateDnsNamespaceDef(BaseCfnResource):
    name: str = pydantic.Field(..., description='The name that you want to assign to this namespace. When you create a private DNS namespace, AWS Cloud Map automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.\n')
    vpc: str = pydantic.Field(..., description='The ID of the Amazon VPC that you want to associate the namespace with.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the namespace.\n')
    properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPrivateDnsNamespace_PropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Properties for the private DNS namespace.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the namespace. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'vpc', 'description', 'properties', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['PrivateDnsPropertiesMutableProperty', 'PropertiesProperty', 'SOAProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespace'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPrivateDnsNamespaceDefConfig] = pydantic.Field(None)


class CfnPrivateDnsNamespaceDefConfig(pydantic.BaseModel):
    PrivateDnsPropertiesMutableProperty: typing.Optional[list[CfnPrivateDnsNamespaceDefPrivatednspropertiesmutablepropertyParams]] = pydantic.Field(None, description='')
    PropertiesProperty: typing.Optional[list[CfnPrivateDnsNamespaceDefPropertiespropertyParams]] = pydantic.Field(None, description='')
    SOAProperty: typing.Optional[list[CfnPrivateDnsNamespaceDefSoapropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnPrivateDnsNamespaceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPrivateDnsNamespaceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPrivateDnsNamespaceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPrivateDnsNamespaceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPrivateDnsNamespaceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPrivateDnsNamespaceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPrivateDnsNamespaceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPrivateDnsNamespaceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPrivateDnsNamespaceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPrivateDnsNamespaceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPrivateDnsNamespaceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPrivateDnsNamespaceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPrivateDnsNamespaceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPrivateDnsNamespaceDefPrivatednspropertiesmutablepropertyParams(pydantic.BaseModel):
    soa: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPrivateDnsNamespace_SOAPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPrivateDnsNamespaceDefPropertiespropertyParams(pydantic.BaseModel):
    dns_properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPrivateDnsNamespace_PrivateDnsPropertiesMutablePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPrivateDnsNamespaceDefSoapropertyParams(pydantic.BaseModel):
    ttl: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnPrivateDnsNamespaceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPrivateDnsNamespaceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPrivateDnsNamespaceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPrivateDnsNamespaceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPrivateDnsNamespaceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPrivateDnsNamespaceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPrivateDnsNamespaceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPrivateDnsNamespaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPrivateDnsNamespaceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPrivateDnsNamespaceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPrivateDnsNamespaceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnPrivateDnsNamespaceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPrivateDnsNamespaceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPrivateDnsNamespaceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.CfnPublicDnsNamespace
class CfnPublicDnsNamespaceDef(BaseCfnResource):
    name: str = pydantic.Field(..., description='The name that you want to assign to this namespace. .. epigraph:: Do not include sensitive information in the name. The name is publicly available using DNS queries.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the namespace.\n')
    properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPublicDnsNamespace_PropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Properties for the public DNS namespace.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the namespace. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'properties', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['PropertiesProperty', 'PublicDnsPropertiesMutableProperty', 'SOAProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPublicDnsNamespace'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPublicDnsNamespaceDefConfig] = pydantic.Field(None)


class CfnPublicDnsNamespaceDefConfig(pydantic.BaseModel):
    PropertiesProperty: typing.Optional[list[CfnPublicDnsNamespaceDefPropertiespropertyParams]] = pydantic.Field(None, description='')
    PublicDnsPropertiesMutableProperty: typing.Optional[list[CfnPublicDnsNamespaceDefPublicdnspropertiesmutablepropertyParams]] = pydantic.Field(None, description='')
    SOAProperty: typing.Optional[list[CfnPublicDnsNamespaceDefSoapropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnPublicDnsNamespaceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPublicDnsNamespaceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPublicDnsNamespaceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPublicDnsNamespaceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPublicDnsNamespaceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPublicDnsNamespaceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPublicDnsNamespaceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPublicDnsNamespaceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPublicDnsNamespaceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPublicDnsNamespaceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPublicDnsNamespaceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPublicDnsNamespaceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPublicDnsNamespaceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPublicDnsNamespaceDefPropertiespropertyParams(pydantic.BaseModel):
    dns_properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPublicDnsNamespace_PublicDnsPropertiesMutablePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPublicDnsNamespaceDefPublicdnspropertiesmutablepropertyParams(pydantic.BaseModel):
    soa: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPublicDnsNamespace_SOAPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPublicDnsNamespaceDefSoapropertyParams(pydantic.BaseModel):
    ttl: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnPublicDnsNamespaceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPublicDnsNamespaceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPublicDnsNamespaceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPublicDnsNamespaceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPublicDnsNamespaceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPublicDnsNamespaceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPublicDnsNamespaceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPublicDnsNamespaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPublicDnsNamespaceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPublicDnsNamespaceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPublicDnsNamespaceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnPublicDnsNamespaceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPublicDnsNamespaceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPublicDnsNamespaceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.CfnService
class CfnServiceDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the service.\n')
    dns_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnService_DnsConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A complex type that contains information about the Route 53 DNS records that you want AWS Cloud Map to create when you register an instance. .. epigraph:: The record types of a service can only be changed by deleting the service and recreating it with a new ``Dnsconfig`` .\n')
    health_check_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnService_HealthCheckConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='*Public DNS and HTTP namespaces only.* A complex type that contains settings for an optional health check. If you specify settings for a health check, AWS Cloud Map associates the health check with the records that you specify in ``DnsConfig`` . For information about the charges for health checks, see `Amazon Route 53 Pricing <https://docs.aws.amazon.com/route53/pricing/>`_ .\n')
    health_check_custom_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnService_HealthCheckCustomConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A complex type that contains information about an optional custom health check. .. epigraph:: If you specify a health check configuration, you can specify either ``HealthCheckCustomConfig`` or ``HealthCheckConfig`` but not both.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the service.\n')
    namespace_id: typing.Optional[str] = pydantic.Field(None, description="The ID of the namespace that was used to create the service. .. epigraph:: You must specify a value for ``NamespaceId`` either for the service properties or for `DnsConfig <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-service-dnsconfig.html>`_ . Don't specify a value in both places.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the service. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='If present, specifies that the service instances are only discoverable using the ``DiscoverInstances`` API operation. No DNS records is registered for the service instances. The only valid value is ``HTTP`` .')
    _init_params: typing.ClassVar[list[str]] = ['description', 'dns_config', 'health_check_config', 'health_check_custom_config', 'name', 'namespace_id', 'tags', 'type']
    _method_names: typing.ClassVar[list[str]] = ['DnsConfigProperty', 'DnsRecordProperty', 'HealthCheckConfigProperty', 'HealthCheckCustomConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnServiceDefConfig] = pydantic.Field(None)


class CfnServiceDefConfig(pydantic.BaseModel):
    DnsConfigProperty: typing.Optional[list[CfnServiceDefDnsconfigpropertyParams]] = pydantic.Field(None, description='')
    DnsRecordProperty: typing.Optional[list[CfnServiceDefDnsrecordpropertyParams]] = pydantic.Field(None, description='')
    HealthCheckConfigProperty: typing.Optional[list[CfnServiceDefHealthcheckconfigpropertyParams]] = pydantic.Field(None, description='')
    HealthCheckCustomConfigProperty: typing.Optional[list[CfnServiceDefHealthcheckcustomconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnServiceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnServiceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnServiceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnServiceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnServiceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnServiceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnServiceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnServiceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnServiceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnServiceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnServiceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnServiceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnServiceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnServiceDefDnsconfigpropertyParams(pydantic.BaseModel):
    dns_records: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnService_DnsRecordPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    namespace_id: typing.Optional[str] = pydantic.Field(None, description='')
    routing_policy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefDnsrecordpropertyParams(pydantic.BaseModel):
    ttl: typing.Union[int, float] = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnServiceDefHealthcheckconfigpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    failure_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='')
    resource_path: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefHealthcheckcustomconfigpropertyParams(pydantic.BaseModel):
    failure_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnServiceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnServiceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnServiceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnServiceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnServiceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnServiceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnServiceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnServiceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnServiceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnServiceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_servicediscovery.CfnHttpNamespaceProps
class CfnHttpNamespacePropsDef(BaseCfnProperty):
    name: str = pydantic.Field(..., description='The name that you want to assign to this namespace.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the namespace.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the namespace. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-httpnamespace.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    cfn_http_namespace_props = servicediscovery.CfnHttpNamespaceProps(\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnHttpNamespaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnInstanceProps
class CfnInstancePropsDef(BaseCfnProperty):
    instance_attributes: typing.Any = pydantic.Field(..., description="A string map that contains the following information for the service that you specify in ``ServiceId`` :. - The attributes that apply to the records that are defined in the service. - For each attribute, the applicable value. Supported attribute keys include the following: - **AWS_ALIAS_DNS_NAME** - If you want AWS Cloud Map to create a Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify the DNS name that is associated with the load balancer. For information about how to get the DNS name, see `AliasTarget->DNSName <https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-DNSName>`_ in the *Route 53 API Reference* . Note the following: - The configuration for the service that is specified by ``ServiceId`` must include settings for an ``A`` record, an ``AAAA`` record, or both. - In the service that is specified by ``ServiceId`` , the value of ``RoutingPolicy`` must be ``WEIGHTED`` . - If the service that is specified by ``ServiceId`` includes ``HealthCheckConfig`` settings, AWS Cloud Map will create the health check, but it won't associate the health check with the alias record. - Auto naming currently doesn't support creating alias records that route traffic to AWS resources other than ELB load balancers. - If you specify a value for ``AWS_ALIAS_DNS_NAME`` , don't specify values for any of the ``AWS_INSTANCE`` attributes. - **AWS_EC2_INSTANCE_ID** - *HTTP namespaces only.* The Amazon EC2 instance ID for the instance. The ``AWS_INSTANCE_IPV4`` attribute contains the primary private IPv4 address. When creating resources with a type of `AWS::ServiceDiscovery::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-instance.html>`_ , if the ``AWS_EC2_INSTANCE_ID`` attribute is specified, the only other attribute that can be specified is ``AWS_INIT_HEALTH_STATUS`` . After the resource has been created, the ``AWS_INSTANCE_IPV4`` attribute contains the primary private IPv4 address. - **AWS_INIT_HEALTH_STATUS** - If the service configuration includes ``HealthCheckCustomConfig`` , when creating resources with a type of `AWS::ServiceDiscovery::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-instance.html>`_ you can optionally use ``AWS_INIT_HEALTH_STATUS`` to specify the initial status of the custom health check, ``HEALTHY`` or ``UNHEALTHY`` . If you don't specify a value for ``AWS_INIT_HEALTH_STATUS`` , the initial status is ``HEALTHY`` . This attribute can only be used when creating resources and will not be seen on existing resources. - **AWS_INSTANCE_CNAME** - If the service configuration includes a ``CNAME`` record, the domain name that you want Route 53 to return in response to DNS queries, for example, ``example.com`` . This value is required if the service specified by ``ServiceId`` includes settings for an ``CNAME`` record. - **AWS_INSTANCE_IPV4** - If the service configuration includes an ``A`` record, the IPv4 address that you want Route 53 to return in response to DNS queries, for example, ``192.0.2.44`` . This value is required if the service specified by ``ServiceId`` includes settings for an ``A`` record. If the service includes settings for an ``SRV`` record, you must specify a value for ``AWS_INSTANCE_IPV4`` , ``AWS_INSTANCE_IPV6`` , or both. - **AWS_INSTANCE_IPV6** - If the service configuration includes an ``AAAA`` record, the IPv6 address that you want Route 53 to return in response to DNS queries, for example, ``2001:0db8:85a3:0000:0000:abcd:0001:2345`` . This value is required if the service specified by ``ServiceId`` includes settings for an ``AAAA`` record. If the service includes settings for an ``SRV`` record, you must specify a value for ``AWS_INSTANCE_IPV4`` , ``AWS_INSTANCE_IPV6`` , or both. - **AWS_INSTANCE_PORT** - If the service includes an ``SRV`` record, the value that you want Route 53 to return for the port. If the service includes ``HealthCheckConfig`` , the port on the endpoint that you want Route 53 to send requests to. This value is required if you specified settings for an ``SRV`` record or a Route 53 health check when you created the service.\n")
    service_id: str = pydantic.Field(..., description='The ID of the service that you want to use for settings for the instance.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='An identifier that you want to associate with the instance. Note the following:. - If the service that\'s specified by ``ServiceId`` includes settings for an ``SRV`` record, the value of ``InstanceId`` is automatically included as part of the value for the ``SRV`` record. For more information, see `DnsRecord > Type <https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type>`_ . - You can use this value to update an existing instance. - To register a new instance, you must specify a value that\'s unique among instances that you register by using the same service. - If you specify an existing ``InstanceId`` and ``ServiceId`` , AWS Cloud Map updates the existing DNS records, if any. If there\'s also an existing health check, AWS Cloud Map deletes the old health check and creates a new one. .. epigraph:: The health check isn\'t deleted immediately, so it will still appear for a while if you submit a ``ListHealthChecks`` request, for example. .. epigraph:: Do not include sensitive information in ``InstanceId`` if the namespace is discoverable by public DNS queries and any ``Type`` member of ``DnsRecord`` for the service contains ``SRV`` because the ``InstanceId`` is discoverable by public DNS queries.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-instance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # instance_attributes: Any\n\n    cfn_instance_props = servicediscovery.CfnInstanceProps(\n        instance_attributes=instance_attributes,\n        service_id="serviceId",\n\n        # the properties below are optional\n        instance_id="instanceId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_attributes', 'service_id', 'instance_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespaceProps
class CfnPrivateDnsNamespacePropsDef(BaseCfnProperty):
    name: str = pydantic.Field(..., description='The name that you want to assign to this namespace. When you create a private DNS namespace, AWS Cloud Map automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.\n')
    vpc: str = pydantic.Field(..., description='The ID of the Amazon VPC that you want to associate the namespace with.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the namespace.\n')
    properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPrivateDnsNamespace_PropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Properties for the private DNS namespace.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the namespace. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-privatednsnamespace.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    cfn_private_dns_namespace_props = servicediscovery.CfnPrivateDnsNamespaceProps(\n        name="name",\n        vpc="vpc",\n\n        # the properties below are optional\n        description="description",\n        properties=servicediscovery.CfnPrivateDnsNamespace.PropertiesProperty(\n            dns_properties=servicediscovery.CfnPrivateDnsNamespace.PrivateDnsPropertiesMutableProperty(\n                soa=servicediscovery.CfnPrivateDnsNamespace.SOAProperty(\n                    ttl=123\n                )\n            )\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'vpc', 'description', 'properties', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPrivateDnsNamespaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnPublicDnsNamespaceProps
class CfnPublicDnsNamespacePropsDef(BaseCfnProperty):
    name: str = pydantic.Field(..., description='The name that you want to assign to this namespace. .. epigraph:: Do not include sensitive information in the name. The name is publicly available using DNS queries.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the namespace.\n')
    properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnPublicDnsNamespace_PropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Properties for the public DNS namespace.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the namespace. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-publicdnsnamespace.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    cfn_public_dns_namespace_props = servicediscovery.CfnPublicDnsNamespaceProps(\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        properties=servicediscovery.CfnPublicDnsNamespace.PropertiesProperty(\n            dns_properties=servicediscovery.CfnPublicDnsNamespace.PublicDnsPropertiesMutableProperty(\n                soa=servicediscovery.CfnPublicDnsNamespace.SOAProperty(\n                    ttl=123\n                )\n            )\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'properties', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnPublicDnsNamespaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_servicediscovery.CfnServiceProps
class CfnServicePropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the service.\n')
    dns_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnService_DnsConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A complex type that contains information about the Route 53 DNS records that you want AWS Cloud Map to create when you register an instance. .. epigraph:: The record types of a service can only be changed by deleting the service and recreating it with a new ``Dnsconfig`` .\n')
    health_check_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnService_HealthCheckConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='*Public DNS and HTTP namespaces only.* A complex type that contains settings for an optional health check. If you specify settings for a health check, AWS Cloud Map associates the health check with the records that you specify in ``DnsConfig`` . For information about the charges for health checks, see `Amazon Route 53 Pricing <https://docs.aws.amazon.com/route53/pricing/>`_ .\n')
    health_check_custom_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_servicediscovery.CfnService_HealthCheckCustomConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A complex type that contains information about an optional custom health check. .. epigraph:: If you specify a health check configuration, you can specify either ``HealthCheckCustomConfig`` or ``HealthCheckConfig`` but not both.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the service.\n')
    namespace_id: typing.Optional[str] = pydantic.Field(None, description="The ID of the namespace that was used to create the service. .. epigraph:: You must specify a value for ``NamespaceId`` either for the service properties or for `DnsConfig <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-servicediscovery-service-dnsconfig.html>`_ . Don't specify a value in both places.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the service. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='If present, specifies that the service instances are only discoverable using the ``DiscoverInstances`` API operation. No DNS records is registered for the service instances. The only valid value is ``HTTP`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-service.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    cfn_service_props = servicediscovery.CfnServiceProps(\n        description="description",\n        dns_config=servicediscovery.CfnService.DnsConfigProperty(\n            dns_records=[servicediscovery.CfnService.DnsRecordProperty(\n                ttl=123,\n                type="type"\n            )],\n\n            # the properties below are optional\n            namespace_id="namespaceId",\n            routing_policy="routingPolicy"\n        ),\n        health_check_config=servicediscovery.CfnService.HealthCheckConfigProperty(\n            type="type",\n\n            # the properties below are optional\n            failure_threshold=123,\n            resource_path="resourcePath"\n        ),\n        health_check_custom_config=servicediscovery.CfnService.HealthCheckCustomConfigProperty(\n            failure_threshold=123\n        ),\n        name="name",\n        namespace_id="namespaceId",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'dns_config', 'health_check_config', 'health_check_custom_config', 'name', 'namespace_id', 'tags', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_servicediscovery.CfnServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    InstanceBase: typing.Optional[dict[str, InstanceBaseDef]] = pydantic.Field(None)
    AliasTargetInstance: typing.Optional[dict[str, AliasTargetInstanceDef]] = pydantic.Field(None)
    CnameInstance: typing.Optional[dict[str, CnameInstanceDef]] = pydantic.Field(None)
    HttpNamespace: typing.Optional[dict[str, HttpNamespaceDef]] = pydantic.Field(None)
    IpInstance: typing.Optional[dict[str, IpInstanceDef]] = pydantic.Field(None)
    NonIpInstance: typing.Optional[dict[str, NonIpInstanceDef]] = pydantic.Field(None)
    PrivateDnsNamespace: typing.Optional[dict[str, PrivateDnsNamespaceDef]] = pydantic.Field(None)
    PublicDnsNamespace: typing.Optional[dict[str, PublicDnsNamespaceDef]] = pydantic.Field(None)
    Service: typing.Optional[dict[str, ServiceDef]] = pydantic.Field(None)
    AliasTargetInstanceProps: typing.Optional[dict[str, AliasTargetInstancePropsDef]] = pydantic.Field(None)
    BaseInstanceProps: typing.Optional[dict[str, BaseInstancePropsDef]] = pydantic.Field(None)
    BaseNamespaceProps: typing.Optional[dict[str, BaseNamespacePropsDef]] = pydantic.Field(None)
    BaseServiceProps: typing.Optional[dict[str, BaseServicePropsDef]] = pydantic.Field(None)
    CfnPrivateDnsNamespace_PrivateDnsPropertiesMutableProperty: typing.Optional[dict[str, CfnPrivateDnsNamespace_PrivateDnsPropertiesMutablePropertyDef]] = pydantic.Field(None)
    CfnPrivateDnsNamespace_PropertiesProperty: typing.Optional[dict[str, CfnPrivateDnsNamespace_PropertiesPropertyDef]] = pydantic.Field(None)
    CfnPrivateDnsNamespace_SOAProperty: typing.Optional[dict[str, CfnPrivateDnsNamespace_SOAPropertyDef]] = pydantic.Field(None)
    CfnPublicDnsNamespace_PropertiesProperty: typing.Optional[dict[str, CfnPublicDnsNamespace_PropertiesPropertyDef]] = pydantic.Field(None)
    CfnPublicDnsNamespace_PublicDnsPropertiesMutableProperty: typing.Optional[dict[str, CfnPublicDnsNamespace_PublicDnsPropertiesMutablePropertyDef]] = pydantic.Field(None)
    CfnPublicDnsNamespace_SOAProperty: typing.Optional[dict[str, CfnPublicDnsNamespace_SOAPropertyDef]] = pydantic.Field(None)
    CfnService_DnsConfigProperty: typing.Optional[dict[str, CfnService_DnsConfigPropertyDef]] = pydantic.Field(None)
    CfnService_DnsRecordProperty: typing.Optional[dict[str, CfnService_DnsRecordPropertyDef]] = pydantic.Field(None)
    CfnService_HealthCheckConfigProperty: typing.Optional[dict[str, CfnService_HealthCheckConfigPropertyDef]] = pydantic.Field(None)
    CfnService_HealthCheckCustomConfigProperty: typing.Optional[dict[str, CfnService_HealthCheckCustomConfigPropertyDef]] = pydantic.Field(None)
    CnameInstanceBaseProps: typing.Optional[dict[str, CnameInstanceBasePropsDef]] = pydantic.Field(None)
    CnameInstanceProps: typing.Optional[dict[str, CnameInstancePropsDef]] = pydantic.Field(None)
    DnsServiceProps: typing.Optional[dict[str, DnsServicePropsDef]] = pydantic.Field(None)
    HealthCheckConfig: typing.Optional[dict[str, HealthCheckConfigDef]] = pydantic.Field(None)
    HealthCheckCustomConfig: typing.Optional[dict[str, HealthCheckCustomConfigDef]] = pydantic.Field(None)
    HttpNamespaceAttributes: typing.Optional[dict[str, HttpNamespaceAttributesDef]] = pydantic.Field(None)
    HttpNamespaceProps: typing.Optional[dict[str, HttpNamespacePropsDef]] = pydantic.Field(None)
    IpInstanceBaseProps: typing.Optional[dict[str, IpInstanceBasePropsDef]] = pydantic.Field(None)
    IpInstanceProps: typing.Optional[dict[str, IpInstancePropsDef]] = pydantic.Field(None)
    NonIpInstanceBaseProps: typing.Optional[dict[str, NonIpInstanceBasePropsDef]] = pydantic.Field(None)
    NonIpInstanceProps: typing.Optional[dict[str, NonIpInstancePropsDef]] = pydantic.Field(None)
    PrivateDnsNamespaceAttributes: typing.Optional[dict[str, PrivateDnsNamespaceAttributesDef]] = pydantic.Field(None)
    PrivateDnsNamespaceProps: typing.Optional[dict[str, PrivateDnsNamespacePropsDef]] = pydantic.Field(None)
    PublicDnsNamespaceAttributes: typing.Optional[dict[str, PublicDnsNamespaceAttributesDef]] = pydantic.Field(None)
    PublicDnsNamespaceProps: typing.Optional[dict[str, PublicDnsNamespacePropsDef]] = pydantic.Field(None)
    ServiceAttributes: typing.Optional[dict[str, ServiceAttributesDef]] = pydantic.Field(None)
    ServiceProps: typing.Optional[dict[str, ServicePropsDef]] = pydantic.Field(None)
    CfnHttpNamespace: typing.Optional[dict[str, CfnHttpNamespaceDef]] = pydantic.Field(None)
    CfnInstance: typing.Optional[dict[str, CfnInstanceDef]] = pydantic.Field(None)
    CfnPrivateDnsNamespace: typing.Optional[dict[str, CfnPrivateDnsNamespaceDef]] = pydantic.Field(None)
    CfnPublicDnsNamespace: typing.Optional[dict[str, CfnPublicDnsNamespaceDef]] = pydantic.Field(None)
    CfnService: typing.Optional[dict[str, CfnServiceDef]] = pydantic.Field(None)
    CfnHttpNamespaceProps: typing.Optional[dict[str, CfnHttpNamespacePropsDef]] = pydantic.Field(None)
    CfnInstanceProps: typing.Optional[dict[str, CfnInstancePropsDef]] = pydantic.Field(None)
    CfnPrivateDnsNamespaceProps: typing.Optional[dict[str, CfnPrivateDnsNamespacePropsDef]] = pydantic.Field(None)
    CfnPublicDnsNamespaceProps: typing.Optional[dict[str, CfnPublicDnsNamespacePropsDef]] = pydantic.Field(None)
    CfnServiceProps: typing.Optional[dict[str, CfnServicePropsDef]] = pydantic.Field(None)
    ...
