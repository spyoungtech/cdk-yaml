from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_events.Authorization
class AuthorizationDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['api_key', 'basic', 'oauth']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.Authorization'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AuthorizationDefConfig] = pydantic.Field(None)


class AuthorizationDefConfig(pydantic.BaseModel):
    api_key: typing.Optional[list[AuthorizationDefApiKeyParams]] = pydantic.Field(None, description='Use API key authorization.\nAPI key authorization has two components: an API key name and an API key value.\nWhat these are depends on the target of your connection.')
    basic: typing.Optional[list[AuthorizationDefBasicParams]] = pydantic.Field(None, description='Use username and password authorization.')
    oauth: typing.Optional[list[AuthorizationDefOauthParams]] = pydantic.Field(None, description='Use OAuth authorization.')

class AuthorizationDefApiKeyParams(pydantic.BaseModel):
    api_key_name: str = pydantic.Field(..., description='-\n')
    api_key_value: models.SecretValueDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_events.AuthorizationDefConfig]] = pydantic.Field(None)
    ...

class AuthorizationDefBasicParams(pydantic.BaseModel):
    username: str = pydantic.Field(..., description='-\n')
    password: models.SecretValueDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_events.AuthorizationDefConfig]] = pydantic.Field(None)
    ...

class AuthorizationDefOauthParams(pydantic.BaseModel):
    authorization_endpoint: str = pydantic.Field(..., description='The URL to the authorization endpoint.\n')
    client_id: str = pydantic.Field(..., description='The client ID to use for OAuth authorization for the connection.\n')
    client_secret: models.SecretValueDef = pydantic.Field(..., description='The client secret associated with the client ID to use for OAuth authorization for the connection.\n')
    http_method: aws_cdk.aws_events.HttpMethod = pydantic.Field(..., description='The method to use for the authorization request. (Can only choose POST, GET or PUT).\n')
    body_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the OAuth request body. Default: - No additional parameters\n')
    header_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the OAuth request header. Default: - No additional parameters\n')
    query_string_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the OAuth request query string. Default: - No additional parameters')
    return_config: typing.Optional[list[models.aws_events.AuthorizationDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_events.EventField
class EventFieldDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['resolve']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_path']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.EventField'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_path']
    ...


    from_path: typing.Optional[EventFieldDefFromPathParams] = pydantic.Field(None, description='Extract a custom JSON path from the event.')
    resource_config: typing.Optional[EventFieldDefConfig] = pydantic.Field(None)


class EventFieldDefConfig(pydantic.BaseModel):
    resolve: typing.Optional[list[EventFieldDefResolveParams]] = pydantic.Field(None, description="Produce the Token's value at resolution time.")

class EventFieldDefFromPathParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='-')
    ...

class EventFieldDefResolveParams(pydantic.BaseModel):
    _ctx: models.UnsupportedResource = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_events.HttpParameter
class HttpParameterDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_secret', 'from_string']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.HttpParameter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_secret', 'from_string']
    ...


    from_secret: typing.Optional[HttpParameterDefFromSecretParams] = pydantic.Field(None, description='Make an OAuthParameter from a secret.')
    from_string: typing.Optional[HttpParameterDefFromStringParams] = pydantic.Field(None, description='Make an OAuthParameter from a string value.\nThe value is not treated as a secret.')

class HttpParameterDefFromSecretParams(pydantic.BaseModel):
    value: models.SecretValueDef = pydantic.Field(..., description='-')
    ...

class HttpParameterDefFromStringParams(pydantic.BaseModel):
    value: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_events.Match
class MatchDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['resolve']
    _classmethod_names: typing.ClassVar[list[str]] = ['all_of', 'any_of', 'anything_but', 'anything_but_prefix', 'cidr', 'does_not_exist', 'equal', 'equals_ignore_case', 'exact_string', 'exists', 'greater_than', 'greater_than_or_equal', 'interval', 'ip_address_range', 'less_than', 'less_than_or_equal', 'null_value', 'prefix', 'suffix']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.Match'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MatchDefConfig] = pydantic.Field(None)


class MatchDefConfig(pydantic.BaseModel):
    all_of: typing.Optional[list[MatchDefAllOfParams]] = pydantic.Field(None, description='Matches an event if any of the provided matchers do.\nOnly numeric matchers are accepted.')
    any_of: typing.Optional[list[MatchDefAnyOfParams]] = pydantic.Field(None, description='Matches an event if any of the provided matchers does.')
    anything_but: typing.Optional[list[MatchDefAnythingButParams]] = pydantic.Field(None, description="Matches anything except what's provided in the rule.\nThe list of provided values must contain\nonly strings or only numbers.")
    anything_but_prefix: typing.Optional[list[MatchDefAnythingButPrefixParams]] = pydantic.Field(None, description="Matches any string that doesn't start with the given prefix.")
    cidr: typing.Optional[list[MatchDefCidrParams]] = pydantic.Field(None, description='Matches IPv4 and IPv6 network addresses using the Classless Inter-Domain Routing (CIDR) format.')
    does_not_exist: typing.Optional[bool] = pydantic.Field(None, description='Matches when the field is absent from the JSON of the event.')
    equal: typing.Optional[list[MatchDefEqualParams]] = pydantic.Field(None, description='Matches numbers equal to the provided value.')
    equals_ignore_case: typing.Optional[list[MatchDefEqualsIgnoreCaseParams]] = pydantic.Field(None, description='Matches a string, regardless of case, in the JSON of the event.')
    exact_string: typing.Optional[list[MatchDefExactStringParams]] = pydantic.Field(None, description='Matches a string, exactly, in the JSON of the event.')
    exists: typing.Optional[bool] = pydantic.Field(None, description='Matches when the field is present in the JSON of the event.')
    greater_than: typing.Optional[list[MatchDefGreaterThanParams]] = pydantic.Field(None, description='Matches numbers greater than the provided value.')
    greater_than_or_equal: typing.Optional[list[MatchDefGreaterThanOrEqualParams]] = pydantic.Field(None, description='Matches numbers greater than, or equal to, the provided value.')
    interval: typing.Optional[list[MatchDefIntervalParams]] = pydantic.Field(None, description='Matches numbers inside a closed numeric interval. Equivalent to:.\nMatch.allOf(Match.greaterThanOrEqual(lower), Match.lessThanOrEqual(upper))')
    ip_address_range: typing.Optional[list[MatchDefIpAddressRangeParams]] = pydantic.Field(None, description='Matches IPv4 and IPv6 network addresses using the Classless Inter-Domain Routing (CIDR) format.\nAlias of ``cidr()``.')
    less_than: typing.Optional[list[MatchDefLessThanParams]] = pydantic.Field(None, description='Matches numbers less than the provided value.')
    less_than_or_equal: typing.Optional[list[MatchDefLessThanOrEqualParams]] = pydantic.Field(None, description='Matches numbers less than, or equal to, the provided value.')
    null_value: typing.Optional[bool] = pydantic.Field(None, description='Matches a null value in the JSON of the event.')
    prefix: typing.Optional[list[MatchDefPrefixParams]] = pydantic.Field(None, description='Matches strings with the given prefix in the JSON of the event.')
    resolve: typing.Optional[list[MatchDefResolveParams]] = pydantic.Field(None, description="Produce the Token's value at resolution time.")
    suffix: typing.Optional[list[MatchDefSuffixParams]] = pydantic.Field(None, description='Matches strings with the given suffix in the JSON of the event.')

class MatchDefAllOfParams(pydantic.BaseModel):
    matchers: list[typing.Any] = pydantic.Field(...)
    ...

class MatchDefAnyOfParams(pydantic.BaseModel):
    matchers: list[typing.Any] = pydantic.Field(...)
    ...

class MatchDefAnythingButParams(pydantic.BaseModel):
    values: list[typing.Any] = pydantic.Field(...)
    ...

class MatchDefAnythingButPrefixParams(pydantic.BaseModel):
    prefix: str = pydantic.Field(..., description='-')
    ...

class MatchDefCidrParams(pydantic.BaseModel):
    range: str = pydantic.Field(..., description='-')
    ...

class MatchDefEqualParams(pydantic.BaseModel):
    value: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...

class MatchDefEqualsIgnoreCaseParams(pydantic.BaseModel):
    value: str = pydantic.Field(..., description='-')
    ...

class MatchDefExactStringParams(pydantic.BaseModel):
    value: str = pydantic.Field(..., description='-')
    ...

class MatchDefGreaterThanParams(pydantic.BaseModel):
    value: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...

class MatchDefGreaterThanOrEqualParams(pydantic.BaseModel):
    value: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...

class MatchDefIntervalParams(pydantic.BaseModel):
    lower: typing.Union[int, float] = pydantic.Field(..., description='Lower bound (inclusive).\n')
    upper: typing.Union[int, float] = pydantic.Field(..., description='Upper bound (inclusive).')
    ...

class MatchDefIpAddressRangeParams(pydantic.BaseModel):
    range: str = pydantic.Field(..., description='-')
    ...

class MatchDefLessThanParams(pydantic.BaseModel):
    value: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...

class MatchDefLessThanOrEqualParams(pydantic.BaseModel):
    value: typing.Union[int, float] = pydantic.Field(..., description='-')
    ...

class MatchDefPrefixParams(pydantic.BaseModel):
    value: str = pydantic.Field(..., description='-')
    ...

class MatchDefResolveParams(pydantic.BaseModel):
    context: models.UnsupportedResource = pydantic.Field(..., description='-')
    ...

class MatchDefSuffixParams(pydantic.BaseModel):
    value: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_events.RuleTargetInput
class RuleTargetInputDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_event_path', 'from_multiline_text', 'from_object', 'from_text']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.RuleTargetInput'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_event_path', 'from_multiline_text', 'from_object', 'from_text']
    ...


    from_event_path: typing.Optional[RuleTargetInputDefFromEventPathParams] = pydantic.Field(None, description='Take the event target input from a path in the event JSON.')
    from_multiline_text: typing.Optional[RuleTargetInputDefFromMultilineTextParams] = pydantic.Field(None, description='Pass text to the event target, splitting on newlines.\nThis is only useful when passing to a target that does not\ntake a single argument.\n\nMay contain strings returned by ``EventField.from()`` to substitute in parts\nof the matched event.')
    from_object: typing.Optional[RuleTargetInputDefFromObjectParams] = pydantic.Field(None, description='Pass a JSON object to the event target.\nMay contain strings returned by ``EventField.from()`` to substitute in parts of the\nmatched event.')
    from_text: typing.Optional[RuleTargetInputDefFromTextParams] = pydantic.Field(None, description='Pass text to the event target.\nMay contain strings returned by ``EventField.from()`` to substitute in parts of the\nmatched event.\n\nThe Rule Target input value will be a single string: the string you pass\nhere.  Do not use this method to pass a complex value like a JSON object to\na Rule Target.  Use ``RuleTargetInput.fromObject()`` instead.')
    resource_config: typing.Optional[RuleTargetInputDefConfig] = pydantic.Field(None)


class RuleTargetInputDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[RuleTargetInputDefBindParams]] = pydantic.Field(None, description='Return the input properties for this input object.')

class RuleTargetInputDefBindParams(pydantic.BaseModel):
    rule: typing.Union[models.aws_events.RuleDef] = pydantic.Field(..., description='-')
    ...

class RuleTargetInputDefFromEventPathParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='-')
    ...

class RuleTargetInputDefFromMultilineTextParams(pydantic.BaseModel):
    text: str = pydantic.Field(..., description='-')
    ...

class RuleTargetInputDefFromObjectParams(pydantic.BaseModel):
    obj: typing.Any = pydantic.Field(..., description='-')
    ...

class RuleTargetInputDefFromTextParams(pydantic.BaseModel):
    text: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_events.Schedule
class ScheduleDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['cron', 'expression', 'rate']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.Schedule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ScheduleDefConfig] = pydantic.Field(None)


class ScheduleDefConfig(pydantic.BaseModel):
    cron: typing.Optional[list[ScheduleDefCronParams]] = pydantic.Field(None, description='Create a schedule from a set of cron fields.')
    expression: typing.Optional[list[ScheduleDefExpressionParams]] = pydantic.Field(None, description='Construct a schedule from a literal schedule expression.')
    rate: typing.Optional[list[ScheduleDefRateParams]] = pydantic.Field(None, description='Construct a schedule from an interval and a time unit.\nRates may be defined with any unit of time, but when converted into minutes, the duration must be a positive whole number of minutes.')

class ScheduleDefCronParams(pydantic.BaseModel):
    day: typing.Optional[str] = pydantic.Field(None, description='The day of the month to run this rule at. Default: - Every day of the month\n')
    hour: typing.Optional[str] = pydantic.Field(None, description='The hour to run this rule at. Default: - Every hour\n')
    minute: typing.Optional[str] = pydantic.Field(None, description='The minute to run this rule at. Default: - Every minute\n')
    month: typing.Optional[str] = pydantic.Field(None, description='The month to run this rule at. Default: - Every month\n')
    week_day: typing.Optional[str] = pydantic.Field(None, description='The day of the week to run this rule at. Default: - Any day of the week\n')
    year: typing.Optional[str] = pydantic.Field(None, description='The year to run this rule at. Default: - Every year')
    return_config: typing.Optional[list[models.aws_events.ScheduleDefConfig]] = pydantic.Field(None)
    ...

class ScheduleDefExpressionParams(pydantic.BaseModel):
    expression: str = pydantic.Field(..., description='The expression to use. Must be in a format that EventBridge will recognize')
    return_config: typing.Optional[list[models.aws_events.ScheduleDefConfig]] = pydantic.Field(None)
    ...

class ScheduleDefRateParams(pydantic.BaseModel):
    duration: models.DurationDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_events.ScheduleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_events.ApiDestination
class ApiDestinationDef(BaseConstruct):
    connection: typing.Union[models.aws_events.ConnectionDef] = pydantic.Field(..., description='The ARN of the connection to use for the API destination.\n')
    endpoint: str = pydantic.Field(..., description='The URL to the HTTP invocation endpoint for the API destination..\n')
    api_destination_name: typing.Optional[str] = pydantic.Field(None, description='The name for the API destination. Default: - A unique name will be generated\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the API destination. Default: - none\n')
    http_method: typing.Optional[aws_cdk.aws_events.HttpMethod] = pydantic.Field(None, description='The method to use for the request to the HTTP invocation endpoint. Default: HttpMethod.POST\n')
    rate_limit_per_second: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of requests per second to send to the HTTP invocation endpoint. Default: - Not rate limited')
    _init_params: typing.ClassVar[list[str]] = ['connection', 'endpoint', 'api_destination_name', 'description', 'http_method', 'rate_limit_per_second']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.ApiDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ApiDestinationDefConfig] = pydantic.Field(None)


class ApiDestinationDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    connection_config: typing.Optional[models._interface_methods.AwsEventsIConnectionDefConfig] = pydantic.Field(None)

class ApiDestinationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_events.Archive
class ArchiveDef(BaseConstruct):
    source_event_bus: typing.Union[models.aws_events.EventBusDef] = pydantic.Field(..., description='The event source associated with the archive.\n')
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any]] = pydantic.Field(..., description='An event pattern to use to filter events sent to the archive.\n')
    archive_name: typing.Optional[str] = pydantic.Field(None, description='The name of the archive. Default: - Automatically generated\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the archive. Default: - none\n')
    retention: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of days to retain events for. Default value is 0. If set to 0, events are retained indefinitely. Default: - Infinite')
    _init_params: typing.ClassVar[list[str]] = ['source_event_bus', 'event_pattern', 'archive_name', 'description', 'retention']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.Archive'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ArchiveDefConfig] = pydantic.Field(None)


class ArchiveDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ArchiveDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_events.Connection
class ConnectionDef(BaseConstruct):
    authorization: models.aws_events.AuthorizationDef = pydantic.Field(..., description='The authorization type for the connection.\n')
    body_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the invocation bodies. Default: - No additional parameters\n')
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection. Default: - A name is automatically generated\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The name of the connection. Default: - none\n')
    header_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the invocation headers. Default: - No additional parameters\n')
    query_string_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the invocation query strings. Default: - No additional parameters')
    _init_params: typing.ClassVar[list[str]] = ['authorization', 'body_parameters', 'connection_name', 'description', 'header_parameters', 'query_string_parameters']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_connection_attributes', 'from_event_bus_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.Connection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_connection_attributes', 'from_event_bus_arn']
    ...


    from_connection_attributes: typing.Optional[ConnectionDefFromConnectionAttributesParams] = pydantic.Field(None, description='Import an existing connection resource.')
    from_event_bus_arn: typing.Optional[ConnectionDefFromEventBusArnParams] = pydantic.Field(None, description='Import an existing connection resource.')
    resource_config: typing.Optional[ConnectionDefConfig] = pydantic.Field(None)


class ConnectionDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ConnectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ConnectionDefFromConnectionAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Parent construct.\n')
    id: str = pydantic.Field(..., description='Construct ID.\n')
    connection_arn: str = pydantic.Field(..., description='The ARN of the connection created.\n')
    connection_name: str = pydantic.Field(..., description='The Name for the connection.\n')
    connection_secret_arn: str = pydantic.Field(..., description='The ARN for the secret created for the connection.')
    ...

class ConnectionDefFromEventBusArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Parent construct.\n')
    id: str = pydantic.Field(..., description='Construct ID.\n')
    connection_arn: str = pydantic.Field(..., description='ARN of imported connection.\n')
    connection_secret_arn: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_events.EventBus
class EventBusDef(BaseConstruct):
    event_bus_name: typing.Optional[str] = pydantic.Field(None, description="The name of the event bus you are creating Note: If 'eventSourceName' is passed in, you cannot set this. Default: - automatically generated name\n")
    event_source_name: typing.Optional[str] = pydantic.Field(None, description="The partner event source to associate with this event bus resource Note: If 'eventBusName' is passed in, you cannot set this. Default: - no partner event source")
    _init_params: typing.ClassVar[list[str]] = ['event_bus_name', 'event_source_name']
    _method_names: typing.ClassVar[list[str]] = ['add_to_resource_policy', 'apply_removal_policy', 'archive', 'grant_put_events_to']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_event_bus_arn', 'from_event_bus_attributes', 'from_event_bus_name', 'grant_all_put_events']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.EventBus'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_event_bus_arn', 'from_event_bus_attributes', 'from_event_bus_name', 'grant_all_put_events']
    ...


    from_event_bus_arn: typing.Optional[EventBusDefFromEventBusArnParams] = pydantic.Field(None, description='Import an existing event bus resource.')
    from_event_bus_attributes: typing.Optional[EventBusDefFromEventBusAttributesParams] = pydantic.Field(None, description='Import an existing event bus resource.')
    from_event_bus_name: typing.Optional[EventBusDefFromEventBusNameParams] = pydantic.Field(None, description='Import an existing event bus resource.')
    grant_all_put_events: typing.Optional[EventBusDefGrantAllPutEventsParams] = pydantic.Field(None, description='Permits an IAM Principal to send custom events to EventBridge so that they can be matched to rules.')
    resource_config: typing.Optional[EventBusDefConfig] = pydantic.Field(None)


class EventBusDefConfig(pydantic.BaseModel):
    add_to_resource_policy: typing.Optional[list[EventBusDefAddToResourcePolicyParams]] = pydantic.Field(None, description='Adds a statement to the IAM resource policy associated with this event bus.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    archive: typing.Optional[list[EventBusDefArchiveParams]] = pydantic.Field(None, description='Create an EventBridge archive to send events to.\nWhen you create an archive, incoming events might not immediately start being sent to the archive.\nAllow a short period of time for changes to take effect.')
    grant_put_events_to: typing.Optional[list[EventBusDefGrantPutEventsToParams]] = pydantic.Field(None, description='Grants an IAM Principal to send custom events to the eventBus so that they can be matched to rules.')

class EventBusDefAddToResourcePolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class EventBusDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class EventBusDefArchiveParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any]] = pydantic.Field(..., description='An event pattern to use to filter events sent to the archive.\n')
    archive_name: typing.Optional[str] = pydantic.Field(None, description='The name of the archive. Default: - Automatically generated\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the archive. Default: - none\n')
    retention: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of days to retain events for. Default value is 0. If set to 0, events are retained indefinitely. Default: - Infinite')
    return_config: typing.Optional[list[models.aws_events.ArchiveDefConfig]] = pydantic.Field(None)
    ...

class EventBusDefFromEventBusArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Parent construct.\n')
    id: str = pydantic.Field(..., description='Construct ID.\n')
    event_bus_arn: str = pydantic.Field(..., description='ARN of imported event bus.')
    ...

class EventBusDefFromEventBusAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Parent construct.\n')
    id: str = pydantic.Field(..., description='Construct ID.\n')
    event_bus_arn: str = pydantic.Field(..., description='The ARN of this event bus resource.\n')
    event_bus_name: str = pydantic.Field(..., description='The physical ID of this event bus resource.\n')
    event_bus_policy: str = pydantic.Field(..., description='The JSON policy of this event bus resource.\n')
    event_source_name: typing.Optional[str] = pydantic.Field(None, description='The partner event source to associate with this event bus resource. Default: - no partner event source')
    ...

class EventBusDefFromEventBusNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Parent construct.\n')
    id: str = pydantic.Field(..., description='Construct ID.\n')
    event_bus_name: str = pydantic.Field(..., description='Name of imported event bus.')
    ...

class EventBusDefGrantAllPutEventsParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='The principal (no-op if undefined).')
    ...

class EventBusDefGrantPutEventsToParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_events.EventBusPolicy
class EventBusPolicyDef(BaseConstruct):
    event_bus: typing.Union[models.aws_events.EventBusDef] = pydantic.Field(..., description='The event bus to which the policy applies.\n')
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='An IAM Policy Statement to apply to the Event Bus.\n')
    statement_id: str = pydantic.Field(..., description='An identifier string for the external account that you are granting permissions to.')
    _init_params: typing.ClassVar[list[str]] = ['event_bus', 'statement', 'statement_id']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.EventBusPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[EventBusPolicyDefConfig] = pydantic.Field(None)


class EventBusPolicyDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class EventBusPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_events.Rule
class RuleDef(BaseConstruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    event_bus: typing.Optional[typing.Union[models.aws_events.EventBusDef]] = pydantic.Field(None, description='The event bus to associate with this rule. Default: - The default event bus.\n')
    schedule: typing.Optional[models.aws_events.ScheduleDef] = pydantic.Field(None, description='The schedule or rate (frequency) that determines when EventBridge runs the rule. You must specify this property, the ``eventPattern`` property, or both. For more information, see Schedule Expression Syntax for Rules in the Amazon EventBridge User Guide. Default: - None.\n')
    targets: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]]] = pydantic.Field(None, description='Targets to invoke when this rule matches an event. Input will be the full matched event. If you wish to specify custom target input, use ``addTarget(target[, inputOptions])``. Default: - No targets.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'event_bus', 'schedule', 'targets', 'cross_stack_scope', 'description', 'event_pattern', 'rule_name']
    _method_names: typing.ClassVar[list[str]] = ['add_event_pattern', 'add_target', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_event_rule_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.Rule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_event_rule_arn']
    ...


    from_event_rule_arn: typing.Optional[RuleDefFromEventRuleArnParams] = pydantic.Field(None, description='Import an existing EventBridge Rule provided an ARN.')
    resource_config: typing.Optional[RuleDefConfig] = pydantic.Field(None)


class RuleDefConfig(pydantic.BaseModel):
    add_event_pattern: typing.Optional[list[RuleDefAddEventPatternParams]] = pydantic.Field(None, description='Adds an event pattern filter to this rule.\nIf a pattern was already specified,\nthese values are merged into the existing pattern.\n\nFor example, if the rule already contains the pattern:\n\n{\n"resources": [ "r1" ],\n"detail": {\n"hello": [ 1 ]\n}\n}\n\nAnd ``addEventPattern`` is called with the pattern:\n\n{\n"resources": [ "r2" ],\n"detail": {\n"foo": [ "bar" ]\n}\n}\n\nThe resulting event pattern will be:\n\n{\n"resources": [ "r1", "r2" ],\n"detail": {\n"hello": [ 1 ],\n"foo": [ "bar" ]\n}\n}')
    add_target: typing.Optional[list[RuleDefAddTargetParams]] = pydantic.Field(None, description='Adds a target to the rule. The abstract class RuleTarget can be extended to define new targets.\nNo-op if target is undefined.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class RuleDefAddEventPatternParams(pydantic.BaseModel):
    account: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The 12-digit number identifying an AWS account. Default: - No filtering on account\n')
    detail: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='A JSON object, whose content is at the discretion of the service originating the event. Default: - No filtering on detail\n')
    detail_type: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Identifies, in combination with the source field, the fields and values that appear in the detail field. Represents the "detail-type" event field. Default: - No filtering on detail type\n')
    id: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A unique value is generated for every event. This can be helpful in tracing events as they move through rules to targets, and are processed. Default: - No filtering on id\n')
    region: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Identifies the AWS region where the event originated. Default: - No filtering on region\n')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='This JSON array contains ARNs that identify resources that are involved in the event. Inclusion of these ARNs is at the discretion of the service. For example, Amazon EC2 instance state-changes include Amazon EC2 instance ARNs, Auto Scaling events include ARNs for both instances and Auto Scaling groups, but API calls with AWS CloudTrail do not include resource ARNs. Default: - No filtering on resource\n')
    source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Identifies the service that sourced the event. All events sourced from within AWS begin with "aws." Customer-generated events can have any value here, as long as it doesn\'t begin with "aws." We recommend the use of Java package-name style reverse domain-name strings. To find the correct value for source for an AWS service, see the table in AWS Service Namespaces. For example, the source value for Amazon CloudFront is aws.cloudfront. Default: - No filtering on source\n')
    time: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The event timestamp, which can be specified by the service originating the event. If the event spans a time interval, the service might choose to report the start time, so this value can be noticeably before the time the event is actually received. Default: - No filtering on time\n')
    version: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='By default, this is set to 0 (zero) in all events. Default: - No filtering on version')
    ...

class RuleDefAddTargetParams(pydantic.BaseModel):
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='-')
    ...

class RuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class RuleDefFromEventRuleArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    event_rule_arn: str = pydantic.Field(..., description='Event Rule ARN (i.e. arn:aws:events:::rule/MyScheduledRule).')
    ...


#  autogenerated from aws_cdk.aws_events.ApiDestinationProps
class ApiDestinationPropsDef(BaseStruct):
    connection: typing.Union[models.aws_events.ConnectionDef] = pydantic.Field(..., description='The ARN of the connection to use for the API destination.\n')
    endpoint: str = pydantic.Field(..., description='The URL to the HTTP invocation endpoint for the API destination..\n')
    api_destination_name: typing.Optional[str] = pydantic.Field(None, description='The name for the API destination. Default: - A unique name will be generated\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the API destination. Default: - none\n')
    http_method: typing.Optional[aws_cdk.aws_events.HttpMethod] = pydantic.Field(None, description='The method to use for the request to the HTTP invocation endpoint. Default: HttpMethod.POST\n')
    rate_limit_per_second: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of requests per second to send to the HTTP invocation endpoint. Default: - Not rate limited\n\n:exampleMetadata: infused\n\nExample::\n\n    connection = events.Connection(self, "Connection",\n        authorization=events.Authorization.api_key("x-api-key", SecretValue.secrets_manager("ApiSecretName")),\n        description="Connection with API Key x-api-key"\n    )\n\n    destination = events.ApiDestination(self, "Destination",\n        connection=connection,\n        endpoint="https://example.com",\n        description="Calling example.com with API key x-api-key"\n    )\n\n    rule = events.Rule(self, "Rule",\n        schedule=events.Schedule.rate(Duration.minutes(1)),\n        targets=[targets.ApiDestination(destination)]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection', 'endpoint', 'api_destination_name', 'description', 'http_method', 'rate_limit_per_second']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.ApiDestinationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.ArchiveProps
class ArchivePropsDef(BaseStruct):
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any]] = pydantic.Field(..., description='An event pattern to use to filter events sent to the archive.\n')
    archive_name: typing.Optional[str] = pydantic.Field(None, description='The name of the archive. Default: - Automatically generated\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the archive. Default: - none\n')
    retention: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of days to retain events for. Default value is 0. If set to 0, events are retained indefinitely. Default: - Infinite\n')
    source_event_bus: typing.Union[models.aws_events.EventBusDef] = pydantic.Field(..., description='The event source associated with the archive.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_events as events\n\n    # detail: Any\n    # event_bus: events.EventBus\n\n    archive_props = events.ArchiveProps(\n        event_pattern=events.EventPattern(\n            account=["account"],\n            detail={\n                "detail_key": detail\n            },\n            detail_type=["detailType"],\n            id=["id"],\n            region=["region"],\n            resources=["resources"],\n            source=["source"],\n            time=["time"],\n            version=["version"]\n        ),\n        source_event_bus=event_bus,\n\n        # the properties below are optional\n        archive_name="archiveName",\n        description="description",\n        retention=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_pattern', 'archive_name', 'description', 'retention', 'source_event_bus']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.ArchiveProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ArchivePropsDefConfig] = pydantic.Field(None)


class ArchivePropsDefConfig(pydantic.BaseModel):
    source_event_bus_config: typing.Optional[models._interface_methods.AwsEventsIEventBusDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_events.BaseArchiveProps
class BaseArchivePropsDef(BaseStruct):
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any]] = pydantic.Field(..., description='An event pattern to use to filter events sent to the archive.\n')
    archive_name: typing.Optional[str] = pydantic.Field(None, description='The name of the archive. Default: - Automatically generated\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the archive. Default: - none\n')
    retention: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of days to retain events for. Default value is 0. If set to 0, events are retained indefinitely. Default: - Infinite\n\n:exampleMetadata: infused\n\nExample::\n\n    bus = events.EventBus(self, "bus",\n        event_bus_name="MyCustomEventBus"\n    )\n\n    bus.archive("MyArchive",\n        archive_name="MyCustomEventBusArchive",\n        description="MyCustomerEventBus Archive",\n        event_pattern=events.EventPattern(\n            account=[Stack.of(self).account]\n        ),\n        retention=Duration.days(365)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_pattern', 'archive_name', 'description', 'retention']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.BaseArchiveProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnConnection.ApiKeyAuthParametersProperty
class CfnConnection_ApiKeyAuthParametersPropertyDef(BaseStruct):
    api_key_name: str = pydantic.Field(..., description='The name of the API key to use for authorization.\n')
    api_key_value: str = pydantic.Field(..., description='The value for the API key to use for authorization.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-connection-apikeyauthparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    api_key_auth_parameters_property = events.CfnConnection.ApiKeyAuthParametersProperty(\n        api_key_name="apiKeyName",\n        api_key_value="apiKeyValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_key_name', 'api_key_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnection.ApiKeyAuthParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnConnection.AuthParametersProperty
class CfnConnection_AuthParametersPropertyDef(BaseStruct):
    api_key_auth_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ApiKeyAuthParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The API Key parameters to use for authorization.\n')
    basic_auth_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_BasicAuthParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The authorization parameters for Basic authorization.\n')
    invocation_http_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ConnectionHttpParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional parameters for the connection that are passed through with every invocation to the HTTP endpoint.\n')
    o_auth_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_OAuthParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The OAuth parameters to use for authorization.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-connection-authparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    auth_parameters_property = events.CfnConnection.AuthParametersProperty(\n        api_key_auth_parameters=events.CfnConnection.ApiKeyAuthParametersProperty(\n            api_key_name="apiKeyName",\n            api_key_value="apiKeyValue"\n        ),\n        basic_auth_parameters=events.CfnConnection.BasicAuthParametersProperty(\n            password="password",\n            username="username"\n        ),\n        invocation_http_parameters=events.CfnConnection.ConnectionHttpParametersProperty(\n            body_parameters=[events.CfnConnection.ParameterProperty(\n                key="key",\n                value="value",\n\n                # the properties below are optional\n                is_value_secret=False\n            )],\n            header_parameters=[events.CfnConnection.ParameterProperty(\n                key="key",\n                value="value",\n\n                # the properties below are optional\n                is_value_secret=False\n            )],\n            query_string_parameters=[events.CfnConnection.ParameterProperty(\n                key="key",\n                value="value",\n\n                # the properties below are optional\n                is_value_secret=False\n            )]\n        ),\n        o_auth_parameters=events.CfnConnection.OAuthParametersProperty(\n            authorization_endpoint="authorizationEndpoint",\n            client_parameters=events.CfnConnection.ClientParametersProperty(\n                client_id="clientId",\n                client_secret="clientSecret"\n            ),\n            http_method="httpMethod",\n\n            # the properties below are optional\n            o_auth_http_parameters=events.CfnConnection.ConnectionHttpParametersProperty(\n                body_parameters=[events.CfnConnection.ParameterProperty(\n                    key="key",\n                    value="value",\n\n                    # the properties below are optional\n                    is_value_secret=False\n                )],\n                header_parameters=[events.CfnConnection.ParameterProperty(\n                    key="key",\n                    value="value",\n\n                    # the properties below are optional\n                    is_value_secret=False\n                )],\n                query_string_parameters=[events.CfnConnection.ParameterProperty(\n                    key="key",\n                    value="value",\n\n                    # the properties below are optional\n                    is_value_secret=False\n                )]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_key_auth_parameters', 'basic_auth_parameters', 'invocation_http_parameters', 'o_auth_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnection.AuthParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnConnection.BasicAuthParametersProperty
class CfnConnection_BasicAuthParametersPropertyDef(BaseStruct):
    password: str = pydantic.Field(..., description='The password associated with the user name to use for Basic authorization.\n')
    username: str = pydantic.Field(..., description='The user name to use for Basic authorization.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-connection-basicauthparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    basic_auth_parameters_property = events.CfnConnection.BasicAuthParametersProperty(\n        password="password",\n        username="username"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['password', 'username']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnection.BasicAuthParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnConnection.ClientParametersProperty
class CfnConnection_ClientParametersPropertyDef(BaseStruct):
    client_id: str = pydantic.Field(..., description='The client ID to use for OAuth authorization.\n')
    client_secret: str = pydantic.Field(..., description='The client secret assciated with the client ID to use for OAuth authorization.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-connection-clientparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    client_parameters_property = events.CfnConnection.ClientParametersProperty(\n        client_id="clientId",\n        client_secret="clientSecret"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_id', 'client_secret']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnection.ClientParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnConnection.ConnectionHttpParametersProperty
class CfnConnection_ConnectionHttpParametersPropertyDef(BaseStruct):
    body_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains additional body string parameters for the connection.\n')
    header_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains additional header parameters for the connection.\n')
    query_string_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains additional query string parameters for the connection.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-connection-connectionhttpparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    connection_http_parameters_property = events.CfnConnection.ConnectionHttpParametersProperty(\n        body_parameters=[events.CfnConnection.ParameterProperty(\n            key="key",\n            value="value",\n\n            # the properties below are optional\n            is_value_secret=False\n        )],\n        header_parameters=[events.CfnConnection.ParameterProperty(\n            key="key",\n            value="value",\n\n            # the properties below are optional\n            is_value_secret=False\n        )],\n        query_string_parameters=[events.CfnConnection.ParameterProperty(\n            key="key",\n            value="value",\n\n            # the properties below are optional\n            is_value_secret=False\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['body_parameters', 'header_parameters', 'query_string_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnection.ConnectionHttpParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnConnection.OAuthParametersProperty
class CfnConnection_OAuthParametersPropertyDef(BaseStruct):
    authorization_endpoint: str = pydantic.Field(..., description='The URL to the authorization endpoint when OAuth is specified as the authorization type.\n')
    client_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ClientParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A ``CreateConnectionOAuthClientRequestParameters`` object that contains the client parameters for OAuth authorization.\n')
    http_method: str = pydantic.Field(..., description='The method to use for the authorization request.\n')
    o_auth_http_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ConnectionHttpParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A ``ConnectionHttpParameters`` object that contains details about the additional parameters to use for the connection.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-connection-oauthparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    o_auth_parameters_property = events.CfnConnection.OAuthParametersProperty(\n        authorization_endpoint="authorizationEndpoint",\n        client_parameters=events.CfnConnection.ClientParametersProperty(\n            client_id="clientId",\n            client_secret="clientSecret"\n        ),\n        http_method="httpMethod",\n\n        # the properties below are optional\n        o_auth_http_parameters=events.CfnConnection.ConnectionHttpParametersProperty(\n            body_parameters=[events.CfnConnection.ParameterProperty(\n                key="key",\n                value="value",\n\n                # the properties below are optional\n                is_value_secret=False\n            )],\n            header_parameters=[events.CfnConnection.ParameterProperty(\n                key="key",\n                value="value",\n\n                # the properties below are optional\n                is_value_secret=False\n            )],\n            query_string_parameters=[events.CfnConnection.ParameterProperty(\n                key="key",\n                value="value",\n\n                # the properties below are optional\n                is_value_secret=False\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorization_endpoint', 'client_parameters', 'http_method', 'o_auth_http_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnection.OAuthParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnConnection.ParameterProperty
class CfnConnection_ParameterPropertyDef(BaseStruct):
    key: str = pydantic.Field(..., description='The key for a query string parameter.\n')
    value: str = pydantic.Field(..., description='The value associated with the key for the query string parameter.\n')
    is_value_secret: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether the value is secret.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-connection-parameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    parameter_property = events.CfnConnection.ParameterProperty(\n        key="key",\n        value="value",\n\n        # the properties below are optional\n        is_value_secret=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value', 'is_value_secret']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnection.ParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEndpoint.EndpointEventBusProperty
class CfnEndpoint_EndpointEventBusPropertyDef(BaseStruct):
    event_bus_arn: str = pydantic.Field(..., description='The ARN of the event bus the endpoint is associated with.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-endpoint-endpointeventbus.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    endpoint_event_bus_property = events.CfnEndpoint.EndpointEventBusProperty(\n        event_bus_arn="eventBusArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_bus_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEndpoint.EndpointEventBusProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEndpoint.FailoverConfigProperty
class CfnEndpoint_FailoverConfigPropertyDef(BaseStruct):
    primary: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_PrimaryPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The main Region of the endpoint.\n')
    secondary: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_SecondaryPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The Region that events are routed to when failover is triggered or event replication is enabled.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-endpoint-failoverconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    failover_config_property = events.CfnEndpoint.FailoverConfigProperty(\n        primary=events.CfnEndpoint.PrimaryProperty(\n            health_check="healthCheck"\n        ),\n        secondary=events.CfnEndpoint.SecondaryProperty(\n            route="route"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['primary', 'secondary']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEndpoint.FailoverConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEndpoint.PrimaryProperty
class CfnEndpoint_PrimaryPropertyDef(BaseStruct):
    health_check: str = pydantic.Field(..., description='The ARN of the health check used by the endpoint to determine whether failover is triggered.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-endpoint-primary.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    primary_property = events.CfnEndpoint.PrimaryProperty(\n        health_check="healthCheck"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['health_check']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEndpoint.PrimaryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEndpoint.ReplicationConfigProperty
class CfnEndpoint_ReplicationConfigPropertyDef(BaseStruct):
    state: str = pydantic.Field(..., description='The state of event replication.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-endpoint-replicationconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    replication_config_property = events.CfnEndpoint.ReplicationConfigProperty(\n        state="state"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['state']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEndpoint.ReplicationConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEndpoint.RoutingConfigProperty
class CfnEndpoint_RoutingConfigPropertyDef(BaseStruct):
    failover_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_FailoverConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The failover configuration for an endpoint. This includes what triggers failover and what happens when it\'s triggered.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-endpoint-routingconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    routing_config_property = events.CfnEndpoint.RoutingConfigProperty(\n        failover_config=events.CfnEndpoint.FailoverConfigProperty(\n            primary=events.CfnEndpoint.PrimaryProperty(\n                health_check="healthCheck"\n            ),\n            secondary=events.CfnEndpoint.SecondaryProperty(\n                route="route"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['failover_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEndpoint.RoutingConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEndpoint.SecondaryProperty
class CfnEndpoint_SecondaryPropertyDef(BaseStruct):
    route: str = pydantic.Field(..., description='Defines the secondary Region.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-endpoint-secondary.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    secondary_property = events.CfnEndpoint.SecondaryProperty(\n        route="route"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEndpoint.SecondaryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEventBus.TagEntryProperty
class CfnEventBus_TagEntryPropertyDef(BaseStruct):
    key: str = pydantic.Field(..., description='A string you can use to assign a value. The combination of tag keys and values can help you organize and categorize your resources.\n')
    value: str = pydantic.Field(..., description='The value for the specified tag key.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-eventbus-tagentry.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    tag_entry_property = events.CfnEventBus.TagEntryProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEventBus.TagEntryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEventBusPolicy.ConditionProperty
class CfnEventBusPolicy_ConditionPropertyDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description='Specifies the key for the condition. Currently the only supported key is ``aws:PrincipalOrgID`` .\n')
    type: typing.Optional[str] = pydantic.Field(None, description='Specifies the type of condition. Currently the only supported value is ``StringEquals`` .\n')
    value: typing.Optional[str] = pydantic.Field(None, description='Specifies the value for the key. Currently, this must be the ID of the organization.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-eventbuspolicy-condition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    condition_property = events.CfnEventBusPolicy.ConditionProperty(\n        key="key",\n        type="type",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'type', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEventBusPolicy.ConditionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.AwsVpcConfigurationProperty
class CfnRule_AwsVpcConfigurationPropertyDef(BaseStruct):
    subnets: typing.Sequence[str] = pydantic.Field(..., description='Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.\n')
    assign_public_ip: typing.Optional[str] = pydantic.Field(None, description="Specifies whether the task's elastic network interface receives a public IP address. You can specify ``ENABLED`` only when ``LaunchType`` in ``EcsParameters`` is set to ``FARGATE`` .\n")
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-awsvpcconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    aws_vpc_configuration_property = events.CfnRule.AwsVpcConfigurationProperty(\n        subnets=["subnets"],\n\n        # the properties below are optional\n        assign_public_ip="assignPublicIp",\n        security_groups=["securityGroups"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnets', 'assign_public_ip', 'security_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.AwsVpcConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.BatchArrayPropertiesProperty
class CfnRule_BatchArrayPropertiesPropertyDef(BaseStruct):
    size: typing.Union[int, float, None] = pydantic.Field(None, description='The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-batcharrayproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    batch_array_properties_property = events.CfnRule.BatchArrayPropertiesProperty(\n        size=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['size']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.BatchArrayPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.BatchParametersProperty
class CfnRule_BatchParametersPropertyDef(BaseStruct):
    job_definition: str = pydantic.Field(..., description='The ARN or name of the job definition to use if the event target is an AWS Batch job. This job definition must already exist.\n')
    job_name: str = pydantic.Field(..., description='The name to use for this execution of the job, if the target is an AWS Batch job.\n')
    array_properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_BatchArrayPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The array properties for the submitted job, such as the size of the array. The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. This parameter is used only if the target is an AWS Batch job.\n')
    retry_strategy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_BatchRetryStrategyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The retry strategy to use for failed jobs, if the target is an AWS Batch job. The retry strategy is the number of times to retry the failed job execution. Valid values are 1–10. When you specify a retry strategy here, it overrides the retry strategy defined in the job definition.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-batchparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    batch_parameters_property = events.CfnRule.BatchParametersProperty(\n        job_definition="jobDefinition",\n        job_name="jobName",\n\n        # the properties below are optional\n        array_properties=events.CfnRule.BatchArrayPropertiesProperty(\n            size=123\n        ),\n        retry_strategy=events.CfnRule.BatchRetryStrategyProperty(\n            attempts=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['job_definition', 'job_name', 'array_properties', 'retry_strategy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.BatchParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.BatchRetryStrategyProperty
class CfnRule_BatchRetryStrategyPropertyDef(BaseStruct):
    attempts: typing.Union[int, float, None] = pydantic.Field(None, description='The number of times to attempt to retry, if the job fails. Valid values are 1–10.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-batchretrystrategy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    batch_retry_strategy_property = events.CfnRule.BatchRetryStrategyProperty(\n        attempts=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attempts']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.BatchRetryStrategyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.CapacityProviderStrategyItemProperty
class CfnRule_CapacityProviderStrategyItemPropertyDef(BaseStruct):
    capacity_provider: str = pydantic.Field(..., description='The short name of the capacity provider.\n')
    base: typing.Union[int, float, None] = pydantic.Field(None, description='The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used.\n')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-capacityproviderstrategyitem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    capacity_provider_strategy_item_property = events.CfnRule.CapacityProviderStrategyItemProperty(\n        capacity_provider="capacityProvider",\n\n        # the properties below are optional\n        base=123,\n        weight=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider', 'base', 'weight']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.CapacityProviderStrategyItemProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.DeadLetterConfigProperty
class CfnRule_DeadLetterConfigPropertyDef(BaseStruct):
    arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the SQS queue specified as the target for the dead-letter queue.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-deadletterconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    dead_letter_config_property = events.CfnRule.DeadLetterConfigProperty(\n        arn="arn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.DeadLetterConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.EcsParametersProperty
class CfnRule_EcsParametersPropertyDef(BaseStruct):
    task_definition_arn: str = pydantic.Field(..., description='The ARN of the task definition to use if the event target is an Amazon ECS task.\n')
    capacity_provider_strategy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_CapacityProviderStrategyItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The capacity provider strategy to use for the task. If a ``capacityProviderStrategy`` is specified, the ``launchType`` parameter must be omitted. If no ``capacityProviderStrategy`` or launchType is specified, the ``defaultCapacityProviderStrategy`` for the cluster is used.\n')
    enable_ecs_managed_tags: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the task. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ in the Amazon Elastic Container Service Developer Guide.\n')
    enable_execute_command: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.\n')
    group: typing.Optional[str] = pydantic.Field(None, description='Specifies an ECS task group for the task. The maximum length is 255 characters.\n')
    launch_type: typing.Optional[str] = pydantic.Field(None, description='Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The ``FARGATE`` value is supported only in the Regions where AWS Fargate with Amazon ECS is supported. For more information, see `AWS Fargate on Amazon ECS <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS-Fargate.html>`_ in the *Amazon Elastic Container Service Developer Guide* .\n')
    network_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_NetworkConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use this structure if the Amazon ECS task uses the ``awsvpc`` network mode. This structure specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. This structure is required if ``LaunchType`` is ``FARGATE`` because the ``awsvpc`` mode is required for Fargate tasks. If you specify ``NetworkConfiguration`` when the target ECS task does not use the ``awsvpc`` network mode, the task fails.\n')
    placement_constraints: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_PlacementConstraintPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).\n')
    placement_strategies: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_PlacementStrategyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.\n')
    platform_version: typing.Optional[str] = pydantic.Field(None, description='Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as ``1.1.0`` . This structure is used only if ``LaunchType`` is ``FARGATE`` . For more information about valid platform versions, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the *Amazon Elastic Container Service Developer Guide* .\n')
    propagate_tags: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the TagResource API action.\n')
    reference_id: typing.Optional[str] = pydantic.Field(None, description='The reference ID to use for the task.\n')
    tag_list: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. To learn more, see `RunTask <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html#ECS-RunTask-request-tags>`_ in the Amazon ECS API Reference.\n')
    task_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of tasks to create based on ``TaskDefinition`` . The default is 1.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-ecsparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    ecs_parameters_property = events.CfnRule.EcsParametersProperty(\n        task_definition_arn="taskDefinitionArn",\n\n        # the properties below are optional\n        capacity_provider_strategy=[events.CfnRule.CapacityProviderStrategyItemProperty(\n            capacity_provider="capacityProvider",\n\n            # the properties below are optional\n            base=123,\n            weight=123\n        )],\n        enable_ecs_managed_tags=False,\n        enable_execute_command=False,\n        group="group",\n        launch_type="launchType",\n        network_configuration=events.CfnRule.NetworkConfigurationProperty(\n            aws_vpc_configuration=events.CfnRule.AwsVpcConfigurationProperty(\n                subnets=["subnets"],\n\n                # the properties below are optional\n                assign_public_ip="assignPublicIp",\n                security_groups=["securityGroups"]\n            )\n        ),\n        placement_constraints=[events.CfnRule.PlacementConstraintProperty(\n            expression="expression",\n            type="type"\n        )],\n        placement_strategies=[events.CfnRule.PlacementStrategyProperty(\n            field="field",\n            type="type"\n        )],\n        platform_version="platformVersion",\n        propagate_tags="propagateTags",\n        reference_id="referenceId",\n        tag_list=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        task_count=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['task_definition_arn', 'capacity_provider_strategy', 'enable_ecs_managed_tags', 'enable_execute_command', 'group', 'launch_type', 'network_configuration', 'placement_constraints', 'placement_strategies', 'platform_version', 'propagate_tags', 'reference_id', 'tag_list', 'task_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.EcsParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.HttpParametersProperty
class CfnRule_HttpParametersPropertyDef(BaseStruct):
    header_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='The headers that need to be sent as part of request invoking the API Gateway API or EventBridge ApiDestination.\n')
    path_parameter_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The path parameter values to be used to populate API Gateway API or EventBridge ApiDestination path wildcards ("*").\n')
    query_string_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='The query string keys/values that need to be sent as part of request invoking the API Gateway API or EventBridge ApiDestination.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-httpparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    http_parameters_property = events.CfnRule.HttpParametersProperty(\n        header_parameters={\n            "header_parameters_key": "headerParameters"\n        },\n        path_parameter_values=["pathParameterValues"],\n        query_string_parameters={\n            "query_string_parameters_key": "queryStringParameters"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['header_parameters', 'path_parameter_values', 'query_string_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.HttpParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.InputTransformerProperty
class CfnRule_InputTransformerPropertyDef(BaseStruct):
    input_template: str = pydantic.Field(..., description='Input template where you specify placeholders that will be filled with the values of the keys from ``InputPathsMap`` to customize the data sent to the target. Enclose each ``InputPathsMaps`` value in brackets: < *value* > If ``InputTemplate`` is a JSON object (surrounded by curly braces), the following restrictions apply: - The placeholder cannot be used as an object key. The following example shows the syntax for using ``InputPathsMap`` and ``InputTemplate`` . ``"InputTransformer":`` ``{`` ``"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},`` ``"InputTemplate": "<instance> is in state <status>"`` ``}`` To have the ``InputTemplate`` include quote marks within a JSON string, escape each quote marks with a slash, as in the following example: ``"InputTransformer":`` ``{`` ``"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},`` ``"InputTemplate": "<instance> is in state \\"<status>\\""`` ``}`` The ``InputTemplate`` can also be valid JSON with varibles in quotes or out, as in the following example: ``"InputTransformer":`` ``{`` ``"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},`` ``"InputTemplate": \'{"myInstance": <instance>,"myStatus": "<instance> is in state \\"<status>\\""}\'`` ``}``\n')
    input_paths_map: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='Map of JSON paths to be extracted from the event. You can then insert these in the template in ``InputTemplate`` to produce the output you want to be sent to the target. ``InputPathsMap`` is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation. The keys cannot start with " AWS ."\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-inputtransformer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    input_transformer_property = events.CfnRule.InputTransformerProperty(\n        input_template="inputTemplate",\n\n        # the properties below are optional\n        input_paths_map={\n            "input_paths_map_key": "inputPathsMap"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input_template', 'input_paths_map']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.InputTransformerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.KinesisParametersProperty
class CfnRule_KinesisParametersPropertyDef(BaseStruct):
    partition_key_path: str = pydantic.Field(..., description='The JSON path to be extracted from the event and used as the partition key. For more information, see `Amazon Kinesis Streams Key Concepts <https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html#partition-key>`_ in the *Amazon Kinesis Streams Developer Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-kinesisparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    kinesis_parameters_property = events.CfnRule.KinesisParametersProperty(\n        partition_key_path="partitionKeyPath"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['partition_key_path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.KinesisParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.NetworkConfigurationProperty
class CfnRule_NetworkConfigurationPropertyDef(BaseStruct):
    aws_vpc_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_AwsVpcConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use this structure to specify the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the ``awsvpc`` network mode.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-networkconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    network_configuration_property = events.CfnRule.NetworkConfigurationProperty(\n        aws_vpc_configuration=events.CfnRule.AwsVpcConfigurationProperty(\n            subnets=["subnets"],\n\n            # the properties below are optional\n            assign_public_ip="assignPublicIp",\n            security_groups=["securityGroups"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['aws_vpc_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.NetworkConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.PlacementConstraintProperty
class CfnRule_PlacementConstraintPropertyDef(BaseStruct):
    expression: typing.Optional[str] = pydantic.Field(None, description='A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is ``distinctInstance`` . To learn more, see `Cluster Query Language <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html>`_ in the Amazon Elastic Container Service Developer Guide.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of constraint. Use distinctInstance to ensure that each task in a particular group is running on a different container instance. Use memberOf to restrict the selection to a group of valid candidates.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-placementconstraint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    placement_constraint_property = events.CfnRule.PlacementConstraintProperty(\n        expression="expression",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['expression', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.PlacementConstraintProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.PlacementStrategyProperty
class CfnRule_PlacementStrategyPropertyDef(BaseStruct):
    field: typing.Optional[str] = pydantic.Field(None, description='The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-placementstrategy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    placement_strategy_property = events.CfnRule.PlacementStrategyProperty(\n        field="field",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['field', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.PlacementStrategyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.RedshiftDataParametersProperty
class CfnRule_RedshiftDataParametersPropertyDef(BaseStruct):
    database: str = pydantic.Field(..., description='The name of the database. Required when authenticating using temporary credentials.\n')
    sql: str = pydantic.Field(..., description='The SQL statement text to run.\n')
    db_user: typing.Optional[str] = pydantic.Field(None, description='The database user name. Required when authenticating using temporary credentials.\n')
    secret_manager_arn: typing.Optional[str] = pydantic.Field(None, description='The name or ARN of the secret that enables access to the database. Required when authenticating using AWS Secrets Manager.\n')
    statement_name: typing.Optional[str] = pydantic.Field(None, description='The name of the SQL statement. You can name the SQL statement when you create it to identify the query.\n')
    with_event: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to send an event back to EventBridge after the SQL statement runs.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-redshiftdataparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    redshift_data_parameters_property = events.CfnRule.RedshiftDataParametersProperty(\n        database="database",\n        sql="sql",\n\n        # the properties below are optional\n        db_user="dbUser",\n        secret_manager_arn="secretManagerArn",\n        statement_name="statementName",\n        with_event=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database', 'sql', 'db_user', 'secret_manager_arn', 'statement_name', 'with_event']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.RedshiftDataParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.RetryPolicyProperty
class CfnRule_RetryPolicyPropertyDef(BaseStruct):
    maximum_event_age_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of time, in seconds, to continue to make retry attempts.\n')
    maximum_retry_attempts: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of retry attempts to make before the request fails. Retry attempts continue until either the maximum number of attempts is made or until the duration of the ``MaximumEventAgeInSeconds`` is met.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-retrypolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    retry_policy_property = events.CfnRule.RetryPolicyProperty(\n        maximum_event_age_in_seconds=123,\n        maximum_retry_attempts=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['maximum_event_age_in_seconds', 'maximum_retry_attempts']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.RetryPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.RunCommandParametersProperty
class CfnRule_RunCommandParametersPropertyDef(BaseStruct):
    run_command_targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_RunCommandTargetPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='Currently, we support including only one RunCommandTarget block, which specifies either an array of InstanceIds or a tag.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-runcommandparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    run_command_parameters_property = events.CfnRule.RunCommandParametersProperty(\n        run_command_targets=[events.CfnRule.RunCommandTargetProperty(\n            key="key",\n            values=["values"]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['run_command_targets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.RunCommandParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.RunCommandTargetProperty
class CfnRule_RunCommandTargetPropertyDef(BaseStruct):
    key: str = pydantic.Field(..., description='Can be either ``tag:`` *tag-key* or ``InstanceIds`` .\n')
    values: typing.Sequence[str] = pydantic.Field(..., description='If ``Key`` is ``tag:`` *tag-key* , ``Values`` is a list of tag values. If ``Key`` is ``InstanceIds`` , ``Values`` is a list of Amazon EC2 instance IDs.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-runcommandtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    run_command_target_property = events.CfnRule.RunCommandTargetProperty(\n        key="key",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.RunCommandTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.SageMakerPipelineParameterProperty
class CfnRule_SageMakerPipelineParameterPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='Name of parameter to start execution of a SageMaker Model Building Pipeline.\n')
    value: str = pydantic.Field(..., description='Value of parameter to start execution of a SageMaker Model Building Pipeline.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-sagemakerpipelineparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    sage_maker_pipeline_parameter_property = events.CfnRule.SageMakerPipelineParameterProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.SageMakerPipelineParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.SageMakerPipelineParametersProperty
class CfnRule_SageMakerPipelineParametersPropertyDef(BaseStruct):
    pipeline_parameter_list: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_SageMakerPipelineParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='List of Parameter names and values for SageMaker Model Building Pipeline execution.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-sagemakerpipelineparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    sage_maker_pipeline_parameters_property = events.CfnRule.SageMakerPipelineParametersProperty(\n        pipeline_parameter_list=[events.CfnRule.SageMakerPipelineParameterProperty(\n            name="name",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['pipeline_parameter_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.SageMakerPipelineParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.SqsParametersProperty
class CfnRule_SqsParametersPropertyDef(BaseStruct):
    message_group_id: str = pydantic.Field(..., description='The FIFO message group ID to use as the target.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-sqsparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    sqs_parameters_property = events.CfnRule.SqsParametersProperty(\n        message_group_id="messageGroupId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['message_group_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.SqsParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.TagProperty
class CfnRule_TagPropertyDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description='A string you can use to assign a value. The combination of tag keys and values can help you organize and categorize your resources.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value for the specified tag key.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-tag.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    tag_property = events.CfnRule.TagProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.TagProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRule.TargetProperty
class CfnRule_TargetPropertyDef(BaseStruct):
    arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the target.\n')
    batch_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_BatchParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='If the event target is an AWS Batch job, this contains the job definition, job name, and other parameters. For more information, see `Jobs <https://docs.aws.amazon.com/batch/latest/userguide/jobs.html>`_ in the *AWS Batch User Guide* .\n')
    dead_letter_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_DeadLetterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The ``DeadLetterConfig`` that defines the target queue to send dead-letter queue events to.\n')
    ecs_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_EcsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains the Amazon ECS task definition and task count to be used, if the event target is an Amazon ECS task. For more information about Amazon ECS tasks, see `Task Definitions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html>`_ in the *Amazon EC2 Container Service Developer Guide* .\n')
    http_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_HttpParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Contains the HTTP parameters to use when the target is a API Gateway endpoint or EventBridge ApiDestination. If you specify an API Gateway API or EventBridge ApiDestination as a target, you can use this parameter to specify headers, path parameters, and query string keys/values as part of your target invoking request. If you're using ApiDestinations, the corresponding Connection can also have these values configured. In case of any conflicting keys, values from the Connection take precedence.\n")
    input: typing.Optional[str] = pydantic.Field(None, description='Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. For more information, see `The JavaScript Object Notation (JSON) Data Interchange Format <https://docs.aws.amazon.com/http://www.rfc-editor.org/rfc/rfc7159.txt>`_ .\n')
    input_path: typing.Optional[str] = pydantic.Field(None, description='The value of the JSONPath that is used for extracting part of the matched event when passing it to the target. You may use JSON dot notation or bracket notation. For more information about JSON paths, see `JSONPath <https://docs.aws.amazon.com/http://goessner.net/articles/JsonPath/>`_ .\n')
    input_transformer: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_InputTransformerPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings to enable you to provide custom input to a target based on certain event data. You can extract one or more key-value pairs from the event and then use that data to send customized input to the target.\n')
    kinesis_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_KinesisParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The custom parameter you can use to control the shard assignment, when the target is a Kinesis data stream. If you do not include this parameter, the default is to use the ``eventId`` as the partition key.\n')
    redshift_data_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_RedshiftDataParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains the Amazon Redshift Data API parameters to use when the target is a Amazon Redshift cluster. If you specify a Amazon Redshift Cluster as a Target, you can use this to specify parameters to invoke the Amazon Redshift Data API ExecuteStatement based on EventBridge events.\n')
    retry_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_RetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The ``RetryPolicy`` object that contains the retry policy configuration to use for the dead-letter queue.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is triggered. If one rule triggers multiple targets, you can use a different IAM role for each target.\n')
    run_command_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_RunCommandParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Parameters used when you are using the rule to invoke Amazon EC2 Run Command.\n')
    sage_maker_pipeline_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_SageMakerPipelineParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains the SageMaker Model Building Pipeline parameters to start execution of a SageMaker Model Building Pipeline. If you specify a SageMaker Model Building Pipeline as a target, you can use this to specify parameters to start a pipeline execution based on EventBridge events.\n')
    sqs_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_SqsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains the message group ID to use when the target is a FIFO queue. If you specify an SQS FIFO queue as a target, the queue must have content-based deduplication enabled.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-rule-target.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    target_property = events.CfnRule.TargetProperty(\n        arn="arn",\n        id="id",\n\n        # the properties below are optional\n        batch_parameters=events.CfnRule.BatchParametersProperty(\n            job_definition="jobDefinition",\n            job_name="jobName",\n\n            # the properties below are optional\n            array_properties=events.CfnRule.BatchArrayPropertiesProperty(\n                size=123\n            ),\n            retry_strategy=events.CfnRule.BatchRetryStrategyProperty(\n                attempts=123\n            )\n        ),\n        dead_letter_config=events.CfnRule.DeadLetterConfigProperty(\n            arn="arn"\n        ),\n        ecs_parameters=events.CfnRule.EcsParametersProperty(\n            task_definition_arn="taskDefinitionArn",\n\n            # the properties below are optional\n            capacity_provider_strategy=[events.CfnRule.CapacityProviderStrategyItemProperty(\n                capacity_provider="capacityProvider",\n\n                # the properties below are optional\n                base=123,\n                weight=123\n            )],\n            enable_ecs_managed_tags=False,\n            enable_execute_command=False,\n            group="group",\n            launch_type="launchType",\n            network_configuration=events.CfnRule.NetworkConfigurationProperty(\n                aws_vpc_configuration=events.CfnRule.AwsVpcConfigurationProperty(\n                    subnets=["subnets"],\n\n                    # the properties below are optional\n                    assign_public_ip="assignPublicIp",\n                    security_groups=["securityGroups"]\n                )\n            ),\n            placement_constraints=[events.CfnRule.PlacementConstraintProperty(\n                expression="expression",\n                type="type"\n            )],\n            placement_strategies=[events.CfnRule.PlacementStrategyProperty(\n                field="field",\n                type="type"\n            )],\n            platform_version="platformVersion",\n            propagate_tags="propagateTags",\n            reference_id="referenceId",\n            tag_list=[CfnTag(\n                key="key",\n                value="value"\n            )],\n            task_count=123\n        ),\n        http_parameters=events.CfnRule.HttpParametersProperty(\n            header_parameters={\n                "header_parameters_key": "headerParameters"\n            },\n            path_parameter_values=["pathParameterValues"],\n            query_string_parameters={\n                "query_string_parameters_key": "queryStringParameters"\n            }\n        ),\n        input="input",\n        input_path="inputPath",\n        input_transformer=events.CfnRule.InputTransformerProperty(\n            input_template="inputTemplate",\n\n            # the properties below are optional\n            input_paths_map={\n                "input_paths_map_key": "inputPathsMap"\n            }\n        ),\n        kinesis_parameters=events.CfnRule.KinesisParametersProperty(\n            partition_key_path="partitionKeyPath"\n        ),\n        redshift_data_parameters=events.CfnRule.RedshiftDataParametersProperty(\n            database="database",\n            sql="sql",\n\n            # the properties below are optional\n            db_user="dbUser",\n            secret_manager_arn="secretManagerArn",\n            statement_name="statementName",\n            with_event=False\n        ),\n        retry_policy=events.CfnRule.RetryPolicyProperty(\n            maximum_event_age_in_seconds=123,\n            maximum_retry_attempts=123\n        ),\n        role_arn="roleArn",\n        run_command_parameters=events.CfnRule.RunCommandParametersProperty(\n            run_command_targets=[events.CfnRule.RunCommandTargetProperty(\n                key="key",\n                values=["values"]\n            )]\n        ),\n        sage_maker_pipeline_parameters=events.CfnRule.SageMakerPipelineParametersProperty(\n            pipeline_parameter_list=[events.CfnRule.SageMakerPipelineParameterProperty(\n                name="name",\n                value="value"\n            )]\n        ),\n        sqs_parameters=events.CfnRule.SqsParametersProperty(\n            message_group_id="messageGroupId"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn', 'batch_parameters', 'dead_letter_config', 'ecs_parameters', 'http_parameters', 'input', 'input_path', 'input_transformer', 'kinesis_parameters', 'redshift_data_parameters', 'retry_policy', 'role_arn', 'run_command_parameters', 'sage_maker_pipeline_parameters', 'sqs_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule.TargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.ConnectionAttributes
class ConnectionAttributesDef(BaseStruct):
    connection_arn: str = pydantic.Field(..., description='The ARN of the connection created.\n')
    connection_name: str = pydantic.Field(..., description='The Name for the connection.\n')
    connection_secret_arn: str = pydantic.Field(..., description='The ARN for the secret created for the connection.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    connection_attributes = events.ConnectionAttributes(\n        connection_arn="connectionArn",\n        connection_name="connectionName",\n        connection_secret_arn="connectionSecretArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_arn', 'connection_name', 'connection_secret_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.ConnectionAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.ConnectionProps
class ConnectionPropsDef(BaseStruct):
    authorization: models.aws_events.AuthorizationDef = pydantic.Field(..., description='The authorization type for the connection.\n')
    body_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the invocation bodies. Default: - No additional parameters\n')
    connection_name: typing.Optional[str] = pydantic.Field(None, description='The name of the connection. Default: - A name is automatically generated\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The name of the connection. Default: - none\n')
    header_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the invocation headers. Default: - No additional parameters\n')
    query_string_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the invocation query strings. Default: - No additional parameters\n\n:exampleMetadata: infused\n\nExample::\n\n    connection = events.Connection(self, "Connection",\n        authorization=events.Authorization.api_key("x-api-key", SecretValue.secrets_manager("ApiSecretName")),\n        description="Connection with API Key x-api-key"\n    )\n\n    destination = events.ApiDestination(self, "Destination",\n        connection=connection,\n        endpoint="https://example.com",\n        description="Calling example.com with API key x-api-key"\n    )\n\n    rule = events.Rule(self, "Rule",\n        schedule=events.Schedule.rate(Duration.minutes(1)),\n        targets=[targets.ApiDestination(destination)]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorization', 'body_parameters', 'connection_name', 'description', 'header_parameters', 'query_string_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.ConnectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ConnectionPropsDefConfig] = pydantic.Field(None)


class ConnectionPropsDefConfig(pydantic.BaseModel):
    authorization_config: typing.Optional[models.aws_events.AuthorizationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_events.CronOptions
class CronOptionsDef(BaseStruct):
    day: typing.Optional[str] = pydantic.Field(None, description='The day of the month to run this rule at. Default: - Every day of the month\n')
    hour: typing.Optional[str] = pydantic.Field(None, description='The hour to run this rule at. Default: - Every hour\n')
    minute: typing.Optional[str] = pydantic.Field(None, description='The minute to run this rule at. Default: - Every minute\n')
    month: typing.Optional[str] = pydantic.Field(None, description='The month to run this rule at. Default: - Every month\n')
    week_day: typing.Optional[str] = pydantic.Field(None, description='The day of the week to run this rule at. Default: - Any day of the week\n')
    year: typing.Optional[str] = pydantic.Field(None, description='The year to run this rule at. Default: - Every year\n\n:see: https://docs.aws.amazon.com/eventbridge/latest/userguide/scheduled-events.html#cron-expressions\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_events as events\n    import aws_cdk.aws_events_targets as targets\n\n    # fn: lambda.Function\n\n    rule = events.Rule(self, "Schedule Rule",\n        schedule=events.Schedule.cron(minute="0", hour="4")\n    )\n    rule.add_target(targets.LambdaFunction(fn))\n')
    _init_params: typing.ClassVar[list[str]] = ['day', 'hour', 'minute', 'month', 'week_day', 'year']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CronOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.EventBusAttributes
class EventBusAttributesDef(BaseStruct):
    event_bus_arn: str = pydantic.Field(..., description='The ARN of this event bus resource.\n')
    event_bus_name: str = pydantic.Field(..., description='The physical ID of this event bus resource.\n')
    event_bus_policy: str = pydantic.Field(..., description='The JSON policy of this event bus resource.\n')
    event_source_name: typing.Optional[str] = pydantic.Field(None, description='The partner event source to associate with this event bus resource. Default: - no partner event source\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    event_bus_attributes = events.EventBusAttributes(\n        event_bus_arn="eventBusArn",\n        event_bus_name="eventBusName",\n        event_bus_policy="eventBusPolicy",\n\n        # the properties below are optional\n        event_source_name="eventSourceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_bus_arn', 'event_bus_name', 'event_bus_policy', 'event_source_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.EventBusAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.EventBusPolicyProps
class EventBusPolicyPropsDef(BaseStruct):
    event_bus: typing.Union[models.aws_events.EventBusDef] = pydantic.Field(..., description='The event bus to which the policy applies.\n')
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='An IAM Policy Statement to apply to the Event Bus.\n')
    statement_id: str = pydantic.Field(..., description='An identifier string for the external account that you are granting permissions to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n    from aws_cdk import aws_iam as iam\n\n    # event_bus: events.EventBus\n    # policy_statement: iam.PolicyStatement\n\n    event_bus_policy_props = events.EventBusPolicyProps(\n        event_bus=event_bus,\n        statement=policy_statement,\n        statement_id="statementId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_bus', 'statement', 'statement_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.EventBusPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[EventBusPolicyPropsDefConfig] = pydantic.Field(None)


class EventBusPolicyPropsDefConfig(pydantic.BaseModel):
    statement_config: typing.Optional[models.aws_iam.PolicyStatementDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_events.EventBusProps
class EventBusPropsDef(BaseStruct):
    event_bus_name: typing.Optional[str] = pydantic.Field(None, description="The name of the event bus you are creating Note: If 'eventSourceName' is passed in, you cannot set this. Default: - automatically generated name\n")
    event_source_name: typing.Optional[str] = pydantic.Field(None, description='The partner event source to associate with this event bus resource Note: If \'eventBusName\' is passed in, you cannot set this. Default: - no partner event source\n\n:exampleMetadata: infused\n\nExample::\n\n    bus = events.EventBus(self, "bus",\n        event_bus_name="MyCustomEventBus"\n    )\n\n    bus.archive("MyArchive",\n        archive_name="MyCustomEventBusArchive",\n        description="MyCustomerEventBus Archive",\n        event_pattern=events.EventPattern(\n            account=[Stack.of(self).account]\n        ),\n        retention=Duration.days(365)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_bus_name', 'event_source_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.EventBusProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.EventCommonOptions
class EventCommonOptionsDef(BaseStruct):
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n    import constructs as constructs\n\n    # construct: constructs.Construct\n    # detail: Any\n\n    event_common_options = events.EventCommonOptions(\n        cross_stack_scope=construct,\n        description="description",\n        event_pattern=events.EventPattern(\n            account=["account"],\n            detail={\n                "detail_key": detail\n            },\n            detail_type=["detailType"],\n            id=["id"],\n            region=["region"],\n            resources=["resources"],\n            source=["source"],\n            time=["time"],\n            version=["version"]\n        ),\n        rule_name="ruleName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cross_stack_scope', 'description', 'event_pattern', 'rule_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.EventCommonOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.EventPattern
class EventPatternDef(BaseStruct):
    account: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The 12-digit number identifying an AWS account. Default: - No filtering on account\n')
    detail: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='A JSON object, whose content is at the discretion of the service originating the event. Default: - No filtering on detail\n')
    detail_type: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Identifies, in combination with the source field, the fields and values that appear in the detail field. Represents the "detail-type" event field. Default: - No filtering on detail type\n')
    region: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Identifies the AWS region where the event originated. Default: - No filtering on region\n')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='This JSON array contains ARNs that identify resources that are involved in the event. Inclusion of these ARNs is at the discretion of the service. For example, Amazon EC2 instance state-changes include Amazon EC2 instance ARNs, Auto Scaling events include ARNs for both instances and Auto Scaling groups, but API calls with AWS CloudTrail do not include resource ARNs. Default: - No filtering on resource\n')
    source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Identifies the service that sourced the event. All events sourced from within AWS begin with "aws." Customer-generated events can have any value here, as long as it doesn\'t begin with "aws." We recommend the use of Java package-name style reverse domain-name strings. To find the correct value for source for an AWS service, see the table in AWS Service Namespaces. For example, the source value for Amazon CloudFront is aws.cloudfront. Default: - No filtering on source\n')
    time: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The event timestamp, which can be specified by the service originating the event. If the event spans a time interval, the service might choose to report the start time, so this value can be noticeably before the time the event is actually received. Default: - No filtering on time\n')
    version: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='By default, this is set to 0 (zero) in all events. Default: - No filtering on version\n\n:see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/CloudWatchEventsandEventPatterns.html\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_lambda as lambda_\n\n\n    fn = lambda_.Function(self, "MyFunc",\n        runtime=lambda_.Runtime.NODEJS_14_X,\n        handler="index.handler",\n        code=lambda_.Code.from_inline("exports.handler = handler.toString()")\n    )\n\n    rule = events.Rule(self, "rule",\n        event_pattern=events.EventPattern(\n            source=["aws.ec2"]\n        )\n    )\n\n    queue = sqs.Queue(self, "Queue")\n\n    rule.add_target(targets.LambdaFunction(fn,\n        dead_letter_queue=queue,  # Optional: add a dead letter queue\n        max_event_age=Duration.hours(2),  # Optional: set the maxEventAge retry policy\n        retry_attempts=2\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'detail', 'detail_type', 'region', 'resources', 'source', 'time', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.EventPattern'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.OAuthAuthorizationProps
class OAuthAuthorizationPropsDef(BaseStruct):
    authorization_endpoint: str = pydantic.Field(..., description='The URL to the authorization endpoint.\n')
    client_id: str = pydantic.Field(..., description='The client ID to use for OAuth authorization for the connection.\n')
    client_secret: models.SecretValueDef = pydantic.Field(..., description='The client secret associated with the client ID to use for OAuth authorization for the connection.\n')
    http_method: aws_cdk.aws_events.HttpMethod = pydantic.Field(..., description='The method to use for the authorization request. (Can only choose POST, GET or PUT).\n')
    body_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the OAuth request body. Default: - No additional parameters\n')
    header_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the OAuth request header. Default: - No additional parameters\n')
    query_string_parameters: typing.Optional[typing.Mapping[str, models.aws_events.HttpParameterDef]] = pydantic.Field(None, description='Additional string parameters to add to the OAuth request query string. Default: - No additional parameters\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_events as events\n\n    # http_parameter: events.HttpParameter\n    # secret_value: cdk.SecretValue\n\n    o_auth_authorization_props = events.OAuthAuthorizationProps(\n        authorization_endpoint="authorizationEndpoint",\n        client_id="clientId",\n        client_secret=secret_value,\n        http_method=events.HttpMethod.POST,\n\n        # the properties below are optional\n        body_parameters={\n            "body_parameters_key": http_parameter\n        },\n        header_parameters={\n            "header_parameters_key": http_parameter\n        },\n        query_string_parameters={\n            "query_string_parameters_key": http_parameter\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorization_endpoint', 'client_id', 'client_secret', 'http_method', 'body_parameters', 'header_parameters', 'query_string_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.OAuthAuthorizationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[OAuthAuthorizationPropsDefConfig] = pydantic.Field(None)


class OAuthAuthorizationPropsDefConfig(pydantic.BaseModel):
    client_secret_config: typing.Optional[models.core.SecretValueDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_events.OnEventOptions
class OnEventOptionsDef(BaseStruct):
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n\n:exampleMetadata: infused\n\nExample::\n\n    # Lambda function containing logic that evaluates compliance with the rule.\n    eval_compliance_fn = lambda_.Function(self, "CustomFunction",\n        code=lambda_.AssetCode.from_inline("exports.handler = (event) => console.log(event);"),\n        handler="index.handler",\n        runtime=lambda_.Runtime.NODEJS_18_X\n    )\n\n    # A custom rule that runs on configuration changes of EC2 instances\n    custom_rule = config.CustomRule(self, "Custom",\n        configuration_changes=True,\n        lambda_function=eval_compliance_fn,\n        rule_scope=config.RuleScope.from_resource(config.ResourceType.EC2_INSTANCE)\n    )\n\n    # A rule to detect stack drifts\n    drift_rule = config.CloudFormationStackDriftDetectionCheck(self, "Drift")\n\n    # Topic to which compliance notification events will be published\n    compliance_topic = sns.Topic(self, "ComplianceTopic")\n\n    # Send notification on compliance change events\n    drift_rule.on_compliance_change("ComplianceChange",\n        target=targets.SnsTopic(compliance_topic)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cross_stack_scope', 'description', 'event_pattern', 'rule_name', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.OnEventOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.RuleProps
class RulePropsDef(BaseStruct):
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    event_bus: typing.Optional[typing.Union[models.aws_events.EventBusDef]] = pydantic.Field(None, description='The event bus to associate with this rule. Default: - The default event bus.\n')
    schedule: typing.Optional[models.aws_events.ScheduleDef] = pydantic.Field(None, description='The schedule or rate (frequency) that determines when EventBridge runs the rule. You must specify this property, the ``eventPattern`` property, or both. For more information, see Schedule Expression Syntax for Rules in the Amazon EventBridge User Guide. Default: - None.\n')
    targets: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]]] = pydantic.Field(None, description='Targets to invoke when this rule matches an event. Input will be the full matched event. If you wish to specify custom target input, use ``addTarget(target[, inputOptions])``. Default: - No targets.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_lambda as lambda_\n\n\n    fn = lambda_.Function(self, "MyFunc",\n        runtime=lambda_.Runtime.NODEJS_14_X,\n        handler="index.handler",\n        code=lambda_.Code.from_inline("exports.handler = handler.toString()")\n    )\n\n    rule = events.Rule(self, "rule",\n        event_pattern=events.EventPattern(\n            source=["aws.ec2"]\n        )\n    )\n\n    queue = sqs.Queue(self, "Queue")\n\n    rule.add_target(targets.LambdaFunction(fn,\n        dead_letter_queue=queue,  # Optional: add a dead letter queue\n        max_event_age=Duration.hours(2),  # Optional: set the maxEventAge retry policy\n        retry_attempts=2\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['cross_stack_scope', 'description', 'event_pattern', 'rule_name', 'enabled', 'event_bus', 'schedule', 'targets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.RuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.RuleTargetConfig
class RuleTargetConfigDef(BaseStruct):
    arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the target.\n')
    batch_parameters: typing.Union[models.aws_events.CfnRule_BatchParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Parameters used when the rule invokes Amazon AWS Batch Job/Queue. Default: no parameters set\n')
    dead_letter_config: typing.Union[models.aws_events.CfnRule_DeadLetterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains information about a dead-letter queue configuration. Default: no dead-letter queue set\n')
    ecs_parameters: typing.Union[models.aws_events.CfnRule_EcsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Amazon ECS task definition and task count to use, if the event target is an Amazon ECS task.\n')
    http_parameters: typing.Union[models.aws_events.CfnRule_HttpParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains the HTTP parameters to use when the target is a API Gateway REST endpoint or EventBridge API destination. Default: - None\n')
    input: typing.Optional[models.aws_events.RuleTargetInputDef] = pydantic.Field(None, description='What input to send to the event target. Default: the entire event\n')
    kinesis_parameters: typing.Union[models.aws_events.CfnRule_KinesisParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Settings that control shard assignment, when the target is a Kinesis stream. If you don't include this parameter, eventId is used as the partition key.\n")
    retry_policy: typing.Union[models.aws_events.CfnRule_RetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A RetryPolicy object that includes information about the retry policy settings. Default: EventBridge default retry policy\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role to use to invoke this event target.\n')
    run_command_parameters: typing.Union[models.aws_events.CfnRule_RunCommandParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Parameters used when the rule invokes Amazon EC2 Systems Manager Run Command.\n')
    sqs_parameters: typing.Union[models.aws_events.CfnRule_SqsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Parameters used when the FIFO sqs queue is used an event target by the rule.\n')
    target_resource: typing.Optional[models.AnyResource] = pydantic.Field(None, description='The resource that is backing this target. This is the resource that will actually have some action performed on it when used as a target (for example, start a build for a CodeBuild project). We need it to determine whether the rule belongs to a different account than the target - if so, we generate a more complex setup, including an additional stack containing the EventBusPolicy. Default: the target is not backed by any resource\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n    from aws_cdk import aws_iam as iam\n    import constructs as constructs\n\n    # construct: constructs.Construct\n    # role: iam.Role\n    # rule_target_input: events.RuleTargetInput\n\n    rule_target_config = events.RuleTargetConfig(\n        arn="arn",\n\n        # the properties below are optional\n        batch_parameters=events.CfnRule.BatchParametersProperty(\n            job_definition="jobDefinition",\n            job_name="jobName",\n\n            # the properties below are optional\n            array_properties=events.CfnRule.BatchArrayPropertiesProperty(\n                size=123\n            ),\n            retry_strategy=events.CfnRule.BatchRetryStrategyProperty(\n                attempts=123\n            )\n        ),\n        dead_letter_config=events.CfnRule.DeadLetterConfigProperty(\n            arn="arn"\n        ),\n        ecs_parameters=events.CfnRule.EcsParametersProperty(\n            task_definition_arn="taskDefinitionArn",\n\n            # the properties below are optional\n            capacity_provider_strategy=[events.CfnRule.CapacityProviderStrategyItemProperty(\n                capacity_provider="capacityProvider",\n\n                # the properties below are optional\n                base=123,\n                weight=123\n            )],\n            enable_ecs_managed_tags=False,\n            enable_execute_command=False,\n            group="group",\n            launch_type="launchType",\n            network_configuration=events.CfnRule.NetworkConfigurationProperty(\n                aws_vpc_configuration=events.CfnRule.AwsVpcConfigurationProperty(\n                    subnets=["subnets"],\n\n                    # the properties below are optional\n                    assign_public_ip="assignPublicIp",\n                    security_groups=["securityGroups"]\n                )\n            ),\n            placement_constraints=[events.CfnRule.PlacementConstraintProperty(\n                expression="expression",\n                type="type"\n            )],\n            placement_strategies=[events.CfnRule.PlacementStrategyProperty(\n                field="field",\n                type="type"\n            )],\n            platform_version="platformVersion",\n            propagate_tags="propagateTags",\n            reference_id="referenceId",\n            tag_list=[CfnTag(\n                key="key",\n                value="value"\n            )],\n            task_count=123\n        ),\n        http_parameters=events.CfnRule.HttpParametersProperty(\n            header_parameters={\n                "header_parameters_key": "headerParameters"\n            },\n            path_parameter_values=["pathParameterValues"],\n            query_string_parameters={\n                "query_string_parameters_key": "queryStringParameters"\n            }\n        ),\n        input=rule_target_input,\n        kinesis_parameters=events.CfnRule.KinesisParametersProperty(\n            partition_key_path="partitionKeyPath"\n        ),\n        retry_policy=events.CfnRule.RetryPolicyProperty(\n            maximum_event_age_in_seconds=123,\n            maximum_retry_attempts=123\n        ),\n        role=role,\n        run_command_parameters=events.CfnRule.RunCommandParametersProperty(\n            run_command_targets=[events.CfnRule.RunCommandTargetProperty(\n                key="key",\n                values=["values"]\n            )]\n        ),\n        sqs_parameters=events.CfnRule.SqsParametersProperty(\n            message_group_id="messageGroupId"\n        ),\n        target_resource=construct\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn', 'batch_parameters', 'dead_letter_config', 'ecs_parameters', 'http_parameters', 'input', 'kinesis_parameters', 'retry_policy', 'role', 'run_command_parameters', 'sqs_parameters', 'target_resource']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.RuleTargetConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.RuleTargetInputProperties
class RuleTargetInputPropertiesDef(BaseStruct):
    input: typing.Optional[str] = pydantic.Field(None, description='Literal input to the target service (must be valid JSON). Default: - input for the event target. If the input contains a paths map values wil be extracted from event and inserted into the ``inputTemplate``.\n')
    input_path: typing.Optional[str] = pydantic.Field(None, description='JsonPath to take input from the input event. Default: - None. The entire matched event is passed as input\n')
    input_paths_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Paths map to extract values from event and insert into ``inputTemplate``. Default: - No values extracted from event.\n')
    input_template: typing.Optional[str] = pydantic.Field(None, description='Input template to insert paths map into. Default: - None.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    rule_target_input_properties = events.RuleTargetInputProperties(\n        input="input",\n        input_path="inputPath",\n        input_paths_map={\n            "input_paths_map_key": "inputPathsMap"\n        },\n        input_template="inputTemplate"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input', 'input_path', 'input_paths_map', 'input_template']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.RuleTargetInputProperties'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.HttpMethod
# skipping emum

#  autogenerated from aws_cdk.aws_events.IApiDestination
#  skipping Interface

#  autogenerated from aws_cdk.aws_events.IConnection
#  skipping Interface

#  autogenerated from aws_cdk.aws_events.IEventBus
#  skipping Interface

#  autogenerated from aws_cdk.aws_events.IRule
#  skipping Interface

#  autogenerated from aws_cdk.aws_events.IRuleTarget
#  skipping Interface

#  autogenerated from aws_cdk.aws_events.CfnApiDestination
class CfnApiDestinationDef(BaseCfnResource):
    connection_arn: str = pydantic.Field(..., description='The ARN of the connection to use for the API destination. The destination endpoint must support the authorization type specified for the connection.\n')
    http_method: str = pydantic.Field(..., description='The method to use for the request to the HTTP invocation endpoint.\n')
    invocation_endpoint: str = pydantic.Field(..., description='The URL to the HTTP invocation endpoint for the API destination.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the API destination to create.\n')
    invocation_rate_limit_per_second: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of requests per second to send to the HTTP invocation endpoint.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name for the API destination to create.')
    _init_params: typing.ClassVar[list[str]] = ['connection_arn', 'http_method', 'invocation_endpoint', 'description', 'invocation_rate_limit_per_second', 'name']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnApiDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnApiDestinationDefConfig] = pydantic.Field(None)


class CfnApiDestinationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnApiDestinationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnApiDestinationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnApiDestinationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnApiDestinationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnApiDestinationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnApiDestinationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnApiDestinationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnApiDestinationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnApiDestinationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnApiDestinationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnApiDestinationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnApiDestinationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnApiDestinationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnApiDestinationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnApiDestinationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiDestinationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnApiDestinationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiDestinationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnApiDestinationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnApiDestinationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnApiDestinationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnApiDestinationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnApiDestinationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiDestinationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnApiDestinationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnApiDestinationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiDestinationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_events.CfnArchive
class CfnArchiveDef(BaseCfnResource):
    source_arn: str = pydantic.Field(..., description='The ARN of the event bus that sends events to the archive.\n')
    archive_name: typing.Optional[str] = pydantic.Field(None, description='The name for the archive to create.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the archive.\n')
    event_pattern: typing.Any = pydantic.Field(None, description='An event pattern to use to filter events sent to the archive.\n')
    retention_days: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days to retain events for. Default value is 0. If set to 0, events are retained indefinitely')
    _init_params: typing.ClassVar[list[str]] = ['source_arn', 'archive_name', 'description', 'event_pattern', 'retention_days']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnArchive'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnArchiveDefConfig] = pydantic.Field(None)


class CfnArchiveDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnArchiveDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnArchiveDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnArchiveDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnArchiveDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnArchiveDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnArchiveDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnArchiveDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnArchiveDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnArchiveDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnArchiveDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnArchiveDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnArchiveDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnArchiveDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnArchiveDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnArchiveDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnArchiveDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnArchiveDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnArchiveDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnArchiveDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnArchiveDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnArchiveDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnArchiveDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnArchiveDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnArchiveDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnArchiveDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnArchiveDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnArchiveDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_events.CfnConnection
class CfnConnectionDef(BaseCfnResource):
    authorization_type: str = pydantic.Field(..., description='The type of authorization to use for the connection. .. epigraph:: OAUTH tokens are refreshed when a 401 or 407 response is returned.\n')
    auth_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_AuthParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A ``CreateConnectionAuthRequestParameters`` object that contains the authorization parameters to use to authorize with the endpoint.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the connection to create.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name for the connection to create.')
    _init_params: typing.ClassVar[list[str]] = ['authorization_type', 'auth_parameters', 'description', 'name']
    _method_names: typing.ClassVar[list[str]] = ['ApiKeyAuthParametersProperty', 'AuthParametersProperty', 'BasicAuthParametersProperty', 'ClientParametersProperty', 'ConnectionHttpParametersProperty', 'OAuthParametersProperty', 'ParameterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnConnectionDefConfig] = pydantic.Field(None)


class CfnConnectionDefConfig(pydantic.BaseModel):
    ApiKeyAuthParametersProperty: typing.Optional[list[CfnConnectionDefApikeyauthparameterspropertyParams]] = pydantic.Field(None, description='')
    AuthParametersProperty: typing.Optional[list[CfnConnectionDefAuthparameterspropertyParams]] = pydantic.Field(None, description='')
    BasicAuthParametersProperty: typing.Optional[list[CfnConnectionDefBasicauthparameterspropertyParams]] = pydantic.Field(None, description='')
    ClientParametersProperty: typing.Optional[list[CfnConnectionDefClientparameterspropertyParams]] = pydantic.Field(None, description='')
    ConnectionHttpParametersProperty: typing.Optional[list[CfnConnectionDefConnectionhttpparameterspropertyParams]] = pydantic.Field(None, description='')
    OAuthParametersProperty: typing.Optional[list[CfnConnectionDefOauthparameterspropertyParams]] = pydantic.Field(None, description='')
    ParameterProperty: typing.Optional[list[CfnConnectionDefParameterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnConnectionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnConnectionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnConnectionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnConnectionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnConnectionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnConnectionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnConnectionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnConnectionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnConnectionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnConnectionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnConnectionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnConnectionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnConnectionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnConnectionDefApikeyauthparameterspropertyParams(pydantic.BaseModel):
    api_key_name: str = pydantic.Field(..., description='')
    api_key_value: str = pydantic.Field(..., description='')
    ...

class CfnConnectionDefAuthparameterspropertyParams(pydantic.BaseModel):
    api_key_auth_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ApiKeyAuthParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    basic_auth_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_BasicAuthParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    invocation_http_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ConnectionHttpParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    o_auth_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_OAuthParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnConnectionDefBasicauthparameterspropertyParams(pydantic.BaseModel):
    password: str = pydantic.Field(..., description='')
    username: str = pydantic.Field(..., description='')
    ...

class CfnConnectionDefClientparameterspropertyParams(pydantic.BaseModel):
    client_id: str = pydantic.Field(..., description='')
    client_secret: str = pydantic.Field(..., description='')
    ...

class CfnConnectionDefConnectionhttpparameterspropertyParams(pydantic.BaseModel):
    body_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    header_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    query_string_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnConnectionDefOauthparameterspropertyParams(pydantic.BaseModel):
    authorization_endpoint: str = pydantic.Field(..., description='')
    client_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ClientParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    http_method: str = pydantic.Field(..., description='')
    o_auth_http_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_ConnectionHttpParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnConnectionDefParameterpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    is_value_secret: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnConnectionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConnectionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConnectionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConnectionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConnectionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConnectionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConnectionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConnectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConnectionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConnectionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConnectionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnConnectionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConnectionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConnectionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_events.CfnEndpoint
class CfnEndpointDef(BaseCfnResource):
    event_buses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_EndpointEventBusPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='The event buses being used by the endpoint. *Exactly* : ``2``\n')
    routing_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_RoutingConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The routing configuration of the endpoint.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the endpoint.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the endpoint.\n')
    replication_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_ReplicationConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Whether event replication was enabled or disabled for this endpoint. The default state is ``ENABLED`` which means you must supply a ``RoleArn`` . If you don't have a ``RoleArn`` or you don't want event replication enabled, set the state to ``DISABLED`` .\n")
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role used by event replication for the endpoint.')
    _init_params: typing.ClassVar[list[str]] = ['event_buses', 'routing_config', 'description', 'name', 'replication_config', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = ['EndpointEventBusProperty', 'FailoverConfigProperty', 'PrimaryProperty', 'ReplicationConfigProperty', 'RoutingConfigProperty', 'SecondaryProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnEndpointDefConfig] = pydantic.Field(None)


class CfnEndpointDefConfig(pydantic.BaseModel):
    EndpointEventBusProperty: typing.Optional[list[CfnEndpointDefEndpointeventbuspropertyParams]] = pydantic.Field(None, description='')
    FailoverConfigProperty: typing.Optional[list[CfnEndpointDefFailoverconfigpropertyParams]] = pydantic.Field(None, description='')
    PrimaryProperty: typing.Optional[list[CfnEndpointDefPrimarypropertyParams]] = pydantic.Field(None, description='')
    ReplicationConfigProperty: typing.Optional[list[CfnEndpointDefReplicationconfigpropertyParams]] = pydantic.Field(None, description='')
    RoutingConfigProperty: typing.Optional[list[CfnEndpointDefRoutingconfigpropertyParams]] = pydantic.Field(None, description='')
    SecondaryProperty: typing.Optional[list[CfnEndpointDefSecondarypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnEndpointDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnEndpointDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnEndpointDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnEndpointDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnEndpointDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnEndpointDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnEndpointDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnEndpointDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnEndpointDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnEndpointDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnEndpointDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnEndpointDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnEndpointDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnEndpointDefEndpointeventbuspropertyParams(pydantic.BaseModel):
    event_bus_arn: str = pydantic.Field(..., description='')
    ...

class CfnEndpointDefFailoverconfigpropertyParams(pydantic.BaseModel):
    primary: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_PrimaryPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    secondary: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_SecondaryPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnEndpointDefPrimarypropertyParams(pydantic.BaseModel):
    health_check: str = pydantic.Field(..., description='')
    ...

class CfnEndpointDefReplicationconfigpropertyParams(pydantic.BaseModel):
    state: str = pydantic.Field(..., description='')
    ...

class CfnEndpointDefRoutingconfigpropertyParams(pydantic.BaseModel):
    failover_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_FailoverConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnEndpointDefSecondarypropertyParams(pydantic.BaseModel):
    route: str = pydantic.Field(..., description='')
    ...

class CfnEndpointDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEndpointDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEndpointDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEndpointDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEndpointDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEndpointDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEndpointDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEndpointDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEndpointDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEndpointDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnEndpointDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEndpointDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEndpointDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_events.CfnEventBus
class CfnEventBusDef(BaseCfnResource):
    name: str = pydantic.Field(..., description="The name of the new event bus. Custom event bus names can't contain the ``/`` character, but you can use the ``/`` character in partner event bus names. In addition, for partner event buses, the name must exactly match the name of the partner event source that this event bus is matched to. You can't use the name ``default`` for a custom event bus, as this name is already used for your account's default event bus.\n")
    event_source_name: typing.Optional[str] = pydantic.Field(None, description='If you are creating a partner event bus, this specifies the partner event source that the new event bus will be matched with.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.aws_events.CfnEventBus_TagEntryPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Tags to associate with the event bus.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'event_source_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['TagEntryProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEventBus'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnEventBusDefConfig] = pydantic.Field(None)


class CfnEventBusDefConfig(pydantic.BaseModel):
    TagEntryProperty: typing.Optional[list[CfnEventBusDefTagentrypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnEventBusDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnEventBusDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnEventBusDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnEventBusDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnEventBusDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnEventBusDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnEventBusDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnEventBusDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnEventBusDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnEventBusDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnEventBusDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnEventBusDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnEventBusDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnEventBusDefTagentrypropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnEventBusDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEventBusDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEventBusDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEventBusDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEventBusDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEventBusDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEventBusDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEventBusDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEventBusDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEventBusDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEventBusDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnEventBusDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEventBusDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEventBusDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_events.CfnEventBusPolicy
class CfnEventBusPolicyDef(BaseCfnResource):
    statement_id: str = pydantic.Field(..., description='An identifier string for the external account that you are granting permissions to. If you later want to revoke the permission for this external account, specify this ``StatementId`` when you run `RemovePermission <https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_RemovePermission.html>`_ . .. epigraph:: Each ``StatementId`` must be unique.\n')
    action: typing.Optional[str] = pydantic.Field(None, description='The action that you are enabling the other account to perform.\n')
    condition: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEventBusPolicy_ConditionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='This parameter enables you to limit the permission to accounts that fulfill a certain condition, such as being a member of a certain AWS organization. For more information about AWS Organizations, see `What Is AWS Organizations <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html>`_ in the *AWS Organizations User Guide* . If you specify ``Condition`` with an AWS organization ID, and specify "*" as the value for ``Principal`` , you grant permission to all the accounts in the named organization. The ``Condition`` is a JSON string which must contain ``Type`` , ``Key`` , and ``Value`` fields.\n')
    event_bus_name: typing.Optional[str] = pydantic.Field(None, description='The name of the event bus associated with the rule. If you omit this, the default event bus is used.\n')
    principal: typing.Optional[str] = pydantic.Field(None, description='The 12-digit AWS account ID that you are permitting to put events to your default event bus. Specify "*" to permit any account to put events to your default event bus. If you specify "*" without specifying ``Condition`` , avoid creating rules that may match undesirable events. To create more secure rules, make sure that the event pattern for each rule contains an ``account`` field with a specific account ID from which to receive events. Rules with an account field do not match any events sent from other accounts.\n')
    statement: typing.Any = pydantic.Field(None, description='A JSON string that describes the permission policy statement. You can include a ``Policy`` parameter in the request instead of using the ``StatementId`` , ``Action`` , ``Principal`` , or ``Condition`` parameters.')
    _init_params: typing.ClassVar[list[str]] = ['statement_id', 'action', 'condition', 'event_bus_name', 'principal', 'statement']
    _method_names: typing.ClassVar[list[str]] = ['ConditionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEventBusPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnEventBusPolicyDefConfig] = pydantic.Field(None)


class CfnEventBusPolicyDefConfig(pydantic.BaseModel):
    ConditionProperty: typing.Optional[list[CfnEventBusPolicyDefConditionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnEventBusPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnEventBusPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnEventBusPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnEventBusPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnEventBusPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnEventBusPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnEventBusPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnEventBusPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnEventBusPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnEventBusPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnEventBusPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnEventBusPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnEventBusPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnEventBusPolicyDefConditionpropertyParams(pydantic.BaseModel):
    key: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEventBusPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEventBusPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEventBusPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEventBusPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEventBusPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEventBusPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEventBusPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEventBusPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEventBusPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEventBusPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEventBusPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnEventBusPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEventBusPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEventBusPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_events.CfnRule
class CfnRuleDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the rule.\n')
    event_bus_name: typing.Optional[str] = pydantic.Field(None, description='The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.\n')
    event_pattern: typing.Any = pydantic.Field(None, description='The event pattern of the rule. For more information, see `Events and Event Patterns <https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html>`_ in the *Amazon EventBridge User Guide* .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the rule.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon Resource Name (ARN) of the role that is used for target invocation. If you're setting an event bus in another account as the target and that account granted permission to your account through an organization instead of directly by the account ID, you must specify a ``RoleArn`` with proper permissions in the ``Target`` structure, instead of here in this parameter.\n")
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)". For more information, see `Creating an Amazon EventBridge rule that runs on a schedule <https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-create-rule-schedule.html>`_ .\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state of the rule.\n')
    targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_TargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Adds the specified targets to the specified rule, or updates the targets if they are already associated with the rule. Targets are the resources that are invoked when a rule is triggered. The maximum number of entries per request is 10. .. epigraph:: Each rule can have up to five (5) targets associated with it at one time. For a list of services you can configure as targets for events, see `EventBridge targets <https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html>`_ in the *Amazon EventBridge User Guide* . Creating rules with built-in targets is supported only in the AWS Management Console . The built-in targets are: - ``Amazon EBS CreateSnapshot API call`` - ``Amazon EC2 RebootInstances API call`` - ``Amazon EC2 StopInstances API call`` - ``Amazon EC2 TerminateInstances API call`` For some target types, ``PutTargets`` provides target-specific parameters. If the target is a Kinesis data stream, you can optionally specify which shard the event goes to by using the ``KinesisParameters`` argument. To invoke a command on multiple EC2 instances with one rule, you can use the ``RunCommandParameters`` field. To be able to make API calls against the resources that you own, Amazon EventBridge needs the appropriate permissions: - For AWS Lambda and Amazon SNS resources, EventBridge relies on resource-based policies. - For EC2 instances, Kinesis Data Streams, AWS Step Functions state machines and API Gateway APIs, EventBridge relies on IAM roles that you specify in the ``RoleARN`` argument in ``PutTargets`` . For more information, see `Authentication and Access Control <https://docs.aws.amazon.com/eventbridge/latest/userguide/auth-and-access-control-eventbridge.html>`_ in the *Amazon EventBridge User Guide* . If another AWS account is in the same region and has granted you permission (using ``PutPermission`` ), you can send events to that account. Set that account's event bus as a target of the rules in your account. To send the matched events to the other account, specify that account's event bus as the ``Arn`` value when you run ``PutTargets`` . If your account sends events to another account, your account is charged for each sent event. Each event sent to another account is charged as a custom event. The account receiving the event is not charged. For more information, see `Amazon EventBridge Pricing <https://docs.aws.amazon.com/eventbridge/pricing/>`_ . .. epigraph:: ``Input`` , ``InputPath`` , and ``InputTransformer`` are not available with ``PutTarget`` if the target is an event bus of a different AWS account. If you are setting the event bus of another account as the target, and that account granted permission to your account through an organization instead of directly by the account ID, then you must specify a ``RoleArn`` with proper permissions in the ``Target`` structure. For more information, see `Sending and Receiving Events Between AWS Accounts <https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html>`_ in the *Amazon EventBridge User Guide* . .. epigraph:: If you have an IAM role on a cross-account event bus target, a ``PutTargets`` call without a role on the same target (same ``Id`` and ``Arn`` ) will not remove the role. For more information about enabling cross-account events, see `PutPermission <https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutPermission.html>`_ . *Input* , *InputPath* , and *InputTransformer* are mutually exclusive and optional parameters of a target. When a rule is triggered due to a matched event: - If none of the following arguments are specified for a target, then the entire event is passed to the target in JSON format (unless the target is Amazon EC2 Run Command or Amazon ECS task, in which case nothing from the event is passed to the target). - If *Input* is specified in the form of valid JSON, then the matched event is overridden with this constant. - If *InputPath* is specified in the form of JSONPath (for example, ``$.detail`` ), then only the part of the event specified in the path is passed to the target (for example, only the detail part of the event is passed). - If *InputTransformer* is specified, then one or more specified JSONPaths are extracted from the event and used as values in a template that you specify as the input to the target. When you specify ``InputPath`` or ``InputTransformer`` , you must use JSON dot notation, not bracket notation. When you add targets to a rule and the associated rule triggers soon after, new or updated targets might not be immediately invoked. Allow a short period of time for changes to take effect. This action can partially fail if too many requests are made at the same time. If that happens, ``FailedEntryCount`` is non-zero in the response and each entry in ``FailedEntries`` provides the ID of the failed target and the error code.")
    _init_params: typing.ClassVar[list[str]] = ['description', 'event_bus_name', 'event_pattern', 'name', 'role_arn', 'schedule_expression', 'state', 'targets']
    _method_names: typing.ClassVar[list[str]] = ['AwsVpcConfigurationProperty', 'BatchArrayPropertiesProperty', 'BatchParametersProperty', 'BatchRetryStrategyProperty', 'CapacityProviderStrategyItemProperty', 'DeadLetterConfigProperty', 'EcsParametersProperty', 'HttpParametersProperty', 'InputTransformerProperty', 'KinesisParametersProperty', 'NetworkConfigurationProperty', 'PlacementConstraintProperty', 'PlacementStrategyProperty', 'RedshiftDataParametersProperty', 'RetryPolicyProperty', 'RunCommandParametersProperty', 'RunCommandTargetProperty', 'SageMakerPipelineParameterProperty', 'SageMakerPipelineParametersProperty', 'SqsParametersProperty', 'TagProperty', 'TargetProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRuleDefConfig] = pydantic.Field(None)


class CfnRuleDefConfig(pydantic.BaseModel):
    AwsVpcConfigurationProperty: typing.Optional[list[CfnRuleDefAwsvpcconfigurationpropertyParams]] = pydantic.Field(None, description='')
    BatchArrayPropertiesProperty: typing.Optional[list[CfnRuleDefBatcharraypropertiespropertyParams]] = pydantic.Field(None, description='')
    BatchParametersProperty: typing.Optional[list[CfnRuleDefBatchparameterspropertyParams]] = pydantic.Field(None, description='')
    BatchRetryStrategyProperty: typing.Optional[list[CfnRuleDefBatchretrystrategypropertyParams]] = pydantic.Field(None, description='')
    CapacityProviderStrategyItemProperty: typing.Optional[list[CfnRuleDefCapacityproviderstrategyitempropertyParams]] = pydantic.Field(None, description='')
    DeadLetterConfigProperty: typing.Optional[list[CfnRuleDefDeadletterconfigpropertyParams]] = pydantic.Field(None, description='')
    EcsParametersProperty: typing.Optional[list[CfnRuleDefEcsparameterspropertyParams]] = pydantic.Field(None, description='')
    HttpParametersProperty: typing.Optional[list[CfnRuleDefHttpparameterspropertyParams]] = pydantic.Field(None, description='')
    InputTransformerProperty: typing.Optional[list[CfnRuleDefInputtransformerpropertyParams]] = pydantic.Field(None, description='')
    KinesisParametersProperty: typing.Optional[list[CfnRuleDefKinesisparameterspropertyParams]] = pydantic.Field(None, description='')
    NetworkConfigurationProperty: typing.Optional[list[CfnRuleDefNetworkconfigurationpropertyParams]] = pydantic.Field(None, description='')
    PlacementConstraintProperty: typing.Optional[list[CfnRuleDefPlacementconstraintpropertyParams]] = pydantic.Field(None, description='')
    PlacementStrategyProperty: typing.Optional[list[CfnRuleDefPlacementstrategypropertyParams]] = pydantic.Field(None, description='')
    RedshiftDataParametersProperty: typing.Optional[list[CfnRuleDefRedshiftdataparameterspropertyParams]] = pydantic.Field(None, description='')
    RetryPolicyProperty: typing.Optional[list[CfnRuleDefRetrypolicypropertyParams]] = pydantic.Field(None, description='')
    RunCommandParametersProperty: typing.Optional[list[CfnRuleDefRuncommandparameterspropertyParams]] = pydantic.Field(None, description='')
    RunCommandTargetProperty: typing.Optional[list[CfnRuleDefRuncommandtargetpropertyParams]] = pydantic.Field(None, description='')
    SageMakerPipelineParameterProperty: typing.Optional[list[CfnRuleDefSagemakerpipelineparameterpropertyParams]] = pydantic.Field(None, description='')
    SageMakerPipelineParametersProperty: typing.Optional[list[CfnRuleDefSagemakerpipelineparameterspropertyParams]] = pydantic.Field(None, description='')
    SqsParametersProperty: typing.Optional[list[CfnRuleDefSqsparameterspropertyParams]] = pydantic.Field(None, description='')
    TagProperty: typing.Optional[list[CfnRuleDefTagpropertyParams]] = pydantic.Field(None, description='')
    TargetProperty: typing.Optional[list[CfnRuleDefTargetpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnRuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnRuleDefAwsvpcconfigurationpropertyParams(pydantic.BaseModel):
    subnets: typing.Sequence[str] = pydantic.Field(..., description='')
    assign_public_ip: typing.Optional[str] = pydantic.Field(None, description='')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnRuleDefBatcharraypropertiespropertyParams(pydantic.BaseModel):
    size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefBatchparameterspropertyParams(pydantic.BaseModel):
    job_definition: str = pydantic.Field(..., description='')
    job_name: str = pydantic.Field(..., description='')
    array_properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_BatchArrayPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    retry_strategy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_BatchRetryStrategyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefBatchretrystrategypropertyParams(pydantic.BaseModel):
    attempts: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefCapacityproviderstrategyitempropertyParams(pydantic.BaseModel):
    capacity_provider: str = pydantic.Field(..., description='')
    base: typing.Union[int, float, None] = pydantic.Field(None, description='')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefDeadletterconfigpropertyParams(pydantic.BaseModel):
    arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRuleDefEcsparameterspropertyParams(pydantic.BaseModel):
    task_definition_arn: str = pydantic.Field(..., description='')
    capacity_provider_strategy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_CapacityProviderStrategyItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    enable_ecs_managed_tags: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    enable_execute_command: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    group: typing.Optional[str] = pydantic.Field(None, description='')
    launch_type: typing.Optional[str] = pydantic.Field(None, description='')
    network_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_NetworkConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    placement_constraints: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_PlacementConstraintPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    placement_strategies: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_PlacementStrategyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    platform_version: typing.Optional[str] = pydantic.Field(None, description='')
    propagate_tags: typing.Optional[str] = pydantic.Field(None, description='')
    reference_id: typing.Optional[str] = pydantic.Field(None, description='')
    tag_list: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    task_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefHttpparameterspropertyParams(pydantic.BaseModel):
    header_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    path_parameter_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    query_string_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefInputtransformerpropertyParams(pydantic.BaseModel):
    input_template: str = pydantic.Field(..., description='')
    input_paths_map: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefKinesisparameterspropertyParams(pydantic.BaseModel):
    partition_key_path: str = pydantic.Field(..., description='')
    ...

class CfnRuleDefNetworkconfigurationpropertyParams(pydantic.BaseModel):
    aws_vpc_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_AwsVpcConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefPlacementconstraintpropertyParams(pydantic.BaseModel):
    expression: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRuleDefPlacementstrategypropertyParams(pydantic.BaseModel):
    field: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRuleDefRedshiftdataparameterspropertyParams(pydantic.BaseModel):
    database: str = pydantic.Field(..., description='')
    sql: str = pydantic.Field(..., description='')
    db_user: typing.Optional[str] = pydantic.Field(None, description='')
    secret_manager_arn: typing.Optional[str] = pydantic.Field(None, description='')
    statement_name: typing.Optional[str] = pydantic.Field(None, description='')
    with_event: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefRetrypolicypropertyParams(pydantic.BaseModel):
    maximum_event_age_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    maximum_retry_attempts: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefRuncommandparameterspropertyParams(pydantic.BaseModel):
    run_command_targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_RunCommandTargetPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnRuleDefRuncommandtargetpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    values: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnRuleDefSagemakerpipelineparameterpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnRuleDefSagemakerpipelineparameterspropertyParams(pydantic.BaseModel):
    pipeline_parameter_list: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_SageMakerPipelineParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefSqsparameterspropertyParams(pydantic.BaseModel):
    message_group_id: str = pydantic.Field(..., description='')
    ...

class CfnRuleDefTagpropertyParams(pydantic.BaseModel):
    key: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRuleDefTargetpropertyParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    batch_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_BatchParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    dead_letter_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_DeadLetterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ecs_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_EcsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_HttpParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    input: typing.Optional[str] = pydantic.Field(None, description='')
    input_path: typing.Optional[str] = pydantic.Field(None, description='')
    input_transformer: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_InputTransformerPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    kinesis_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_KinesisParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    redshift_data_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_RedshiftDataParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    retry_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_RetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    run_command_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_RunCommandParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sage_maker_pipeline_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_SageMakerPipelineParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sqs_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_SqsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnRuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_events.CfnApiDestinationProps
class CfnApiDestinationPropsDef(BaseCfnProperty):
    connection_arn: str = pydantic.Field(..., description='The ARN of the connection to use for the API destination. The destination endpoint must support the authorization type specified for the connection.\n')
    http_method: str = pydantic.Field(..., description='The method to use for the request to the HTTP invocation endpoint.\n')
    invocation_endpoint: str = pydantic.Field(..., description='The URL to the HTTP invocation endpoint for the API destination.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the API destination to create.\n')
    invocation_rate_limit_per_second: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of requests per second to send to the HTTP invocation endpoint.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name for the API destination to create.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-apidestination.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    cfn_api_destination_props = events.CfnApiDestinationProps(\n        connection_arn="connectionArn",\n        http_method="httpMethod",\n        invocation_endpoint="invocationEndpoint",\n\n        # the properties below are optional\n        description="description",\n        invocation_rate_limit_per_second=123,\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_arn', 'http_method', 'invocation_endpoint', 'description', 'invocation_rate_limit_per_second', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnApiDestinationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnArchiveProps
class CfnArchivePropsDef(BaseCfnProperty):
    source_arn: str = pydantic.Field(..., description='The ARN of the event bus that sends events to the archive.\n')
    archive_name: typing.Optional[str] = pydantic.Field(None, description='The name for the archive to create.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the archive.\n')
    event_pattern: typing.Any = pydantic.Field(None, description='An event pattern to use to filter events sent to the archive.\n')
    retention_days: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days to retain events for. Default value is 0. If set to 0, events are retained indefinitely\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-archive.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    # event_pattern: Any\n\n    cfn_archive_props = events.CfnArchiveProps(\n        source_arn="sourceArn",\n\n        # the properties below are optional\n        archive_name="archiveName",\n        description="description",\n        event_pattern=event_pattern,\n        retention_days=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source_arn', 'archive_name', 'description', 'event_pattern', 'retention_days']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnArchiveProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnConnectionProps
class CfnConnectionPropsDef(BaseCfnProperty):
    authorization_type: str = pydantic.Field(..., description='The type of authorization to use for the connection. .. epigraph:: OAUTH tokens are refreshed when a 401 or 407 response is returned.\n')
    auth_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnConnection_AuthParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A ``CreateConnectionAuthRequestParameters`` object that contains the authorization parameters to use to authorize with the endpoint.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the connection to create.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name for the connection to create.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-connection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    cfn_connection_props = events.CfnConnectionProps(\n        authorization_type="authorizationType",\n        auth_parameters=events.CfnConnection.AuthParametersProperty(\n            api_key_auth_parameters=events.CfnConnection.ApiKeyAuthParametersProperty(\n                api_key_name="apiKeyName",\n                api_key_value="apiKeyValue"\n            ),\n            basic_auth_parameters=events.CfnConnection.BasicAuthParametersProperty(\n                password="password",\n                username="username"\n            ),\n            invocation_http_parameters=events.CfnConnection.ConnectionHttpParametersProperty(\n                body_parameters=[events.CfnConnection.ParameterProperty(\n                    key="key",\n                    value="value",\n\n                    # the properties below are optional\n                    is_value_secret=False\n                )],\n                header_parameters=[events.CfnConnection.ParameterProperty(\n                    key="key",\n                    value="value",\n\n                    # the properties below are optional\n                    is_value_secret=False\n                )],\n                query_string_parameters=[events.CfnConnection.ParameterProperty(\n                    key="key",\n                    value="value",\n\n                    # the properties below are optional\n                    is_value_secret=False\n                )]\n            ),\n            o_auth_parameters=events.CfnConnection.OAuthParametersProperty(\n                authorization_endpoint="authorizationEndpoint",\n                client_parameters=events.CfnConnection.ClientParametersProperty(\n                    client_id="clientId",\n                    client_secret="clientSecret"\n                ),\n                http_method="httpMethod",\n\n                # the properties below are optional\n                o_auth_http_parameters=events.CfnConnection.ConnectionHttpParametersProperty(\n                    body_parameters=[events.CfnConnection.ParameterProperty(\n                        key="key",\n                        value="value",\n\n                        # the properties below are optional\n                        is_value_secret=False\n                    )],\n                    header_parameters=[events.CfnConnection.ParameterProperty(\n                        key="key",\n                        value="value",\n\n                        # the properties below are optional\n                        is_value_secret=False\n                    )],\n                    query_string_parameters=[events.CfnConnection.ParameterProperty(\n                        key="key",\n                        value="value",\n\n                        # the properties below are optional\n                        is_value_secret=False\n                    )]\n                )\n            )\n        ),\n\n        # the properties below are optional\n        description="description",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorization_type', 'auth_parameters', 'description', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnConnectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEndpointProps
class CfnEndpointPropsDef(BaseCfnProperty):
    event_buses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_EndpointEventBusPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='The event buses being used by the endpoint. *Exactly* : ``2``\n')
    routing_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_RoutingConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The routing configuration of the endpoint.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the endpoint.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the endpoint.\n')
    replication_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEndpoint_ReplicationConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Whether event replication was enabled or disabled for this endpoint. The default state is ``ENABLED`` which means you must supply a ``RoleArn`` . If you don't have a ``RoleArn`` or you don't want event replication enabled, set the state to ``DISABLED`` .\n")
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role used by event replication for the endpoint.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-endpoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    cfn_endpoint_props = events.CfnEndpointProps(\n        event_buses=[events.CfnEndpoint.EndpointEventBusProperty(\n            event_bus_arn="eventBusArn"\n        )],\n        routing_config=events.CfnEndpoint.RoutingConfigProperty(\n            failover_config=events.CfnEndpoint.FailoverConfigProperty(\n                primary=events.CfnEndpoint.PrimaryProperty(\n                    health_check="healthCheck"\n                ),\n                secondary=events.CfnEndpoint.SecondaryProperty(\n                    route="route"\n                )\n            )\n        ),\n\n        # the properties below are optional\n        description="description",\n        name="name",\n        replication_config=events.CfnEndpoint.ReplicationConfigProperty(\n            state="state"\n        ),\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_buses', 'routing_config', 'description', 'name', 'replication_config', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEndpointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEventBusPolicyProps
class CfnEventBusPolicyPropsDef(BaseCfnProperty):
    statement_id: str = pydantic.Field(..., description='An identifier string for the external account that you are granting permissions to. If you later want to revoke the permission for this external account, specify this ``StatementId`` when you run `RemovePermission <https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_RemovePermission.html>`_ . .. epigraph:: Each ``StatementId`` must be unique.\n')
    action: typing.Optional[str] = pydantic.Field(None, description='The action that you are enabling the other account to perform.\n')
    condition: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnEventBusPolicy_ConditionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='This parameter enables you to limit the permission to accounts that fulfill a certain condition, such as being a member of a certain AWS organization. For more information about AWS Organizations, see `What Is AWS Organizations <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html>`_ in the *AWS Organizations User Guide* . If you specify ``Condition`` with an AWS organization ID, and specify "*" as the value for ``Principal`` , you grant permission to all the accounts in the named organization. The ``Condition`` is a JSON string which must contain ``Type`` , ``Key`` , and ``Value`` fields.\n')
    event_bus_name: typing.Optional[str] = pydantic.Field(None, description='The name of the event bus associated with the rule. If you omit this, the default event bus is used.\n')
    principal: typing.Optional[str] = pydantic.Field(None, description='The 12-digit AWS account ID that you are permitting to put events to your default event bus. Specify "*" to permit any account to put events to your default event bus. If you specify "*" without specifying ``Condition`` , avoid creating rules that may match undesirable events. To create more secure rules, make sure that the event pattern for each rule contains an ``account`` field with a specific account ID from which to receive events. Rules with an account field do not match any events sent from other accounts.\n')
    statement: typing.Any = pydantic.Field(None, description='A JSON string that describes the permission policy statement. You can include a ``Policy`` parameter in the request instead of using the ``StatementId`` , ``Action`` , ``Principal`` , or ``Condition`` parameters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    # statement: Any\n\n    cfn_event_bus_policy_props = events.CfnEventBusPolicyProps(\n        statement_id="statementId",\n\n        # the properties below are optional\n        action="action",\n        condition=events.CfnEventBusPolicy.ConditionProperty(\n            key="key",\n            type="type",\n            value="value"\n        ),\n        event_bus_name="eventBusName",\n        principal="principal",\n        statement=statement\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['statement_id', 'action', 'condition', 'event_bus_name', 'principal', 'statement']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEventBusPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnEventBusProps
class CfnEventBusPropsDef(BaseCfnProperty):
    name: str = pydantic.Field(..., description="The name of the new event bus. Custom event bus names can't contain the ``/`` character, but you can use the ``/`` character in partner event bus names. In addition, for partner event buses, the name must exactly match the name of the partner event source that this event bus is matched to. You can't use the name ``default`` for a custom event bus, as this name is already used for your account's default event bus.\n")
    event_source_name: typing.Optional[str] = pydantic.Field(None, description='If you are creating a partner event bus, this specifies the partner event source that the new event bus will be matched with.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.aws_events.CfnEventBus_TagEntryPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Tags to associate with the event bus.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    cfn_event_bus_props = events.CfnEventBusProps(\n        name="name",\n\n        # the properties below are optional\n        event_source_name="eventSourceName",\n        tags=[events.CfnEventBus.TagEntryProperty(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'event_source_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnEventBusProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_events.CfnRuleProps
class CfnRulePropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the rule.\n')
    event_bus_name: typing.Optional[str] = pydantic.Field(None, description='The name or ARN of the event bus associated with the rule. If you omit this, the default event bus is used.\n')
    event_pattern: typing.Any = pydantic.Field(None, description='The event pattern of the rule. For more information, see `Events and Event Patterns <https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html>`_ in the *Amazon EventBridge User Guide* .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the rule.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon Resource Name (ARN) of the role that is used for target invocation. If you're setting an event bus in another account as the target and that account granted permission to your account through an organization instead of directly by the account ID, you must specify a ``RoleArn`` with proper permissions in the ``Target`` structure, instead of here in this parameter.\n")
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)". For more information, see `Creating an Amazon EventBridge rule that runs on a schedule <https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-create-rule-schedule.html>`_ .\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state of the rule.\n')
    targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_events.CfnRule_TargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Adds the specified targets to the specified rule, or updates the targets if they are already associated with the rule. Targets are the resources that are invoked when a rule is triggered. The maximum number of entries per request is 10. .. epigraph:: Each rule can have up to five (5) targets associated with it at one time. For a list of services you can configure as targets for events, see `EventBridge targets <https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html>`_ in the *Amazon EventBridge User Guide* . Creating rules with built-in targets is supported only in the AWS Management Console . The built-in targets are: - ``Amazon EBS CreateSnapshot API call`` - ``Amazon EC2 RebootInstances API call`` - ``Amazon EC2 StopInstances API call`` - ``Amazon EC2 TerminateInstances API call`` For some target types, ``PutTargets`` provides target-specific parameters. If the target is a Kinesis data stream, you can optionally specify which shard the event goes to by using the ``KinesisParameters`` argument. To invoke a command on multiple EC2 instances with one rule, you can use the ``RunCommandParameters`` field. To be able to make API calls against the resources that you own, Amazon EventBridge needs the appropriate permissions: - For AWS Lambda and Amazon SNS resources, EventBridge relies on resource-based policies. - For EC2 instances, Kinesis Data Streams, AWS Step Functions state machines and API Gateway APIs, EventBridge relies on IAM roles that you specify in the ``RoleARN`` argument in ``PutTargets`` . For more information, see `Authentication and Access Control <https://docs.aws.amazon.com/eventbridge/latest/userguide/auth-and-access-control-eventbridge.html>`_ in the *Amazon EventBridge User Guide* . If another AWS account is in the same region and has granted you permission (using ``PutPermission`` ), you can send events to that account. Set that account\'s event bus as a target of the rules in your account. To send the matched events to the other account, specify that account\'s event bus as the ``Arn`` value when you run ``PutTargets`` . If your account sends events to another account, your account is charged for each sent event. Each event sent to another account is charged as a custom event. The account receiving the event is not charged. For more information, see `Amazon EventBridge Pricing <https://docs.aws.amazon.com/eventbridge/pricing/>`_ . .. epigraph:: ``Input`` , ``InputPath`` , and ``InputTransformer`` are not available with ``PutTarget`` if the target is an event bus of a different AWS account. If you are setting the event bus of another account as the target, and that account granted permission to your account through an organization instead of directly by the account ID, then you must specify a ``RoleArn`` with proper permissions in the ``Target`` structure. For more information, see `Sending and Receiving Events Between AWS Accounts <https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html>`_ in the *Amazon EventBridge User Guide* . .. epigraph:: If you have an IAM role on a cross-account event bus target, a ``PutTargets`` call without a role on the same target (same ``Id`` and ``Arn`` ) will not remove the role. For more information about enabling cross-account events, see `PutPermission <https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutPermission.html>`_ . *Input* , *InputPath* , and *InputTransformer* are mutually exclusive and optional parameters of a target. When a rule is triggered due to a matched event: - If none of the following arguments are specified for a target, then the entire event is passed to the target in JSON format (unless the target is Amazon EC2 Run Command or Amazon ECS task, in which case nothing from the event is passed to the target). - If *Input* is specified in the form of valid JSON, then the matched event is overridden with this constant. - If *InputPath* is specified in the form of JSONPath (for example, ``$.detail`` ), then only the part of the event specified in the path is passed to the target (for example, only the detail part of the event is passed). - If *InputTransformer* is specified, then one or more specified JSONPaths are extracted from the event and used as values in a template that you specify as the input to the target. When you specify ``InputPath`` or ``InputTransformer`` , you must use JSON dot notation, not bracket notation. When you add targets to a rule and the associated rule triggers soon after, new or updated targets might not be immediately invoked. Allow a short period of time for changes to take effect. This action can partially fail if too many requests are made at the same time. If that happens, ``FailedEntryCount`` is non-zero in the response and each entry in ``FailedEntries`` provides the ID of the failed target and the error code.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-rule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_events as events\n\n    # event_pattern: Any\n\n    cfn_rule_props = events.CfnRuleProps(\n        description="description",\n        event_bus_name="eventBusName",\n        event_pattern=event_pattern,\n        name="name",\n        role_arn="roleArn",\n        schedule_expression="scheduleExpression",\n        state="state",\n        targets=[events.CfnRule.TargetProperty(\n            arn="arn",\n            id="id",\n\n            # the properties below are optional\n            batch_parameters=events.CfnRule.BatchParametersProperty(\n                job_definition="jobDefinition",\n                job_name="jobName",\n\n                # the properties below are optional\n                array_properties=events.CfnRule.BatchArrayPropertiesProperty(\n                    size=123\n                ),\n                retry_strategy=events.CfnRule.BatchRetryStrategyProperty(\n                    attempts=123\n                )\n            ),\n            dead_letter_config=events.CfnRule.DeadLetterConfigProperty(\n                arn="arn"\n            ),\n            ecs_parameters=events.CfnRule.EcsParametersProperty(\n                task_definition_arn="taskDefinitionArn",\n\n                # the properties below are optional\n                capacity_provider_strategy=[events.CfnRule.CapacityProviderStrategyItemProperty(\n                    capacity_provider="capacityProvider",\n\n                    # the properties below are optional\n                    base=123,\n                    weight=123\n                )],\n                enable_ecs_managed_tags=False,\n                enable_execute_command=False,\n                group="group",\n                launch_type="launchType",\n                network_configuration=events.CfnRule.NetworkConfigurationProperty(\n                    aws_vpc_configuration=events.CfnRule.AwsVpcConfigurationProperty(\n                        subnets=["subnets"],\n\n                        # the properties below are optional\n                        assign_public_ip="assignPublicIp",\n                        security_groups=["securityGroups"]\n                    )\n                ),\n                placement_constraints=[events.CfnRule.PlacementConstraintProperty(\n                    expression="expression",\n                    type="type"\n                )],\n                placement_strategies=[events.CfnRule.PlacementStrategyProperty(\n                    field="field",\n                    type="type"\n                )],\n                platform_version="platformVersion",\n                propagate_tags="propagateTags",\n                reference_id="referenceId",\n                tag_list=[CfnTag(\n                    key="key",\n                    value="value"\n                )],\n                task_count=123\n            ),\n            http_parameters=events.CfnRule.HttpParametersProperty(\n                header_parameters={\n                    "header_parameters_key": "headerParameters"\n                },\n                path_parameter_values=["pathParameterValues"],\n                query_string_parameters={\n                    "query_string_parameters_key": "queryStringParameters"\n                }\n            ),\n            input="input",\n            input_path="inputPath",\n            input_transformer=events.CfnRule.InputTransformerProperty(\n                input_template="inputTemplate",\n\n                # the properties below are optional\n                input_paths_map={\n                    "input_paths_map_key": "inputPathsMap"\n                }\n            ),\n            kinesis_parameters=events.CfnRule.KinesisParametersProperty(\n                partition_key_path="partitionKeyPath"\n            ),\n            redshift_data_parameters=events.CfnRule.RedshiftDataParametersProperty(\n                database="database",\n                sql="sql",\n\n                # the properties below are optional\n                db_user="dbUser",\n                secret_manager_arn="secretManagerArn",\n                statement_name="statementName",\n                with_event=False\n            ),\n            retry_policy=events.CfnRule.RetryPolicyProperty(\n                maximum_event_age_in_seconds=123,\n                maximum_retry_attempts=123\n            ),\n            role_arn="roleArn",\n            run_command_parameters=events.CfnRule.RunCommandParametersProperty(\n                run_command_targets=[events.CfnRule.RunCommandTargetProperty(\n                    key="key",\n                    values=["values"]\n                )]\n            ),\n            sage_maker_pipeline_parameters=events.CfnRule.SageMakerPipelineParametersProperty(\n                pipeline_parameter_list=[events.CfnRule.SageMakerPipelineParameterProperty(\n                    name="name",\n                    value="value"\n                )]\n            ),\n            sqs_parameters=events.CfnRule.SqsParametersProperty(\n                message_group_id="messageGroupId"\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'event_bus_name', 'event_pattern', 'name', 'role_arn', 'schedule_expression', 'state', 'targets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_events.CfnRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    Authorization: typing.Optional[dict[str, AuthorizationDef]] = pydantic.Field(None)
    EventField: typing.Optional[dict[str, EventFieldDef]] = pydantic.Field(None)
    HttpParameter: typing.Optional[dict[str, HttpParameterDef]] = pydantic.Field(None)
    Match: typing.Optional[dict[str, MatchDef]] = pydantic.Field(None)
    RuleTargetInput: typing.Optional[dict[str, RuleTargetInputDef]] = pydantic.Field(None)
    Schedule: typing.Optional[dict[str, ScheduleDef]] = pydantic.Field(None)
    ApiDestination: typing.Optional[dict[str, ApiDestinationDef]] = pydantic.Field(None)
    Archive: typing.Optional[dict[str, ArchiveDef]] = pydantic.Field(None)
    Connection: typing.Optional[dict[str, ConnectionDef]] = pydantic.Field(None)
    EventBus: typing.Optional[dict[str, EventBusDef]] = pydantic.Field(None)
    EventBusPolicy: typing.Optional[dict[str, EventBusPolicyDef]] = pydantic.Field(None)
    Rule: typing.Optional[dict[str, RuleDef]] = pydantic.Field(None)
    ApiDestinationProps: typing.Optional[dict[str, ApiDestinationPropsDef]] = pydantic.Field(None)
    ArchiveProps: typing.Optional[dict[str, ArchivePropsDef]] = pydantic.Field(None)
    BaseArchiveProps: typing.Optional[dict[str, BaseArchivePropsDef]] = pydantic.Field(None)
    CfnConnection_ApiKeyAuthParametersProperty: typing.Optional[dict[str, CfnConnection_ApiKeyAuthParametersPropertyDef]] = pydantic.Field(None)
    CfnConnection_AuthParametersProperty: typing.Optional[dict[str, CfnConnection_AuthParametersPropertyDef]] = pydantic.Field(None)
    CfnConnection_BasicAuthParametersProperty: typing.Optional[dict[str, CfnConnection_BasicAuthParametersPropertyDef]] = pydantic.Field(None)
    CfnConnection_ClientParametersProperty: typing.Optional[dict[str, CfnConnection_ClientParametersPropertyDef]] = pydantic.Field(None)
    CfnConnection_ConnectionHttpParametersProperty: typing.Optional[dict[str, CfnConnection_ConnectionHttpParametersPropertyDef]] = pydantic.Field(None)
    CfnConnection_OAuthParametersProperty: typing.Optional[dict[str, CfnConnection_OAuthParametersPropertyDef]] = pydantic.Field(None)
    CfnConnection_ParameterProperty: typing.Optional[dict[str, CfnConnection_ParameterPropertyDef]] = pydantic.Field(None)
    CfnEndpoint_EndpointEventBusProperty: typing.Optional[dict[str, CfnEndpoint_EndpointEventBusPropertyDef]] = pydantic.Field(None)
    CfnEndpoint_FailoverConfigProperty: typing.Optional[dict[str, CfnEndpoint_FailoverConfigPropertyDef]] = pydantic.Field(None)
    CfnEndpoint_PrimaryProperty: typing.Optional[dict[str, CfnEndpoint_PrimaryPropertyDef]] = pydantic.Field(None)
    CfnEndpoint_ReplicationConfigProperty: typing.Optional[dict[str, CfnEndpoint_ReplicationConfigPropertyDef]] = pydantic.Field(None)
    CfnEndpoint_RoutingConfigProperty: typing.Optional[dict[str, CfnEndpoint_RoutingConfigPropertyDef]] = pydantic.Field(None)
    CfnEndpoint_SecondaryProperty: typing.Optional[dict[str, CfnEndpoint_SecondaryPropertyDef]] = pydantic.Field(None)
    CfnEventBus_TagEntryProperty: typing.Optional[dict[str, CfnEventBus_TagEntryPropertyDef]] = pydantic.Field(None)
    CfnEventBusPolicy_ConditionProperty: typing.Optional[dict[str, CfnEventBusPolicy_ConditionPropertyDef]] = pydantic.Field(None)
    CfnRule_AwsVpcConfigurationProperty: typing.Optional[dict[str, CfnRule_AwsVpcConfigurationPropertyDef]] = pydantic.Field(None)
    CfnRule_BatchArrayPropertiesProperty: typing.Optional[dict[str, CfnRule_BatchArrayPropertiesPropertyDef]] = pydantic.Field(None)
    CfnRule_BatchParametersProperty: typing.Optional[dict[str, CfnRule_BatchParametersPropertyDef]] = pydantic.Field(None)
    CfnRule_BatchRetryStrategyProperty: typing.Optional[dict[str, CfnRule_BatchRetryStrategyPropertyDef]] = pydantic.Field(None)
    CfnRule_CapacityProviderStrategyItemProperty: typing.Optional[dict[str, CfnRule_CapacityProviderStrategyItemPropertyDef]] = pydantic.Field(None)
    CfnRule_DeadLetterConfigProperty: typing.Optional[dict[str, CfnRule_DeadLetterConfigPropertyDef]] = pydantic.Field(None)
    CfnRule_EcsParametersProperty: typing.Optional[dict[str, CfnRule_EcsParametersPropertyDef]] = pydantic.Field(None)
    CfnRule_HttpParametersProperty: typing.Optional[dict[str, CfnRule_HttpParametersPropertyDef]] = pydantic.Field(None)
    CfnRule_InputTransformerProperty: typing.Optional[dict[str, CfnRule_InputTransformerPropertyDef]] = pydantic.Field(None)
    CfnRule_KinesisParametersProperty: typing.Optional[dict[str, CfnRule_KinesisParametersPropertyDef]] = pydantic.Field(None)
    CfnRule_NetworkConfigurationProperty: typing.Optional[dict[str, CfnRule_NetworkConfigurationPropertyDef]] = pydantic.Field(None)
    CfnRule_PlacementConstraintProperty: typing.Optional[dict[str, CfnRule_PlacementConstraintPropertyDef]] = pydantic.Field(None)
    CfnRule_PlacementStrategyProperty: typing.Optional[dict[str, CfnRule_PlacementStrategyPropertyDef]] = pydantic.Field(None)
    CfnRule_RedshiftDataParametersProperty: typing.Optional[dict[str, CfnRule_RedshiftDataParametersPropertyDef]] = pydantic.Field(None)
    CfnRule_RetryPolicyProperty: typing.Optional[dict[str, CfnRule_RetryPolicyPropertyDef]] = pydantic.Field(None)
    CfnRule_RunCommandParametersProperty: typing.Optional[dict[str, CfnRule_RunCommandParametersPropertyDef]] = pydantic.Field(None)
    CfnRule_RunCommandTargetProperty: typing.Optional[dict[str, CfnRule_RunCommandTargetPropertyDef]] = pydantic.Field(None)
    CfnRule_SageMakerPipelineParameterProperty: typing.Optional[dict[str, CfnRule_SageMakerPipelineParameterPropertyDef]] = pydantic.Field(None)
    CfnRule_SageMakerPipelineParametersProperty: typing.Optional[dict[str, CfnRule_SageMakerPipelineParametersPropertyDef]] = pydantic.Field(None)
    CfnRule_SqsParametersProperty: typing.Optional[dict[str, CfnRule_SqsParametersPropertyDef]] = pydantic.Field(None)
    CfnRule_TagProperty: typing.Optional[dict[str, CfnRule_TagPropertyDef]] = pydantic.Field(None)
    CfnRule_TargetProperty: typing.Optional[dict[str, CfnRule_TargetPropertyDef]] = pydantic.Field(None)
    ConnectionAttributes: typing.Optional[dict[str, ConnectionAttributesDef]] = pydantic.Field(None)
    ConnectionProps: typing.Optional[dict[str, ConnectionPropsDef]] = pydantic.Field(None)
    CronOptions: typing.Optional[dict[str, CronOptionsDef]] = pydantic.Field(None)
    EventBusAttributes: typing.Optional[dict[str, EventBusAttributesDef]] = pydantic.Field(None)
    EventBusPolicyProps: typing.Optional[dict[str, EventBusPolicyPropsDef]] = pydantic.Field(None)
    EventBusProps: typing.Optional[dict[str, EventBusPropsDef]] = pydantic.Field(None)
    EventCommonOptions: typing.Optional[dict[str, EventCommonOptionsDef]] = pydantic.Field(None)
    EventPattern: typing.Optional[dict[str, EventPatternDef]] = pydantic.Field(None)
    OAuthAuthorizationProps: typing.Optional[dict[str, OAuthAuthorizationPropsDef]] = pydantic.Field(None)
    OnEventOptions: typing.Optional[dict[str, OnEventOptionsDef]] = pydantic.Field(None)
    RuleProps: typing.Optional[dict[str, RulePropsDef]] = pydantic.Field(None)
    RuleTargetConfig: typing.Optional[dict[str, RuleTargetConfigDef]] = pydantic.Field(None)
    RuleTargetInputProperties: typing.Optional[dict[str, RuleTargetInputPropertiesDef]] = pydantic.Field(None)
    CfnApiDestination: typing.Optional[dict[str, CfnApiDestinationDef]] = pydantic.Field(None)
    CfnArchive: typing.Optional[dict[str, CfnArchiveDef]] = pydantic.Field(None)
    CfnConnection: typing.Optional[dict[str, CfnConnectionDef]] = pydantic.Field(None)
    CfnEndpoint: typing.Optional[dict[str, CfnEndpointDef]] = pydantic.Field(None)
    CfnEventBus: typing.Optional[dict[str, CfnEventBusDef]] = pydantic.Field(None)
    CfnEventBusPolicy: typing.Optional[dict[str, CfnEventBusPolicyDef]] = pydantic.Field(None)
    CfnRule: typing.Optional[dict[str, CfnRuleDef]] = pydantic.Field(None)
    CfnApiDestinationProps: typing.Optional[dict[str, CfnApiDestinationPropsDef]] = pydantic.Field(None)
    CfnArchiveProps: typing.Optional[dict[str, CfnArchivePropsDef]] = pydantic.Field(None)
    CfnConnectionProps: typing.Optional[dict[str, CfnConnectionPropsDef]] = pydantic.Field(None)
    CfnEndpointProps: typing.Optional[dict[str, CfnEndpointPropsDef]] = pydantic.Field(None)
    CfnEventBusPolicyProps: typing.Optional[dict[str, CfnEventBusPolicyPropsDef]] = pydantic.Field(None)
    CfnEventBusProps: typing.Optional[dict[str, CfnEventBusPropsDef]] = pydantic.Field(None)
    CfnRuleProps: typing.Optional[dict[str, CfnRulePropsDef]] = pydantic.Field(None)
    ...
