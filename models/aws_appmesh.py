from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_appmesh.AccessLog
class AccessLogDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_file_path']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.AccessLog'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_file_path']
    ...


    from_file_path: typing.Optional[AccessLogDefFromFilePathParams] = pydantic.Field(None, description='Path to a file to write access logs to.')
    resource_config: typing.Optional[AccessLogDefConfig] = pydantic.Field(None)


class AccessLogDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[AccessLogDefBindParams]] = pydantic.Field(None, description='Called when the AccessLog type is initialized.\nCan be used to enforce\nmutual exclusivity with future properties')

class AccessLogDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class AccessLogDefFromFilePathParams(pydantic.BaseModel):
    file_path: str = pydantic.Field(..., description='-\n')
    logging_format: typing.Optional[models.aws_appmesh.LoggingFormatDef] = pydantic.Field(None, description='-\n\n:default: - no file based access logging\n')
    ...


#  autogenerated from aws_cdk.aws_appmesh.Backend
class BackendDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['virtual_service']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.Backend'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[BackendDefConfig] = pydantic.Field(None)


class BackendDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[BackendDefBindParams]] = pydantic.Field(None, description='Return backend config.')
    virtual_service: typing.Optional[list[BackendDefVirtualServiceParams]] = pydantic.Field(None, description='Construct a Virtual Service backend.')

class BackendDefBindParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class BackendDefVirtualServiceParams(pydantic.BaseModel):
    virtual_service: typing.Union[models.aws_appmesh.VirtualServiceDef] = pydantic.Field(..., description='-\n')
    tls_client_policy: typing.Union[models.aws_appmesh.TlsClientPolicyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='TLS properties for Client policy for the backend. Default: - none')
    return_config: typing.Optional[list[models.aws_appmesh.BackendDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.GatewayRouteHostnameMatch
class GatewayRouteHostnameMatchDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['ends_with', 'exactly']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GatewayRouteHostnameMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[GatewayRouteHostnameMatchDefConfig] = pydantic.Field(None)


class GatewayRouteHostnameMatchDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[GatewayRouteHostnameMatchDefBindParams]] = pydantic.Field(None, description='Returns the gateway route host name match configuration.')
    ends_with: typing.Optional[list[GatewayRouteHostnameMatchDefEndsWithParams]] = pydantic.Field(None, description='The value of the host name with the given name must end with the specified characters.')
    exactly: typing.Optional[list[GatewayRouteHostnameMatchDefExactlyParams]] = pydantic.Field(None, description='The value of the host name must match the specified value exactly.')

class GatewayRouteHostnameMatchDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class GatewayRouteHostnameMatchDefEndsWithParams(pydantic.BaseModel):
    suffix: str = pydantic.Field(..., description='The specified ending characters of the host name to match on.')
    return_config: typing.Optional[list[models.aws_appmesh.GatewayRouteHostnameMatchDefConfig]] = pydantic.Field(None)
    ...

class GatewayRouteHostnameMatchDefExactlyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='The exact host name to match on.')
    return_config: typing.Optional[list[models.aws_appmesh.GatewayRouteHostnameMatchDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.GatewayRouteSpec
class GatewayRouteSpecDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GatewayRouteSpec'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[GatewayRouteSpecDefConfig] = pydantic.Field(None)


class GatewayRouteSpecDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[GatewayRouteSpecDefBindParams]] = pydantic.Field(None, description='Called when the GatewayRouteSpec type is initialized.\nCan be used to enforce\nmutual exclusivity with future properties')
    grpc: typing.Optional[list[GatewayRouteSpecDefGrpcParams]] = pydantic.Field(None, description='Creates an gRPC Based GatewayRoute.')
    http: typing.Optional[list[GatewayRouteSpecDefHttpParams]] = pydantic.Field(None, description='Creates an HTTP Based GatewayRoute.')
    http2: typing.Optional[list[GatewayRouteSpecDefHttp2Params]] = pydantic.Field(None, description='Creates an HTTP2 Based GatewayRoute.')

class GatewayRouteSpecDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class GatewayRouteSpecDefGrpcParams(pydantic.BaseModel):
    match: typing.Union[models.aws_appmesh.GrpcGatewayRouteMatchDef, dict[str, typing.Any]] = pydantic.Field(..., description='The criterion for determining a request match for this GatewayRoute.\n')
    route_target: typing.Union[models.aws_appmesh.VirtualServiceDef] = pydantic.Field(..., description='The VirtualService this GatewayRoute directs traffic to.\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the gateway route. When a Virtual Gateway has multiple gateway routes, gateway route match is performed in the order of specified value, where 0 is the highest priority, and first matched gateway route is selected. Default: - no particular priority')
    return_config: typing.Optional[list[models.aws_appmesh.GatewayRouteSpecDefConfig]] = pydantic.Field(None)
    ...

class GatewayRouteSpecDefHttpParams(pydantic.BaseModel):
    route_target: typing.Union[models.aws_appmesh.VirtualServiceDef] = pydantic.Field(..., description='The VirtualService this GatewayRoute directs traffic to.\n')
    match: typing.Union[models.aws_appmesh.HttpGatewayRouteMatchDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The criterion for determining a request match for this GatewayRoute. When path match is defined, this may optionally determine the path rewrite configuration. Default: - matches any path and automatically rewrites the path to '/'\n")
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the gateway route. When a Virtual Gateway has multiple gateway routes, gateway route match is performed in the order of specified value, where 0 is the highest priority, and first matched gateway route is selected. Default: - no particular priority')
    return_config: typing.Optional[list[models.aws_appmesh.GatewayRouteSpecDefConfig]] = pydantic.Field(None)
    ...

class GatewayRouteSpecDefHttp2Params(pydantic.BaseModel):
    route_target: typing.Union[models.aws_appmesh.VirtualServiceDef] = pydantic.Field(..., description='The VirtualService this GatewayRoute directs traffic to.\n')
    match: typing.Union[models.aws_appmesh.HttpGatewayRouteMatchDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The criterion for determining a request match for this GatewayRoute. When path match is defined, this may optionally determine the path rewrite configuration. Default: - matches any path and automatically rewrites the path to '/'\n")
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the gateway route. When a Virtual Gateway has multiple gateway routes, gateway route match is performed in the order of specified value, where 0 is the highest priority, and first matched gateway route is selected. Default: - no particular priority')
    return_config: typing.Optional[list[models.aws_appmesh.GatewayRouteSpecDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.HeaderMatch
class HeaderMatchDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['value_does_not_end_with', 'value_does_not_match_regex', 'value_does_not_start_with', 'value_ends_with', 'value_is', 'value_is_not', 'value_matches_regex', 'value_starts_with', 'values_is_in_range', 'values_is_not_in_range']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HeaderMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[HeaderMatchDefConfig] = pydantic.Field(None)


class HeaderMatchDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[HeaderMatchDefBindParams]] = pydantic.Field(None, description='Returns the header match configuration.')
    value_does_not_end_with: typing.Optional[list[HeaderMatchDefValueDoesNotEndWithParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must not end with the specified characters.')
    value_does_not_match_regex: typing.Optional[list[HeaderMatchDefValueDoesNotMatchRegexParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must not include the specified characters.')
    value_does_not_start_with: typing.Optional[list[HeaderMatchDefValueDoesNotStartWithParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must not start with the specified characters.')
    value_ends_with: typing.Optional[list[HeaderMatchDefValueEndsWithParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must end with the specified characters.')
    value_is: typing.Optional[list[HeaderMatchDefValueIsParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must match the specified value exactly.')
    value_is_not: typing.Optional[list[HeaderMatchDefValueIsNotParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must not match the specified value exactly.')
    value_matches_regex: typing.Optional[list[HeaderMatchDefValueMatchesRegexParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must include the specified characters.')
    value_starts_with: typing.Optional[list[HeaderMatchDefValueStartsWithParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must start with the specified characters.')
    values_is_in_range: typing.Optional[list[HeaderMatchDefValuesIsInRangeParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must be in a range of values.')
    values_is_not_in_range: typing.Optional[list[HeaderMatchDefValuesIsNotInRangeParams]] = pydantic.Field(None, description='The value of the header with the given name in the request must not be in a range of values.')

class HeaderMatchDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class HeaderMatchDefValueDoesNotEndWithParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    suffix: str = pydantic.Field(..., description='The suffix to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValueDoesNotMatchRegexParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    regex: str = pydantic.Field(..., description='The regex to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValueDoesNotStartWithParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    prefix: str = pydantic.Field(..., description='The prefix to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValueEndsWithParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    suffix: str = pydantic.Field(..., description='The suffix to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValueIsParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    header_value: str = pydantic.Field(..., description='The exact value to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValueIsNotParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    header_value: str = pydantic.Field(..., description='The exact value to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValueMatchesRegexParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    regex: str = pydantic.Field(..., description='The regex to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValueStartsWithParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    prefix: str = pydantic.Field(..., description='The prefix to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValuesIsInRangeParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    start: typing.Union[int, float] = pydantic.Field(..., description='Match on values starting at and including this value.\n')
    end: typing.Union[int, float] = pydantic.Field(..., description='Match on values up to but not including this value.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...

class HeaderMatchDefValuesIsNotInRangeParams(pydantic.BaseModel):
    header_name: str = pydantic.Field(..., description='the name of the header to match against.\n')
    start: typing.Union[int, float] = pydantic.Field(..., description='Match on values starting at and including this value.\n')
    end: typing.Union[int, float] = pydantic.Field(..., description='Match on values up to but not including this value.')
    return_config: typing.Optional[list[models.aws_appmesh.HeaderMatchDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.HealthCheck
class HealthCheckDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2', 'tcp']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HealthCheck'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[HealthCheckDefConfig] = pydantic.Field(None)


class HealthCheckDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[HealthCheckDefBindParams]] = pydantic.Field(None, description='Called when the AccessLog type is initialized.\nCan be used to enforce\nmutual exclusivity with future properties')
    grpc: typing.Optional[list[HealthCheckDefGrpcParams]] = pydantic.Field(None, description='Construct a GRPC health check.')
    http: typing.Optional[list[HealthCheckDefHttpParams]] = pydantic.Field(None, description='Construct a HTTP health check.')
    http2: typing.Optional[list[HealthCheckDefHttp2Params]] = pydantic.Field(None, description='Construct a HTTP2 health check.')
    tcp: typing.Optional[list[HealthCheckDefTcpParams]] = pydantic.Field(None, description='Construct a TCP health check.')

class HealthCheckDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    default_port: typing.Union[int, float, None] = pydantic.Field(None, description='Port for Health Check interface. Default: - no default port is provided')
    ...

class HealthCheckDefGrpcParams(pydantic.BaseModel):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive successful health checks that must occur before declaring listener healthy. Default: 2\n')
    interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The time period between each health check execution. Default: Duration.seconds(5)\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time to wait when receiving a response from the health check. Default: Duration.seconds(2)\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive failed health checks that must occur before declaring a listener unhealthy. Default: - 2')
    return_config: typing.Optional[list[models.aws_appmesh.HealthCheckDefConfig]] = pydantic.Field(None)
    ...

class HealthCheckDefHttpParams(pydantic.BaseModel):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive successful health checks that must occur before declaring listener healthy. Default: 2\n')
    interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The time period between each health check execution. Default: Duration.seconds(5)\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The destination path for the health check request. Default: /\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time to wait when receiving a response from the health check. Default: Duration.seconds(2)\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive failed health checks that must occur before declaring a listener unhealthy. Default: - 2')
    return_config: typing.Optional[list[models.aws_appmesh.HealthCheckDefConfig]] = pydantic.Field(None)
    ...

class HealthCheckDefHttp2Params(pydantic.BaseModel):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive successful health checks that must occur before declaring listener healthy. Default: 2\n')
    interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The time period between each health check execution. Default: Duration.seconds(5)\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The destination path for the health check request. Default: /\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time to wait when receiving a response from the health check. Default: Duration.seconds(2)\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive failed health checks that must occur before declaring a listener unhealthy. Default: - 2')
    return_config: typing.Optional[list[models.aws_appmesh.HealthCheckDefConfig]] = pydantic.Field(None)
    ...

class HealthCheckDefTcpParams(pydantic.BaseModel):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive successful health checks that must occur before declaring listener healthy. Default: 2\n')
    interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The time period between each health check execution. Default: Duration.seconds(5)\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time to wait when receiving a response from the health check. Default: Duration.seconds(2)\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive failed health checks that must occur before declaring a listener unhealthy. Default: - 2')
    return_config: typing.Optional[list[models.aws_appmesh.HealthCheckDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.HttpGatewayRoutePathMatch
class HttpGatewayRoutePathMatchDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['exactly', 'regex', 'starts_with']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpGatewayRoutePathMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[HttpGatewayRoutePathMatchDefConfig] = pydantic.Field(None)


class HttpGatewayRoutePathMatchDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[HttpGatewayRoutePathMatchDefBindParams]] = pydantic.Field(None, description='Returns the gateway route path match configuration.')
    exactly: typing.Optional[list[HttpGatewayRoutePathMatchDefExactlyParams]] = pydantic.Field(None, description="The value of the path must match the specified value exactly.\nThe provided ``path`` must start with the '/' character.")
    regex: typing.Optional[list[HttpGatewayRoutePathMatchDefRegexParams]] = pydantic.Field(None, description='The value of the path must match the specified regex.')
    starts_with: typing.Optional[list[HttpGatewayRoutePathMatchDefStartsWithParams]] = pydantic.Field(None, description='The value of the path must match the specified prefix.')

class HttpGatewayRoutePathMatchDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class HttpGatewayRoutePathMatchDefExactlyParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='the exact path to match on.\n')
    rewrite_to: typing.Optional[str] = pydantic.Field(None, description="the value to substitute for the matched part of the path of the gateway request URL As a default, retains original request's URL path.")
    return_config: typing.Optional[list[models.aws_appmesh.HttpGatewayRoutePathMatchDefConfig]] = pydantic.Field(None)
    ...

class HttpGatewayRoutePathMatchDefRegexParams(pydantic.BaseModel):
    regex: str = pydantic.Field(..., description='the regex used to match the path.\n')
    rewrite_to: typing.Optional[str] = pydantic.Field(None, description="the value to substitute for the matched part of the path of the gateway request URL As a default, retains original request's URL path.")
    return_config: typing.Optional[list[models.aws_appmesh.HttpGatewayRoutePathMatchDefConfig]] = pydantic.Field(None)
    ...

class HttpGatewayRoutePathMatchDefStartsWithParams(pydantic.BaseModel):
    prefix: str = pydantic.Field(..., description='the value to use to match the beginning of the path part of the URL of the request. It must start with the \'/\' character. When ``rewriteTo`` is provided, it must also end with the \'/\' character. If provided as "/", matches all requests. For example, if your virtual service name is "my-service.local" and you want the route to match requests to "my-service.local/metrics", your prefix should be "/metrics".\n')
    rewrite_to: typing.Optional[str] = pydantic.Field(None, description="Specify either disabling automatic rewrite or rewriting to specified prefix path. To disable automatic rewrite, provide ``''``. As a default, request's URL path is automatically rewritten to '/'.")
    return_config: typing.Optional[list[models.aws_appmesh.HttpGatewayRoutePathMatchDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.HttpRoutePathMatch
class HttpRoutePathMatchDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['exactly', 'regex', 'starts_with']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpRoutePathMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[HttpRoutePathMatchDefConfig] = pydantic.Field(None)


class HttpRoutePathMatchDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[HttpRoutePathMatchDefBindParams]] = pydantic.Field(None, description='Returns the route path match configuration.')
    exactly: typing.Optional[list[HttpRoutePathMatchDefExactlyParams]] = pydantic.Field(None, description="The value of the path must match the specified value exactly.\nThe provided ``path`` must start with the '/' character.")
    regex: typing.Optional[list[HttpRoutePathMatchDefRegexParams]] = pydantic.Field(None, description='The value of the path must match the specified regex.')
    starts_with: typing.Optional[list[HttpRoutePathMatchDefStartsWithParams]] = pydantic.Field(None, description='The value of the path must match the specified prefix.')

class HttpRoutePathMatchDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class HttpRoutePathMatchDefExactlyParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='the exact path to match on.')
    return_config: typing.Optional[list[models.aws_appmesh.HttpRoutePathMatchDefConfig]] = pydantic.Field(None)
    ...

class HttpRoutePathMatchDefRegexParams(pydantic.BaseModel):
    regex: str = pydantic.Field(..., description='the regex used to match the path.')
    return_config: typing.Optional[list[models.aws_appmesh.HttpRoutePathMatchDefConfig]] = pydantic.Field(None)
    ...

class HttpRoutePathMatchDefStartsWithParams(pydantic.BaseModel):
    prefix: str = pydantic.Field(..., description='the value to use to match the beginning of the path part of the URL of the request. It must start with the \'/\' character. If provided as "/", matches all requests. For example, if your virtual service name is "my-service.local" and you want the route to match requests to "my-service.local/metrics", your prefix should be "/metrics".')
    return_config: typing.Optional[list[models.aws_appmesh.HttpRoutePathMatchDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.LoggingFormat
class LoggingFormatDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_json', 'from_text']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.LoggingFormat'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_json', 'from_text']
    ...


    from_json: typing.Optional[LoggingFormatDefFromJsonParams] = pydantic.Field(None, description='Generate logging format from json key pairs.')
    from_text: typing.Optional[LoggingFormatDefFromTextParams] = pydantic.Field(None, description='Generate logging format from text pattern.')
    resource_config: typing.Optional[LoggingFormatDefConfig] = pydantic.Field(None)


class LoggingFormatDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[LoggingFormatDefBindParams]] = pydantic.Field(None, description='Called when the Access Log Format is initialized.\nCan be used to enforce\nmutual exclusivity with future properties')

class LoggingFormatDefBindParams(pydantic.BaseModel):
    ...

class LoggingFormatDefFromJsonParams(pydantic.BaseModel):
    json_logging_format: typing.Mapping[str, str] = pydantic.Field(..., description='-')
    ...

class LoggingFormatDefFromTextParams(pydantic.BaseModel):
    text: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_appmesh.MutualTlsCertificate
class MutualTlsCertificateDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['acm', 'file', 'sds']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.MutualTlsCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MutualTlsCertificateDefConfig] = pydantic.Field(None)


class MutualTlsCertificateDefConfig(pydantic.BaseModel):
    acm: typing.Optional[list[MutualTlsCertificateDefAcmParams]] = pydantic.Field(None, description='Returns an ACM TLS Certificate.')
    bind: typing.Optional[list[MutualTlsCertificateDefBindParams]] = pydantic.Field(None, description='Returns TLS certificate based provider.')
    file: typing.Optional[list[MutualTlsCertificateDefFileParams]] = pydantic.Field(None, description='Returns an File TLS Certificate.')
    sds: typing.Optional[list[MutualTlsCertificateDefSdsParams]] = pydantic.Field(None, description='Returns an SDS TLS Certificate.')

class MutualTlsCertificateDefAcmParams(pydantic.BaseModel):
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.TlsCertificateDefConfig]] = pydantic.Field(None)
    ...

class MutualTlsCertificateDefBindParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class MutualTlsCertificateDefFileParams(pydantic.BaseModel):
    certificate_chain_path: str = pydantic.Field(..., description='-\n')
    private_key_path: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.MutualTlsCertificateDefConfig]] = pydantic.Field(None)
    ...

class MutualTlsCertificateDefSdsParams(pydantic.BaseModel):
    secret_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.MutualTlsCertificateDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.MutualTlsValidationTrust
class MutualTlsValidationTrustDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['acm', 'file', 'sds']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.MutualTlsValidationTrust'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MutualTlsValidationTrustDefConfig] = pydantic.Field(None)


class MutualTlsValidationTrustDefConfig(pydantic.BaseModel):
    acm: typing.Optional[list[MutualTlsValidationTrustDefAcmParams]] = pydantic.Field(None, description='TLS Validation Context Trust for ACM Private Certificate Authority (CA).')
    bind: typing.Optional[list[MutualTlsValidationTrustDefBindParams]] = pydantic.Field(None, description='Returns Trust context based on trust type.')
    file: typing.Optional[list[MutualTlsValidationTrustDefFileParams]] = pydantic.Field(None, description='Tells envoy where to fetch the validation context from.')
    sds: typing.Optional[list[MutualTlsValidationTrustDefSdsParams]] = pydantic.Field(None, description="TLS Validation Context Trust for Envoy' service discovery service.")

class MutualTlsValidationTrustDefAcmParams(pydantic.BaseModel):
    certificate_authorities: typing.Sequence[models.UnsupportedResource] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.TlsValidationTrustDefConfig]] = pydantic.Field(None)
    ...

class MutualTlsValidationTrustDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class MutualTlsValidationTrustDefFileParams(pydantic.BaseModel):
    certificate_chain: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.MutualTlsValidationTrustDefConfig]] = pydantic.Field(None)
    ...

class MutualTlsValidationTrustDefSdsParams(pydantic.BaseModel):
    secret_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.MutualTlsValidationTrustDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.QueryParameterMatch
class QueryParameterMatchDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['value_is']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.QueryParameterMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[QueryParameterMatchDefConfig] = pydantic.Field(None)


class QueryParameterMatchDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[QueryParameterMatchDefBindParams]] = pydantic.Field(None, description='Returns the query parameter match configuration.')
    value_is: typing.Optional[list[QueryParameterMatchDefValueIsParams]] = pydantic.Field(None, description='The value of the query parameter with the given name in the request must match the specified value exactly.')

class QueryParameterMatchDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class QueryParameterMatchDefValueIsParams(pydantic.BaseModel):
    query_parameter_name: str = pydantic.Field(..., description='the name of the query parameter to match against.\n')
    query_parameter_value: str = pydantic.Field(..., description='The exact value to test against.')
    return_config: typing.Optional[list[models.aws_appmesh.QueryParameterMatchDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.RouteSpec
class RouteSpecDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2', 'tcp']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.RouteSpec'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RouteSpecDefConfig] = pydantic.Field(None)


class RouteSpecDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[RouteSpecDefBindParams]] = pydantic.Field(None, description='Called when the RouteSpec type is initialized.\nCan be used to enforce\nmutual exclusivity with future properties')
    grpc: typing.Optional[list[RouteSpecDefGrpcParams]] = pydantic.Field(None, description='Creates a GRPC Based RouteSpec.')
    http: typing.Optional[list[RouteSpecDefHttpParams]] = pydantic.Field(None, description='Creates an HTTP Based RouteSpec.')
    http2: typing.Optional[list[RouteSpecDefHttp2Params]] = pydantic.Field(None, description='Creates an HTTP2 Based RouteSpec.')
    tcp: typing.Optional[list[RouteSpecDefTcpParams]] = pydantic.Field(None, description='Creates a TCP Based RouteSpec.')

class RouteSpecDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class RouteSpecDefGrpcParams(pydantic.BaseModel):
    match: typing.Union[models.aws_appmesh.GrpcRouteMatchDef, dict[str, typing.Any]] = pydantic.Field(..., description='The criterion for determining a request match for this Route.\n')
    weighted_targets: typing.Sequence[typing.Union[models.aws_appmesh.WeightedTargetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='List of targets that traffic is routed to when a request matches the route.\n')
    retry_policy: typing.Union[models.aws_appmesh.GrpcRetryPolicyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The retry policy. Default: - no retry policy\n')
    timeout: typing.Union[models.aws_appmesh.GrpcTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a grpc timeout. Default: - None\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority')
    return_config: typing.Optional[list[models.aws_appmesh.RouteSpecDefConfig]] = pydantic.Field(None)
    ...

class RouteSpecDefHttpParams(pydantic.BaseModel):
    weighted_targets: typing.Sequence[typing.Union[models.aws_appmesh.WeightedTargetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='List of targets that traffic is routed to when a request matches the route.\n')
    match: typing.Union[models.aws_appmesh.HttpRouteMatchDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The criterion for determining a request match for this Route. Default: - matches on '/'\n")
    retry_policy: typing.Union[models.aws_appmesh.HttpRetryPolicyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The retry policy. Default: - no retry policy\n')
    timeout: typing.Union[models.aws_appmesh.HttpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a http timeout. Default: - None\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority')
    return_config: typing.Optional[list[models.aws_appmesh.RouteSpecDefConfig]] = pydantic.Field(None)
    ...

class RouteSpecDefHttp2Params(pydantic.BaseModel):
    weighted_targets: typing.Sequence[typing.Union[models.aws_appmesh.WeightedTargetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='List of targets that traffic is routed to when a request matches the route.\n')
    match: typing.Union[models.aws_appmesh.HttpRouteMatchDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The criterion for determining a request match for this Route. Default: - matches on '/'\n")
    retry_policy: typing.Union[models.aws_appmesh.HttpRetryPolicyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The retry policy. Default: - no retry policy\n')
    timeout: typing.Union[models.aws_appmesh.HttpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a http timeout. Default: - None\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority')
    return_config: typing.Optional[list[models.aws_appmesh.RouteSpecDefConfig]] = pydantic.Field(None)
    ...

class RouteSpecDefTcpParams(pydantic.BaseModel):
    weighted_targets: typing.Sequence[typing.Union[models.aws_appmesh.WeightedTargetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='List of targets that traffic is routed to when a request matches the route.\n')
    timeout: typing.Union[models.aws_appmesh.TcpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a tcp timeout. Default: - None\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority')
    return_config: typing.Optional[list[models.aws_appmesh.RouteSpecDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.ServiceDiscovery
class ServiceDiscoveryDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['cloud_map', 'dns']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.ServiceDiscovery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ServiceDiscoveryDefConfig] = pydantic.Field(None)


class ServiceDiscoveryDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[ServiceDiscoveryDefBindParams]] = pydantic.Field(None, description='Binds the current object when adding Service Discovery to a VirtualNode.')
    cloud_map: typing.Optional[list[ServiceDiscoveryDefCloudMapParams]] = pydantic.Field(None, description='Returns Cloud Map based service discovery.')
    dns: typing.Optional[list[ServiceDiscoveryDefDnsParams]] = pydantic.Field(None, description='Returns DNS based service discovery.')

class ServiceDiscoveryDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class ServiceDiscoveryDefCloudMapParams(pydantic.BaseModel):
    service: typing.Union[models.aws_servicediscovery.ServiceDef] = pydantic.Field(..., description='The AWS Cloud Map Service to use for service discovery.\n')
    instance_attributes: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A string map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.\n')
    ip_preference: typing.Optional[aws_cdk.aws_appmesh.IpPreference] = pydantic.Field(None, description='No IP preference is applied to the Virtual Node.')
    return_config: typing.Optional[list[models.aws_appmesh.ServiceDiscoveryDefConfig]] = pydantic.Field(None)
    ...

class ServiceDiscoveryDefDnsParams(pydantic.BaseModel):
    hostname: str = pydantic.Field(..., description='-\n')
    response_type: typing.Optional[aws_cdk.aws_appmesh.DnsResponseType] = pydantic.Field(None, description='Specifies the DNS response type for the virtual node. The default is ``DnsResponseType.LOAD_BALANCER``.\n')
    ip_preference: typing.Optional[aws_cdk.aws_appmesh.IpPreference] = pydantic.Field(None, description='No IP preference is applied to the Virtual Node.')
    return_config: typing.Optional[list[models.aws_appmesh.ServiceDiscoveryDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.SubjectAlternativeNames
class SubjectAlternativeNamesDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['matching_exactly']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.SubjectAlternativeNames'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SubjectAlternativeNamesDefConfig] = pydantic.Field(None)


class SubjectAlternativeNamesDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[SubjectAlternativeNamesDefBindParams]] = pydantic.Field(None, description='Returns Subject Alternative Names Matcher based on method type.')
    matching_exactly: typing.Optional[list[SubjectAlternativeNamesDefMatchingExactlyParams]] = pydantic.Field(None, description='The values of the SAN must match the specified values exactly.')

class SubjectAlternativeNamesDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class SubjectAlternativeNamesDefMatchingExactlyParams(pydantic.BaseModel):
    names: list[str] = pydantic.Field(...)
    return_config: typing.Optional[list[models.aws_appmesh.SubjectAlternativeNamesDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.TlsCertificate
class TlsCertificateDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['acm', 'file', 'sds']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TlsCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[TlsCertificateDefConfig] = pydantic.Field(None)


class TlsCertificateDefConfig(pydantic.BaseModel):
    acm: typing.Optional[list[TlsCertificateDefAcmParams]] = pydantic.Field(None, description='Returns an ACM TLS Certificate.')
    bind: typing.Optional[list[TlsCertificateDefBindParams]] = pydantic.Field(None, description='Returns TLS certificate based provider.')
    file: typing.Optional[list[TlsCertificateDefFileParams]] = pydantic.Field(None, description='Returns an File TLS Certificate.')
    sds: typing.Optional[list[TlsCertificateDefSdsParams]] = pydantic.Field(None, description='Returns an SDS TLS Certificate.')

class TlsCertificateDefAcmParams(pydantic.BaseModel):
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.TlsCertificateDefConfig]] = pydantic.Field(None)
    ...

class TlsCertificateDefBindParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class TlsCertificateDefFileParams(pydantic.BaseModel):
    certificate_chain_path: str = pydantic.Field(..., description='-\n')
    private_key_path: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.MutualTlsCertificateDefConfig]] = pydantic.Field(None)
    ...

class TlsCertificateDefSdsParams(pydantic.BaseModel):
    secret_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.MutualTlsCertificateDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.TlsValidationTrust
class TlsValidationTrustDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['acm', 'file', 'sds']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TlsValidationTrust'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[TlsValidationTrustDefConfig] = pydantic.Field(None)


class TlsValidationTrustDefConfig(pydantic.BaseModel):
    acm: typing.Optional[list[TlsValidationTrustDefAcmParams]] = pydantic.Field(None, description='TLS Validation Context Trust for ACM Private Certificate Authority (CA).')
    bind: typing.Optional[list[TlsValidationTrustDefBindParams]] = pydantic.Field(None, description='Returns Trust context based on trust type.')
    file: typing.Optional[list[TlsValidationTrustDefFileParams]] = pydantic.Field(None, description='Tells envoy where to fetch the validation context from.')
    sds: typing.Optional[list[TlsValidationTrustDefSdsParams]] = pydantic.Field(None, description="TLS Validation Context Trust for Envoy' service discovery service.")

class TlsValidationTrustDefAcmParams(pydantic.BaseModel):
    certificate_authorities: typing.Sequence[models.UnsupportedResource] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.TlsValidationTrustDefConfig]] = pydantic.Field(None)
    ...

class TlsValidationTrustDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class TlsValidationTrustDefFileParams(pydantic.BaseModel):
    certificate_chain: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.MutualTlsValidationTrustDefConfig]] = pydantic.Field(None)
    ...

class TlsValidationTrustDefSdsParams(pydantic.BaseModel):
    secret_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.MutualTlsValidationTrustDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.VirtualGatewayListener
class VirtualGatewayListenerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualGatewayListener'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualGatewayListenerDefConfig] = pydantic.Field(None)


class VirtualGatewayListenerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[VirtualGatewayListenerDefBindParams]] = pydantic.Field(None, description='Called when the GatewayListener type is initialized.\nCan be used to enforce\nmutual exclusivity')
    grpc: typing.Optional[list[VirtualGatewayListenerDefGrpcParams]] = pydantic.Field(None, description='Returns a GRPC Listener for a VirtualGateway.')
    http: typing.Optional[list[VirtualGatewayListenerDefHttpParams]] = pydantic.Field(None, description='Returns an HTTP Listener for a VirtualGateway.')
    http2: typing.Optional[list[VirtualGatewayListenerDefHttp2Params]] = pydantic.Field(None, description='Returns an HTTP2 Listener for a VirtualGateway.')

class VirtualGatewayListenerDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class VirtualGatewayListenerDefGrpcParams(pydantic.BaseModel):
    connection_pool: typing.Union[models.aws_appmesh.GrpcConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualGatewayListenerDefConfig]] = pydantic.Field(None)
    ...

class VirtualGatewayListenerDefHttpParams(pydantic.BaseModel):
    connection_pool: typing.Union[models.aws_appmesh.HttpConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualGatewayListenerDefConfig]] = pydantic.Field(None)
    ...

class VirtualGatewayListenerDefHttp2Params(pydantic.BaseModel):
    connection_pool: typing.Union[models.aws_appmesh.Http2ConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualGatewayListenerDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.VirtualNodeListener
class VirtualNodeListenerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2', 'tcp']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualNodeListener'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualNodeListenerDefConfig] = pydantic.Field(None)


class VirtualNodeListenerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[VirtualNodeListenerDefBindParams]] = pydantic.Field(None, description='Binds the current object when adding Listener to a VirtualNode.')
    grpc: typing.Optional[list[VirtualNodeListenerDefGrpcParams]] = pydantic.Field(None, description='Returns an GRPC Listener for a VirtualNode.')
    http: typing.Optional[list[VirtualNodeListenerDefHttpParams]] = pydantic.Field(None, description='Returns an HTTP Listener for a VirtualNode.')
    http2: typing.Optional[list[VirtualNodeListenerDefHttp2Params]] = pydantic.Field(None, description='Returns an HTTP2 Listener for a VirtualNode.')
    tcp: typing.Optional[list[VirtualNodeListenerDefTcpParams]] = pydantic.Field(None, description='Returns an TCP Listener for a VirtualNode.')

class VirtualNodeListenerDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class VirtualNodeListenerDefGrpcParams(pydantic.BaseModel):
    connection_pool: typing.Union[models.aws_appmesh.GrpcConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    outlier_detection: typing.Union[models.aws_appmesh.OutlierDetectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling outlier detection. Default: - none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    timeout: typing.Union[models.aws_appmesh.GrpcTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Timeout for GRPC protocol. Default: - None\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualNodeListenerDefConfig]] = pydantic.Field(None)
    ...

class VirtualNodeListenerDefHttpParams(pydantic.BaseModel):
    connection_pool: typing.Union[models.aws_appmesh.HttpConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    outlier_detection: typing.Union[models.aws_appmesh.OutlierDetectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling outlier detection. Default: - none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    timeout: typing.Union[models.aws_appmesh.HttpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Timeout for HTTP protocol. Default: - None\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualNodeListenerDefConfig]] = pydantic.Field(None)
    ...

class VirtualNodeListenerDefHttp2Params(pydantic.BaseModel):
    connection_pool: typing.Union[models.aws_appmesh.Http2ConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http2 listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    outlier_detection: typing.Union[models.aws_appmesh.OutlierDetectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling outlier detection. Default: - none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    timeout: typing.Union[models.aws_appmesh.HttpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Timeout for HTTP protocol. Default: - None\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualNodeListenerDefConfig]] = pydantic.Field(None)
    ...

class VirtualNodeListenerDefTcpParams(pydantic.BaseModel):
    connection_pool: typing.Union[models.aws_appmesh.TcpConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    outlier_detection: typing.Union[models.aws_appmesh.OutlierDetectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling outlier detection. Default: - none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    timeout: typing.Union[models.aws_appmesh.TcpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Timeout for TCP protocol. Default: - None\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualNodeListenerDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.VirtualRouterListener
class VirtualRouterListenerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2', 'tcp']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualRouterListener'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualRouterListenerDefConfig] = pydantic.Field(None)


class VirtualRouterListenerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[VirtualRouterListenerDefBindParams]] = pydantic.Field(None, description='Called when the VirtualRouterListener type is initialized.\nCan be used to enforce\nmutual exclusivity')
    grpc: typing.Optional[list[VirtualRouterListenerDefGrpcParams]] = pydantic.Field(None, description='Returns a GRPC Listener for a VirtualRouter.')
    http: typing.Optional[list[VirtualRouterListenerDefHttpParams]] = pydantic.Field(None, description='Returns an HTTP Listener for a VirtualRouter.')
    http2: typing.Optional[list[VirtualRouterListenerDefHttp2Params]] = pydantic.Field(None, description='Returns an HTTP2 Listener for a VirtualRouter.')
    tcp: typing.Optional[list[VirtualRouterListenerDefTcpParams]] = pydantic.Field(None, description='Returns a TCP Listener for a VirtualRouter.')

class VirtualRouterListenerDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class VirtualRouterListenerDefGrpcParams(pydantic.BaseModel):
    port: typing.Union[int, float, None] = pydantic.Field(None, description='the optional port of the listener, 8080 by default.')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualRouterListenerDefConfig]] = pydantic.Field(None)
    ...

class VirtualRouterListenerDefHttpParams(pydantic.BaseModel):
    port: typing.Union[int, float, None] = pydantic.Field(None, description='the optional port of the listener, 8080 by default.')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualRouterListenerDefConfig]] = pydantic.Field(None)
    ...

class VirtualRouterListenerDefHttp2Params(pydantic.BaseModel):
    port: typing.Union[int, float, None] = pydantic.Field(None, description='the optional port of the listener, 8080 by default.')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualRouterListenerDefConfig]] = pydantic.Field(None)
    ...

class VirtualRouterListenerDefTcpParams(pydantic.BaseModel):
    port: typing.Union[int, float, None] = pydantic.Field(None, description='the optional port of the listener, 8080 by default.')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualRouterListenerDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.VirtualServiceProvider
class VirtualServiceProviderDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['none', 'virtual_node', 'virtual_router']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualServiceProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualServiceProviderDefConfig] = pydantic.Field(None)


class VirtualServiceProviderDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[VirtualServiceProviderDefBindParams]] = pydantic.Field(None, description='Enforces mutual exclusivity for VirtualService provider types.')
    none: typing.Optional[list[VirtualServiceProviderDefNoneParams]] = pydantic.Field(None, description='Returns an Empty Provider for a VirtualService.\nThis provides no routing capabilities\nand should only be used as a placeholder')
    virtual_node: typing.Optional[list[VirtualServiceProviderDefVirtualNodeParams]] = pydantic.Field(None, description='Returns a VirtualNode based Provider for a VirtualService.')
    virtual_router: typing.Optional[list[VirtualServiceProviderDefVirtualRouterParams]] = pydantic.Field(None, description='Returns a VirtualRouter based Provider for a VirtualService.')

class VirtualServiceProviderDefBindParams(pydantic.BaseModel):
    _construct: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualServiceProviderConfigDefConfig]] = pydantic.Field(None)
    ...

class VirtualServiceProviderDefNoneParams(pydantic.BaseModel):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualServiceProviderDefConfig]] = pydantic.Field(None)
    ...

class VirtualServiceProviderDefVirtualNodeParams(pydantic.BaseModel):
    virtual_node: typing.Union[models.aws_appmesh.VirtualNodeDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualServiceProviderDefConfig]] = pydantic.Field(None)
    ...

class VirtualServiceProviderDefVirtualRouterParams(pydantic.BaseModel):
    virtual_router: typing.Union[models.aws_appmesh.VirtualRouterDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualServiceProviderDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.GatewayRoute
class GatewayRouteDef(BaseConstruct):
    virtual_gateway: typing.Union[models.aws_appmesh.VirtualGatewayDef] = pydantic.Field(..., description='The VirtualGateway this GatewayRoute is associated with.\n')
    route_spec: models.aws_appmesh.GatewayRouteSpecDef = pydantic.Field(..., description='What protocol the route uses.\n')
    gateway_route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the GatewayRoute. Default: - an automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['virtual_gateway', 'route_spec', 'gateway_route_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_gateway_route_arn', 'from_gateway_route_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GatewayRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_gateway_route_arn', 'from_gateway_route_attributes']
    ...


    from_gateway_route_arn: typing.Optional[GatewayRouteDefFromGatewayRouteArnParams] = pydantic.Field(None, description='Import an existing GatewayRoute given an ARN.')
    from_gateway_route_attributes: typing.Optional[GatewayRouteDefFromGatewayRouteAttributesParams] = pydantic.Field(None, description='Import an existing GatewayRoute given attributes.')
    resource_config: typing.Optional[GatewayRouteDefConfig] = pydantic.Field(None)


class GatewayRouteDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    virtual_gateway_config: typing.Optional[models._interface_methods.AwsAppmeshIVirtualGatewayDefConfig] = pydantic.Field(None)

class GatewayRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class GatewayRouteDefFromGatewayRouteArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    gateway_route_arn: str = pydantic.Field(..., description='-')
    ...

class GatewayRouteDefFromGatewayRouteAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    gateway_route_name: str = pydantic.Field(..., description='The name of the GatewayRoute.\n')
    virtual_gateway: typing.Union[models.aws_appmesh.VirtualGatewayDef] = pydantic.Field(..., description='The VirtualGateway this GatewayRoute is associated with.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.Mesh
class MeshDef(BaseConstruct):
    egress_filter: typing.Optional[aws_cdk.aws_appmesh.MeshFilterType] = pydantic.Field(None, description='Egress filter to be applied to the Mesh. Default: DROP_ALL\n')
    mesh_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Mesh being defined. Default: - A name is automatically generated\n')
    service_discovery: typing.Union[models.aws_appmesh.MeshServiceDiscoveryDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines how upstream clients will discover VirtualNodes in the Mesh. Default: - No Service Discovery')
    _init_params: typing.ClassVar[list[str]] = ['egress_filter', 'mesh_name', 'service_discovery']
    _method_names: typing.ClassVar[list[str]] = ['add_virtual_gateway', 'add_virtual_node', 'add_virtual_router', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_mesh_arn', 'from_mesh_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.Mesh'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_mesh_arn', 'from_mesh_name']
    ...


    from_mesh_arn: typing.Optional[MeshDefFromMeshArnParams] = pydantic.Field(None, description='Import an existing mesh by arn.')
    from_mesh_name: typing.Optional[MeshDefFromMeshNameParams] = pydantic.Field(None, description='Import an existing mesh by name.')
    resource_config: typing.Optional[MeshDefConfig] = pydantic.Field(None)


class MeshDefConfig(pydantic.BaseModel):
    add_virtual_gateway: typing.Optional[list[MeshDefAddVirtualGatewayParams]] = pydantic.Field(None, description='Adds a VirtualGateway to the Mesh.')
    add_virtual_node: typing.Optional[list[MeshDefAddVirtualNodeParams]] = pydantic.Field(None, description='Adds a VirtualNode to the Mesh.')
    add_virtual_router: typing.Optional[list[MeshDefAddVirtualRouterParams]] = pydantic.Field(None, description='Adds a VirtualRouter to the Mesh with the given id and props.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class MeshDefAddVirtualGatewayParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    access_log: typing.Optional[models.aws_appmesh.AccessLogDef] = pydantic.Field(None, description='Access Logging Configuration for the VirtualGateway. Default: - no access logging\n')
    backend_defaults: typing.Union[models.aws_appmesh.BackendDefaultsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Default Configuration Virtual Node uses to communicate with Virtual Service. Default: - No Config\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualGatewayListenerDef]] = pydantic.Field(None, description='Listeners for the VirtualGateway. Only one is supported. Default: - Single HTTP listener on port 8080\n')
    virtual_gateway_name: typing.Optional[str] = pydantic.Field(None, description='Name of the VirtualGateway. Default: - A name is automatically determined')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualGatewayDefConfig]] = pydantic.Field(None)
    ...

class MeshDefAddVirtualNodeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    access_log: typing.Optional[models.aws_appmesh.AccessLogDef] = pydantic.Field(None, description='Access Logging Configuration for the virtual node. Default: - No access logging\n')
    backend_defaults: typing.Union[models.aws_appmesh.BackendDefaultsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Default Configuration Virtual Node uses to communicate with Virtual Service. Default: - No Config\n')
    backends: typing.Optional[typing.Sequence[models.aws_appmesh.BackendDef]] = pydantic.Field(None, description='Virtual Services that this is node expected to send outbound traffic to. Default: - No backends\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualNodeListenerDef]] = pydantic.Field(None, description='Initial listener for the virtual node. Default: - No listeners\n')
    service_discovery: typing.Optional[models.aws_appmesh.ServiceDiscoveryDef] = pydantic.Field(None, description='Defines how upstream clients will discover this VirtualNode. Default: - No Service Discovery\n')
    virtual_node_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualNode. Default: - A name is automatically determined')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualNodeDefConfig]] = pydantic.Field(None)
    ...

class MeshDefAddVirtualRouterParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualRouterListenerDef]] = pydantic.Field(None, description='Listener specification for the VirtualRouter. Default: - A listener on HTTP port 8080\n')
    virtual_router_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualRouter. Default: - A name is automatically determined')
    return_config: typing.Optional[list[models.aws_appmesh.VirtualRouterDefConfig]] = pydantic.Field(None)
    ...

class MeshDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class MeshDefFromMeshArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    mesh_arn: str = pydantic.Field(..., description='-')
    ...

class MeshDefFromMeshNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    mesh_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_appmesh.Route
class RouteDef(BaseConstruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The service mesh to define the route in.\n')
    virtual_router: typing.Union[models.aws_appmesh.VirtualRouterDef] = pydantic.Field(..., description='The VirtualRouter the Route belongs to.\n')
    route_spec: models.aws_appmesh.RouteSpecDef = pydantic.Field(..., description='Protocol specific spec.\n')
    route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the route. Default: - An automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'virtual_router', 'route_spec', 'route_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_route_arn', 'from_route_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.Route'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_route_arn', 'from_route_attributes']
    ...


    from_route_arn: typing.Optional[RouteDefFromRouteArnParams] = pydantic.Field(None, description='Import an existing Route given an ARN.')
    from_route_attributes: typing.Optional[RouteDefFromRouteAttributesParams] = pydantic.Field(None, description='Import an existing Route given attributes.')
    resource_config: typing.Optional[RouteDefConfig] = pydantic.Field(None)


class RouteDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    virtual_router_config: typing.Optional[models._interface_methods.AwsAppmeshIVirtualRouterDefConfig] = pydantic.Field(None)

class RouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class RouteDefFromRouteArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    route_arn: str = pydantic.Field(..., description='-')
    ...

class RouteDefFromRouteAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    route_name: str = pydantic.Field(..., description='The name of the Route.\n')
    virtual_router: typing.Union[models.aws_appmesh.VirtualRouterDef] = pydantic.Field(..., description='The VirtualRouter the Route belongs to.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.VirtualGateway
class VirtualGatewayDef(BaseConstruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualGateway belongs to.\n')
    access_log: typing.Optional[models.aws_appmesh.AccessLogDef] = pydantic.Field(None, description='Access Logging Configuration for the VirtualGateway. Default: - no access logging\n')
    backend_defaults: typing.Union[models.aws_appmesh.BackendDefaultsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Default Configuration Virtual Node uses to communicate with Virtual Service. Default: - No Config\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualGatewayListenerDef]] = pydantic.Field(None, description='Listeners for the VirtualGateway. Only one is supported. Default: - Single HTTP listener on port 8080\n')
    virtual_gateway_name: typing.Optional[str] = pydantic.Field(None, description='Name of the VirtualGateway. Default: - A name is automatically determined')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'access_log', 'backend_defaults', 'listeners', 'virtual_gateway_name']
    _method_names: typing.ClassVar[list[str]] = ['add_gateway_route', 'apply_removal_policy', 'grant_stream_aggregated_resources']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_virtual_gateway_arn', 'from_virtual_gateway_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_virtual_gateway_arn', 'from_virtual_gateway_attributes']
    ...


    from_virtual_gateway_arn: typing.Optional[VirtualGatewayDefFromVirtualGatewayArnParams] = pydantic.Field(None, description='Import an existing VirtualGateway given an ARN.')
    from_virtual_gateway_attributes: typing.Optional[VirtualGatewayDefFromVirtualGatewayAttributesParams] = pydantic.Field(None, description='Import an existing VirtualGateway given its attributes.')
    resource_config: typing.Optional[VirtualGatewayDefConfig] = pydantic.Field(None)


class VirtualGatewayDefConfig(pydantic.BaseModel):
    add_gateway_route: typing.Optional[list[VirtualGatewayDefAddGatewayRouteParams]] = pydantic.Field(None, description='Utility method to add a new GatewayRoute to the VirtualGateway.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_stream_aggregated_resources: typing.Optional[list[VirtualGatewayDefGrantStreamAggregatedResourcesParams]] = pydantic.Field(None, description='Grants the given entity ``appmesh:StreamAggregatedResources``.')
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)

class VirtualGatewayDefAddGatewayRouteParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    route_spec: models.aws_appmesh.GatewayRouteSpecDef = pydantic.Field(..., description='What protocol the route uses.\n')
    gateway_route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the GatewayRoute. Default: - an automatically generated name')
    return_config: typing.Optional[list[models.aws_appmesh.GatewayRouteDefConfig]] = pydantic.Field(None)
    ...

class VirtualGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VirtualGatewayDefFromVirtualGatewayArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    virtual_gateway_arn: str = pydantic.Field(..., description='-')
    ...

class VirtualGatewayDefFromVirtualGatewayAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh that the VirtualGateway belongs to.\n')
    virtual_gateway_name: str = pydantic.Field(..., description='The name of the VirtualGateway.')
    ...

class VirtualGatewayDefGrantStreamAggregatedResourcesParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.VirtualNode
class VirtualNodeDef(BaseConstruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualNode belongs to.\n')
    access_log: typing.Optional[models.aws_appmesh.AccessLogDef] = pydantic.Field(None, description='Access Logging Configuration for the virtual node. Default: - No access logging\n')
    backend_defaults: typing.Union[models.aws_appmesh.BackendDefaultsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Default Configuration Virtual Node uses to communicate with Virtual Service. Default: - No Config\n')
    backends: typing.Optional[typing.Sequence[models.aws_appmesh.BackendDef]] = pydantic.Field(None, description='Virtual Services that this is node expected to send outbound traffic to. Default: - No backends\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualNodeListenerDef]] = pydantic.Field(None, description='Initial listener for the virtual node. Default: - No listeners\n')
    service_discovery: typing.Optional[models.aws_appmesh.ServiceDiscoveryDef] = pydantic.Field(None, description='Defines how upstream clients will discover this VirtualNode. Default: - No Service Discovery\n')
    virtual_node_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualNode. Default: - A name is automatically determined')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'access_log', 'backend_defaults', 'backends', 'listeners', 'service_discovery', 'virtual_node_name']
    _method_names: typing.ClassVar[list[str]] = ['add_backend', 'add_listener', 'apply_removal_policy', 'grant_stream_aggregated_resources']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_virtual_node_arn', 'from_virtual_node_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualNode'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_virtual_node_arn', 'from_virtual_node_attributes']
    ...


    from_virtual_node_arn: typing.Optional[VirtualNodeDefFromVirtualNodeArnParams] = pydantic.Field(None, description='Import an existing VirtualNode given an ARN.')
    from_virtual_node_attributes: typing.Optional[VirtualNodeDefFromVirtualNodeAttributesParams] = pydantic.Field(None, description='Import an existing VirtualNode given its name.')
    resource_config: typing.Optional[VirtualNodeDefConfig] = pydantic.Field(None)


class VirtualNodeDefConfig(pydantic.BaseModel):
    add_backend: typing.Optional[list[VirtualNodeDefAddBackendParams]] = pydantic.Field(None, description='Add a Virtual Services that this node is expected to send outbound traffic to.')
    add_listener: typing.Optional[list[VirtualNodeDefAddListenerParams]] = pydantic.Field(None, description='Utility method to add an inbound listener for this VirtualNode.\nNote: At this time, Virtual Nodes support at most one listener. Adding\nmore than one will result in a failure to deploy the CloudFormation stack.\nHowever, the App Mesh team has plans to add support for multiple listeners\non Virtual Nodes and Virtual Routers.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_stream_aggregated_resources: typing.Optional[list[VirtualNodeDefGrantStreamAggregatedResourcesParams]] = pydantic.Field(None, description='Grants the given entity ``appmesh:StreamAggregatedResources``.')
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)

class VirtualNodeDefAddBackendParams(pydantic.BaseModel):
    backend: models.aws_appmesh.BackendDef = pydantic.Field(..., description='-')
    ...

class VirtualNodeDefAddListenerParams(pydantic.BaseModel):
    listener: models.aws_appmesh.VirtualNodeListenerDef = pydantic.Field(..., description='-\n\n:see: https://github.com/aws/aws-app-mesh-roadmap/issues/120\n')
    ...

class VirtualNodeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VirtualNodeDefFromVirtualNodeArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    virtual_node_arn: str = pydantic.Field(..., description='-')
    ...

class VirtualNodeDefFromVirtualNodeAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh that the VirtualNode belongs to.\n')
    virtual_node_name: str = pydantic.Field(..., description='The name of the VirtualNode.')
    ...

class VirtualNodeDefGrantStreamAggregatedResourcesParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_appmesh.VirtualRouter
class VirtualRouterDef(BaseConstruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualRouter belongs to.\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualRouterListenerDef]] = pydantic.Field(None, description='Listener specification for the VirtualRouter. Default: - A listener on HTTP port 8080\n')
    virtual_router_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualRouter. Default: - A name is automatically determined')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'listeners', 'virtual_router_name']
    _method_names: typing.ClassVar[list[str]] = ['add_route', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_virtual_router_arn', 'from_virtual_router_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualRouter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_virtual_router_arn', 'from_virtual_router_attributes']
    ...


    from_virtual_router_arn: typing.Optional[VirtualRouterDefFromVirtualRouterArnParams] = pydantic.Field(None, description='Import an existing VirtualRouter given an ARN.')
    from_virtual_router_attributes: typing.Optional[VirtualRouterDefFromVirtualRouterAttributesParams] = pydantic.Field(None, description='Import an existing VirtualRouter given attributes.')
    resource_config: typing.Optional[VirtualRouterDefConfig] = pydantic.Field(None)


class VirtualRouterDefConfig(pydantic.BaseModel):
    add_route: typing.Optional[list[VirtualRouterDefAddRouteParams]] = pydantic.Field(None, description='Add a single route to the router.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)

class VirtualRouterDefAddRouteParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    route_spec: models.aws_appmesh.RouteSpecDef = pydantic.Field(..., description='Protocol specific spec.\n')
    route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the route. Default: - An automatically generated name')
    return_config: typing.Optional[list[models.aws_appmesh.RouteDefConfig]] = pydantic.Field(None)
    ...

class VirtualRouterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VirtualRouterDefFromVirtualRouterArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    virtual_router_arn: str = pydantic.Field(..., description='-')
    ...

class VirtualRouterDefFromVirtualRouterAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualRouter belongs to.\n')
    virtual_router_name: str = pydantic.Field(..., description='The name of the VirtualRouter.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.VirtualService
class VirtualServiceDef(BaseConstruct):
    virtual_service_provider: models.aws_appmesh.VirtualServiceProviderDef = pydantic.Field(..., description='The VirtualNode or VirtualRouter which the VirtualService uses as its provider.\n')
    virtual_service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualService. It is recommended this follows the fully-qualified domain name format, such as "my-service.default.svc.cluster.local". Example value: ``service.domain.local`` Default: - A name is automatically generated')
    _init_params: typing.ClassVar[list[str]] = ['virtual_service_provider', 'virtual_service_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_virtual_service_arn', 'from_virtual_service_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_virtual_service_arn', 'from_virtual_service_attributes']
    ...


    from_virtual_service_arn: typing.Optional[VirtualServiceDefFromVirtualServiceArnParams] = pydantic.Field(None, description='Import an existing VirtualService given an ARN.')
    from_virtual_service_attributes: typing.Optional[VirtualServiceDefFromVirtualServiceAttributesParams] = pydantic.Field(None, description='Import an existing VirtualService given its attributes.')
    resource_config: typing.Optional[VirtualServiceDefConfig] = pydantic.Field(None)


class VirtualServiceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)

class VirtualServiceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VirtualServiceDefFromVirtualServiceArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    virtual_service_arn: str = pydantic.Field(..., description='-')
    ...

class VirtualServiceDefFromVirtualServiceAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualService belongs to.\n')
    virtual_service_name: str = pydantic.Field(..., description='The name of the VirtualService, it is recommended this follows the fully-qualified domain name format.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.AccessLogConfig
class AccessLogConfigDef(BaseStruct):
    virtual_gateway_access_log: typing.Union[models.aws_appmesh.CfnVirtualGateway_VirtualGatewayAccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='VirtualGateway CFN configuration for Access Logging. Default: - no access logging\n')
    virtual_node_access_log: typing.Union[models.aws_appmesh.CfnVirtualNode_AccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='VirtualNode CFN configuration for Access Logging. Default: - no access logging\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    access_log_config = appmesh.AccessLogConfig(\n        virtual_gateway_access_log=appmesh.CfnVirtualGateway.VirtualGatewayAccessLogProperty(\n            file=appmesh.CfnVirtualGateway.VirtualGatewayFileAccessLogProperty(\n                path="path",\n\n                # the properties below are optional\n                format=appmesh.CfnVirtualGateway.LoggingFormatProperty(\n                    json=[appmesh.CfnVirtualGateway.JsonFormatRefProperty(\n                        key="key",\n                        value="value"\n                    )],\n                    text="text"\n                )\n            )\n        ),\n        virtual_node_access_log=appmesh.CfnVirtualNode.AccessLogProperty(\n            file=appmesh.CfnVirtualNode.FileAccessLogProperty(\n                path="path",\n\n                # the properties below are optional\n                format=appmesh.CfnVirtualNode.LoggingFormatProperty(\n                    json=[appmesh.CfnVirtualNode.JsonFormatRefProperty(\n                        key="key",\n                        value="value"\n                    )],\n                    text="text"\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_gateway_access_log', 'virtual_node_access_log']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.AccessLogConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.BackendConfig
class BackendConfigDef(BaseStruct):
    virtual_service_backend: typing.Union[models.aws_appmesh.CfnVirtualNode_BackendPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Config for a Virtual Service backend.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    backend_config = appmesh.BackendConfig(\n        virtual_service_backend=appmesh.CfnVirtualNode.BackendProperty(\n            virtual_service=appmesh.CfnVirtualNode.VirtualServiceBackendProperty(\n                virtual_service_name="virtualServiceName",\n\n                # the properties below are optional\n                client_policy=appmesh.CfnVirtualNode.ClientPolicyProperty(\n                    tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n                        validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                            trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                                acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                                    certificate_authority_arns=["certificateAuthorityArns"]\n                                ),\n                                file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                                    certificate_chain="certificateChain"\n                                ),\n                                sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                                    secret_name="secretName"\n                                )\n                            ),\n\n                            # the properties below are optional\n                            subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                                match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                                    exact=["exact"]\n                                )\n                            )\n                        ),\n\n                        # the properties below are optional\n                        certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                            file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                                certificate_chain="certificateChain",\n                                private_key="privateKey"\n                            ),\n                            sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n                        enforce=False,\n                        ports=[123]\n                    )\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_service_backend']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.BackendConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.BackendDefaults
class BackendDefaultsDef(BaseStruct):
    tls_client_policy: typing.Union[models.aws_appmesh.TlsClientPolicyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='TLS properties for Client policy for backend defaults. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    # service: cloudmap.Service\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=8080,\n            health_check=appmesh.HealthCheck.http(\n                healthy_threshold=3,\n                interval=Duration.seconds(5),\n                path="/ping",\n                timeout=Duration.seconds(2),\n                unhealthy_threshold=2\n            ),\n            timeout=appmesh.HttpTimeout(\n                idle=Duration.seconds(5)\n            )\n        )],\n        backend_defaults=appmesh.BackendDefaults(\n            tls_client_policy=appmesh.TlsClientPolicy(\n                validation=appmesh.TlsValidation(\n                    trust=appmesh.TlsValidationTrust.file("/keys/local_cert_chain.pem")\n                )\n            )\n        ),\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout")\n    )\n\n    cdk.Tags.of(node).add("Environment", "Dev")\n')
    _init_params: typing.ClassVar[list[str]] = ['tls_client_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.BackendDefaults'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty
class CfnGatewayRoute_GatewayRouteHostnameMatchPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The exact host name to match on.\n')
    suffix: typing.Optional[str] = pydantic.Field(None, description='The specified ending characters of the host name to match on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-gatewayroutehostnamematch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_hostname_match_property = appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n        exact="exact",\n        suffix="suffix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact', 'suffix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty
class CfnGatewayRoute_GatewayRouteHostnameRewritePropertyDef(BaseStruct):
    default_target_hostname: typing.Optional[str] = pydantic.Field(None, description='The default target host name to write to.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-gatewayroutehostnamerewrite.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_hostname_rewrite_property = appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n        default_target_hostname="defaultTargetHostname"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_target_hostname']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty
class CfnGatewayRoute_GatewayRouteMetadataMatchPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The exact method header to be matched on.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='The specified beginning characters of the method header to be matched on.\n')
    range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteRangeMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the range of values to match on.\n')
    regex: typing.Optional[str] = pydantic.Field(None, description='The regex used to match the method header.\n')
    suffix: typing.Optional[str] = pydantic.Field(None, description='The specified ending characters of the method header to match on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-gatewayroutemetadatamatch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_metadata_match_property = appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty(\n        exact="exact",\n        prefix="prefix",\n        range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n            end=123,\n            start=123\n        ),\n        regex="regex",\n        suffix="suffix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact', 'prefix', 'range', 'regex', 'suffix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty
class CfnGatewayRoute_GatewayRouteRangeMatchPropertyDef(BaseStruct):
    end: typing.Union[int, float] = pydantic.Field(..., description='The end of the range.\n')
    start: typing.Union[int, float] = pydantic.Field(..., description='The start of the range.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-gatewayrouterangematch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_range_match_property = appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n        end=123,\n        start=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['end', 'start']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteSpecProperty
class CfnGatewayRoute_GatewayRouteSpecPropertyDef(BaseStruct):
    grpc_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the specification of a gRPC gateway route.\n')
    http2_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the specification of an HTTP/2 gateway route.\n')
    http_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the specification of an HTTP gateway route.\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The ordering of the gateway routes spec.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-gatewayroutespec.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_spec_property = appmesh.CfnGatewayRoute.GatewayRouteSpecProperty(\n        grpc_route=appmesh.CfnGatewayRoute.GrpcGatewayRouteProperty(\n            action=appmesh.CfnGatewayRoute.GrpcGatewayRouteActionProperty(\n                target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                    virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                        virtual_service_name="virtualServiceName"\n                    ),\n\n                    # the properties below are optional\n                    port=123\n                ),\n\n                # the properties below are optional\n                rewrite=appmesh.CfnGatewayRoute.GrpcGatewayRouteRewriteProperty(\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                        default_target_hostname="defaultTargetHostname"\n                    )\n                )\n            ),\n            match=appmesh.CfnGatewayRoute.GrpcGatewayRouteMatchProperty(\n                hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                    exact="exact",\n                    suffix="suffix"\n                ),\n                metadata=[appmesh.CfnGatewayRoute.GrpcGatewayRouteMetadataProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                port=123,\n                service_name="serviceName"\n            )\n        ),\n        http2_route=appmesh.CfnGatewayRoute.HttpGatewayRouteProperty(\n            action=appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty(\n                target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                    virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                        virtual_service_name="virtualServiceName"\n                    ),\n\n                    # the properties below are optional\n                    port=123\n                ),\n\n                # the properties below are optional\n                rewrite=appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                        default_target_hostname="defaultTargetHostname"\n                    ),\n                    path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n                        exact="exact"\n                    ),\n                    prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n                        default_prefix="defaultPrefix",\n                        value="value"\n                    )\n                )\n            ),\n            match=appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty(\n                headers=[appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                    exact="exact",\n                    suffix="suffix"\n                ),\n                method="method",\n                path=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n                    exact="exact",\n                    regex="regex"\n                ),\n                port=123,\n                prefix="prefix",\n                query_parameters=[appmesh.CfnGatewayRoute.QueryParameterProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n                        exact="exact"\n                    )\n                )]\n            )\n        ),\n        http_route=appmesh.CfnGatewayRoute.HttpGatewayRouteProperty(\n            action=appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty(\n                target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                    virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                        virtual_service_name="virtualServiceName"\n                    ),\n\n                    # the properties below are optional\n                    port=123\n                ),\n\n                # the properties below are optional\n                rewrite=appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                        default_target_hostname="defaultTargetHostname"\n                    ),\n                    path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n                        exact="exact"\n                    ),\n                    prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n                        default_prefix="defaultPrefix",\n                        value="value"\n                    )\n                )\n            ),\n            match=appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty(\n                headers=[appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                    exact="exact",\n                    suffix="suffix"\n                ),\n                method="method",\n                path=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n                    exact="exact",\n                    regex="regex"\n                ),\n                port=123,\n                prefix="prefix",\n                query_parameters=[appmesh.CfnGatewayRoute.QueryParameterProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n                        exact="exact"\n                    )\n                )]\n            )\n        ),\n        priority=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['grpc_route', 'http2_route', 'http_route', 'priority']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteSpecProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteTargetProperty
class CfnGatewayRoute_GatewayRouteTargetPropertyDef(BaseStruct):
    virtual_service: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteVirtualServicePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents a virtual service gateway route target.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number of the gateway route target.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-gatewayroutetarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_target_property = appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n        virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n            virtual_service_name="virtualServiceName"\n        ),\n\n        # the properties below are optional\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_service', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty
class CfnGatewayRoute_GatewayRouteVirtualServicePropertyDef(BaseStruct):
    virtual_service_name: str = pydantic.Field(..., description='The name of the virtual service that traffic is routed to.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-gatewayroutevirtualservice.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_virtual_service_property = appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n        virtual_service_name="virtualServiceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteActionProperty
class CfnGatewayRoute_GrpcGatewayRouteActionPropertyDef(BaseStruct):
    target: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteTargetPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the target that traffic is routed to when a request matches the gateway route.\n')
    rewrite: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRouteRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The gateway route action to rewrite.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-grpcgatewayrouteaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_gateway_route_action_property = appmesh.CfnGatewayRoute.GrpcGatewayRouteActionProperty(\n        target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n            virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                virtual_service_name="virtualServiceName"\n            ),\n\n            # the properties below are optional\n            port=123\n        ),\n\n        # the properties below are optional\n        rewrite=appmesh.CfnGatewayRoute.GrpcGatewayRouteRewriteProperty(\n            hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                default_target_hostname="defaultTargetHostname"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target', 'rewrite']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteMatchProperty
class CfnGatewayRoute_GrpcGatewayRouteMatchPropertyDef(BaseStruct):
    hostname: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The gateway route host name to be matched on.\n')
    metadata: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRouteMetadataPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The gateway route metadata to be matched on.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The gateway route port to be matched on.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The fully qualified domain name for the service to match from the request.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-grpcgatewayroutematch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_gateway_route_match_property = appmesh.CfnGatewayRoute.GrpcGatewayRouteMatchProperty(\n        hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n            exact="exact",\n            suffix="suffix"\n        ),\n        metadata=[appmesh.CfnGatewayRoute.GrpcGatewayRouteMetadataProperty(\n            name="name",\n\n            # the properties below are optional\n            invert=False,\n            match=appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty(\n                exact="exact",\n                prefix="prefix",\n                range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                    end=123,\n                    start=123\n                ),\n                regex="regex",\n                suffix="suffix"\n            )\n        )],\n        port=123,\n        service_name="serviceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hostname', 'metadata', 'port', 'service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteMetadataProperty
class CfnGatewayRoute_GrpcGatewayRouteMetadataPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the gateway route metadata.\n')
    invert: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specify ``True`` to match anything except the match criteria. The default value is ``False`` .\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteMetadataMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The criteria for determining a metadata match.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-grpcgatewayroutemetadata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_gateway_route_metadata_property = appmesh.CfnGatewayRoute.GrpcGatewayRouteMetadataProperty(\n        name="name",\n\n        # the properties below are optional\n        invert=False,\n        match=appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty(\n            exact="exact",\n            prefix="prefix",\n            range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                end=123,\n                start=123\n            ),\n            regex="regex",\n            suffix="suffix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'invert', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteMetadataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteProperty
class CfnGatewayRoute_GrpcGatewayRoutePropertyDef(BaseStruct):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the action to take if a match is determined.\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRouteMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the criteria for determining a request match.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-grpcgatewayroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_gateway_route_property = appmesh.CfnGatewayRoute.GrpcGatewayRouteProperty(\n        action=appmesh.CfnGatewayRoute.GrpcGatewayRouteActionProperty(\n            target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                    virtual_service_name="virtualServiceName"\n                ),\n\n                # the properties below are optional\n                port=123\n            ),\n\n            # the properties below are optional\n            rewrite=appmesh.CfnGatewayRoute.GrpcGatewayRouteRewriteProperty(\n                hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                    default_target_hostname="defaultTargetHostname"\n                )\n            )\n        ),\n        match=appmesh.CfnGatewayRoute.GrpcGatewayRouteMatchProperty(\n            hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                exact="exact",\n                suffix="suffix"\n            ),\n            metadata=[appmesh.CfnGatewayRoute.GrpcGatewayRouteMetadataProperty(\n                name="name",\n\n                # the properties below are optional\n                invert=False,\n                match=appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty(\n                    exact="exact",\n                    prefix="prefix",\n                    range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                        end=123,\n                        start=123\n                    ),\n                    regex="regex",\n                    suffix="suffix"\n                )\n            )],\n            port=123,\n            service_name="serviceName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteRewriteProperty
class CfnGatewayRoute_GrpcGatewayRouteRewritePropertyDef(BaseStruct):
    hostname: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The host name of the gateway route to rewrite.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-grpcgatewayrouterewrite.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_gateway_route_rewrite_property = appmesh.CfnGatewayRoute.GrpcGatewayRouteRewriteProperty(\n        hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n            default_target_hostname="defaultTargetHostname"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hostname']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.GrpcGatewayRouteRewriteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty
class CfnGatewayRoute_HttpGatewayRouteActionPropertyDef(BaseStruct):
    target: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteTargetPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the target that traffic is routed to when a request matches the gateway route.\n')
    rewrite: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The gateway route action to rewrite.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpgatewayrouteaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_action_property = appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty(\n        target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n            virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                virtual_service_name="virtualServiceName"\n            ),\n\n            # the properties below are optional\n            port=123\n        ),\n\n        # the properties below are optional\n        rewrite=appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n            hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                default_target_hostname="defaultTargetHostname"\n            ),\n            path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n                exact="exact"\n            ),\n            prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n                default_prefix="defaultPrefix",\n                value="value"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target', 'rewrite']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty
class CfnGatewayRoute_HttpGatewayRouteHeaderMatchPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must match the specified value exactly.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must begin with the specified characters.\n')
    range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteRangeMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the range of values to match on.\n')
    regex: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must include the specified characters.\n')
    suffix: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must end with the specified characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpgatewayrouteheadermatch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_header_match_property = appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n        exact="exact",\n        prefix="prefix",\n        range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n            end=123,\n            start=123\n        ),\n        regex="regex",\n        suffix="suffix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact', 'prefix', 'range', 'regex', 'suffix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty
class CfnGatewayRoute_HttpGatewayRouteHeaderPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the HTTP header in the gateway route that will be matched on.\n')
    invert: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specify ``True`` to match anything except the match criteria. The default value is ``False`` .\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteHeaderMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the method and value to match with the header value sent in a request. Specify one match method.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpgatewayrouteheader.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_header_property = appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n        name="name",\n\n        # the properties below are optional\n        invert=False,\n        match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n            exact="exact",\n            prefix="prefix",\n            range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                end=123,\n                start=123\n            ),\n            regex="regex",\n            suffix="suffix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'invert', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty
class CfnGatewayRoute_HttpGatewayRouteMatchPropertyDef(BaseStruct):
    headers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteHeaderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The client request headers to match on.\n')
    hostname: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The host name to match on.\n')
    method: typing.Optional[str] = pydantic.Field(None, description='The method to match on.\n')
    path: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpPathMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The path to match on.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number to match on.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='Specifies the path to match requests with. This parameter must always start with ``/`` , which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is ``my-service.local`` and you want the route to match requests to ``my-service.local/metrics`` , your prefix should be ``/metrics`` .\n')
    query_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_QueryParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The query parameter to match on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpgatewayroutematch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_match_property = appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty(\n        headers=[appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n            name="name",\n\n            # the properties below are optional\n            invert=False,\n            match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n                exact="exact",\n                prefix="prefix",\n                range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                    end=123,\n                    start=123\n                ),\n                regex="regex",\n                suffix="suffix"\n            )\n        )],\n        hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n            exact="exact",\n            suffix="suffix"\n        ),\n        method="method",\n        path=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n            exact="exact",\n            regex="regex"\n        ),\n        port=123,\n        prefix="prefix",\n        query_parameters=[appmesh.CfnGatewayRoute.QueryParameterProperty(\n            name="name",\n\n            # the properties below are optional\n            match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n                exact="exact"\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['headers', 'hostname', 'method', 'path', 'port', 'prefix', 'query_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty
class CfnGatewayRoute_HttpGatewayRoutePathRewritePropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The exact path to rewrite.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpgatewayroutepathrewrite.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_path_rewrite_property = appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n        exact="exact"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty
class CfnGatewayRoute_HttpGatewayRoutePrefixRewritePropertyDef(BaseStruct):
    default_prefix: typing.Optional[str] = pydantic.Field(None, description='The default prefix used to replace the incoming route prefix when rewritten.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value used to replace the incoming route prefix when rewritten.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpgatewayrouteprefixrewrite.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_prefix_rewrite_property = appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n        default_prefix="defaultPrefix",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_prefix', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteProperty
class CfnGatewayRoute_HttpGatewayRoutePropertyDef(BaseStruct):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the action to take if a match is determined.\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the criteria for determining a request match.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpgatewayroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_property = appmesh.CfnGatewayRoute.HttpGatewayRouteProperty(\n        action=appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty(\n            target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                    virtual_service_name="virtualServiceName"\n                ),\n\n                # the properties below are optional\n                port=123\n            ),\n\n            # the properties below are optional\n            rewrite=appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n                hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                    default_target_hostname="defaultTargetHostname"\n                ),\n                path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n                    exact="exact"\n                ),\n                prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n                    default_prefix="defaultPrefix",\n                    value="value"\n                )\n            )\n        ),\n        match=appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty(\n            headers=[appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n                name="name",\n\n                # the properties below are optional\n                invert=False,\n                match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n                    exact="exact",\n                    prefix="prefix",\n                    range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                        end=123,\n                        start=123\n                    ),\n                    regex="regex",\n                    suffix="suffix"\n                )\n            )],\n            hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                exact="exact",\n                suffix="suffix"\n            ),\n            method="method",\n            path=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n                exact="exact",\n                regex="regex"\n            ),\n            port=123,\n            prefix="prefix",\n            query_parameters=[appmesh.CfnGatewayRoute.QueryParameterProperty(\n                name="name",\n\n                # the properties below are optional\n                match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n                    exact="exact"\n                )\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty
class CfnGatewayRoute_HttpGatewayRouteRewritePropertyDef(BaseStruct):
    hostname: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The host name to rewrite.\n')
    path: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePathRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The path to rewrite.\n')
    prefix: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePrefixRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The specified beginning characters to rewrite.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpgatewayrouterewrite.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_rewrite_property = appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n        hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n            default_target_hostname="defaultTargetHostname"\n        ),\n        path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n            exact="exact"\n        ),\n        prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n            default_prefix="defaultPrefix",\n            value="value"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hostname', 'path', 'prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpPathMatchProperty
class CfnGatewayRoute_HttpPathMatchPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The exact path to match on.\n')
    regex: typing.Optional[str] = pydantic.Field(None, description='The regex used to match the path.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httppathmatch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_path_match_property = appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n        exact="exact",\n        regex="regex"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact', 'regex']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpPathMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty
class CfnGatewayRoute_HttpQueryParameterMatchPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The exact query parameter to match on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-httpqueryparametermatch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_query_parameter_match_property = appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n        exact="exact"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute.QueryParameterProperty
class CfnGatewayRoute_QueryParameterPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the query parameter that will be matched on.\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpQueryParameterMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The query parameter to match on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-gatewayroute-queryparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    query_parameter_property = appmesh.CfnGatewayRoute.QueryParameterProperty(\n        name="name",\n\n        # the properties below are optional\n        match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n            exact="exact"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute.QueryParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnMesh.EgressFilterProperty
class CfnMesh_EgressFilterPropertyDef(BaseStruct):
    type: str = pydantic.Field(..., description='The egress filter type. By default, the type is ``DROP_ALL`` , which allows egress only from virtual nodes to other defined resources in the service mesh (and any traffic to ``*.amazonaws.com`` for AWS API calls). You can set the egress filter type to ``ALLOW_ALL`` to allow egress to any endpoint inside or outside of the service mesh. .. epigraph:: If you specify any backends on a virtual node when using ``ALLOW_ALL`` , you must specifiy all egress for that virtual node as backends. Otherwise, ``ALLOW_ALL`` will no longer work for that virtual node.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-mesh-egressfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    egress_filter_property = appmesh.CfnMesh.EgressFilterProperty(\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnMesh.EgressFilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnMesh.MeshServiceDiscoveryProperty
class CfnMesh_MeshServiceDiscoveryPropertyDef(BaseStruct):
    ip_preference: typing.Optional[str] = pydantic.Field(None, description='The IP version to use to control traffic within the mesh.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-mesh-meshservicediscovery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    mesh_service_discovery_property = appmesh.CfnMesh.MeshServiceDiscoveryProperty(\n        ip_preference="ipPreference"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip_preference']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnMesh.MeshServiceDiscoveryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnMesh.MeshSpecProperty
class CfnMesh_MeshSpecPropertyDef(BaseStruct):
    egress_filter: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnMesh_EgressFilterPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The egress filter rules for the service mesh.\n')
    service_discovery: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnMesh_MeshServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='``CfnMesh.MeshSpecProperty.ServiceDiscovery``.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-mesh-meshspec.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    mesh_spec_property = appmesh.CfnMesh.MeshSpecProperty(\n        egress_filter=appmesh.CfnMesh.EgressFilterProperty(\n            type="type"\n        ),\n        service_discovery=appmesh.CfnMesh.MeshServiceDiscoveryProperty(\n            ip_preference="ipPreference"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['egress_filter', 'service_discovery']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnMesh.MeshSpecProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.DurationProperty
class CfnRoute_DurationPropertyDef(BaseStruct):
    unit: str = pydantic.Field(..., description='A unit of time.\n')
    value: typing.Union[int, float] = pydantic.Field(..., description='A number of time units.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-duration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    duration_property = appmesh.CfnRoute.DurationProperty(\n        unit="unit",\n        value=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['unit', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.DurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.GrpcRetryPolicyProperty
class CfnRoute_GrpcRetryPolicyPropertyDef(BaseStruct):
    max_retries: typing.Union[int, float] = pydantic.Field(..., description='The maximum number of retry attempts.\n')
    per_retry_timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The timeout for each retry attempt.\n')
    grpc_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify at least one of the valid values.\n')
    http_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify at least one of the following values. - *server-error*  HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511 - *gateway-error*  HTTP status codes 502, 503, and 504 - *client-error*  HTTP status code 409 - *stream-error*  Retry on refused stream\n')
    tcp_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-grpcretrypolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_retry_policy_property = appmesh.CfnRoute.GrpcRetryPolicyProperty(\n        max_retries=123,\n        per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n            unit="unit",\n            value=123\n        ),\n\n        # the properties below are optional\n        grpc_retry_events=["grpcRetryEvents"],\n        http_retry_events=["httpRetryEvents"],\n        tcp_retry_events=["tcpRetryEvents"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_retries', 'per_retry_timeout', 'grpc_retry_events', 'http_retry_events', 'tcp_retry_events']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.GrpcRetryPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.GrpcRouteActionProperty
class CfnRoute_GrpcRouteActionPropertyDef(BaseStruct):
    weighted_targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_WeightedTargetPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='An object that represents the targets that traffic is routed to when a request matches the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-grpcrouteaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_route_action_property = appmesh.CfnRoute.GrpcRouteActionProperty(\n        weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n            virtual_node="virtualNode",\n            weight=123,\n\n            # the properties below are optional\n            port=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['weighted_targets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.GrpcRouteActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.GrpcRouteMatchProperty
class CfnRoute_GrpcRouteMatchPropertyDef(BaseStruct):
    metadata: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRouteMetadataPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An object that represents the data to match from the request.\n')
    method_name: typing.Optional[str] = pydantic.Field(None, description='The method name to match from the request. If you specify a name, you must also specify a ``serviceName`` .\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number to match on.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The fully qualified domain name for the service to match from the request.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-grpcroutematch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_route_match_property = appmesh.CfnRoute.GrpcRouteMatchProperty(\n        metadata=[appmesh.CfnRoute.GrpcRouteMetadataProperty(\n            name="name",\n\n            # the properties below are optional\n            invert=False,\n            match=appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty(\n                exact="exact",\n                prefix="prefix",\n                range=appmesh.CfnRoute.MatchRangeProperty(\n                    end=123,\n                    start=123\n                ),\n                regex="regex",\n                suffix="suffix"\n            )\n        )],\n        method_name="methodName",\n        port=123,\n        service_name="serviceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metadata', 'method_name', 'port', 'service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.GrpcRouteMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty
class CfnRoute_GrpcRouteMetadataMatchMethodPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must match the specified value exactly.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must begin with the specified characters.\n')
    range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_MatchRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the range of values to match on.\n')
    regex: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must include the specified characters.\n')
    suffix: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must end with the specified characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-grpcroutemetadatamatchmethod.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_route_metadata_match_method_property = appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty(\n        exact="exact",\n        prefix="prefix",\n        range=appmesh.CfnRoute.MatchRangeProperty(\n            end=123,\n            start=123\n        ),\n        regex="regex",\n        suffix="suffix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact', 'prefix', 'range', 'regex', 'suffix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.GrpcRouteMetadataProperty
class CfnRoute_GrpcRouteMetadataPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='The name of the route.\n')
    invert: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specify ``True`` to match anything except the match criteria. The default value is ``False`` .\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRouteMetadataMatchMethodPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the data to match from the request.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-grpcroutemetadata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_route_metadata_property = appmesh.CfnRoute.GrpcRouteMetadataProperty(\n        name="name",\n\n        # the properties below are optional\n        invert=False,\n        match=appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty(\n            exact="exact",\n            prefix="prefix",\n            range=appmesh.CfnRoute.MatchRangeProperty(\n                end=123,\n                start=123\n            ),\n            regex="regex",\n            suffix="suffix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'invert', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.GrpcRouteMetadataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.GrpcRouteProperty
class CfnRoute_GrpcRoutePropertyDef(BaseStruct):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the action to take if a match is determined.\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRouteMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the criteria for determining a request match.\n')
    retry_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a retry policy.\n')
    timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents types of timeouts.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-grpcroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_route_property = appmesh.CfnRoute.GrpcRouteProperty(\n        action=appmesh.CfnRoute.GrpcRouteActionProperty(\n            weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                virtual_node="virtualNode",\n                weight=123,\n\n                # the properties below are optional\n                port=123\n            )]\n        ),\n        match=appmesh.CfnRoute.GrpcRouteMatchProperty(\n            metadata=[appmesh.CfnRoute.GrpcRouteMetadataProperty(\n                name="name",\n\n                # the properties below are optional\n                invert=False,\n                match=appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty(\n                    exact="exact",\n                    prefix="prefix",\n                    range=appmesh.CfnRoute.MatchRangeProperty(\n                        end=123,\n                        start=123\n                    ),\n                    regex="regex",\n                    suffix="suffix"\n                )\n            )],\n            method_name="methodName",\n            port=123,\n            service_name="serviceName"\n        ),\n\n        # the properties below are optional\n        retry_policy=appmesh.CfnRoute.GrpcRetryPolicyProperty(\n            max_retries=123,\n            per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n\n            # the properties below are optional\n            grpc_retry_events=["grpcRetryEvents"],\n            http_retry_events=["httpRetryEvents"],\n            tcp_retry_events=["tcpRetryEvents"]\n        ),\n        timeout=appmesh.CfnRoute.GrpcTimeoutProperty(\n            idle=appmesh.CfnRoute.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n            per_request=appmesh.CfnRoute.DurationProperty(\n                unit="unit",\n                value=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'match', 'retry_policy', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.GrpcRouteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.GrpcTimeoutProperty
class CfnRoute_GrpcTimeoutPropertyDef(BaseStruct):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.\n')
    per_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-grpctimeout.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_timeout_property = appmesh.CfnRoute.GrpcTimeoutProperty(\n        idle=appmesh.CfnRoute.DurationProperty(\n            unit="unit",\n            value=123\n        ),\n        per_request=appmesh.CfnRoute.DurationProperty(\n            unit="unit",\n            value=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle', 'per_request']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.GrpcTimeoutProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HeaderMatchMethodProperty
class CfnRoute_HeaderMatchMethodPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must match the specified value exactly.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must begin with the specified characters.\n')
    range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_MatchRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the range of values to match on.\n')
    regex: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must include the specified characters.\n')
    suffix: typing.Optional[str] = pydantic.Field(None, description='The value sent by the client must end with the specified characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-headermatchmethod.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    header_match_method_property = appmesh.CfnRoute.HeaderMatchMethodProperty(\n        exact="exact",\n        prefix="prefix",\n        range=appmesh.CfnRoute.MatchRangeProperty(\n            end=123,\n            start=123\n        ),\n        regex="regex",\n        suffix="suffix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact', 'prefix', 'range', 'regex', 'suffix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HeaderMatchMethodProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HttpPathMatchProperty
class CfnRoute_HttpPathMatchPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The exact path to match on.\n')
    regex: typing.Optional[str] = pydantic.Field(None, description='The regex used to match the path.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-httppathmatch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_path_match_property = appmesh.CfnRoute.HttpPathMatchProperty(\n        exact="exact",\n        regex="regex"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact', 'regex']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HttpPathMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HttpQueryParameterMatchProperty
class CfnRoute_HttpQueryParameterMatchPropertyDef(BaseStruct):
    exact: typing.Optional[str] = pydantic.Field(None, description='The exact query parameter to match on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-httpqueryparametermatch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_query_parameter_match_property = appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n        exact="exact"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HttpQueryParameterMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HttpRetryPolicyProperty
class CfnRoute_HttpRetryPolicyPropertyDef(BaseStruct):
    max_retries: typing.Union[int, float] = pydantic.Field(..., description='The maximum number of retry attempts.\n')
    per_retry_timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The timeout for each retry attempt.\n')
    http_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify at least one of the following values. - *server-error*  HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511 - *gateway-error*  HTTP status codes 502, 503, and 504 - *client-error*  HTTP status code 409 - *stream-error*  Retry on refused stream\n')
    tcp_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-httpretrypolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_retry_policy_property = appmesh.CfnRoute.HttpRetryPolicyProperty(\n        max_retries=123,\n        per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n            unit="unit",\n            value=123\n        ),\n\n        # the properties below are optional\n        http_retry_events=["httpRetryEvents"],\n        tcp_retry_events=["tcpRetryEvents"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_retries', 'per_retry_timeout', 'http_retry_events', 'tcp_retry_events']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HttpRetryPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HttpRouteActionProperty
class CfnRoute_HttpRouteActionPropertyDef(BaseStruct):
    weighted_targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_WeightedTargetPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='An object that represents the targets that traffic is routed to when a request matches the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-httprouteaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_route_action_property = appmesh.CfnRoute.HttpRouteActionProperty(\n        weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n            virtual_node="virtualNode",\n            weight=123,\n\n            # the properties below are optional\n            port=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['weighted_targets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HttpRouteActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HttpRouteHeaderProperty
class CfnRoute_HttpRouteHeaderPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the HTTP header in the client request that will be matched on.\n')
    invert: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specify ``True`` to match anything except the match criteria. The default value is ``False`` .\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HeaderMatchMethodPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The ``HeaderMatchMethod`` object.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-httprouteheader.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_route_header_property = appmesh.CfnRoute.HttpRouteHeaderProperty(\n        name="name",\n\n        # the properties below are optional\n        invert=False,\n        match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n            exact="exact",\n            prefix="prefix",\n            range=appmesh.CfnRoute.MatchRangeProperty(\n                end=123,\n                start=123\n            ),\n            regex="regex",\n            suffix="suffix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'invert', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HttpRouteHeaderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HttpRouteMatchProperty
class CfnRoute_HttpRouteMatchPropertyDef(BaseStruct):
    headers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRouteHeaderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The client request headers to match on.\n')
    method: typing.Optional[str] = pydantic.Field(None, description='The client request method to match on. Specify only one.\n')
    path: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpPathMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The client request path to match on.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number to match on.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='Specifies the path to match requests with. This parameter must always start with ``/`` , which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is ``my-service.local`` and you want the route to match requests to ``my-service.local/metrics`` , your prefix should be ``/metrics`` .\n')
    query_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_QueryParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The client request query parameters to match on.\n')
    scheme: typing.Optional[str] = pydantic.Field(None, description='The client request scheme to match on. Specify only one. Applicable only for HTTP2 routes.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-httproutematch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_route_match_property = appmesh.CfnRoute.HttpRouteMatchProperty(\n        headers=[appmesh.CfnRoute.HttpRouteHeaderProperty(\n            name="name",\n\n            # the properties below are optional\n            invert=False,\n            match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                exact="exact",\n                prefix="prefix",\n                range=appmesh.CfnRoute.MatchRangeProperty(\n                    end=123,\n                    start=123\n                ),\n                regex="regex",\n                suffix="suffix"\n            )\n        )],\n        method="method",\n        path=appmesh.CfnRoute.HttpPathMatchProperty(\n            exact="exact",\n            regex="regex"\n        ),\n        port=123,\n        prefix="prefix",\n        query_parameters=[appmesh.CfnRoute.QueryParameterProperty(\n            name="name",\n\n            # the properties below are optional\n            match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                exact="exact"\n            )\n        )],\n        scheme="scheme"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['headers', 'method', 'path', 'port', 'prefix', 'query_parameters', 'scheme']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HttpRouteMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HttpRouteProperty
class CfnRoute_HttpRoutePropertyDef(BaseStruct):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the action to take if a match is determined.\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRouteMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the criteria for determining a request match.\n')
    retry_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a retry policy.\n')
    timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents types of timeouts.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-httproute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_route_property = appmesh.CfnRoute.HttpRouteProperty(\n        action=appmesh.CfnRoute.HttpRouteActionProperty(\n            weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                virtual_node="virtualNode",\n                weight=123,\n\n                # the properties below are optional\n                port=123\n            )]\n        ),\n        match=appmesh.CfnRoute.HttpRouteMatchProperty(\n            headers=[appmesh.CfnRoute.HttpRouteHeaderProperty(\n                name="name",\n\n                # the properties below are optional\n                invert=False,\n                match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                    exact="exact",\n                    prefix="prefix",\n                    range=appmesh.CfnRoute.MatchRangeProperty(\n                        end=123,\n                        start=123\n                    ),\n                    regex="regex",\n                    suffix="suffix"\n                )\n            )],\n            method="method",\n            path=appmesh.CfnRoute.HttpPathMatchProperty(\n                exact="exact",\n                regex="regex"\n            ),\n            port=123,\n            prefix="prefix",\n            query_parameters=[appmesh.CfnRoute.QueryParameterProperty(\n                name="name",\n\n                # the properties below are optional\n                match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                    exact="exact"\n                )\n            )],\n            scheme="scheme"\n        ),\n\n        # the properties below are optional\n        retry_policy=appmesh.CfnRoute.HttpRetryPolicyProperty(\n            max_retries=123,\n            per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n\n            # the properties below are optional\n            http_retry_events=["httpRetryEvents"],\n            tcp_retry_events=["tcpRetryEvents"]\n        ),\n        timeout=appmesh.CfnRoute.HttpTimeoutProperty(\n            idle=appmesh.CfnRoute.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n            per_request=appmesh.CfnRoute.DurationProperty(\n                unit="unit",\n                value=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'match', 'retry_policy', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HttpRouteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.HttpTimeoutProperty
class CfnRoute_HttpTimeoutPropertyDef(BaseStruct):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.\n')
    per_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-httptimeout.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_timeout_property = appmesh.CfnRoute.HttpTimeoutProperty(\n        idle=appmesh.CfnRoute.DurationProperty(\n            unit="unit",\n            value=123\n        ),\n        per_request=appmesh.CfnRoute.DurationProperty(\n            unit="unit",\n            value=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle', 'per_request']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.HttpTimeoutProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.MatchRangeProperty
class CfnRoute_MatchRangePropertyDef(BaseStruct):
    end: typing.Union[int, float] = pydantic.Field(..., description='The end of the range.\n')
    start: typing.Union[int, float] = pydantic.Field(..., description='The start of the range.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-matchrange.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    match_range_property = appmesh.CfnRoute.MatchRangeProperty(\n        end=123,\n        start=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['end', 'start']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.MatchRangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.QueryParameterProperty
class CfnRoute_QueryParameterPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='A name for the query parameter that will be matched on.\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpQueryParameterMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The query parameter to match on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-queryparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    query_parameter_property = appmesh.CfnRoute.QueryParameterProperty(\n        name="name",\n\n        # the properties below are optional\n        match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n            exact="exact"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.QueryParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.RouteSpecProperty
class CfnRoute_RouteSpecPropertyDef(BaseStruct):
    grpc_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the specification of a gRPC route.\n')
    http2_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the specification of an HTTP/2 route.\n')
    http_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the specification of an HTTP route.\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. Routes are matched based on the specified value, where 0 is the highest priority.\n')
    tcp_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_TcpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the specification of a TCP route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-routespec.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    route_spec_property = appmesh.CfnRoute.RouteSpecProperty(\n        grpc_route=appmesh.CfnRoute.GrpcRouteProperty(\n            action=appmesh.CfnRoute.GrpcRouteActionProperty(\n                weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                    virtual_node="virtualNode",\n                    weight=123,\n\n                    # the properties below are optional\n                    port=123\n                )]\n            ),\n            match=appmesh.CfnRoute.GrpcRouteMatchProperty(\n                metadata=[appmesh.CfnRoute.GrpcRouteMetadataProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnRoute.MatchRangeProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                method_name="methodName",\n                port=123,\n                service_name="serviceName"\n            ),\n\n            # the properties below are optional\n            retry_policy=appmesh.CfnRoute.GrpcRetryPolicyProperty(\n                max_retries=123,\n                per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n\n                # the properties below are optional\n                grpc_retry_events=["grpcRetryEvents"],\n                http_retry_events=["httpRetryEvents"],\n                tcp_retry_events=["tcpRetryEvents"]\n            ),\n            timeout=appmesh.CfnRoute.GrpcTimeoutProperty(\n                idle=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        ),\n        http2_route=appmesh.CfnRoute.HttpRouteProperty(\n            action=appmesh.CfnRoute.HttpRouteActionProperty(\n                weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                    virtual_node="virtualNode",\n                    weight=123,\n\n                    # the properties below are optional\n                    port=123\n                )]\n            ),\n            match=appmesh.CfnRoute.HttpRouteMatchProperty(\n                headers=[appmesh.CfnRoute.HttpRouteHeaderProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnRoute.MatchRangeProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                method="method",\n                path=appmesh.CfnRoute.HttpPathMatchProperty(\n                    exact="exact",\n                    regex="regex"\n                ),\n                port=123,\n                prefix="prefix",\n                query_parameters=[appmesh.CfnRoute.QueryParameterProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                        exact="exact"\n                    )\n                )],\n                scheme="scheme"\n            ),\n\n            # the properties below are optional\n            retry_policy=appmesh.CfnRoute.HttpRetryPolicyProperty(\n                max_retries=123,\n                per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n\n                # the properties below are optional\n                http_retry_events=["httpRetryEvents"],\n                tcp_retry_events=["tcpRetryEvents"]\n            ),\n            timeout=appmesh.CfnRoute.HttpTimeoutProperty(\n                idle=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        ),\n        http_route=appmesh.CfnRoute.HttpRouteProperty(\n            action=appmesh.CfnRoute.HttpRouteActionProperty(\n                weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                    virtual_node="virtualNode",\n                    weight=123,\n\n                    # the properties below are optional\n                    port=123\n                )]\n            ),\n            match=appmesh.CfnRoute.HttpRouteMatchProperty(\n                headers=[appmesh.CfnRoute.HttpRouteHeaderProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnRoute.MatchRangeProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                method="method",\n                path=appmesh.CfnRoute.HttpPathMatchProperty(\n                    exact="exact",\n                    regex="regex"\n                ),\n                port=123,\n                prefix="prefix",\n                query_parameters=[appmesh.CfnRoute.QueryParameterProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                        exact="exact"\n                    )\n                )],\n                scheme="scheme"\n            ),\n\n            # the properties below are optional\n            retry_policy=appmesh.CfnRoute.HttpRetryPolicyProperty(\n                max_retries=123,\n                per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n\n                # the properties below are optional\n                http_retry_events=["httpRetryEvents"],\n                tcp_retry_events=["tcpRetryEvents"]\n            ),\n            timeout=appmesh.CfnRoute.HttpTimeoutProperty(\n                idle=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        ),\n        priority=123,\n        tcp_route=appmesh.CfnRoute.TcpRouteProperty(\n            action=appmesh.CfnRoute.TcpRouteActionProperty(\n                weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                    virtual_node="virtualNode",\n                    weight=123,\n\n                    # the properties below are optional\n                    port=123\n                )]\n            ),\n\n            # the properties below are optional\n            match=appmesh.CfnRoute.TcpRouteMatchProperty(\n                port=123\n            ),\n            timeout=appmesh.CfnRoute.TcpTimeoutProperty(\n                idle=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['grpc_route', 'http2_route', 'http_route', 'priority', 'tcp_route']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.RouteSpecProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.TcpRouteActionProperty
class CfnRoute_TcpRouteActionPropertyDef(BaseStruct):
    weighted_targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_WeightedTargetPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='An object that represents the targets that traffic is routed to when a request matches the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-tcprouteaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tcp_route_action_property = appmesh.CfnRoute.TcpRouteActionProperty(\n        weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n            virtual_node="virtualNode",\n            weight=123,\n\n            # the properties below are optional\n            port=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['weighted_targets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.TcpRouteActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.TcpRouteMatchProperty
class CfnRoute_TcpRouteMatchPropertyDef(BaseStruct):
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number to match on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-tcproutematch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tcp_route_match_property = appmesh.CfnRoute.TcpRouteMatchProperty(\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.TcpRouteMatchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.TcpRouteProperty
class CfnRoute_TcpRoutePropertyDef(BaseStruct):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_TcpRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The action to take if a match is determined.\n')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_TcpRouteMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents the criteria for determining a request match.\n')
    timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_TcpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents types of timeouts.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-tcproute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tcp_route_property = appmesh.CfnRoute.TcpRouteProperty(\n        action=appmesh.CfnRoute.TcpRouteActionProperty(\n            weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                virtual_node="virtualNode",\n                weight=123,\n\n                # the properties below are optional\n                port=123\n            )]\n        ),\n\n        # the properties below are optional\n        match=appmesh.CfnRoute.TcpRouteMatchProperty(\n            port=123\n        ),\n        timeout=appmesh.CfnRoute.TcpTimeoutProperty(\n            idle=appmesh.CfnRoute.DurationProperty(\n                unit="unit",\n                value=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'match', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.TcpRouteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.TcpTimeoutProperty
class CfnRoute_TcpTimeoutPropertyDef(BaseStruct):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-tcptimeout.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tcp_timeout_property = appmesh.CfnRoute.TcpTimeoutProperty(\n        idle=appmesh.CfnRoute.DurationProperty(\n            unit="unit",\n            value=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.TcpTimeoutProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRoute.WeightedTargetProperty
class CfnRoute_WeightedTargetPropertyDef(BaseStruct):
    virtual_node: str = pydantic.Field(..., description='The virtual node to associate with the weighted target.\n')
    weight: typing.Union[int, float] = pydantic.Field(..., description='The relative weight of the weighted target.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The targeted port of the weighted object.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-route-weightedtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    weighted_target_property = appmesh.CfnRoute.WeightedTargetProperty(\n        virtual_node="virtualNode",\n        weight=123,\n\n        # the properties below are optional\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_node', 'weight', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute.WeightedTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.JsonFormatRefProperty
class CfnVirtualGateway_JsonFormatRefPropertyDef(BaseStruct):
    key: str = pydantic.Field(..., description='The specified key for the JSON.\n')
    value: str = pydantic.Field(..., description='The specified value for the JSON.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-jsonformatref.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    json_format_ref_property = appmesh.CfnVirtualGateway.JsonFormatRefProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.JsonFormatRefProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.LoggingFormatProperty
class CfnVirtualGateway_LoggingFormatPropertyDef(BaseStruct):
    json_: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_JsonFormatRefPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The logging format for JSON.\n', alias='json')
    text: typing.Optional[str] = pydantic.Field(None, description='The logging format for text.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-loggingformat.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    logging_format_property = appmesh.CfnVirtualGateway.LoggingFormatProperty(\n        json=[appmesh.CfnVirtualGateway.JsonFormatRefProperty(\n            key="key",\n            value="value"\n        )],\n        text="text"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['json', 'text']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.LoggingFormatProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty
class CfnVirtualGateway_SubjectAlternativeNameMatchersPropertyDef(BaseStruct):
    exact: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The values sent must match the specified values exactly.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-subjectalternativenamematchers.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    subject_alternative_name_matchers_property = appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n        exact=["exact"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty
class CfnVirtualGateway_SubjectAlternativeNamesPropertyDef(BaseStruct):
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_SubjectAlternativeNameMatchersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the criteria for determining a SANs match.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-subjectalternativenames.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    subject_alternative_names_property = appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n        match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n            exact=["exact"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayAccessLogProperty
class CfnVirtualGateway_VirtualGatewayAccessLogPropertyDef(BaseStruct):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayFileAccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The file object to send virtual gateway access logs to.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayaccesslog.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_access_log_property = appmesh.CfnVirtualGateway.VirtualGatewayAccessLogProperty(\n        file=appmesh.CfnVirtualGateway.VirtualGatewayFileAccessLogProperty(\n            path="path",\n\n            # the properties below are optional\n            format=appmesh.CfnVirtualGateway.LoggingFormatProperty(\n                json=[appmesh.CfnVirtualGateway.JsonFormatRefProperty(\n                    key="key",\n                    value="value"\n                )],\n                text="text"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayAccessLogProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayBackendDefaultsProperty
class CfnVirtualGateway_VirtualGatewayBackendDefaultsPropertyDef(BaseStruct):
    client_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayClientPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a client policy.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaybackenddefaults.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_backend_defaults_property = appmesh.CfnVirtualGateway.VirtualGatewayBackendDefaultsProperty(\n        client_policy=appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyProperty(\n            tls=appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyTlsProperty(\n                validation=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextProperty(\n                    trust=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty(\n                        acm=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty(\n                            certificate_authority_arns=["certificateAuthorityArns"]\n                        ),\n                        file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                            certificate_chain="certificateChain"\n                        ),\n                        sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n\n                    # the properties below are optional\n                    subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                        match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                            exact=["exact"]\n                        )\n                    )\n                ),\n\n                # the properties below are optional\n                certificate=appmesh.CfnVirtualGateway.VirtualGatewayClientTlsCertificateProperty(\n                    file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                        certificate_chain="certificateChain",\n                        private_key="privateKey"\n                    ),\n                    sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                        secret_name="secretName"\n                    )\n                ),\n                enforce=False,\n                ports=[123]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayBackendDefaultsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyProperty
class CfnVirtualGateway_VirtualGatewayClientPolicyPropertyDef(BaseStruct):
    tls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayClientPolicyTlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a Transport Layer Security (TLS) client policy.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayclientpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_client_policy_property = appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyProperty(\n        tls=appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyTlsProperty(\n            validation=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextProperty(\n                trust=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty(\n                    acm=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty(\n                        certificate_authority_arns=["certificateAuthorityArns"]\n                    ),\n                    file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                        certificate_chain="certificateChain"\n                    ),\n                    sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                        secret_name="secretName"\n                    )\n                ),\n\n                # the properties below are optional\n                subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                    match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                        exact=["exact"]\n                    )\n                )\n            ),\n\n            # the properties below are optional\n            certificate=appmesh.CfnVirtualGateway.VirtualGatewayClientTlsCertificateProperty(\n                file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                    certificate_chain="certificateChain",\n                    private_key="privateKey"\n                ),\n                sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                    secret_name="secretName"\n                )\n            ),\n            enforce=False,\n            ports=[123]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyTlsProperty
class CfnVirtualGateway_VirtualGatewayClientPolicyTlsPropertyDef(BaseStruct):
    validation: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A reference to an object that represents a Transport Layer Security (TLS) validation context.\n')
    certificate: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayClientTlsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="A reference to an object that represents a virtual gateway's client's Transport Layer Security (TLS) certificate.\n")
    enforce: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Whether the policy is enforced. The default is ``True`` , if a value isn't specified.\n")
    ports: typing.Union[typing.Sequence[typing.Union[int, float]], typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='One or more ports that the policy is enforced for.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayclientpolicytls.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_client_policy_tls_property = appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyTlsProperty(\n        validation=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextProperty(\n            trust=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty(\n                acm=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty(\n                    certificate_authority_arns=["certificateAuthorityArns"]\n                ),\n                file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                    certificate_chain="certificateChain"\n                ),\n                sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                    secret_name="secretName"\n                )\n            ),\n\n            # the properties below are optional\n            subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                    exact=["exact"]\n                )\n            )\n        ),\n\n        # the properties below are optional\n        certificate=appmesh.CfnVirtualGateway.VirtualGatewayClientTlsCertificateProperty(\n            file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                certificate_chain="certificateChain",\n                private_key="privateKey"\n            ),\n            sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                secret_name="secretName"\n            )\n        ),\n        enforce=False,\n        ports=[123]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['validation', 'certificate', 'enforce', 'ports']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyTlsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayClientTlsCertificateProperty
class CfnVirtualGateway_VirtualGatewayClientTlsCertificatePropertyDef(BaseStruct):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsFileCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see `Transport Layer Security (TLS) <https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html>`_ .\n')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsSdsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a virtual gateway\'s client\'s Secret Discovery Service certificate.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayclienttlscertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_client_tls_certificate_property = appmesh.CfnVirtualGateway.VirtualGatewayClientTlsCertificateProperty(\n        file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n            certificate_chain="certificateChain",\n            private_key="privateKey"\n        ),\n        sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n            secret_name="secretName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file', 'sds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayClientTlsCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayConnectionPoolProperty
class CfnVirtualGateway_VirtualGatewayConnectionPoolPropertyDef(BaseStruct):
    grpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayGrpcConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a type of connection pool.\n')
    http: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayHttpConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a type of connection pool.\n')
    http2: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayHttp2ConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a type of connection pool.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayconnectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_connection_pool_property = appmesh.CfnVirtualGateway.VirtualGatewayConnectionPoolProperty(\n        grpc=appmesh.CfnVirtualGateway.VirtualGatewayGrpcConnectionPoolProperty(\n            max_requests=123\n        ),\n        http=appmesh.CfnVirtualGateway.VirtualGatewayHttpConnectionPoolProperty(\n            max_connections=123,\n\n            # the properties below are optional\n            max_pending_requests=123\n        ),\n        http2=appmesh.CfnVirtualGateway.VirtualGatewayHttp2ConnectionPoolProperty(\n            max_requests=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayFileAccessLogProperty
class CfnVirtualGateway_VirtualGatewayFileAccessLogPropertyDef(BaseStruct):
    path: str = pydantic.Field(..., description="The file path to write access logs to. You can use ``/dev/stdout`` to send access logs to standard out and configure your Envoy container to use a log driver, such as ``awslogs`` , to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk.\n")
    format: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_LoggingFormatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The specified format for the virtual gateway access logs. It can be either ``json_format`` or ``text_format`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayfileaccesslog.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_file_access_log_property = appmesh.CfnVirtualGateway.VirtualGatewayFileAccessLogProperty(\n        path="path",\n\n        # the properties below are optional\n        format=appmesh.CfnVirtualGateway.LoggingFormatProperty(\n            json=[appmesh.CfnVirtualGateway.JsonFormatRefProperty(\n                key="key",\n                value="value"\n            )],\n            text="text"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['path', 'format']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayFileAccessLogProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayGrpcConnectionPoolProperty
class CfnVirtualGateway_VirtualGatewayGrpcConnectionPoolPropertyDef(BaseStruct):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaygrpcconnectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_grpc_connection_pool_property = appmesh.CfnVirtualGateway.VirtualGatewayGrpcConnectionPoolProperty(\n        max_requests=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayGrpcConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayHealthCheckPolicyProperty
class CfnVirtualGateway_VirtualGatewayHealthCheckPolicyPropertyDef(BaseStruct):
    healthy_threshold: typing.Union[int, float] = pydantic.Field(..., description='The number of consecutive successful health checks that must occur before declaring the listener healthy.\n')
    interval_millis: typing.Union[int, float] = pydantic.Field(..., description='The time period in milliseconds between each health check execution.\n')
    protocol: str = pydantic.Field(..., description='The protocol for the health check request. If you specify ``grpc`` , then your service must conform to the `GRPC Health Checking Protocol <https://docs.aws.amazon.com/https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ .\n')
    timeout_millis: typing.Union[int, float] = pydantic.Field(..., description='The amount of time to wait when receiving a response from the health check, in milliseconds.\n')
    unhealthy_threshold: typing.Union[int, float] = pydantic.Field(..., description='The number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The destination port for the health check request. This port must match the port defined in the ``PortMapping`` for the listener.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayhealthcheckpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_health_check_policy_property = appmesh.CfnVirtualGateway.VirtualGatewayHealthCheckPolicyProperty(\n        healthy_threshold=123,\n        interval_millis=123,\n        protocol="protocol",\n        timeout_millis=123,\n        unhealthy_threshold=123,\n\n        # the properties below are optional\n        path="path",\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['healthy_threshold', 'interval_millis', 'protocol', 'timeout_millis', 'unhealthy_threshold', 'path', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayHealthCheckPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayHttp2ConnectionPoolProperty
class CfnVirtualGateway_VirtualGatewayHttp2ConnectionPoolPropertyDef(BaseStruct):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayhttp2connectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_http2_connection_pool_property = appmesh.CfnVirtualGateway.VirtualGatewayHttp2ConnectionPoolProperty(\n        max_requests=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayHttp2ConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayHttpConnectionPoolProperty
class CfnVirtualGateway_VirtualGatewayHttpConnectionPoolPropertyDef(BaseStruct):
    max_connections: typing.Union[int, float] = pydantic.Field(..., description='Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.\n')
    max_pending_requests: typing.Union[int, float, None] = pydantic.Field(None, description='Number of overflowing requests after ``max_connections`` Envoy will queue to upstream cluster.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayhttpconnectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_http_connection_pool_property = appmesh.CfnVirtualGateway.VirtualGatewayHttpConnectionPoolProperty(\n        max_connections=123,\n\n        # the properties below are optional\n        max_pending_requests=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_connections', 'max_pending_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayHttpConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerProperty
class CfnVirtualGateway_VirtualGatewayListenerPropertyDef(BaseStruct):
    port_mapping: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayPortMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The port mapping information for the listener.\n')
    connection_pool: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The connection pool information for the listener.\n')
    health_check: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayHealthCheckPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The health check information for the listener.\n')
    tls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the Transport Layer Security (TLS) properties for the listener.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylistener.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_property = appmesh.CfnVirtualGateway.VirtualGatewayListenerProperty(\n        port_mapping=appmesh.CfnVirtualGateway.VirtualGatewayPortMappingProperty(\n            port=123,\n            protocol="protocol"\n        ),\n\n        # the properties below are optional\n        connection_pool=appmesh.CfnVirtualGateway.VirtualGatewayConnectionPoolProperty(\n            grpc=appmesh.CfnVirtualGateway.VirtualGatewayGrpcConnectionPoolProperty(\n                max_requests=123\n            ),\n            http=appmesh.CfnVirtualGateway.VirtualGatewayHttpConnectionPoolProperty(\n                max_connections=123,\n\n                # the properties below are optional\n                max_pending_requests=123\n            ),\n            http2=appmesh.CfnVirtualGateway.VirtualGatewayHttp2ConnectionPoolProperty(\n                max_requests=123\n            )\n        ),\n        health_check=appmesh.CfnVirtualGateway.VirtualGatewayHealthCheckPolicyProperty(\n            healthy_threshold=123,\n            interval_millis=123,\n            protocol="protocol",\n            timeout_millis=123,\n            unhealthy_threshold=123,\n\n            # the properties below are optional\n            path="path",\n            port=123\n        ),\n        tls=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsProperty(\n            certificate=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsCertificateProperty(\n                acm=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty(\n                    certificate_arn="certificateArn"\n                ),\n                file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                    certificate_chain="certificateChain",\n                    private_key="privateKey"\n                ),\n                sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                    secret_name="secretName"\n                )\n            ),\n            mode="mode",\n\n            # the properties below are optional\n            validation=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextProperty(\n                trust=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty(\n                    file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                        certificate_chain="certificateChain"\n                    ),\n                    sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                        secret_name="secretName"\n                    )\n                ),\n\n                # the properties below are optional\n                subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                    match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                        exact=["exact"]\n                    )\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port_mapping', 'connection_pool', 'health_check', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty
class CfnVirtualGateway_VirtualGatewayListenerTlsAcmCertificatePropertyDef(BaseStruct):
    certificate_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see `Transport Layer Security (TLS) <https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites>`_ .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylistenertlsacmcertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_tls_acm_certificate_property = appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty(\n        certificate_arn="certificateArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsCertificateProperty
class CfnVirtualGateway_VirtualGatewayListenerTlsCertificatePropertyDef(BaseStruct):
    acm: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsAcmCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents an AWS Certificate Manager certificate.\n')
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsFileCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a local file certificate.\n')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsSdsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a virtual gateway\'s listener\'s Secret Discovery Service certificate.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylistenertlscertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_tls_certificate_property = appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsCertificateProperty(\n        acm=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty(\n            certificate_arn="certificateArn"\n        ),\n        file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n            certificate_chain="certificateChain",\n            private_key="privateKey"\n        ),\n        sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n            secret_name="secretName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['acm', 'file', 'sds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty
class CfnVirtualGateway_VirtualGatewayListenerTlsFileCertificatePropertyDef(BaseStruct):
    certificate_chain: str = pydantic.Field(..., description='The certificate chain for the certificate.\n')
    private_key: str = pydantic.Field(..., description='The private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylistenertlsfilecertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_tls_file_certificate_property = appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n        certificate_chain="certificateChain",\n        private_key="privateKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_chain', 'private_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsProperty
class CfnVirtualGateway_VirtualGatewayListenerTlsPropertyDef(BaseStruct):
    certificate: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsCertificatePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents a Transport Layer Security (TLS) certificate.\n')
    mode: str = pydantic.Field(..., description='Specify one of the following modes. - ** STRICT  Listener only accepts connections with TLS enabled. - ** PERMISSIVE  Listener accepts connections with or without TLS enabled. - ** DISABLED  Listener only accepts connections without TLS.\n')
    validation: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a virtual gateway\'s listener\'s Transport Layer Security (TLS) validation context.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylistenertls.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_tls_property = appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsProperty(\n        certificate=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsCertificateProperty(\n            acm=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty(\n                certificate_arn="certificateArn"\n            ),\n            file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                certificate_chain="certificateChain",\n                private_key="privateKey"\n            ),\n            sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                secret_name="secretName"\n            )\n        ),\n        mode="mode",\n\n        # the properties below are optional\n        validation=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextProperty(\n            trust=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty(\n                file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                    certificate_chain="certificateChain"\n                ),\n                sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                    secret_name="secretName"\n                )\n            ),\n\n            # the properties below are optional\n            subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                    exact=["exact"]\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate', 'mode', 'validation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty
class CfnVirtualGateway_VirtualGatewayListenerTlsSdsCertificatePropertyDef(BaseStruct):
    secret_name: str = pydantic.Field(..., description='A reference to an object that represents the name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylistenertlssdscertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_tls_sds_certificate_property = appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n        secret_name="secretName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['secret_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextProperty
class CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextPropertyDef(BaseStruct):
    trust: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A reference to where to retrieve the trust chain when validating a peers Transport Layer Security (TLS) certificate.\n')
    subject_alternative_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_SubjectAlternativeNamesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the SANs for a virtual gateway listener\'s Transport Layer Security (TLS) validation context.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylistenertlsvalidationcontext.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_tls_validation_context_property = appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextProperty(\n        trust=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty(\n            file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                certificate_chain="certificateChain"\n            ),\n            sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                secret_name="secretName"\n            )\n        ),\n\n        # the properties below are optional\n        subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n            match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                exact=["exact"]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['trust', 'subject_alternative_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty
class CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextTrustPropertyDef(BaseStruct):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextFileTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a Transport Layer Security (TLS) validation context trust for a local file.\n')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextSdsTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a virtual gateway\'s listener\'s Transport Layer Security (TLS) Secret Discovery Service validation context trust.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylistenertlsvalidationcontexttrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_tls_validation_context_trust_property = appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty(\n        file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n            certificate_chain="certificateChain"\n        ),\n        sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n            secret_name="secretName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file', 'sds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayLoggingProperty
class CfnVirtualGateway_VirtualGatewayLoggingPropertyDef(BaseStruct):
    access_log: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayAccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The access log configuration.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaylogging.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_logging_property = appmesh.CfnVirtualGateway.VirtualGatewayLoggingProperty(\n        access_log=appmesh.CfnVirtualGateway.VirtualGatewayAccessLogProperty(\n            file=appmesh.CfnVirtualGateway.VirtualGatewayFileAccessLogProperty(\n                path="path",\n\n                # the properties below are optional\n                format=appmesh.CfnVirtualGateway.LoggingFormatProperty(\n                    json=[appmesh.CfnVirtualGateway.JsonFormatRefProperty(\n                        key="key",\n                        value="value"\n                    )],\n                    text="text"\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_log']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayLoggingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayPortMappingProperty
class CfnVirtualGateway_VirtualGatewayPortMappingPropertyDef(BaseStruct):
    port: typing.Union[int, float] = pydantic.Field(..., description='The port used for the port mapping. Specify one protocol.\n')
    protocol: str = pydantic.Field(..., description='The protocol used for the port mapping.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayportmapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_port_mapping_property = appmesh.CfnVirtualGateway.VirtualGatewayPortMappingProperty(\n        port=123,\n        protocol="protocol"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port', 'protocol']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayPortMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewaySpecProperty
class CfnVirtualGateway_VirtualGatewaySpecPropertyDef(BaseStruct):
    listeners: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='The listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.\n')
    backend_defaults: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayBackendDefaultsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the defaults for backends.\n')
    logging: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayLoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents logging information.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewayspec.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_spec_property = appmesh.CfnVirtualGateway.VirtualGatewaySpecProperty(\n        listeners=[appmesh.CfnVirtualGateway.VirtualGatewayListenerProperty(\n            port_mapping=appmesh.CfnVirtualGateway.VirtualGatewayPortMappingProperty(\n                port=123,\n                protocol="protocol"\n            ),\n\n            # the properties below are optional\n            connection_pool=appmesh.CfnVirtualGateway.VirtualGatewayConnectionPoolProperty(\n                grpc=appmesh.CfnVirtualGateway.VirtualGatewayGrpcConnectionPoolProperty(\n                    max_requests=123\n                ),\n                http=appmesh.CfnVirtualGateway.VirtualGatewayHttpConnectionPoolProperty(\n                    max_connections=123,\n\n                    # the properties below are optional\n                    max_pending_requests=123\n                ),\n                http2=appmesh.CfnVirtualGateway.VirtualGatewayHttp2ConnectionPoolProperty(\n                    max_requests=123\n                )\n            ),\n            health_check=appmesh.CfnVirtualGateway.VirtualGatewayHealthCheckPolicyProperty(\n                healthy_threshold=123,\n                interval_millis=123,\n                protocol="protocol",\n                timeout_millis=123,\n                unhealthy_threshold=123,\n\n                # the properties below are optional\n                path="path",\n                port=123\n            ),\n            tls=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsProperty(\n                certificate=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsCertificateProperty(\n                    acm=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty(\n                        certificate_arn="certificateArn"\n                    ),\n                    file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                        certificate_chain="certificateChain",\n                        private_key="privateKey"\n                    ),\n                    sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                        secret_name="secretName"\n                    )\n                ),\n                mode="mode",\n\n                # the properties below are optional\n                validation=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextProperty(\n                    trust=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty(\n                        file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                            certificate_chain="certificateChain"\n                        ),\n                        sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n\n                    # the properties below are optional\n                    subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                        match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                            exact=["exact"]\n                        )\n                    )\n                )\n            )\n        )],\n\n        # the properties below are optional\n        backend_defaults=appmesh.CfnVirtualGateway.VirtualGatewayBackendDefaultsProperty(\n            client_policy=appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyProperty(\n                tls=appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyTlsProperty(\n                    validation=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextProperty(\n                        trust=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty(\n                            acm=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty(\n                                certificate_authority_arns=["certificateAuthorityArns"]\n                            ),\n                            file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                                certificate_chain="certificateChain"\n                            ),\n                            sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n\n                        # the properties below are optional\n                        subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                            match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                                exact=["exact"]\n                            )\n                        )\n                    ),\n\n                    # the properties below are optional\n                    certificate=appmesh.CfnVirtualGateway.VirtualGatewayClientTlsCertificateProperty(\n                        file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                            certificate_chain="certificateChain",\n                            private_key="privateKey"\n                        ),\n                        sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n                    enforce=False,\n                    ports=[123]\n                )\n            )\n        ),\n        logging=appmesh.CfnVirtualGateway.VirtualGatewayLoggingProperty(\n            access_log=appmesh.CfnVirtualGateway.VirtualGatewayAccessLogProperty(\n                file=appmesh.CfnVirtualGateway.VirtualGatewayFileAccessLogProperty(\n                    path="path",\n\n                    # the properties below are optional\n                    format=appmesh.CfnVirtualGateway.LoggingFormatProperty(\n                        json=[appmesh.CfnVirtualGateway.JsonFormatRefProperty(\n                            key="key",\n                            value="value"\n                        )],\n                        text="text"\n                    )\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listeners', 'backend_defaults', 'logging']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewaySpecProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty
class CfnVirtualGateway_VirtualGatewayTlsValidationContextAcmTrustPropertyDef(BaseStruct):
    certificate_authority_arns: typing.Sequence[str] = pydantic.Field(..., description='One or more ACM Amazon Resource Name (ARN)s.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaytlsvalidationcontextacmtrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_tls_validation_context_acm_trust_property = appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty(\n        certificate_authority_arns=["certificateAuthorityArns"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_authority_arns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty
class CfnVirtualGateway_VirtualGatewayTlsValidationContextFileTrustPropertyDef(BaseStruct):
    certificate_chain: str = pydantic.Field(..., description='The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaytlsvalidationcontextfiletrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_tls_validation_context_file_trust_property = appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n        certificate_chain="certificateChain"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_chain']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextProperty
class CfnVirtualGateway_VirtualGatewayTlsValidationContextPropertyDef(BaseStruct):
    trust: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A reference to where to retrieve the trust chain when validating a peers Transport Layer Security (TLS) certificate.\n')
    subject_alternative_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_SubjectAlternativeNamesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the SANs for a virtual gateway\'s listener\'s Transport Layer Security (TLS) validation context.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaytlsvalidationcontext.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_tls_validation_context_property = appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextProperty(\n        trust=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty(\n            acm=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty(\n                certificate_authority_arns=["certificateAuthorityArns"]\n            ),\n            file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                certificate_chain="certificateChain"\n            ),\n            sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                secret_name="secretName"\n            )\n        ),\n\n        # the properties below are optional\n        subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n            match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                exact=["exact"]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['trust', 'subject_alternative_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty
class CfnVirtualGateway_VirtualGatewayTlsValidationContextSdsTrustPropertyDef(BaseStruct):
    secret_name: str = pydantic.Field(..., description='A reference to an object that represents the name of the secret for a virtual gateway\'s Transport Layer Security (TLS) Secret Discovery Service validation context trust.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaytlsvalidationcontextsdstrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_tls_validation_context_sds_trust_property = appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n        secret_name="secretName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['secret_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty
class CfnVirtualGateway_VirtualGatewayTlsValidationContextTrustPropertyDef(BaseStruct):
    acm: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextAcmTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an AWS Certificate Manager certificate.\n')
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextFileTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a Transport Layer Security (TLS) validation context trust for a local file.\n')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextSdsTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a virtual gateway\'s Transport Layer Security (TLS) Secret Discovery Service validation context trust.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualgateway-virtualgatewaytlsvalidationcontexttrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_tls_validation_context_trust_property = appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty(\n        acm=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty(\n            certificate_authority_arns=["certificateAuthorityArns"]\n        ),\n        file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n            certificate_chain="certificateChain"\n        ),\n        sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n            secret_name="secretName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['acm', 'file', 'sds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.AccessLogProperty
class CfnVirtualNode_AccessLogPropertyDef(BaseStruct):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_FileAccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The file object to send virtual node access logs to.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-accesslog.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    access_log_property = appmesh.CfnVirtualNode.AccessLogProperty(\n        file=appmesh.CfnVirtualNode.FileAccessLogProperty(\n            path="path",\n\n            # the properties below are optional\n            format=appmesh.CfnVirtualNode.LoggingFormatProperty(\n                json=[appmesh.CfnVirtualNode.JsonFormatRefProperty(\n                    key="key",\n                    value="value"\n                )],\n                text="text"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.AccessLogProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.AwsCloudMapInstanceAttributeProperty
class CfnVirtualNode_AwsCloudMapInstanceAttributePropertyDef(BaseStruct):
    key: str = pydantic.Field(..., description='The name of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service instance that contains the specified key and value is returned.\n')
    value: str = pydantic.Field(..., description='The value of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service instance that contains the specified key and value is returned.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-awscloudmapinstanceattribute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    aws_cloud_map_instance_attribute_property = appmesh.CfnVirtualNode.AwsCloudMapInstanceAttributeProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.AwsCloudMapInstanceAttributeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.AwsCloudMapServiceDiscoveryProperty
class CfnVirtualNode_AwsCloudMapServiceDiscoveryPropertyDef(BaseStruct):
    namespace_name: str = pydantic.Field(..., description='The HTTP name of the AWS Cloud Map namespace to use.\n')
    service_name: str = pydantic.Field(..., description='The name of the AWS Cloud Map service to use.\n')
    attributes: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_AwsCloudMapInstanceAttributePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A string map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.\n')
    ip_preference: typing.Optional[str] = pydantic.Field(None, description='The preferred IP version that this virtual node uses. Setting the IP preference on the virtual node only overrides the IP preference set for the mesh on this specific node.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-awscloudmapservicediscovery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    aws_cloud_map_service_discovery_property = appmesh.CfnVirtualNode.AwsCloudMapServiceDiscoveryProperty(\n        namespace_name="namespaceName",\n        service_name="serviceName",\n\n        # the properties below are optional\n        attributes=[appmesh.CfnVirtualNode.AwsCloudMapInstanceAttributeProperty(\n            key="key",\n            value="value"\n        )],\n        ip_preference="ipPreference"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace_name', 'service_name', 'attributes', 'ip_preference']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.AwsCloudMapServiceDiscoveryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.BackendDefaultsProperty
class CfnVirtualNode_BackendDefaultsPropertyDef(BaseStruct):
    client_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ClientPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a client policy.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-backenddefaults.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    backend_defaults_property = appmesh.CfnVirtualNode.BackendDefaultsProperty(\n        client_policy=appmesh.CfnVirtualNode.ClientPolicyProperty(\n            tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n                validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                    trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                        acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                            certificate_authority_arns=["certificateAuthorityArns"]\n                        ),\n                        file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                            certificate_chain="certificateChain"\n                        ),\n                        sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n\n                    # the properties below are optional\n                    subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                        match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                            exact=["exact"]\n                        )\n                    )\n                ),\n\n                # the properties below are optional\n                certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                    file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                        certificate_chain="certificateChain",\n                        private_key="privateKey"\n                    ),\n                    sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                        secret_name="secretName"\n                    )\n                ),\n                enforce=False,\n                ports=[123]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.BackendDefaultsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.BackendProperty
class CfnVirtualNode_BackendPropertyDef(BaseStruct):
    virtual_service: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualServiceBackendPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies a virtual service to use as a backend.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-backend.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    backend_property = appmesh.CfnVirtualNode.BackendProperty(\n        virtual_service=appmesh.CfnVirtualNode.VirtualServiceBackendProperty(\n            virtual_service_name="virtualServiceName",\n\n            # the properties below are optional\n            client_policy=appmesh.CfnVirtualNode.ClientPolicyProperty(\n                tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n                    validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                        trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                            acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                                certificate_authority_arns=["certificateAuthorityArns"]\n                            ),\n                            file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                                certificate_chain="certificateChain"\n                            ),\n                            sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n\n                        # the properties below are optional\n                        subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                            match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                                exact=["exact"]\n                            )\n                        )\n                    ),\n\n                    # the properties below are optional\n                    certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                        file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                            certificate_chain="certificateChain",\n                            private_key="privateKey"\n                        ),\n                        sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n                    enforce=False,\n                    ports=[123]\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_service']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.BackendProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ClientPolicyProperty
class CfnVirtualNode_ClientPolicyPropertyDef(BaseStruct):
    tls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ClientPolicyTlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a Transport Layer Security (TLS) client policy.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-clientpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    client_policy_property = appmesh.CfnVirtualNode.ClientPolicyProperty(\n        tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n            validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                    acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                        certificate_authority_arns=["certificateAuthorityArns"]\n                    ),\n                    file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                        certificate_chain="certificateChain"\n                    ),\n                    sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                        secret_name="secretName"\n                    )\n                ),\n\n                # the properties below are optional\n                subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                    match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                        exact=["exact"]\n                    )\n                )\n            ),\n\n            # the properties below are optional\n            certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                    certificate_chain="certificateChain",\n                    private_key="privateKey"\n                ),\n                sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                    secret_name="secretName"\n                )\n            ),\n            enforce=False,\n            ports=[123]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ClientPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ClientPolicyTlsProperty
class CfnVirtualNode_ClientPolicyTlsPropertyDef(BaseStruct):
    validation: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A reference to an object that represents a TLS validation context.\n')
    certificate: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ClientTlsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="A reference to an object that represents a client's TLS certificate.\n")
    enforce: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Whether the policy is enforced. The default is ``True`` , if a value isn't specified.\n")
    ports: typing.Union[typing.Sequence[typing.Union[int, float]], typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='One or more ports that the policy is enforced for.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-clientpolicytls.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    client_policy_tls_property = appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n        validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n            trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                    certificate_authority_arns=["certificateAuthorityArns"]\n                ),\n                file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                    certificate_chain="certificateChain"\n                ),\n                sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                    secret_name="secretName"\n                )\n            ),\n\n            # the properties below are optional\n            subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                    exact=["exact"]\n                )\n            )\n        ),\n\n        # the properties below are optional\n        certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n            file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                certificate_chain="certificateChain",\n                private_key="privateKey"\n            ),\n            sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                secret_name="secretName"\n            )\n        ),\n        enforce=False,\n        ports=[123]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['validation', 'certificate', 'enforce', 'ports']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ClientPolicyTlsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ClientTlsCertificateProperty
class CfnVirtualNode_ClientTlsCertificatePropertyDef(BaseStruct):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsFileCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see `Transport Layer Security (TLS) <https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html>`_ .\n')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsSdsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a client\'s TLS Secret Discovery Service certificate.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-clienttlscertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    client_tls_certificate_property = appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n        file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n            certificate_chain="certificateChain",\n            private_key="privateKey"\n        ),\n        sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n            secret_name="secretName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file', 'sds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ClientTlsCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.DnsServiceDiscoveryProperty
class CfnVirtualNode_DnsServiceDiscoveryPropertyDef(BaseStruct):
    hostname: str = pydantic.Field(..., description='Specifies the DNS service discovery hostname for the virtual node.\n')
    ip_preference: typing.Optional[str] = pydantic.Field(None, description='The preferred IP version that this virtual node uses. Setting the IP preference on the virtual node only overrides the IP preference set for the mesh on this specific node.\n')
    response_type: typing.Optional[str] = pydantic.Field(None, description='Specifies the DNS response type for the virtual node.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-dnsservicediscovery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    dns_service_discovery_property = appmesh.CfnVirtualNode.DnsServiceDiscoveryProperty(\n        hostname="hostname",\n\n        # the properties below are optional\n        ip_preference="ipPreference",\n        response_type="responseType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hostname', 'ip_preference', 'response_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.DnsServiceDiscoveryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.DurationProperty
class CfnVirtualNode_DurationPropertyDef(BaseStruct):
    unit: str = pydantic.Field(..., description='A unit of time.\n')
    value: typing.Union[int, float] = pydantic.Field(..., description='A number of time units.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-duration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    duration_property = appmesh.CfnVirtualNode.DurationProperty(\n        unit="unit",\n        value=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['unit', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.DurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.FileAccessLogProperty
class CfnVirtualNode_FileAccessLogPropertyDef(BaseStruct):
    path: str = pydantic.Field(..., description="The file path to write access logs to. You can use ``/dev/stdout`` to send access logs to standard out and configure your Envoy container to use a log driver, such as ``awslogs`` , to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk. .. epigraph:: The Envoy process must have write permissions to the path that you specify here. Otherwise, Envoy fails to bootstrap properly.\n")
    format: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_LoggingFormatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The specified format for the logs. The format is either ``json_format`` or ``text_format`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-fileaccesslog.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    file_access_log_property = appmesh.CfnVirtualNode.FileAccessLogProperty(\n        path="path",\n\n        # the properties below are optional\n        format=appmesh.CfnVirtualNode.LoggingFormatProperty(\n            json=[appmesh.CfnVirtualNode.JsonFormatRefProperty(\n                key="key",\n                value="value"\n            )],\n            text="text"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['path', 'format']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.FileAccessLogProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.GrpcTimeoutProperty
class CfnVirtualNode_GrpcTimeoutPropertyDef(BaseStruct):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.\n')
    per_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-grpctimeout.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_timeout_property = appmesh.CfnVirtualNode.GrpcTimeoutProperty(\n        idle=appmesh.CfnVirtualNode.DurationProperty(\n            unit="unit",\n            value=123\n        ),\n        per_request=appmesh.CfnVirtualNode.DurationProperty(\n            unit="unit",\n            value=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle', 'per_request']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.GrpcTimeoutProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.HealthCheckProperty
class CfnVirtualNode_HealthCheckPropertyDef(BaseStruct):
    healthy_threshold: typing.Union[int, float] = pydantic.Field(..., description='The number of consecutive successful health checks that must occur before declaring listener healthy.\n')
    interval_millis: typing.Union[int, float] = pydantic.Field(..., description='The time period in milliseconds between each health check execution.\n')
    protocol: str = pydantic.Field(..., description='The protocol for the health check request. If you specify ``grpc`` , then your service must conform to the `GRPC Health Checking Protocol <https://docs.aws.amazon.com/https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ .\n')
    timeout_millis: typing.Union[int, float] = pydantic.Field(..., description='The amount of time to wait when receiving a response from the health check, in milliseconds.\n')
    unhealthy_threshold: typing.Union[int, float] = pydantic.Field(..., description='The number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The destination port for the health check request. This port must match the port defined in the ``PortMapping`` for the listener.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-healthcheck.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    health_check_property = appmesh.CfnVirtualNode.HealthCheckProperty(\n        healthy_threshold=123,\n        interval_millis=123,\n        protocol="protocol",\n        timeout_millis=123,\n        unhealthy_threshold=123,\n\n        # the properties below are optional\n        path="path",\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['healthy_threshold', 'interval_millis', 'protocol', 'timeout_millis', 'unhealthy_threshold', 'path', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.HealthCheckProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.HttpTimeoutProperty
class CfnVirtualNode_HttpTimeoutPropertyDef(BaseStruct):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.\n')
    per_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-httptimeout.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_timeout_property = appmesh.CfnVirtualNode.HttpTimeoutProperty(\n        idle=appmesh.CfnVirtualNode.DurationProperty(\n            unit="unit",\n            value=123\n        ),\n        per_request=appmesh.CfnVirtualNode.DurationProperty(\n            unit="unit",\n            value=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle', 'per_request']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.HttpTimeoutProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.JsonFormatRefProperty
class CfnVirtualNode_JsonFormatRefPropertyDef(BaseStruct):
    key: str = pydantic.Field(..., description='The specified key for the JSON.\n')
    value: str = pydantic.Field(..., description='The specified value for the JSON.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-jsonformatref.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    json_format_ref_property = appmesh.CfnVirtualNode.JsonFormatRefProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.JsonFormatRefProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerProperty
class CfnVirtualNode_ListenerPropertyDef(BaseStruct):
    port_mapping: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_PortMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The port mapping information for the listener.\n')
    connection_pool: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The connection pool information for the listener.\n')
    health_check: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_HealthCheckPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The health check information for the listener.\n')
    outlier_detection: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_OutlierDetectionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The outlier detection information for the listener.\n')
    timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents timeouts for different protocols.\n')
    tls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the Transport Layer Security (TLS) properties for a listener.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listener.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_property = appmesh.CfnVirtualNode.ListenerProperty(\n        port_mapping=appmesh.CfnVirtualNode.PortMappingProperty(\n            port=123,\n            protocol="protocol"\n        ),\n\n        # the properties below are optional\n        connection_pool=appmesh.CfnVirtualNode.VirtualNodeConnectionPoolProperty(\n            grpc=appmesh.CfnVirtualNode.VirtualNodeGrpcConnectionPoolProperty(\n                max_requests=123\n            ),\n            http=appmesh.CfnVirtualNode.VirtualNodeHttpConnectionPoolProperty(\n                max_connections=123,\n\n                # the properties below are optional\n                max_pending_requests=123\n            ),\n            http2=appmesh.CfnVirtualNode.VirtualNodeHttp2ConnectionPoolProperty(\n                max_requests=123\n            ),\n            tcp=appmesh.CfnVirtualNode.VirtualNodeTcpConnectionPoolProperty(\n                max_connections=123\n            )\n        ),\n        health_check=appmesh.CfnVirtualNode.HealthCheckProperty(\n            healthy_threshold=123,\n            interval_millis=123,\n            protocol="protocol",\n            timeout_millis=123,\n            unhealthy_threshold=123,\n\n            # the properties below are optional\n            path="path",\n            port=123\n        ),\n        outlier_detection=appmesh.CfnVirtualNode.OutlierDetectionProperty(\n            base_ejection_duration=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n            interval=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n            max_ejection_percent=123,\n            max_server_errors=123\n        ),\n        timeout=appmesh.CfnVirtualNode.ListenerTimeoutProperty(\n            grpc=appmesh.CfnVirtualNode.GrpcTimeoutProperty(\n                idle=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            ),\n            http=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n                idle=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            ),\n            http2=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n                idle=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            ),\n            tcp=appmesh.CfnVirtualNode.TcpTimeoutProperty(\n                idle=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        ),\n        tls=appmesh.CfnVirtualNode.ListenerTlsProperty(\n            certificate=appmesh.CfnVirtualNode.ListenerTlsCertificateProperty(\n                acm=appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty(\n                    certificate_arn="certificateArn"\n                ),\n                file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                    certificate_chain="certificateChain",\n                    private_key="privateKey"\n                ),\n                sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                    secret_name="secretName"\n                )\n            ),\n            mode="mode",\n\n            # the properties below are optional\n            validation=appmesh.CfnVirtualNode.ListenerTlsValidationContextProperty(\n                trust=appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty(\n                    file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                        certificate_chain="certificateChain"\n                    ),\n                    sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                        secret_name="secretName"\n                    )\n                ),\n\n                # the properties below are optional\n                subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                    match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                        exact=["exact"]\n                    )\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port_mapping', 'connection_pool', 'health_check', 'outlier_detection', 'timeout', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTimeoutProperty
class CfnVirtualNode_ListenerTimeoutPropertyDef(BaseStruct):
    grpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_GrpcTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents types of timeouts.\n')
    http: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_HttpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents types of timeouts.\n')
    http2: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_HttpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents types of timeouts.\n')
    tcp: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TcpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents types of timeouts.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listenertimeout.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_timeout_property = appmesh.CfnVirtualNode.ListenerTimeoutProperty(\n        grpc=appmesh.CfnVirtualNode.GrpcTimeoutProperty(\n            idle=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n            per_request=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            )\n        ),\n        http=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n            idle=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n            per_request=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            )\n        ),\n        http2=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n            idle=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            ),\n            per_request=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            )\n        ),\n        tcp=appmesh.CfnVirtualNode.TcpTimeoutProperty(\n            idle=appmesh.CfnVirtualNode.DurationProperty(\n                unit="unit",\n                value=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2', 'tcp']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTimeoutProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty
class CfnVirtualNode_ListenerTlsAcmCertificatePropertyDef(BaseStruct):
    certificate_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see `Transport Layer Security (TLS) <https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites>`_ .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listenertlsacmcertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_tls_acm_certificate_property = appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty(\n        certificate_arn="certificateArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsCertificateProperty
class CfnVirtualNode_ListenerTlsCertificatePropertyDef(BaseStruct):
    acm: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsAcmCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents an AWS Certificate Manager certificate.\n')
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsFileCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a local file certificate.\n')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsSdsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a listener\'s Secret Discovery Service certificate.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listenertlscertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_tls_certificate_property = appmesh.CfnVirtualNode.ListenerTlsCertificateProperty(\n        acm=appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty(\n            certificate_arn="certificateArn"\n        ),\n        file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n            certificate_chain="certificateChain",\n            private_key="privateKey"\n        ),\n        sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n            secret_name="secretName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['acm', 'file', 'sds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty
class CfnVirtualNode_ListenerTlsFileCertificatePropertyDef(BaseStruct):
    certificate_chain: str = pydantic.Field(..., description='The certificate chain for the certificate.\n')
    private_key: str = pydantic.Field(..., description='The private key for a certificate stored on the file system of the virtual node that the proxy is running on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listenertlsfilecertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_tls_file_certificate_property = appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n        certificate_chain="certificateChain",\n        private_key="privateKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_chain', 'private_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsProperty
class CfnVirtualNode_ListenerTlsPropertyDef(BaseStruct):
    certificate: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsCertificatePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description="A reference to an object that represents a listener's Transport Layer Security (TLS) certificate.\n")
    mode: str = pydantic.Field(..., description='Specify one of the following modes. - ** STRICT  Listener only accepts connections with TLS enabled. - ** PERMISSIVE  Listener accepts connections with or without TLS enabled. - ** DISABLED  Listener only accepts connections without TLS.\n')
    validation: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsValidationContextPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a listener\'s Transport Layer Security (TLS) validation context.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listenertls.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_tls_property = appmesh.CfnVirtualNode.ListenerTlsProperty(\n        certificate=appmesh.CfnVirtualNode.ListenerTlsCertificateProperty(\n            acm=appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty(\n                certificate_arn="certificateArn"\n            ),\n            file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                certificate_chain="certificateChain",\n                private_key="privateKey"\n            ),\n            sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                secret_name="secretName"\n            )\n        ),\n        mode="mode",\n\n        # the properties below are optional\n        validation=appmesh.CfnVirtualNode.ListenerTlsValidationContextProperty(\n            trust=appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty(\n                file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                    certificate_chain="certificateChain"\n                ),\n                sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                    secret_name="secretName"\n                )\n            ),\n\n            # the properties below are optional\n            subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                    exact=["exact"]\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate', 'mode', 'validation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty
class CfnVirtualNode_ListenerTlsSdsCertificatePropertyDef(BaseStruct):
    secret_name: str = pydantic.Field(..., description='A reference to an object that represents the name of the secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listenertlssdscertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_tls_sds_certificate_property = appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n        secret_name="secretName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['secret_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsValidationContextProperty
class CfnVirtualNode_ListenerTlsValidationContextPropertyDef(BaseStruct):
    trust: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A reference to where to retrieve the trust chain when validating a peers Transport Layer Security (TLS) certificate.\n')
    subject_alternative_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_SubjectAlternativeNamesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the SANs for a listener\'s Transport Layer Security (TLS) validation context.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listenertlsvalidationcontext.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_tls_validation_context_property = appmesh.CfnVirtualNode.ListenerTlsValidationContextProperty(\n        trust=appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty(\n            file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                certificate_chain="certificateChain"\n            ),\n            sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                secret_name="secretName"\n            )\n        ),\n\n        # the properties below are optional\n        subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n            match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                exact=["exact"]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['trust', 'subject_alternative_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsValidationContextProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty
class CfnVirtualNode_ListenerTlsValidationContextTrustPropertyDef(BaseStruct):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextFileTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a Transport Layer Security (TLS) validation context trust for a local file.\n')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextSdsTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a listener\'s Transport Layer Security (TLS) Secret Discovery Service validation context trust.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-listenertlsvalidationcontexttrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    listener_tls_validation_context_trust_property = appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty(\n        file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n            certificate_chain="certificateChain"\n        ),\n        sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n            secret_name="secretName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file', 'sds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.LoggingFormatProperty
class CfnVirtualNode_LoggingFormatPropertyDef(BaseStruct):
    json_: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_JsonFormatRefPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The logging format for JSON.\n', alias='json')
    text: typing.Optional[str] = pydantic.Field(None, description='The logging format for text.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-loggingformat.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    logging_format_property = appmesh.CfnVirtualNode.LoggingFormatProperty(\n        json=[appmesh.CfnVirtualNode.JsonFormatRefProperty(\n            key="key",\n            value="value"\n        )],\n        text="text"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['json', 'text']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.LoggingFormatProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.LoggingProperty
class CfnVirtualNode_LoggingPropertyDef(BaseStruct):
    access_log: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_AccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The access log configuration for a virtual node.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-logging.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    logging_property = appmesh.CfnVirtualNode.LoggingProperty(\n        access_log=appmesh.CfnVirtualNode.AccessLogProperty(\n            file=appmesh.CfnVirtualNode.FileAccessLogProperty(\n                path="path",\n\n                # the properties below are optional\n                format=appmesh.CfnVirtualNode.LoggingFormatProperty(\n                    json=[appmesh.CfnVirtualNode.JsonFormatRefProperty(\n                        key="key",\n                        value="value"\n                    )],\n                    text="text"\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_log']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.LoggingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.OutlierDetectionProperty
class CfnVirtualNode_OutlierDetectionPropertyDef(BaseStruct):
    base_ejection_duration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The base amount of time for which a host is ejected.\n')
    interval: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The time interval between ejection sweep analysis.\n')
    max_ejection_percent: typing.Union[int, float] = pydantic.Field(..., description='Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.\n')
    max_server_errors: typing.Union[int, float] = pydantic.Field(..., description='Number of consecutive ``5xx`` errors required for ejection.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-outlierdetection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    outlier_detection_property = appmesh.CfnVirtualNode.OutlierDetectionProperty(\n        base_ejection_duration=appmesh.CfnVirtualNode.DurationProperty(\n            unit="unit",\n            value=123\n        ),\n        interval=appmesh.CfnVirtualNode.DurationProperty(\n            unit="unit",\n            value=123\n        ),\n        max_ejection_percent=123,\n        max_server_errors=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_ejection_duration', 'interval', 'max_ejection_percent', 'max_server_errors']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.OutlierDetectionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.PortMappingProperty
class CfnVirtualNode_PortMappingPropertyDef(BaseStruct):
    port: typing.Union[int, float] = pydantic.Field(..., description='The port used for the port mapping.\n')
    protocol: str = pydantic.Field(..., description='The protocol used for the port mapping. Specify ``http`` , ``http2`` , ``grpc`` , or ``tcp`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-portmapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    port_mapping_property = appmesh.CfnVirtualNode.PortMappingProperty(\n        port=123,\n        protocol="protocol"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port', 'protocol']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.PortMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.ServiceDiscoveryProperty
class CfnVirtualNode_ServiceDiscoveryPropertyDef(BaseStruct):
    aws_cloud_map: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_AwsCloudMapServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies any AWS Cloud Map information for the virtual node.\n')
    dns: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DnsServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the DNS information for the virtual node.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-servicediscovery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    service_discovery_property = appmesh.CfnVirtualNode.ServiceDiscoveryProperty(\n        aws_cloud_map=appmesh.CfnVirtualNode.AwsCloudMapServiceDiscoveryProperty(\n            namespace_name="namespaceName",\n            service_name="serviceName",\n\n            # the properties below are optional\n            attributes=[appmesh.CfnVirtualNode.AwsCloudMapInstanceAttributeProperty(\n                key="key",\n                value="value"\n            )],\n            ip_preference="ipPreference"\n        ),\n        dns=appmesh.CfnVirtualNode.DnsServiceDiscoveryProperty(\n            hostname="hostname",\n\n            # the properties below are optional\n            ip_preference="ipPreference",\n            response_type="responseType"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['aws_cloud_map', 'dns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.ServiceDiscoveryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty
class CfnVirtualNode_SubjectAlternativeNameMatchersPropertyDef(BaseStruct):
    exact: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The values sent must match the specified values exactly.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-subjectalternativenamematchers.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    subject_alternative_name_matchers_property = appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n        exact=["exact"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exact']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty
class CfnVirtualNode_SubjectAlternativeNamesPropertyDef(BaseStruct):
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_SubjectAlternativeNameMatchersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='An object that represents the criteria for determining a SANs match.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-subjectalternativenames.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    subject_alternative_names_property = appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n        match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n            exact=["exact"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.TcpTimeoutProperty
class CfnVirtualNode_TcpTimeoutPropertyDef(BaseStruct):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-tcptimeout.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tcp_timeout_property = appmesh.CfnVirtualNode.TcpTimeoutProperty(\n        idle=appmesh.CfnVirtualNode.DurationProperty(\n            unit="unit",\n            value=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.TcpTimeoutProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty
class CfnVirtualNode_TlsValidationContextAcmTrustPropertyDef(BaseStruct):
    certificate_authority_arns: typing.Sequence[str] = pydantic.Field(..., description='One or more ACM Amazon Resource Name (ARN)s.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-tlsvalidationcontextacmtrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tls_validation_context_acm_trust_property = appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n        certificate_authority_arns=["certificateAuthorityArns"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_authority_arns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty
class CfnVirtualNode_TlsValidationContextFileTrustPropertyDef(BaseStruct):
    certificate_chain: str = pydantic.Field(..., description='The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-tlsvalidationcontextfiletrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tls_validation_context_file_trust_property = appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n        certificate_chain="certificateChain"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_chain']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextProperty
class CfnVirtualNode_TlsValidationContextPropertyDef(BaseStruct):
    trust: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='A reference to where to retrieve the trust chain when validating a peers Transport Layer Security (TLS) certificate.\n')
    subject_alternative_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_SubjectAlternativeNamesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the SANs for a Transport Layer Security (TLS) validation context. If you don\'t specify SANs on the *terminating* mesh endpoint, the Envoy proxy for that node doesn\'t verify the SAN on a peer client certificate. If you don\'t specify SANs on the *originating* mesh endpoint, the SAN on the certificate provided by the terminating endpoint must match the mesh endpoint service discovery configuration. Since SPIRE vended certificates have a SPIFFE ID as a name, you must set the SAN since the name doesn\'t match the service discovery name.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-tlsvalidationcontext.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tls_validation_context_property = appmesh.CfnVirtualNode.TlsValidationContextProperty(\n        trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n            acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                certificate_authority_arns=["certificateAuthorityArns"]\n            ),\n            file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                certificate_chain="certificateChain"\n            ),\n            sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                secret_name="secretName"\n            )\n        ),\n\n        # the properties below are optional\n        subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n            match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                exact=["exact"]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['trust', 'subject_alternative_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty
class CfnVirtualNode_TlsValidationContextSdsTrustPropertyDef(BaseStruct):
    secret_name: str = pydantic.Field(..., description='A reference to an object that represents the name of the secret for a Transport Layer Security (TLS) Secret Discovery Service validation context trust.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-tlsvalidationcontextsdstrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tls_validation_context_sds_trust_property = appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n        secret_name="secretName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['secret_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextTrustProperty
class CfnVirtualNode_TlsValidationContextTrustPropertyDef(BaseStruct):
    acm: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextAcmTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an AWS Certificate Manager certificate.\n')
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextFileTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a Transport Layer Security (TLS) validation context trust for a local file.\n')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextSdsTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-tlsvalidationcontexttrust.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tls_validation_context_trust_property = appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n        acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n            certificate_authority_arns=["certificateAuthorityArns"]\n        ),\n        file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n            certificate_chain="certificateChain"\n        ),\n        sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n            secret_name="secretName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['acm', 'file', 'sds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.TlsValidationContextTrustProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeConnectionPoolProperty
class CfnVirtualNode_VirtualNodeConnectionPoolPropertyDef(BaseStruct):
    grpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeGrpcConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a type of connection pool.\n')
    http: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeHttpConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a type of connection pool.\n')
    http2: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeHttp2ConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a type of connection pool.\n')
    tcp: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeTcpConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a type of connection pool.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-virtualnodeconnectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_node_connection_pool_property = appmesh.CfnVirtualNode.VirtualNodeConnectionPoolProperty(\n        grpc=appmesh.CfnVirtualNode.VirtualNodeGrpcConnectionPoolProperty(\n            max_requests=123\n        ),\n        http=appmesh.CfnVirtualNode.VirtualNodeHttpConnectionPoolProperty(\n            max_connections=123,\n\n            # the properties below are optional\n            max_pending_requests=123\n        ),\n        http2=appmesh.CfnVirtualNode.VirtualNodeHttp2ConnectionPoolProperty(\n            max_requests=123\n        ),\n        tcp=appmesh.CfnVirtualNode.VirtualNodeTcpConnectionPoolProperty(\n            max_connections=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['grpc', 'http', 'http2', 'tcp']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeGrpcConnectionPoolProperty
class CfnVirtualNode_VirtualNodeGrpcConnectionPoolPropertyDef(BaseStruct):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-virtualnodegrpcconnectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_node_grpc_connection_pool_property = appmesh.CfnVirtualNode.VirtualNodeGrpcConnectionPoolProperty(\n        max_requests=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeGrpcConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeHttp2ConnectionPoolProperty
class CfnVirtualNode_VirtualNodeHttp2ConnectionPoolPropertyDef(BaseStruct):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-virtualnodehttp2connectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_node_http2_connection_pool_property = appmesh.CfnVirtualNode.VirtualNodeHttp2ConnectionPoolProperty(\n        max_requests=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeHttp2ConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeHttpConnectionPoolProperty
class CfnVirtualNode_VirtualNodeHttpConnectionPoolPropertyDef(BaseStruct):
    max_connections: typing.Union[int, float] = pydantic.Field(..., description='Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.\n')
    max_pending_requests: typing.Union[int, float, None] = pydantic.Field(None, description='Number of overflowing requests after ``max_connections`` Envoy will queue to upstream cluster.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-virtualnodehttpconnectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_node_http_connection_pool_property = appmesh.CfnVirtualNode.VirtualNodeHttpConnectionPoolProperty(\n        max_connections=123,\n\n        # the properties below are optional\n        max_pending_requests=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_connections', 'max_pending_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeHttpConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeSpecProperty
class CfnVirtualNode_VirtualNodeSpecPropertyDef(BaseStruct):
    backend_defaults: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_BackendDefaultsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the defaults for backends.\n')
    backends: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_BackendPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The backends that the virtual node is expected to send outbound traffic to. .. epigraph:: App Mesh doesn't validate the existence of those virtual services specified in backends. This is to prevent a cyclic dependency between virtual nodes and virtual services creation. Make sure the virtual service name is correct. The virtual service can be created afterwards if it doesn't already exist.\n")
    listeners: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The listener that the virtual node is expected to receive inbound traffic from. You can specify one listener.\n')
    logging: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_LoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The inbound and outbound access logging information for the virtual node.\n')
    service_discovery: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The service discovery information for the virtual node. If your virtual node does not expect ingress traffic, you can omit this parameter. If you specify a ``listener`` , then you must specify service discovery information.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-virtualnodespec.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_node_spec_property = appmesh.CfnVirtualNode.VirtualNodeSpecProperty(\n        backend_defaults=appmesh.CfnVirtualNode.BackendDefaultsProperty(\n            client_policy=appmesh.CfnVirtualNode.ClientPolicyProperty(\n                tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n                    validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                        trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                            acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                                certificate_authority_arns=["certificateAuthorityArns"]\n                            ),\n                            file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                                certificate_chain="certificateChain"\n                            ),\n                            sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n\n                        # the properties below are optional\n                        subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                            match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                                exact=["exact"]\n                            )\n                        )\n                    ),\n\n                    # the properties below are optional\n                    certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                        file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                            certificate_chain="certificateChain",\n                            private_key="privateKey"\n                        ),\n                        sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n                    enforce=False,\n                    ports=[123]\n                )\n            )\n        ),\n        backends=[appmesh.CfnVirtualNode.BackendProperty(\n            virtual_service=appmesh.CfnVirtualNode.VirtualServiceBackendProperty(\n                virtual_service_name="virtualServiceName",\n\n                # the properties below are optional\n                client_policy=appmesh.CfnVirtualNode.ClientPolicyProperty(\n                    tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n                        validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                            trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                                acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                                    certificate_authority_arns=["certificateAuthorityArns"]\n                                ),\n                                file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                                    certificate_chain="certificateChain"\n                                ),\n                                sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                                    secret_name="secretName"\n                                )\n                            ),\n\n                            # the properties below are optional\n                            subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                                match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                                    exact=["exact"]\n                                )\n                            )\n                        ),\n\n                        # the properties below are optional\n                        certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                            file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                                certificate_chain="certificateChain",\n                                private_key="privateKey"\n                            ),\n                            sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n                        enforce=False,\n                        ports=[123]\n                    )\n                )\n            )\n        )],\n        listeners=[appmesh.CfnVirtualNode.ListenerProperty(\n            port_mapping=appmesh.CfnVirtualNode.PortMappingProperty(\n                port=123,\n                protocol="protocol"\n            ),\n\n            # the properties below are optional\n            connection_pool=appmesh.CfnVirtualNode.VirtualNodeConnectionPoolProperty(\n                grpc=appmesh.CfnVirtualNode.VirtualNodeGrpcConnectionPoolProperty(\n                    max_requests=123\n                ),\n                http=appmesh.CfnVirtualNode.VirtualNodeHttpConnectionPoolProperty(\n                    max_connections=123,\n\n                    # the properties below are optional\n                    max_pending_requests=123\n                ),\n                http2=appmesh.CfnVirtualNode.VirtualNodeHttp2ConnectionPoolProperty(\n                    max_requests=123\n                ),\n                tcp=appmesh.CfnVirtualNode.VirtualNodeTcpConnectionPoolProperty(\n                    max_connections=123\n                )\n            ),\n            health_check=appmesh.CfnVirtualNode.HealthCheckProperty(\n                healthy_threshold=123,\n                interval_millis=123,\n                protocol="protocol",\n                timeout_millis=123,\n                unhealthy_threshold=123,\n\n                # the properties below are optional\n                path="path",\n                port=123\n            ),\n            outlier_detection=appmesh.CfnVirtualNode.OutlierDetectionProperty(\n                base_ejection_duration=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                interval=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                max_ejection_percent=123,\n                max_server_errors=123\n            ),\n            timeout=appmesh.CfnVirtualNode.ListenerTimeoutProperty(\n                grpc=appmesh.CfnVirtualNode.GrpcTimeoutProperty(\n                    idle=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                ),\n                http=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n                    idle=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                ),\n                http2=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n                    idle=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                ),\n                tcp=appmesh.CfnVirtualNode.TcpTimeoutProperty(\n                    idle=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                )\n            ),\n            tls=appmesh.CfnVirtualNode.ListenerTlsProperty(\n                certificate=appmesh.CfnVirtualNode.ListenerTlsCertificateProperty(\n                    acm=appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty(\n                        certificate_arn="certificateArn"\n                    ),\n                    file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                        certificate_chain="certificateChain",\n                        private_key="privateKey"\n                    ),\n                    sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                        secret_name="secretName"\n                    )\n                ),\n                mode="mode",\n\n                # the properties below are optional\n                validation=appmesh.CfnVirtualNode.ListenerTlsValidationContextProperty(\n                    trust=appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty(\n                        file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                            certificate_chain="certificateChain"\n                        ),\n                        sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n\n                    # the properties below are optional\n                    subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                        match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                            exact=["exact"]\n                        )\n                    )\n                )\n            )\n        )],\n        logging=appmesh.CfnVirtualNode.LoggingProperty(\n            access_log=appmesh.CfnVirtualNode.AccessLogProperty(\n                file=appmesh.CfnVirtualNode.FileAccessLogProperty(\n                    path="path",\n\n                    # the properties below are optional\n                    format=appmesh.CfnVirtualNode.LoggingFormatProperty(\n                        json=[appmesh.CfnVirtualNode.JsonFormatRefProperty(\n                            key="key",\n                            value="value"\n                        )],\n                        text="text"\n                    )\n                )\n            )\n        ),\n        service_discovery=appmesh.CfnVirtualNode.ServiceDiscoveryProperty(\n            aws_cloud_map=appmesh.CfnVirtualNode.AwsCloudMapServiceDiscoveryProperty(\n                namespace_name="namespaceName",\n                service_name="serviceName",\n\n                # the properties below are optional\n                attributes=[appmesh.CfnVirtualNode.AwsCloudMapInstanceAttributeProperty(\n                    key="key",\n                    value="value"\n                )],\n                ip_preference="ipPreference"\n            ),\n            dns=appmesh.CfnVirtualNode.DnsServiceDiscoveryProperty(\n                hostname="hostname",\n\n                # the properties below are optional\n                ip_preference="ipPreference",\n                response_type="responseType"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backend_defaults', 'backends', 'listeners', 'logging', 'service_discovery']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeSpecProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeTcpConnectionPoolProperty
class CfnVirtualNode_VirtualNodeTcpConnectionPoolPropertyDef(BaseStruct):
    max_connections: typing.Union[int, float] = pydantic.Field(..., description='Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-virtualnodetcpconnectionpool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_node_tcp_connection_pool_property = appmesh.CfnVirtualNode.VirtualNodeTcpConnectionPoolProperty(\n        max_connections=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_connections']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.VirtualNodeTcpConnectionPoolProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode.VirtualServiceBackendProperty
class CfnVirtualNode_VirtualServiceBackendPropertyDef(BaseStruct):
    virtual_service_name: str = pydantic.Field(..., description="The name of the virtual service that is acting as a virtual node backend. .. epigraph:: App Mesh doesn't validate the existence of those virtual services specified in backends. This is to prevent a cyclic dependency between virtual nodes and virtual services creation. Make sure the virtual service name is correct. The virtual service can be created afterwards if it doesn't already exist.\n")
    client_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ClientPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A reference to an object that represents the client policy for a backend.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualnode-virtualservicebackend.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_service_backend_property = appmesh.CfnVirtualNode.VirtualServiceBackendProperty(\n        virtual_service_name="virtualServiceName",\n\n        # the properties below are optional\n        client_policy=appmesh.CfnVirtualNode.ClientPolicyProperty(\n            tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n                validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                    trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                        acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                            certificate_authority_arns=["certificateAuthorityArns"]\n                        ),\n                        file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                            certificate_chain="certificateChain"\n                        ),\n                        sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n\n                    # the properties below are optional\n                    subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                        match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                            exact=["exact"]\n                        )\n                    )\n                ),\n\n                # the properties below are optional\n                certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                    file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                        certificate_chain="certificateChain",\n                        private_key="privateKey"\n                    ),\n                    sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                        secret_name="secretName"\n                    )\n                ),\n                enforce=False,\n                ports=[123]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_service_name', 'client_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode.VirtualServiceBackendProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualRouter.PortMappingProperty
class CfnVirtualRouter_PortMappingPropertyDef(BaseStruct):
    port: typing.Union[int, float] = pydantic.Field(..., description='The port used for the port mapping.\n')
    protocol: str = pydantic.Field(..., description='The protocol used for the port mapping. Specify one protocol.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualrouter-portmapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    port_mapping_property = appmesh.CfnVirtualRouter.PortMappingProperty(\n        port=123,\n        protocol="protocol"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port', 'protocol']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualRouter.PortMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualRouter.VirtualRouterListenerProperty
class CfnVirtualRouter_VirtualRouterListenerPropertyDef(BaseStruct):
    port_mapping: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualRouter_PortMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The port mapping information for the listener.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualrouter-virtualrouterlistener.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_router_listener_property = appmesh.CfnVirtualRouter.VirtualRouterListenerProperty(\n        port_mapping=appmesh.CfnVirtualRouter.PortMappingProperty(\n            port=123,\n            protocol="protocol"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port_mapping']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualRouter.VirtualRouterListenerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualRouter.VirtualRouterSpecProperty
class CfnVirtualRouter_VirtualRouterSpecPropertyDef(BaseStruct):
    listeners: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualRouter_VirtualRouterListenerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='The listeners that the virtual router is expected to receive inbound traffic from.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualrouter-virtualrouterspec.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_router_spec_property = appmesh.CfnVirtualRouter.VirtualRouterSpecProperty(\n        listeners=[appmesh.CfnVirtualRouter.VirtualRouterListenerProperty(\n            port_mapping=appmesh.CfnVirtualRouter.PortMappingProperty(\n                port=123,\n                protocol="protocol"\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listeners']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualRouter.VirtualRouterSpecProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualService.VirtualNodeServiceProviderProperty
class CfnVirtualService_VirtualNodeServiceProviderPropertyDef(BaseStruct):
    virtual_node_name: str = pydantic.Field(..., description='The name of the virtual node that is acting as a service provider.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualservice-virtualnodeserviceprovider.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_node_service_provider_property = appmesh.CfnVirtualService.VirtualNodeServiceProviderProperty(\n        virtual_node_name="virtualNodeName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_node_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualService.VirtualNodeServiceProviderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualService.VirtualRouterServiceProviderProperty
class CfnVirtualService_VirtualRouterServiceProviderPropertyDef(BaseStruct):
    virtual_router_name: str = pydantic.Field(..., description='The name of the virtual router that is acting as a service provider.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualservice-virtualrouterserviceprovider.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_router_service_provider_property = appmesh.CfnVirtualService.VirtualRouterServiceProviderProperty(\n        virtual_router_name="virtualRouterName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_router_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualService.VirtualRouterServiceProviderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualService.VirtualServiceProviderProperty
class CfnVirtualService_VirtualServiceProviderPropertyDef(BaseStruct):
    virtual_node: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualService_VirtualNodeServiceProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The virtual node associated with a virtual service.\n')
    virtual_router: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualService_VirtualRouterServiceProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The virtual router associated with a virtual service.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualservice-virtualserviceprovider.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_service_provider_property = appmesh.CfnVirtualService.VirtualServiceProviderProperty(\n        virtual_node=appmesh.CfnVirtualService.VirtualNodeServiceProviderProperty(\n            virtual_node_name="virtualNodeName"\n        ),\n        virtual_router=appmesh.CfnVirtualService.VirtualRouterServiceProviderProperty(\n            virtual_router_name="virtualRouterName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_node', 'virtual_router']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualService.VirtualServiceProviderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualService.VirtualServiceSpecProperty
class CfnVirtualService_VirtualServiceSpecPropertyDef(BaseStruct):
    provider: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualService_VirtualServiceProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-appmesh-virtualservice-virtualservicespec.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_service_spec_property = appmesh.CfnVirtualService.VirtualServiceSpecProperty(\n        provider=appmesh.CfnVirtualService.VirtualServiceProviderProperty(\n            virtual_node=appmesh.CfnVirtualService.VirtualNodeServiceProviderProperty(\n                virtual_node_name="virtualNodeName"\n            ),\n            virtual_router=appmesh.CfnVirtualService.VirtualRouterServiceProviderProperty(\n                virtual_router_name="virtualRouterName"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['provider']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualService.VirtualServiceSpecProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CommonGatewayRouteSpecOptions
class CommonGatewayRouteSpecOptionsDef(BaseStruct):
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the gateway route. When a Virtual Gateway has multiple gateway routes, gateway route match is performed in the order of specified value, where 0 is the highest priority, and first matched gateway route is selected. Default: - no particular priority\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    common_gateway_route_spec_options = appmesh.CommonGatewayRouteSpecOptions(\n        priority=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['priority']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CommonGatewayRouteSpecOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GatewayRouteAttributes
class GatewayRouteAttributesDef(BaseStruct):
    gateway_route_name: str = pydantic.Field(..., description='The name of the GatewayRoute.\n')
    virtual_gateway: typing.Union[models.aws_appmesh.VirtualGatewayDef] = pydantic.Field(..., description='The VirtualGateway this GatewayRoute is associated with.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # virtual_gateway: appmesh.VirtualGateway\n\n    gateway_route_attributes = appmesh.GatewayRouteAttributes(\n        gateway_route_name="gatewayRouteName",\n        virtual_gateway=virtual_gateway\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['gateway_route_name', 'virtual_gateway']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GatewayRouteAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GatewayRouteBaseProps
class GatewayRouteBasePropsDef(BaseStruct):
    route_spec: models.aws_appmesh.GatewayRouteSpecDef = pydantic.Field(..., description='What protocol the route uses.\n')
    gateway_route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the GatewayRoute. Default: - an automatically generated name\n\n:exampleMetadata: infused\n\nExample::\n\n    # gateway: appmesh.VirtualGateway\n    # virtual_service: appmesh.VirtualService\n\n\n    gateway.add_gateway_route("gateway-route-grpc",\n        route_spec=appmesh.GatewayRouteSpec.grpc(\n            route_target=virtual_service,\n            match=appmesh.GrpcGatewayRouteMatch(\n                hostname=appmesh.GatewayRouteHostnameMatch.exactly("example.com"),\n                # This disables the default rewrite to virtual service name and retain original request.\n                rewrite_request_hostname=False\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route_spec', 'gateway_route_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GatewayRouteBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GatewayRouteHostnameMatchConfig
class GatewayRouteHostnameMatchConfigDef(BaseStruct):
    hostname_match: typing.Union[models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='GatewayRoute CFN configuration for host name match.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_hostname_match_config = appmesh.GatewayRouteHostnameMatchConfig(\n        hostname_match=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n            exact="exact",\n            suffix="suffix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hostname_match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GatewayRouteHostnameMatchConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GatewayRouteProps
class GatewayRoutePropsDef(BaseStruct):
    route_spec: models.aws_appmesh.GatewayRouteSpecDef = pydantic.Field(..., description='What protocol the route uses.\n')
    gateway_route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the GatewayRoute. Default: - an automatically generated name\n')
    virtual_gateway: typing.Union[models.aws_appmesh.VirtualGatewayDef] = pydantic.Field(..., description='The VirtualGateway this GatewayRoute is associated with.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # gateway_route_spec: appmesh.GatewayRouteSpec\n    # virtual_gateway: appmesh.VirtualGateway\n\n    gateway_route_props = appmesh.GatewayRouteProps(\n        route_spec=gateway_route_spec,\n        virtual_gateway=virtual_gateway,\n\n        # the properties below are optional\n        gateway_route_name="gatewayRouteName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route_spec', 'gateway_route_name', 'virtual_gateway']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GatewayRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GatewayRouteSpecConfig
class GatewayRouteSpecConfigDef(BaseStruct):
    grpc_spec_config: typing.Union[models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The spec for a grpc gateway route. Default: - no grpc spec\n')
    http2_spec_config: typing.Union[models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The spec for an http2 gateway route. Default: - no http2 spec\n')
    http_spec_config: typing.Union[models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The spec for an http gateway route. Default: - no http spec\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the gateway route. When a Virtual Gateway has multiple gateway routes, gateway route match is performed in the order of specified value, where 0 is the highest priority, and first matched gateway route is selected. Default: - no particular priority\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    gateway_route_spec_config = appmesh.GatewayRouteSpecConfig(\n        grpc_spec_config=appmesh.CfnGatewayRoute.GrpcGatewayRouteProperty(\n            action=appmesh.CfnGatewayRoute.GrpcGatewayRouteActionProperty(\n                target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                    virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                        virtual_service_name="virtualServiceName"\n                    ),\n\n                    # the properties below are optional\n                    port=123\n                ),\n\n                # the properties below are optional\n                rewrite=appmesh.CfnGatewayRoute.GrpcGatewayRouteRewriteProperty(\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                        default_target_hostname="defaultTargetHostname"\n                    )\n                )\n            ),\n            match=appmesh.CfnGatewayRoute.GrpcGatewayRouteMatchProperty(\n                hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                    exact="exact",\n                    suffix="suffix"\n                ),\n                metadata=[appmesh.CfnGatewayRoute.GrpcGatewayRouteMetadataProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                port=123,\n                service_name="serviceName"\n            )\n        ),\n        http2_spec_config=appmesh.CfnGatewayRoute.HttpGatewayRouteProperty(\n            action=appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty(\n                target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                    virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                        virtual_service_name="virtualServiceName"\n                    ),\n\n                    # the properties below are optional\n                    port=123\n                ),\n\n                # the properties below are optional\n                rewrite=appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                        default_target_hostname="defaultTargetHostname"\n                    ),\n                    path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n                        exact="exact"\n                    ),\n                    prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n                        default_prefix="defaultPrefix",\n                        value="value"\n                    )\n                )\n            ),\n            match=appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty(\n                headers=[appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                    exact="exact",\n                    suffix="suffix"\n                ),\n                method="method",\n                path=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n                    exact="exact",\n                    regex="regex"\n                ),\n                port=123,\n                prefix="prefix",\n                query_parameters=[appmesh.CfnGatewayRoute.QueryParameterProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n                        exact="exact"\n                    )\n                )]\n            )\n        ),\n        http_spec_config=appmesh.CfnGatewayRoute.HttpGatewayRouteProperty(\n            action=appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty(\n                target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                    virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                        virtual_service_name="virtualServiceName"\n                    ),\n\n                    # the properties below are optional\n                    port=123\n                ),\n\n                # the properties below are optional\n                rewrite=appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                        default_target_hostname="defaultTargetHostname"\n                    ),\n                    path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n                        exact="exact"\n                    ),\n                    prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n                        default_prefix="defaultPrefix",\n                        value="value"\n                    )\n                )\n            ),\n            match=appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty(\n                headers=[appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                    exact="exact",\n                    suffix="suffix"\n                ),\n                method="method",\n                path=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n                    exact="exact",\n                    regex="regex"\n                ),\n                port=123,\n                prefix="prefix",\n                query_parameters=[appmesh.CfnGatewayRoute.QueryParameterProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n                        exact="exact"\n                    )\n                )]\n            )\n        ),\n        priority=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['grpc_spec_config', 'http2_spec_config', 'http_spec_config', 'priority']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GatewayRouteSpecConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcConnectionPool
class GrpcConnectionPoolDef(BaseStruct):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='The maximum requests in the pool. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # A Virtual Node with a gRPC listener with a connection pool set\n    # mesh: appmesh.Mesh\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        # DNS service discovery can optionally specify the DNS response type as either LOAD_BALANCER or ENDPOINTS.\n        # LOAD_BALANCER means that the DNS resolver returns a loadbalanced set of endpoints,\n        # whereas ENDPOINTS means that the DNS resolver is returning all the endpoints.\n        # By default, the response type is assumed to be LOAD_BALANCER\n        service_discovery=appmesh.ServiceDiscovery.dns("node", appmesh.DnsResponseType.ENDPOINTS),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=80,\n            connection_pool=appmesh.HttpConnectionPool(\n                max_connections=100,\n                max_pending_requests=10\n            )\n        )]\n    )\n\n    # A Virtual Gateway with a gRPC listener with a connection pool set\n    gateway = appmesh.VirtualGateway(self, "gateway",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.grpc(\n            port=8080,\n            connection_pool=appmesh.GrpcConnectionPool(\n                max_requests=10\n            )\n        )],\n        virtual_gateway_name="gateway"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcConnectionPool'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcGatewayListenerOptions
class GrpcGatewayListenerOptionsDef(BaseStruct):
    connection_pool: typing.Union[models.aws_appmesh.GrpcConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # A Virtual Node with listener TLS from an ACM provided certificate\n    # cert: certificatemanager.Certificate\n    # mesh: appmesh.Mesh\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.dns("node"),\n        listeners=[appmesh.VirtualNodeListener.grpc(\n            port=80,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.acm(cert)\n            )\n        )]\n    )\n\n    # A Virtual Gateway with listener TLS from a customer provided file certificate\n    gateway = appmesh.VirtualGateway(self, "gateway",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.grpc(\n            port=8080,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.file("path/to/certChain", "path/to/privateKey")\n            )\n        )],\n        virtual_gateway_name="gateway"\n    )\n\n    # A Virtual Gateway with listener TLS from a SDS provided certificate\n    gateway2 = appmesh.VirtualGateway(self, "gateway2",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.http2(\n            port=8080,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.sds("secrete_certificate")\n            )\n        )],\n        virtual_gateway_name="gateway2"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_pool', 'health_check', 'port', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcGatewayListenerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcGatewayRouteMatch
class GrpcGatewayRouteMatchDef(BaseStruct):
    hostname: typing.Optional[models.aws_appmesh.GatewayRouteHostnameMatchDef] = pydantic.Field(None, description='Create host name based gRPC gateway route match. Default: - no matching on host name\n')
    metadata: typing.Optional[typing.Sequence[models.aws_appmesh.HeaderMatchDef]] = pydantic.Field(None, description='Create metadata based gRPC gateway route match. All specified metadata must match for the route to match. Default: - no matching on metadata\n')
    rewrite_request_hostname: typing.Optional[bool] = pydantic.Field(None, description='When ``true``, rewrites the original request received at the Virtual Gateway to the destination Virtual Service name. When ``false``, retains the original hostname from the request. Default: true\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Create service name based gRPC gateway route match. Default: - no matching on service name\n\n:exampleMetadata: infused\n\nExample::\n\n    # gateway: appmesh.VirtualGateway\n    # virtual_service: appmesh.VirtualService\n\n\n    gateway.add_gateway_route("gateway-route-grpc",\n        route_spec=appmesh.GatewayRouteSpec.grpc(\n            route_target=virtual_service,\n            match=appmesh.GrpcGatewayRouteMatch(\n                hostname=appmesh.GatewayRouteHostnameMatch.ends_with(".example.com")\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hostname', 'metadata', 'rewrite_request_hostname', 'service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcGatewayRouteMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcGatewayRouteSpecOptions
class GrpcGatewayRouteSpecOptionsDef(BaseStruct):
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the gateway route. When a Virtual Gateway has multiple gateway routes, gateway route match is performed in the order of specified value, where 0 is the highest priority, and first matched gateway route is selected. Default: - no particular priority\n')
    match: typing.Union[models.aws_appmesh.GrpcGatewayRouteMatchDef, dict[str, typing.Any]] = pydantic.Field(..., description='The criterion for determining a request match for this GatewayRoute.\n')
    route_target: typing.Union[models.aws_appmesh.VirtualServiceDef] = pydantic.Field(..., description='The VirtualService this GatewayRoute directs traffic to.\n\n:exampleMetadata: infused\n\nExample::\n\n    # gateway: appmesh.VirtualGateway\n    # virtual_service: appmesh.VirtualService\n\n\n    gateway.add_gateway_route("gateway-route-grpc",\n        route_spec=appmesh.GatewayRouteSpec.grpc(\n            route_target=virtual_service,\n            match=appmesh.GrpcGatewayRouteMatch(\n                hostname=appmesh.GatewayRouteHostnameMatch.ends_with(".example.com")\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['priority', 'match', 'route_target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcGatewayRouteSpecOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcHealthCheckOptions
class GrpcHealthCheckOptionsDef(BaseStruct):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive successful health checks that must occur before declaring listener healthy. Default: 2\n')
    interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The time period between each health check execution. Default: Duration.seconds(5)\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time to wait when receiving a response from the health check. Default: Duration.seconds(2)\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive failed health checks that must occur before declaring a listener unhealthy. Default: - 2\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_appmesh as appmesh\n\n    grpc_health_check_options = appmesh.GrpcHealthCheckOptions(\n        healthy_threshold=123,\n        interval=cdk.Duration.minutes(30),\n        timeout=cdk.Duration.minutes(30),\n        unhealthy_threshold=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['healthy_threshold', 'interval', 'timeout', 'unhealthy_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcHealthCheckOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcRetryPolicy
class GrpcRetryPolicyDef(BaseStruct):
    retry_attempts: typing.Union[int, float] = pydantic.Field(..., description='The maximum number of retry attempts.\n')
    retry_timeout: models.DurationDef = pydantic.Field(..., description='The timeout for each retry attempt.\n')
    http_retry_events: typing.Optional[typing.Sequence[aws_cdk.aws_appmesh.HttpRetryEvent]] = pydantic.Field(None, description='Specify HTTP events on which to retry. You must specify at least one value for at least one types of retry events. Default: - no retries for http events\n')
    tcp_retry_events: typing.Optional[typing.Sequence[aws_cdk.aws_appmesh.TcpRetryEvent]] = pydantic.Field(None, description='TCP events on which to retry. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable. You must specify at least one value for at least one types of retry events. Default: - no retries for tcp events\n')
    grpc_retry_events: typing.Optional[typing.Sequence[aws_cdk.aws_appmesh.GrpcRetryEvent]] = pydantic.Field(None, description='gRPC events on which to retry. You must specify at least one value for at least one types of retry events. Default: - no retries for gRPC events\n\n:exampleMetadata: infused\n\nExample::\n\n    # router: appmesh.VirtualRouter\n    # node: appmesh.VirtualNode\n\n\n    router.add_route("route-grpc-retry",\n        route_spec=appmesh.RouteSpec.grpc(\n            weighted_targets=[appmesh.WeightedTarget(virtual_node=node)],\n            match=appmesh.GrpcRouteMatch(service_name="servicename"),\n            retry_policy=appmesh.GrpcRetryPolicy(\n                tcp_retry_events=[appmesh.TcpRetryEvent.CONNECTION_ERROR],\n                http_retry_events=[appmesh.HttpRetryEvent.GATEWAY_ERROR],\n                # Retry if gRPC responds that the request was cancelled, a resource\n                # was exhausted, or if the service is unavailable\n                grpc_retry_events=[appmesh.GrpcRetryEvent.CANCELLED, appmesh.GrpcRetryEvent.RESOURCE_EXHAUSTED, appmesh.GrpcRetryEvent.UNAVAILABLE\n                ],\n                retry_attempts=5,\n                retry_timeout=Duration.seconds(1)\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['retry_attempts', 'retry_timeout', 'http_retry_events', 'tcp_retry_events', 'grpc_retry_events']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcRetryPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[GrpcRetryPolicyDefConfig] = pydantic.Field(None)


class GrpcRetryPolicyDefConfig(pydantic.BaseModel):
    retry_timeout_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.GrpcRouteMatch
class GrpcRouteMatchDef(BaseStruct):
    metadata: typing.Optional[typing.Sequence[models.aws_appmesh.HeaderMatchDef]] = pydantic.Field(None, description='Create metadata based gRPC route match. All specified metadata must match for the route to match. Default: - do not match on metadata\n')
    method_name: typing.Optional[str] = pydantic.Field(None, description='The method name to match from the request. If the method name is specified, service name must be also provided. Default: - do not match on method name\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Create service name based gRPC route match. Default: - do not match on service name\n\n:exampleMetadata: infused\n\nExample::\n\n    # router: appmesh.VirtualRouter\n    # node: appmesh.VirtualNode\n\n\n    router.add_route("route-grpc-retry",\n        route_spec=appmesh.RouteSpec.grpc(\n            weighted_targets=[appmesh.WeightedTarget(virtual_node=node)],\n            match=appmesh.GrpcRouteMatch(\n                # When method name is specified, service name must be also specified.\n                method_name="methodname",\n                service_name="servicename",\n                metadata=[\n                    # All specified metadata must match for the route to match.\n                    appmesh.HeaderMatch.value_starts_with("Content-Type", "application/"),\n                    appmesh.HeaderMatch.value_does_not_start_with("Content-Type", "text/")\n                ]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metadata', 'method_name', 'service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcRouteMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcRouteSpecOptions
class GrpcRouteSpecOptionsDef(BaseStruct):
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority\n')
    match: typing.Union[models.aws_appmesh.GrpcRouteMatchDef, dict[str, typing.Any]] = pydantic.Field(..., description='The criterion for determining a request match for this Route.\n')
    weighted_targets: typing.Sequence[typing.Union[models.aws_appmesh.WeightedTargetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='List of targets that traffic is routed to when a request matches the route.\n')
    retry_policy: typing.Union[models.aws_appmesh.GrpcRetryPolicyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The retry policy. Default: - no retry policy\n')
    timeout: typing.Union[models.aws_appmesh.GrpcTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a grpc timeout. Default: - None\n\n:exampleMetadata: infused\n\nExample::\n\n    # router: appmesh.VirtualRouter\n    # node: appmesh.VirtualNode\n\n\n    router.add_route("route-grpc-retry",\n        route_spec=appmesh.RouteSpec.grpc(\n            weighted_targets=[appmesh.WeightedTarget(virtual_node=node)],\n            match=appmesh.GrpcRouteMatch(\n                # When method name is specified, service name must be also specified.\n                method_name="methodname",\n                service_name="servicename",\n                metadata=[\n                    # All specified metadata must match for the route to match.\n                    appmesh.HeaderMatch.value_starts_with("Content-Type", "application/"),\n                    appmesh.HeaderMatch.value_does_not_start_with("Content-Type", "text/")\n                ]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['priority', 'match', 'weighted_targets', 'retry_policy', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcRouteSpecOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcTimeout
class GrpcTimeoutDef(BaseStruct):
    idle: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Represents an idle timeout. The amount of time that a connection may be idle. Default: - none\n')
    per_request: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Represents per request timeout. Default: - 15 s\n\n:exampleMetadata: infused\n\nExample::\n\n    # router: appmesh.VirtualRouter\n    # node: appmesh.VirtualNode\n\n\n    router.add_route("route-http",\n        route_spec=appmesh.RouteSpec.grpc(\n            weighted_targets=[appmesh.WeightedTarget(\n                virtual_node=node\n            )\n            ],\n            match=appmesh.GrpcRouteMatch(\n                service_name="my-service.default.svc.cluster.local"\n            ),\n            timeout=appmesh.GrpcTimeout(\n                idle=Duration.seconds(2),\n                per_request=Duration.seconds(1)\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle', 'per_request']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcTimeout'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.GrpcVirtualNodeListenerOptions
class GrpcVirtualNodeListenerOptionsDef(BaseStruct):
    connection_pool: typing.Union[models.aws_appmesh.GrpcConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    outlier_detection: typing.Union[models.aws_appmesh.OutlierDetectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling outlier detection. Default: - none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    timeout: typing.Union[models.aws_appmesh.GrpcTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Timeout for GRPC protocol. Default: - None\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # A Virtual Node with listener TLS from an ACM provided certificate\n    # cert: certificatemanager.Certificate\n    # mesh: appmesh.Mesh\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.dns("node"),\n        listeners=[appmesh.VirtualNodeListener.grpc(\n            port=80,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.acm(cert)\n            )\n        )]\n    )\n\n    # A Virtual Gateway with listener TLS from a customer provided file certificate\n    gateway = appmesh.VirtualGateway(self, "gateway",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.grpc(\n            port=8080,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.file("path/to/certChain", "path/to/privateKey")\n            )\n        )],\n        virtual_gateway_name="gateway"\n    )\n\n    # A Virtual Gateway with listener TLS from a SDS provided certificate\n    gateway2 = appmesh.VirtualGateway(self, "gateway2",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.http2(\n            port=8080,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.sds("secrete_certificate")\n            )\n        )],\n        virtual_gateway_name="gateway2"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_pool', 'health_check', 'outlier_detection', 'port', 'timeout', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.GrpcVirtualNodeListenerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HeaderMatchConfig
class HeaderMatchConfigDef(BaseStruct):
    header_match: typing.Union[models.aws_appmesh.CfnRoute_HttpRouteHeaderPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Route CFN configuration for the route header match.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    header_match_config = appmesh.HeaderMatchConfig(\n        header_match=appmesh.CfnRoute.HttpRouteHeaderProperty(\n            name="name",\n\n            # the properties below are optional\n            invert=False,\n            match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                exact="exact",\n                prefix="prefix",\n                range=appmesh.CfnRoute.MatchRangeProperty(\n                    end=123,\n                    start=123\n                ),\n                regex="regex",\n                suffix="suffix"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['header_match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HeaderMatchConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HealthCheckBindOptions
class HealthCheckBindOptionsDef(BaseStruct):
    default_port: typing.Union[int, float, None] = pydantic.Field(None, description='Port for Health Check interface. Default: - no default port is provided\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    health_check_bind_options = appmesh.HealthCheckBindOptions(\n        default_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HealthCheckBindOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HealthCheckConfig
class HealthCheckConfigDef(BaseStruct):
    virtual_gateway_health_check: typing.Union[models.aws_appmesh.CfnVirtualGateway_VirtualGatewayHealthCheckPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='VirtualGateway CFN configuration for Health Checks. Default: - no health checks\n')
    virtual_node_health_check: typing.Union[models.aws_appmesh.CfnVirtualNode_HealthCheckPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='VirtualNode CFN configuration for Health Checks. Default: - no health checks\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    health_check_config = appmesh.HealthCheckConfig(\n        virtual_gateway_health_check=appmesh.CfnVirtualGateway.VirtualGatewayHealthCheckPolicyProperty(\n            healthy_threshold=123,\n            interval_millis=123,\n            protocol="protocol",\n            timeout_millis=123,\n            unhealthy_threshold=123,\n\n            # the properties below are optional\n            path="path",\n            port=123\n        ),\n        virtual_node_health_check=appmesh.CfnVirtualNode.HealthCheckProperty(\n            healthy_threshold=123,\n            interval_millis=123,\n            protocol="protocol",\n            timeout_millis=123,\n            unhealthy_threshold=123,\n\n            # the properties below are optional\n            path="path",\n            port=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_gateway_health_check', 'virtual_node_health_check']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HealthCheckConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.Http2ConnectionPool
class Http2ConnectionPoolDef(BaseStruct):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='The maximum requests in the pool. Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http2_connection_pool = appmesh.Http2ConnectionPool(\n        max_requests=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.Http2ConnectionPool'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.Http2GatewayListenerOptions
class Http2GatewayListenerOptionsDef(BaseStruct):
    connection_pool: typing.Union[models.aws_appmesh.Http2ConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # A Virtual Node with listener TLS from an ACM provided certificate\n    # cert: certificatemanager.Certificate\n    # mesh: appmesh.Mesh\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.dns("node"),\n        listeners=[appmesh.VirtualNodeListener.grpc(\n            port=80,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.acm(cert)\n            )\n        )]\n    )\n\n    # A Virtual Gateway with listener TLS from a customer provided file certificate\n    gateway = appmesh.VirtualGateway(self, "gateway",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.grpc(\n            port=8080,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.file("path/to/certChain", "path/to/privateKey")\n            )\n        )],\n        virtual_gateway_name="gateway"\n    )\n\n    # A Virtual Gateway with listener TLS from a SDS provided certificate\n    gateway2 = appmesh.VirtualGateway(self, "gateway2",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.http2(\n            port=8080,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.sds("secrete_certificate")\n            )\n        )],\n        virtual_gateway_name="gateway2"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_pool', 'health_check', 'port', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.Http2GatewayListenerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.Http2VirtualNodeListenerOptions
class Http2VirtualNodeListenerOptionsDef(BaseStruct):
    connection_pool: typing.Union[models.aws_appmesh.Http2ConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http2 listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    outlier_detection: typing.Union[models.aws_appmesh.OutlierDetectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling outlier detection. Default: - none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    timeout: typing.Union[models.aws_appmesh.HttpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Timeout for HTTP protocol. Default: - None\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_appmesh as appmesh\n\n    # health_check: appmesh.HealthCheck\n    # mutual_tls_validation_trust: appmesh.MutualTlsValidationTrust\n    # subject_alternative_names: appmesh.SubjectAlternativeNames\n    # tls_certificate: appmesh.TlsCertificate\n\n    http2_virtual_node_listener_options = appmesh.Http2VirtualNodeListenerOptions(\n        connection_pool=appmesh.Http2ConnectionPool(\n            max_requests=123\n        ),\n        health_check=health_check,\n        outlier_detection=appmesh.OutlierDetection(\n            base_ejection_duration=cdk.Duration.minutes(30),\n            interval=cdk.Duration.minutes(30),\n            max_ejection_percent=123,\n            max_server_errors=123\n        ),\n        port=123,\n        timeout=appmesh.HttpTimeout(\n            idle=cdk.Duration.minutes(30),\n            per_request=cdk.Duration.minutes(30)\n        ),\n        tls=appmesh.ListenerTlsOptions(\n            certificate=tls_certificate,\n            mode=appmesh.TlsMode.STRICT,\n\n            # the properties below are optional\n            mutual_tls_validation=appmesh.MutualTlsValidation(\n                trust=mutual_tls_validation_trust,\n\n                # the properties below are optional\n                subject_alternative_names=subject_alternative_names\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_pool', 'health_check', 'outlier_detection', 'port', 'timeout', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.Http2VirtualNodeListenerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpConnectionPool
class HttpConnectionPoolDef(BaseStruct):
    max_connections: typing.Union[int, float] = pydantic.Field(..., description='The maximum connections in the pool. Default: - none\n')
    max_pending_requests: typing.Union[int, float] = pydantic.Field(..., description='The maximum pending requests in the pool. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # A Virtual Node with a gRPC listener with a connection pool set\n    # mesh: appmesh.Mesh\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        # DNS service discovery can optionally specify the DNS response type as either LOAD_BALANCER or ENDPOINTS.\n        # LOAD_BALANCER means that the DNS resolver returns a loadbalanced set of endpoints,\n        # whereas ENDPOINTS means that the DNS resolver is returning all the endpoints.\n        # By default, the response type is assumed to be LOAD_BALANCER\n        service_discovery=appmesh.ServiceDiscovery.dns("node", appmesh.DnsResponseType.ENDPOINTS),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=80,\n            connection_pool=appmesh.HttpConnectionPool(\n                max_connections=100,\n                max_pending_requests=10\n            )\n        )]\n    )\n\n    # A Virtual Gateway with a gRPC listener with a connection pool set\n    gateway = appmesh.VirtualGateway(self, "gateway",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.grpc(\n            port=8080,\n            connection_pool=appmesh.GrpcConnectionPool(\n                max_requests=10\n            )\n        )],\n        virtual_gateway_name="gateway"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_connections', 'max_pending_requests']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpConnectionPool'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpGatewayListenerOptions
class HttpGatewayListenerOptionsDef(BaseStruct):
    connection_pool: typing.Union[models.aws_appmesh.HttpConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n\n    certificate_authority_arn = "arn:aws:acm-pca:us-east-1:123456789012:certificate-authority/12345678-1234-1234-1234-123456789012"\n\n    gateway = appmesh.VirtualGateway(self, "gateway",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.http(\n            port=443,\n            health_check=appmesh.HealthCheck.http(\n                interval=Duration.seconds(10)\n            )\n        )],\n        backend_defaults=appmesh.BackendDefaults(\n            tls_client_policy=appmesh.TlsClientPolicy(\n                ports=[8080, 8081],\n                validation=appmesh.TlsValidation(\n                    trust=appmesh.TlsValidationTrust.acm([\n                        acmpca.CertificateAuthority.from_certificate_authority_arn(self, "certificate", certificate_authority_arn)\n                    ])\n                )\n            )\n        ),\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout"),\n        virtual_gateway_name="virtualGateway"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_pool', 'health_check', 'port', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpGatewayListenerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpGatewayRouteMatch
class HttpGatewayRouteMatchDef(BaseStruct):
    headers: typing.Optional[typing.Sequence[models.aws_appmesh.HeaderMatchDef]] = pydantic.Field(None, description='Specifies the client request headers to match on. All specified headers must match for the gateway route to match. Default: - do not match on headers\n')
    hostname: typing.Optional[models.aws_appmesh.GatewayRouteHostnameMatchDef] = pydantic.Field(None, description='The gateway route host name to be matched on. Default: - do not match on host name\n')
    method: typing.Optional[aws_cdk.aws_appmesh.HttpRouteMethod] = pydantic.Field(None, description='The method to match on. Default: - do not match on method\n')
    path: typing.Optional[models.aws_appmesh.HttpGatewayRoutePathMatchDef] = pydantic.Field(None, description="Specify how to match requests based on the 'path' part of their URL. Default: - matches requests with any path\n")
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number to match on. Default: - no default port\n')
    query_parameters: typing.Optional[typing.Sequence[models.aws_appmesh.QueryParameterMatchDef]] = pydantic.Field(None, description='The query parameters to match on. All specified query parameters must match for the route to match. Default: - do not match on query parameters\n')
    rewrite_request_hostname: typing.Optional[bool] = pydantic.Field(None, description='When ``true``, rewrites the original request received at the Virtual Gateway to the destination Virtual Service name. When ``false``, retains the original hostname from the request. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # gateway: appmesh.VirtualGateway\n    # virtual_service: appmesh.VirtualService\n\n\n    gateway.add_gateway_route("gateway-route-http-2",\n        route_spec=appmesh.GatewayRouteSpec.http(\n            route_target=virtual_service,\n            match=appmesh.HttpGatewayRouteMatch(\n                # This rewrites the path from \'/test\' to \'/rewrittenPath\'.\n                path=appmesh.HttpGatewayRoutePathMatch.exactly("/test", "/rewrittenPath")\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['headers', 'hostname', 'method', 'path', 'port', 'query_parameters', 'rewrite_request_hostname']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpGatewayRouteMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpGatewayRoutePathMatchConfig
class HttpGatewayRoutePathMatchConfigDef(BaseStruct):
    prefix_path_match: typing.Optional[str] = pydantic.Field(None, description='Gateway route configuration for matching on the prefix of the URL path of the request. Default: - no matching will be performed on the prefix of the URL path\n')
    prefix_path_rewrite: typing.Union[models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePrefixRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Gateway route configuration for rewriting the prefix of the URL path of the request. Default: - rewrites the request's URL path to '/'\n")
    whole_path_match: typing.Union[models.aws_appmesh.CfnGatewayRoute_HttpPathMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Gateway route configuration for matching on the complete URL path of the request. Default: - no matching will be performed on the complete URL path\n')
    whole_path_rewrite: typing.Union[models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePathRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Gateway route configuration for rewriting the complete URL path of the request.. Default: - no rewrite will be performed on the request\'s complete URL path\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_gateway_route_path_match_config = appmesh.HttpGatewayRoutePathMatchConfig(\n        prefix_path_match="prefixPathMatch",\n        prefix_path_rewrite=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n            default_prefix="defaultPrefix",\n            value="value"\n        ),\n        whole_path_match=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n            exact="exact",\n            regex="regex"\n        ),\n        whole_path_rewrite=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n            exact="exact"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['prefix_path_match', 'prefix_path_rewrite', 'whole_path_match', 'whole_path_rewrite']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpGatewayRoutePathMatchConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpGatewayRouteSpecOptions
class HttpGatewayRouteSpecOptionsDef(BaseStruct):
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the gateway route. When a Virtual Gateway has multiple gateway routes, gateway route match is performed in the order of specified value, where 0 is the highest priority, and first matched gateway route is selected. Default: - no particular priority\n')
    route_target: typing.Union[models.aws_appmesh.VirtualServiceDef] = pydantic.Field(..., description='The VirtualService this GatewayRoute directs traffic to.\n')
    match: typing.Union[models.aws_appmesh.HttpGatewayRouteMatchDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The criterion for determining a request match for this GatewayRoute. When path match is defined, this may optionally determine the path rewrite configuration. Default: - matches any path and automatically rewrites the path to \'/\'\n\n:exampleMetadata: infused\n\nExample::\n\n    # gateway: appmesh.VirtualGateway\n    # virtual_service: appmesh.VirtualService\n\n\n    gateway.add_gateway_route("gateway-route-http-2",\n        route_spec=appmesh.GatewayRouteSpec.http(\n            route_target=virtual_service,\n            match=appmesh.HttpGatewayRouteMatch(\n                # This rewrites the path from \'/test\' to \'/rewrittenPath\'.\n                path=appmesh.HttpGatewayRoutePathMatch.exactly("/test", "/rewrittenPath")\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['priority', 'route_target', 'match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpGatewayRouteSpecOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpHealthCheckOptions
class HttpHealthCheckOptionsDef(BaseStruct):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive successful health checks that must occur before declaring listener healthy. Default: 2\n')
    interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The time period between each health check execution. Default: Duration.seconds(5)\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The destination path for the health check request. Default: /\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time to wait when receiving a response from the health check. Default: Duration.seconds(2)\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive failed health checks that must occur before declaring a listener unhealthy. Default: - 2\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    vpc = ec2.Vpc(self, "vpc")\n    namespace = cloudmap.PrivateDnsNamespace(self, "test-namespace",\n        vpc=vpc,\n        name="domain.local"\n    )\n    service = namespace.create_service("Svc")\n    node = mesh.add_virtual_node("virtual-node",\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=8081,\n            health_check=appmesh.HealthCheck.http(\n                healthy_threshold=3,\n                interval=Duration.seconds(5),  # minimum\n                path="/health-check-path",\n                timeout=Duration.seconds(2),  # minimum\n                unhealthy_threshold=2\n            )\n        )],\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout")\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['healthy_threshold', 'interval', 'path', 'timeout', 'unhealthy_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpHealthCheckOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpRetryPolicy
class HttpRetryPolicyDef(BaseStruct):
    retry_attempts: typing.Union[int, float] = pydantic.Field(..., description='The maximum number of retry attempts.\n')
    retry_timeout: models.DurationDef = pydantic.Field(..., description='The timeout for each retry attempt.\n')
    http_retry_events: typing.Optional[typing.Sequence[aws_cdk.aws_appmesh.HttpRetryEvent]] = pydantic.Field(None, description='Specify HTTP events on which to retry. You must specify at least one value for at least one types of retry events. Default: - no retries for http events\n')
    tcp_retry_events: typing.Optional[typing.Sequence[aws_cdk.aws_appmesh.TcpRetryEvent]] = pydantic.Field(None, description='TCP events on which to retry. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable. You must specify at least one value for at least one types of retry events. Default: - no retries for tcp events\n\n:exampleMetadata: infused\n\nExample::\n\n    # router: appmesh.VirtualRouter\n    # node: appmesh.VirtualNode\n\n\n    router.add_route("route-http2-retry",\n        route_spec=appmesh.RouteSpec.http2(\n            weighted_targets=[appmesh.WeightedTarget(virtual_node=node)],\n            retry_policy=appmesh.HttpRetryPolicy(\n                # Retry if the connection failed\n                tcp_retry_events=[appmesh.TcpRetryEvent.CONNECTION_ERROR],\n                # Retry if HTTP responds with a gateway error (502, 503, 504)\n                http_retry_events=[appmesh.HttpRetryEvent.GATEWAY_ERROR],\n                # Retry five times\n                retry_attempts=5,\n                # Use a 1 second timeout per retry\n                retry_timeout=Duration.seconds(1)\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['retry_attempts', 'retry_timeout', 'http_retry_events', 'tcp_retry_events']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpRetryPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[HttpRetryPolicyDefConfig] = pydantic.Field(None)


class HttpRetryPolicyDefConfig(pydantic.BaseModel):
    retry_timeout_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.HttpRouteMatch
class HttpRouteMatchDef(BaseStruct):
    headers: typing.Optional[typing.Sequence[models.aws_appmesh.HeaderMatchDef]] = pydantic.Field(None, description='Specifies the client request headers to match on. All specified headers must match for the route to match. Default: - do not match on headers\n')
    method: typing.Optional[aws_cdk.aws_appmesh.HttpRouteMethod] = pydantic.Field(None, description='The HTTP client request method to match on. Default: - do not match on request method\n')
    path: typing.Optional[models.aws_appmesh.HttpRoutePathMatchDef] = pydantic.Field(None, description='Specifies how is the request matched based on the path part of its URL. Default: - matches requests with all paths\n')
    protocol: typing.Optional[aws_cdk.aws_appmesh.HttpRouteProtocol] = pydantic.Field(None, description='The client request protocol to match on. Applicable only for HTTP2 routes. Default: - do not match on HTTP2 request protocol\n')
    query_parameters: typing.Optional[typing.Sequence[models.aws_appmesh.QueryParameterMatchDef]] = pydantic.Field(None, description='The query parameters to match on. All specified query parameters must match for the route to match. Default: - do not match on query parameters\n\n:exampleMetadata: infused\n\nExample::\n\n    # router: appmesh.VirtualRouter\n    # node: appmesh.VirtualNode\n\n\n    router.add_route("route-http",\n        route_spec=appmesh.RouteSpec.http(\n            weighted_targets=[appmesh.WeightedTarget(\n                virtual_node=node,\n                weight=50\n            ), appmesh.WeightedTarget(\n                virtual_node=node,\n                weight=50\n            )\n            ],\n            match=appmesh.HttpRouteMatch(\n                path=appmesh.HttpRoutePathMatch.starts_with("/path-to-app")\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['headers', 'method', 'path', 'protocol', 'query_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpRouteMatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpRoutePathMatchConfig
class HttpRoutePathMatchConfigDef(BaseStruct):
    prefix_path_match: typing.Optional[str] = pydantic.Field(None, description='Route configuration for matching on the prefix of the URL path of the request. Default: - no matching will be performed on the prefix of the URL path\n')
    whole_path_match: typing.Union[models.aws_appmesh.CfnRoute_HttpPathMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Route configuration for matching on the complete URL path of the request. Default: - no matching will be performed on the complete URL path\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    http_route_path_match_config = appmesh.HttpRoutePathMatchConfig(\n        prefix_path_match="prefixPathMatch",\n        whole_path_match=appmesh.CfnRoute.HttpPathMatchProperty(\n            exact="exact",\n            regex="regex"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['prefix_path_match', 'whole_path_match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpRoutePathMatchConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpRouteSpecOptions
class HttpRouteSpecOptionsDef(BaseStruct):
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority\n')
    weighted_targets: typing.Sequence[typing.Union[models.aws_appmesh.WeightedTargetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='List of targets that traffic is routed to when a request matches the route.\n')
    match: typing.Union[models.aws_appmesh.HttpRouteMatchDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The criterion for determining a request match for this Route. Default: - matches on '/'\n")
    retry_policy: typing.Union[models.aws_appmesh.HttpRetryPolicyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The retry policy. Default: - no retry policy\n')
    timeout: typing.Union[models.aws_appmesh.HttpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a http timeout. Default: - None\n\n:exampleMetadata: infused\n\nExample::\n\n    # router: appmesh.VirtualRouter\n    # node: appmesh.VirtualNode\n\n\n    router.add_route("route-http2-retry",\n        route_spec=appmesh.RouteSpec.http2(\n            weighted_targets=[appmesh.WeightedTarget(virtual_node=node)],\n            retry_policy=appmesh.HttpRetryPolicy(\n                # Retry if the connection failed\n                tcp_retry_events=[appmesh.TcpRetryEvent.CONNECTION_ERROR],\n                # Retry if HTTP responds with a gateway error (502, 503, 504)\n                http_retry_events=[appmesh.HttpRetryEvent.GATEWAY_ERROR],\n                # Retry five times\n                retry_attempts=5,\n                # Use a 1 second timeout per retry\n                retry_timeout=Duration.seconds(1)\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['priority', 'weighted_targets', 'match', 'retry_policy', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpRouteSpecOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpTimeout
class HttpTimeoutDef(BaseStruct):
    idle: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Represents an idle timeout. The amount of time that a connection may be idle. Default: - none\n')
    per_request: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Represents per request timeout. Default: - 15 s\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    # service: cloudmap.Service\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=8080,\n            health_check=appmesh.HealthCheck.http(\n                healthy_threshold=3,\n                interval=Duration.seconds(5),\n                path="/ping",\n                timeout=Duration.seconds(2),\n                unhealthy_threshold=2\n            ),\n            timeout=appmesh.HttpTimeout(\n                idle=Duration.seconds(5)\n            )\n        )],\n        backend_defaults=appmesh.BackendDefaults(\n            tls_client_policy=appmesh.TlsClientPolicy(\n                validation=appmesh.TlsValidation(\n                    trust=appmesh.TlsValidationTrust.file("/keys/local_cert_chain.pem")\n                )\n            )\n        ),\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout")\n    )\n\n    cdk.Tags.of(node).add("Environment", "Dev")\n')
    _init_params: typing.ClassVar[list[str]] = ['idle', 'per_request']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpTimeout'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.HttpVirtualNodeListenerOptions
class HttpVirtualNodeListenerOptionsDef(BaseStruct):
    connection_pool: typing.Union[models.aws_appmesh.HttpConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    outlier_detection: typing.Union[models.aws_appmesh.OutlierDetectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling outlier detection. Default: - none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    timeout: typing.Union[models.aws_appmesh.HttpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Timeout for HTTP protocol. Default: - None\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    vpc = ec2.Vpc(self, "vpc")\n    namespace = cloudmap.PrivateDnsNamespace(self, "test-namespace",\n        vpc=vpc,\n        name="domain.local"\n    )\n    service = namespace.create_service("Svc")\n    node = mesh.add_virtual_node("virtual-node",\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=8081,\n            health_check=appmesh.HealthCheck.http(\n                healthy_threshold=3,\n                interval=Duration.seconds(5),  # minimum\n                path="/health-check-path",\n                timeout=Duration.seconds(2),  # minimum\n                unhealthy_threshold=2\n            )\n        )],\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout")\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_pool', 'health_check', 'outlier_detection', 'port', 'timeout', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.HttpVirtualNodeListenerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.ListenerTlsOptions
class ListenerTlsOptionsDef(BaseStruct):
    certificate: models.aws_appmesh.TlsCertificateDef = pydantic.Field(..., description='Represents TLS certificate.\n')
    mode: aws_cdk.aws_appmesh.TlsMode = pydantic.Field(..., description='The TLS mode.\n')
    mutual_tls_validation: typing.Union[models.aws_appmesh.MutualTlsValidationDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents a listener\'s TLS validation context. The client certificate will only be validated if the client provides it, enabling mutual TLS. Default: - client TLS certificate is not required\n\n:exampleMetadata: infused\n\nExample::\n\n    # A Virtual Node with listener TLS from an ACM provided certificate\n    # cert: certificatemanager.Certificate\n    # mesh: appmesh.Mesh\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.dns("node"),\n        listeners=[appmesh.VirtualNodeListener.grpc(\n            port=80,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.acm(cert)\n            )\n        )]\n    )\n\n    # A Virtual Gateway with listener TLS from a customer provided file certificate\n    gateway = appmesh.VirtualGateway(self, "gateway",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.grpc(\n            port=8080,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.file("path/to/certChain", "path/to/privateKey")\n            )\n        )],\n        virtual_gateway_name="gateway"\n    )\n\n    # A Virtual Gateway with listener TLS from a SDS provided certificate\n    gateway2 = appmesh.VirtualGateway(self, "gateway2",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.http2(\n            port=8080,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.sds("secrete_certificate")\n            )\n        )],\n        virtual_gateway_name="gateway2"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate', 'mode', 'mutual_tls_validation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.ListenerTlsOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.LoggingFormatConfig
class LoggingFormatConfigDef(BaseStruct):
    format_config: typing.Union[models.aws_appmesh.CfnVirtualNode_LoggingFormatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='CFN configuration for Access Logging Format. Default: - no access logging format\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    logging_format_config = appmesh.LoggingFormatConfig(\n        format_config=appmesh.CfnVirtualNode.LoggingFormatProperty(\n            json=[appmesh.CfnVirtualNode.JsonFormatRefProperty(\n                key="key",\n                value="value"\n            )],\n            text="text"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['format_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.LoggingFormatConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.MeshProps
class MeshPropsDef(BaseStruct):
    egress_filter: typing.Optional[aws_cdk.aws_appmesh.MeshFilterType] = pydantic.Field(None, description='Egress filter to be applied to the Mesh. Default: DROP_ALL\n')
    mesh_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Mesh being defined. Default: - A name is automatically generated\n')
    service_discovery: typing.Union[models.aws_appmesh.MeshServiceDiscoveryDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines how upstream clients will discover VirtualNodes in the Mesh. Default: - No Service Discovery\n\n:exampleMetadata: infused\n\nExample::\n\n    # infra_stack: cdk.Stack\n    # app_stack: cdk.Stack\n\n\n    mesh = appmesh.Mesh(infra_stack, "AppMesh",\n        mesh_name="myAwsMesh",\n        egress_filter=appmesh.MeshFilterType.ALLOW_ALL\n    )\n\n    # the VirtualRouter will belong to \'appStack\',\n    # even though the Mesh belongs to \'infraStack\'\n    router = appmesh.VirtualRouter(app_stack, "router",\n        mesh=mesh,  # notice that mesh is a required property when creating a router with the \'new\' statement\n        listeners=[appmesh.VirtualRouterListener.http(8081)]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['egress_filter', 'mesh_name', 'service_discovery']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.MeshProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.MeshServiceDiscovery
class MeshServiceDiscoveryDef(BaseStruct):
    ip_preference: typing.Optional[aws_cdk.aws_appmesh.IpPreference] = pydantic.Field(None, description='IP preference applied to all Virtual Nodes in the Mesh. Default: - No IP preference is applied to any of the Virtual Nodes in the Mesh. Virtual Nodes without an IP preference will have the following configured. Envoy listeners are configured to bind only to IPv4. Envoy will use IPv4 when sending traffic to a local application. For DNS service discovery, the Envoy DNS resolver to prefer using IPv6 and fall back to IPv4. For CloudMap service discovery, App Mesh will prefer using IPv4 and fall back to IPv6 for IPs returned by CloudMap.\n\n:exampleMetadata: infused\n\nExample::\n\n    mesh = appmesh.Mesh(self, "AppMesh",\n        mesh_name="myAwsMesh",\n        service_discovery=appmesh.MeshServiceDiscovery(\n            ip_preference=appmesh.IpPreference.IPV4_ONLY\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip_preference']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.MeshServiceDiscovery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.MutualTlsValidation
class MutualTlsValidationDef(BaseStruct):
    trust: models.aws_appmesh.MutualTlsValidationTrustDef = pydantic.Field(..., description='Reference to where to retrieve the trust chain.\n')
    subject_alternative_names: typing.Optional[models.aws_appmesh.SubjectAlternativeNamesDef] = pydantic.Field(None, description='Represents the subject alternative names (SANs) secured by the certificate. SANs must be in the FQDN or URI format. Default: - If you don\'t specify SANs on the terminating mesh endpoint, the Envoy proxy for that node doesn\'t verify the SAN on a peer client certificate. If you don\'t specify SANs on the originating mesh endpoint, the SAN on the certificate provided by the terminating endpoint must match the mesh endpoint service discovery configuration.\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n\n\n    node1 = appmesh.VirtualNode(self, "node1",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.dns("node"),\n        listeners=[appmesh.VirtualNodeListener.grpc(\n            port=80,\n            tls=appmesh.ListenerTlsOptions(\n                mode=appmesh.TlsMode.STRICT,\n                certificate=appmesh.TlsCertificate.file("path/to/certChain", "path/to/privateKey"),\n                # Validate a file client certificates to enable mutual TLS authentication when a client provides a certificate.\n                mutual_tls_validation=appmesh.MutualTlsValidation(\n                    trust=appmesh.TlsValidationTrust.file("path-to-certificate")\n                )\n            )\n        )]\n    )\n\n    certificate_authority_arn = "arn:aws:acm-pca:us-east-1:123456789012:certificate-authority/12345678-1234-1234-1234-123456789012"\n    node2 = appmesh.VirtualNode(self, "node2",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.dns("node2"),\n        backend_defaults=appmesh.BackendDefaults(\n            tls_client_policy=appmesh.TlsClientPolicy(\n                ports=[8080, 8081],\n                validation=appmesh.TlsValidation(\n                    subject_alternative_names=appmesh.SubjectAlternativeNames.matching_exactly("mesh-endpoint.apps.local"),\n                    trust=appmesh.TlsValidationTrust.acm([\n                        acmpca.CertificateAuthority.from_certificate_authority_arn(self, "certificate", certificate_authority_arn)\n                    ])\n                ),\n                # Provide a SDS client certificate when a server requests it and enable mutual TLS authentication.\n                mutual_tls_certificate=appmesh.TlsCertificate.sds("secret_certificate")\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['trust', 'subject_alternative_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.MutualTlsValidation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.OutlierDetection
class OutlierDetectionDef(BaseStruct):
    base_ejection_duration: models.DurationDef = pydantic.Field(..., description='The base amount of time for which a host is ejected.\n')
    interval: models.DurationDef = pydantic.Field(..., description='The time interval between ejection sweep analysis.\n')
    max_ejection_percent: typing.Union[int, float] = pydantic.Field(..., description='Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.\n')
    max_server_errors: typing.Union[int, float] = pydantic.Field(..., description='Number of consecutive 5xx errors required for ejection.\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    # Cloud Map service discovery is currently required for host ejection by outlier detection\n    vpc = ec2.Vpc(self, "vpc")\n    namespace = cloudmap.PrivateDnsNamespace(self, "test-namespace",\n        vpc=vpc,\n        name="domain.local"\n    )\n    service = namespace.create_service("Svc")\n    node = mesh.add_virtual_node("virtual-node",\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            outlier_detection=appmesh.OutlierDetection(\n                base_ejection_duration=Duration.seconds(10),\n                interval=Duration.seconds(30),\n                max_ejection_percent=50,\n                max_server_errors=5\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_ejection_duration', 'interval', 'max_ejection_percent', 'max_server_errors']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.OutlierDetection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[OutlierDetectionDefConfig] = pydantic.Field(None)


class OutlierDetectionDefConfig(pydantic.BaseModel):
    base_ejection_duration_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)
    interval_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.QueryParameterMatchConfig
class QueryParameterMatchConfigDef(BaseStruct):
    query_parameter_match: typing.Union[models.aws_appmesh.CfnRoute_QueryParameterPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Route CFN configuration for route query parameter match.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    query_parameter_match_config = appmesh.QueryParameterMatchConfig(\n        query_parameter_match=appmesh.CfnRoute.QueryParameterProperty(\n            name="name",\n\n            # the properties below are optional\n            match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                exact="exact"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['query_parameter_match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.QueryParameterMatchConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.RouteAttributes
class RouteAttributesDef(BaseStruct):
    route_name: str = pydantic.Field(..., description='The name of the Route.\n')
    virtual_router: typing.Union[models.aws_appmesh.VirtualRouterDef] = pydantic.Field(..., description='The VirtualRouter the Route belongs to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # virtual_router: appmesh.VirtualRouter\n\n    route_attributes = appmesh.RouteAttributes(\n        route_name="routeName",\n        virtual_router=virtual_router\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route_name', 'virtual_router']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.RouteAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RouteAttributesDefConfig] = pydantic.Field(None)


class RouteAttributesDefConfig(pydantic.BaseModel):
    virtual_router_config: typing.Optional[models._interface_methods.AwsAppmeshIVirtualRouterDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.RouteBaseProps
class RouteBasePropsDef(BaseStruct):
    route_spec: models.aws_appmesh.RouteSpecDef = pydantic.Field(..., description='Protocol specific spec.\n')
    route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the route. Default: - An automatically generated name\n\n:exampleMetadata: infused\n\nExample::\n\n    # router: appmesh.VirtualRouter\n    # node: appmesh.VirtualNode\n\n\n    router.add_route("route-http2-retry",\n        route_spec=appmesh.RouteSpec.http2(\n            weighted_targets=[appmesh.WeightedTarget(virtual_node=node)],\n            retry_policy=appmesh.HttpRetryPolicy(\n                # Retry if the connection failed\n                tcp_retry_events=[appmesh.TcpRetryEvent.CONNECTION_ERROR],\n                # Retry if HTTP responds with a gateway error (502, 503, 504)\n                http_retry_events=[appmesh.HttpRetryEvent.GATEWAY_ERROR],\n                # Retry five times\n                retry_attempts=5,\n                # Use a 1 second timeout per retry\n                retry_timeout=Duration.seconds(1)\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route_spec', 'route_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.RouteBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.RouteProps
class RoutePropsDef(BaseStruct):
    route_spec: models.aws_appmesh.RouteSpecDef = pydantic.Field(..., description='Protocol specific spec.\n')
    route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the route. Default: - An automatically generated name\n')
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The service mesh to define the route in.\n')
    virtual_router: typing.Union[models.aws_appmesh.VirtualRouterDef] = pydantic.Field(..., description='The VirtualRouter the Route belongs to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # mesh: appmesh.Mesh\n    # route_spec: appmesh.RouteSpec\n    # virtual_router: appmesh.VirtualRouter\n\n    route_props = appmesh.RouteProps(\n        mesh=mesh,\n        route_spec=route_spec,\n        virtual_router=virtual_router,\n\n        # the properties below are optional\n        route_name="routeName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route_spec', 'route_name', 'mesh', 'virtual_router']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.RouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RoutePropsDefConfig] = pydantic.Field(None)


class RoutePropsDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)
    virtual_router_config: typing.Optional[models._interface_methods.AwsAppmeshIVirtualRouterDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.RouteSpecConfig
class RouteSpecConfigDef(BaseStruct):
    grpc_route_spec: typing.Union[models.aws_appmesh.CfnRoute_GrpcRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The spec for a grpc route. Default: - no grpc spec\n')
    http2_route_spec: typing.Union[models.aws_appmesh.CfnRoute_HttpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The spec for an http2 route. Default: - no http2 spec\n')
    http_route_spec: typing.Union[models.aws_appmesh.CfnRoute_HttpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The spec for an http route. Default: - no http spec\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority\n')
    tcp_route_spec: typing.Union[models.aws_appmesh.CfnRoute_TcpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The spec for a tcp route. Default: - no tcp spec\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    route_spec_config = appmesh.RouteSpecConfig(\n        grpc_route_spec=appmesh.CfnRoute.GrpcRouteProperty(\n            action=appmesh.CfnRoute.GrpcRouteActionProperty(\n                weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                    virtual_node="virtualNode",\n                    weight=123,\n\n                    # the properties below are optional\n                    port=123\n                )]\n            ),\n            match=appmesh.CfnRoute.GrpcRouteMatchProperty(\n                metadata=[appmesh.CfnRoute.GrpcRouteMetadataProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnRoute.MatchRangeProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                method_name="methodName",\n                port=123,\n                service_name="serviceName"\n            ),\n\n            # the properties below are optional\n            retry_policy=appmesh.CfnRoute.GrpcRetryPolicyProperty(\n                max_retries=123,\n                per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n\n                # the properties below are optional\n                grpc_retry_events=["grpcRetryEvents"],\n                http_retry_events=["httpRetryEvents"],\n                tcp_retry_events=["tcpRetryEvents"]\n            ),\n            timeout=appmesh.CfnRoute.GrpcTimeoutProperty(\n                idle=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        ),\n        http2_route_spec=appmesh.CfnRoute.HttpRouteProperty(\n            action=appmesh.CfnRoute.HttpRouteActionProperty(\n                weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                    virtual_node="virtualNode",\n                    weight=123,\n\n                    # the properties below are optional\n                    port=123\n                )]\n            ),\n            match=appmesh.CfnRoute.HttpRouteMatchProperty(\n                headers=[appmesh.CfnRoute.HttpRouteHeaderProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnRoute.MatchRangeProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                method="method",\n                path=appmesh.CfnRoute.HttpPathMatchProperty(\n                    exact="exact",\n                    regex="regex"\n                ),\n                port=123,\n                prefix="prefix",\n                query_parameters=[appmesh.CfnRoute.QueryParameterProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                        exact="exact"\n                    )\n                )],\n                scheme="scheme"\n            ),\n\n            # the properties below are optional\n            retry_policy=appmesh.CfnRoute.HttpRetryPolicyProperty(\n                max_retries=123,\n                per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n\n                # the properties below are optional\n                http_retry_events=["httpRetryEvents"],\n                tcp_retry_events=["tcpRetryEvents"]\n            ),\n            timeout=appmesh.CfnRoute.HttpTimeoutProperty(\n                idle=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        ),\n        http_route_spec=appmesh.CfnRoute.HttpRouteProperty(\n            action=appmesh.CfnRoute.HttpRouteActionProperty(\n                weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                    virtual_node="virtualNode",\n                    weight=123,\n\n                    # the properties below are optional\n                    port=123\n                )]\n            ),\n            match=appmesh.CfnRoute.HttpRouteMatchProperty(\n                headers=[appmesh.CfnRoute.HttpRouteHeaderProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    invert=False,\n                    match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                        exact="exact",\n                        prefix="prefix",\n                        range=appmesh.CfnRoute.MatchRangeProperty(\n                            end=123,\n                            start=123\n                        ),\n                        regex="regex",\n                        suffix="suffix"\n                    )\n                )],\n                method="method",\n                path=appmesh.CfnRoute.HttpPathMatchProperty(\n                    exact="exact",\n                    regex="regex"\n                ),\n                port=123,\n                prefix="prefix",\n                query_parameters=[appmesh.CfnRoute.QueryParameterProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                        exact="exact"\n                    )\n                )],\n                scheme="scheme"\n            ),\n\n            # the properties below are optional\n            retry_policy=appmesh.CfnRoute.HttpRetryPolicyProperty(\n                max_retries=123,\n                per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n\n                # the properties below are optional\n                http_retry_events=["httpRetryEvents"],\n                tcp_retry_events=["tcpRetryEvents"]\n            ),\n            timeout=appmesh.CfnRoute.HttpTimeoutProperty(\n                idle=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                per_request=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        ),\n        priority=123,\n        tcp_route_spec=appmesh.CfnRoute.TcpRouteProperty(\n            action=appmesh.CfnRoute.TcpRouteActionProperty(\n                weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                    virtual_node="virtualNode",\n                    weight=123,\n\n                    # the properties below are optional\n                    port=123\n                )]\n            ),\n\n            # the properties below are optional\n            match=appmesh.CfnRoute.TcpRouteMatchProperty(\n                port=123\n            ),\n            timeout=appmesh.CfnRoute.TcpTimeoutProperty(\n                idle=appmesh.CfnRoute.DurationProperty(\n                    unit="unit",\n                    value=123\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['grpc_route_spec', 'http2_route_spec', 'http_route_spec', 'priority', 'tcp_route_spec']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.RouteSpecConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.RouteSpecOptionsBase
class RouteSpecOptionsBaseDef(BaseStruct):
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    route_spec_options_base = appmesh.RouteSpecOptionsBase(\n        priority=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['priority']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.RouteSpecOptionsBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.ServiceDiscoveryConfig
class ServiceDiscoveryConfigDef(BaseStruct):
    cloudmap: typing.Union[models.aws_appmesh.CfnVirtualNode_AwsCloudMapServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Cloud Map based Service Discovery. Default: - no Cloud Map based service discovery\n')
    dns: typing.Union[models.aws_appmesh.CfnVirtualNode_DnsServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='DNS based Service Discovery. Default: - no DNS based service discovery\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    service_discovery_config = appmesh.ServiceDiscoveryConfig(\n        cloudmap=appmesh.CfnVirtualNode.AwsCloudMapServiceDiscoveryProperty(\n            namespace_name="namespaceName",\n            service_name="serviceName",\n\n            # the properties below are optional\n            attributes=[appmesh.CfnVirtualNode.AwsCloudMapInstanceAttributeProperty(\n                key="key",\n                value="value"\n            )],\n            ip_preference="ipPreference"\n        ),\n        dns=appmesh.CfnVirtualNode.DnsServiceDiscoveryProperty(\n            hostname="hostname",\n\n            # the properties below are optional\n            ip_preference="ipPreference",\n            response_type="responseType"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloudmap', 'dns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.ServiceDiscoveryConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.SubjectAlternativeNamesMatcherConfig
class SubjectAlternativeNamesMatcherConfigDef(BaseStruct):
    subject_alternative_names_match: typing.Union[models.aws_appmesh.CfnVirtualNode_SubjectAlternativeNameMatchersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='VirtualNode CFN configuration for subject alternative names secured by the certificate.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    subject_alternative_names_matcher_config = appmesh.SubjectAlternativeNamesMatcherConfig(\n        subject_alternative_names_match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n            exact=["exact"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subject_alternative_names_match']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.SubjectAlternativeNamesMatcherConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TcpConnectionPool
class TcpConnectionPoolDef(BaseStruct):
    max_connections: typing.Union[int, float] = pydantic.Field(..., description='The maximum connections in the pool. Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tcp_connection_pool = appmesh.TcpConnectionPool(\n        max_connections=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_connections']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TcpConnectionPool'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TcpHealthCheckOptions
class TcpHealthCheckOptionsDef(BaseStruct):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive successful health checks that must occur before declaring listener healthy. Default: 2\n')
    interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The time period between each health check execution. Default: Duration.seconds(5)\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time to wait when receiving a response from the health check. Default: Duration.seconds(2)\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive failed health checks that must occur before declaring a listener unhealthy. Default: - 2\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_appmesh as appmesh\n\n    tcp_health_check_options = appmesh.TcpHealthCheckOptions(\n        healthy_threshold=123,\n        interval=cdk.Duration.minutes(30),\n        timeout=cdk.Duration.minutes(30),\n        unhealthy_threshold=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['healthy_threshold', 'interval', 'timeout', 'unhealthy_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TcpHealthCheckOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TcpRouteSpecOptions
class TcpRouteSpecOptionsDef(BaseStruct):
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the route. When a Virtual Router has multiple routes, route match is performed in the order of specified value, where 0 is the highest priority, and first matched route is selected. Default: - no particular priority\n')
    weighted_targets: typing.Sequence[typing.Union[models.aws_appmesh.WeightedTargetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='List of targets that traffic is routed to when a request matches the route.\n')
    timeout: typing.Union[models.aws_appmesh.TcpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that represents a tcp timeout. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_appmesh as appmesh\n\n    # virtual_node: appmesh.VirtualNode\n\n    tcp_route_spec_options = appmesh.TcpRouteSpecOptions(\n        weighted_targets=[appmesh.WeightedTarget(\n            virtual_node=virtual_node,\n\n            # the properties below are optional\n            weight=123\n        )],\n\n        # the properties below are optional\n        priority=123,\n        timeout=appmesh.TcpTimeout(\n            idle=cdk.Duration.minutes(30)\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['priority', 'weighted_targets', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TcpRouteSpecOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TcpTimeout
class TcpTimeoutDef(BaseStruct):
    idle: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Represents an idle timeout. The amount of time that a connection may be idle. Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_appmesh as appmesh\n\n    tcp_timeout = appmesh.TcpTimeout(\n        idle=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TcpTimeout'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TcpVirtualNodeListenerOptions
class TcpVirtualNodeListenerOptionsDef(BaseStruct):
    connection_pool: typing.Union[models.aws_appmesh.TcpConnectionPoolDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Connection pool for http listeners. Default: - None\n')
    health_check: typing.Optional[models.aws_appmesh.HealthCheckDef] = pydantic.Field(None, description='The health check information for the listener. Default: - no healthcheck\n')
    outlier_detection: typing.Union[models.aws_appmesh.OutlierDetectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling outlier detection. Default: - none\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='Port to listen for connections on. Default: - 8080\n')
    timeout: typing.Union[models.aws_appmesh.TcpTimeoutDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Timeout for TCP protocol. Default: - None\n')
    tls: typing.Union[models.aws_appmesh.ListenerTlsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents the configuration for enabling TLS on a listener. Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_appmesh as appmesh\n\n    # health_check: appmesh.HealthCheck\n    # mutual_tls_validation_trust: appmesh.MutualTlsValidationTrust\n    # subject_alternative_names: appmesh.SubjectAlternativeNames\n    # tls_certificate: appmesh.TlsCertificate\n\n    tcp_virtual_node_listener_options = appmesh.TcpVirtualNodeListenerOptions(\n        connection_pool=appmesh.TcpConnectionPool(\n            max_connections=123\n        ),\n        health_check=health_check,\n        outlier_detection=appmesh.OutlierDetection(\n            base_ejection_duration=cdk.Duration.minutes(30),\n            interval=cdk.Duration.minutes(30),\n            max_ejection_percent=123,\n            max_server_errors=123\n        ),\n        port=123,\n        timeout=appmesh.TcpTimeout(\n            idle=cdk.Duration.minutes(30)\n        ),\n        tls=appmesh.ListenerTlsOptions(\n            certificate=tls_certificate,\n            mode=appmesh.TlsMode.STRICT,\n\n            # the properties below are optional\n            mutual_tls_validation=appmesh.MutualTlsValidation(\n                trust=mutual_tls_validation_trust,\n\n                # the properties below are optional\n                subject_alternative_names=subject_alternative_names\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_pool', 'health_check', 'outlier_detection', 'port', 'timeout', 'tls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TcpVirtualNodeListenerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TlsCertificateConfig
class TlsCertificateConfigDef(BaseStruct):
    tls_certificate: typing.Union[models.aws_appmesh.CfnVirtualNode_ListenerTlsCertificatePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The CFN shape for a TLS certificate.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tls_certificate_config = appmesh.TlsCertificateConfig(\n        tls_certificate=appmesh.CfnVirtualNode.ListenerTlsCertificateProperty(\n            acm=appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty(\n                certificate_arn="certificateArn"\n            ),\n            file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                certificate_chain="certificateChain",\n                private_key="privateKey"\n            ),\n            sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                secret_name="secretName"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tls_certificate']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TlsCertificateConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TlsClientPolicy
class TlsClientPolicyDef(BaseStruct):
    validation: typing.Union[models.aws_appmesh.TlsValidationDef, dict[str, typing.Any]] = pydantic.Field(..., description='Represents the object for TLS validation context.\n')
    enforce: typing.Optional[bool] = pydantic.Field(None, description='Whether the policy is enforced. Default: true\n')
    mutual_tls_certificate: typing.Optional[models.aws_appmesh.MutualTlsCertificateDef] = pydantic.Field(None, description='Represents a client TLS certificate. The certificate will be sent only if the server requests it, enabling mutual TLS. Default: - client TLS certificate is not provided\n')
    ports: typing.Optional[typing.Sequence[typing.Union[int, float]]] = pydantic.Field(None, description='TLS is enforced on the ports specified here. If no ports are specified, TLS will be enforced on all the ports. Default: - all ports\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    # service: cloudmap.Service\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=8080,\n            health_check=appmesh.HealthCheck.http(\n                healthy_threshold=3,\n                interval=Duration.seconds(5),\n                path="/ping",\n                timeout=Duration.seconds(2),\n                unhealthy_threshold=2\n            ),\n            timeout=appmesh.HttpTimeout(\n                idle=Duration.seconds(5)\n            )\n        )],\n        backend_defaults=appmesh.BackendDefaults(\n            tls_client_policy=appmesh.TlsClientPolicy(\n                validation=appmesh.TlsValidation(\n                    trust=appmesh.TlsValidationTrust.file("/keys/local_cert_chain.pem")\n                )\n            )\n        ),\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout")\n    )\n\n    cdk.Tags.of(node).add("Environment", "Dev")\n')
    _init_params: typing.ClassVar[list[str]] = ['validation', 'enforce', 'mutual_tls_certificate', 'ports']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TlsClientPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TlsValidation
class TlsValidationDef(BaseStruct):
    trust: models.aws_appmesh.TlsValidationTrustDef = pydantic.Field(..., description='Reference to where to retrieve the trust chain.\n')
    subject_alternative_names: typing.Optional[models.aws_appmesh.SubjectAlternativeNamesDef] = pydantic.Field(None, description='Represents the subject alternative names (SANs) secured by the certificate. SANs must be in the FQDN or URI format. Default: - If you don\'t specify SANs on the terminating mesh endpoint, the Envoy proxy for that node doesn\'t verify the SAN on a peer client certificate. If you don\'t specify SANs on the originating mesh endpoint, the SAN on the certificate provided by the terminating endpoint must match the mesh endpoint service discovery configuration.\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    # service: cloudmap.Service\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=8080,\n            health_check=appmesh.HealthCheck.http(\n                healthy_threshold=3,\n                interval=Duration.seconds(5),\n                path="/ping",\n                timeout=Duration.seconds(2),\n                unhealthy_threshold=2\n            ),\n            timeout=appmesh.HttpTimeout(\n                idle=Duration.seconds(5)\n            )\n        )],\n        backend_defaults=appmesh.BackendDefaults(\n            tls_client_policy=appmesh.TlsClientPolicy(\n                validation=appmesh.TlsValidation(\n                    trust=appmesh.TlsValidationTrust.file("/keys/local_cert_chain.pem")\n                )\n            )\n        ),\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout")\n    )\n\n    cdk.Tags.of(node).add("Environment", "Dev")\n')
    _init_params: typing.ClassVar[list[str]] = ['trust', 'subject_alternative_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TlsValidation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.TlsValidationTrustConfig
class TlsValidationTrustConfigDef(BaseStruct):
    tls_validation_trust: typing.Union[models.aws_appmesh.CfnVirtualNode_TlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='VirtualNode CFN configuration for client policy\'s TLS Validation Trust.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    tls_validation_trust_config = appmesh.TlsValidationTrustConfig(\n        tls_validation_trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n            acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                certificate_authority_arns=["certificateAuthorityArns"]\n            ),\n            file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                certificate_chain="certificateChain"\n            ),\n            sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                secret_name="secretName"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tls_validation_trust']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.TlsValidationTrustConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualGatewayAttributes
class VirtualGatewayAttributesDef(BaseStruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh that the VirtualGateway belongs to.\n')
    virtual_gateway_name: str = pydantic.Field(..., description='The name of the VirtualGateway.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # mesh: appmesh.Mesh\n\n    virtual_gateway_attributes = appmesh.VirtualGatewayAttributes(\n        mesh=mesh,\n        virtual_gateway_name="virtualGatewayName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'virtual_gateway_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualGatewayAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualGatewayAttributesDefConfig] = pydantic.Field(None)


class VirtualGatewayAttributesDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.VirtualGatewayBaseProps
class VirtualGatewayBasePropsDef(BaseStruct):
    access_log: typing.Optional[models.aws_appmesh.AccessLogDef] = pydantic.Field(None, description='Access Logging Configuration for the VirtualGateway. Default: - no access logging\n')
    backend_defaults: typing.Union[models.aws_appmesh.BackendDefaultsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Default Configuration Virtual Node uses to communicate with Virtual Service. Default: - No Config\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualGatewayListenerDef]] = pydantic.Field(None, description='Listeners for the VirtualGateway. Only one is supported. Default: - Single HTTP listener on port 8080\n')
    virtual_gateway_name: typing.Optional[str] = pydantic.Field(None, description='Name of the VirtualGateway. Default: - A name is automatically determined\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n\n\n    gateway = mesh.add_virtual_gateway("gateway",\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout"),\n        virtual_gateway_name="virtualGateway",\n        listeners=[appmesh.VirtualGatewayListener.http(\n            port=443,\n            health_check=appmesh.HealthCheck.http(\n                interval=Duration.seconds(10)\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_log', 'backend_defaults', 'listeners', 'virtual_gateway_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualGatewayBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualGatewayListenerConfig
class VirtualGatewayListenerConfigDef(BaseStruct):
    listener: typing.Union[models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Single listener config for a VirtualGateway.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_gateway_listener_config = appmesh.VirtualGatewayListenerConfig(\n        listener=appmesh.CfnVirtualGateway.VirtualGatewayListenerProperty(\n            port_mapping=appmesh.CfnVirtualGateway.VirtualGatewayPortMappingProperty(\n                port=123,\n                protocol="protocol"\n            ),\n\n            # the properties below are optional\n            connection_pool=appmesh.CfnVirtualGateway.VirtualGatewayConnectionPoolProperty(\n                grpc=appmesh.CfnVirtualGateway.VirtualGatewayGrpcConnectionPoolProperty(\n                    max_requests=123\n                ),\n                http=appmesh.CfnVirtualGateway.VirtualGatewayHttpConnectionPoolProperty(\n                    max_connections=123,\n\n                    # the properties below are optional\n                    max_pending_requests=123\n                ),\n                http2=appmesh.CfnVirtualGateway.VirtualGatewayHttp2ConnectionPoolProperty(\n                    max_requests=123\n                )\n            ),\n            health_check=appmesh.CfnVirtualGateway.VirtualGatewayHealthCheckPolicyProperty(\n                healthy_threshold=123,\n                interval_millis=123,\n                protocol="protocol",\n                timeout_millis=123,\n                unhealthy_threshold=123,\n\n                # the properties below are optional\n                path="path",\n                port=123\n            ),\n            tls=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsProperty(\n                certificate=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsCertificateProperty(\n                    acm=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty(\n                        certificate_arn="certificateArn"\n                    ),\n                    file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                        certificate_chain="certificateChain",\n                        private_key="privateKey"\n                    ),\n                    sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                        secret_name="secretName"\n                    )\n                ),\n                mode="mode",\n\n                # the properties below are optional\n                validation=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextProperty(\n                    trust=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty(\n                        file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                            certificate_chain="certificateChain"\n                        ),\n                        sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n\n                    # the properties below are optional\n                    subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                        match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                            exact=["exact"]\n                        )\n                    )\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listener']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualGatewayListenerConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualGatewayProps
class VirtualGatewayPropsDef(BaseStruct):
    access_log: typing.Optional[models.aws_appmesh.AccessLogDef] = pydantic.Field(None, description='Access Logging Configuration for the VirtualGateway. Default: - no access logging\n')
    backend_defaults: typing.Union[models.aws_appmesh.BackendDefaultsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Default Configuration Virtual Node uses to communicate with Virtual Service. Default: - No Config\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualGatewayListenerDef]] = pydantic.Field(None, description='Listeners for the VirtualGateway. Only one is supported. Default: - Single HTTP listener on port 8080\n')
    virtual_gateway_name: typing.Optional[str] = pydantic.Field(None, description='Name of the VirtualGateway. Default: - A name is automatically determined\n')
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualGateway belongs to.\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n\n    certificate_authority_arn = "arn:aws:acm-pca:us-east-1:123456789012:certificate-authority/12345678-1234-1234-1234-123456789012"\n\n    gateway = appmesh.VirtualGateway(self, "gateway",\n        mesh=mesh,\n        listeners=[appmesh.VirtualGatewayListener.http(\n            port=443,\n            health_check=appmesh.HealthCheck.http(\n                interval=Duration.seconds(10)\n            )\n        )],\n        backend_defaults=appmesh.BackendDefaults(\n            tls_client_policy=appmesh.TlsClientPolicy(\n                ports=[8080, 8081],\n                validation=appmesh.TlsValidation(\n                    trust=appmesh.TlsValidationTrust.acm([\n                        acmpca.CertificateAuthority.from_certificate_authority_arn(self, "certificate", certificate_authority_arn)\n                    ])\n                )\n            )\n        ),\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout"),\n        virtual_gateway_name="virtualGateway"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_log', 'backend_defaults', 'listeners', 'virtual_gateway_name', 'mesh']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualGatewayPropsDefConfig] = pydantic.Field(None)


class VirtualGatewayPropsDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.VirtualNodeAttributes
class VirtualNodeAttributesDef(BaseStruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh that the VirtualNode belongs to.\n')
    virtual_node_name: str = pydantic.Field(..., description='The name of the VirtualNode.\n\n:exampleMetadata: infused\n\nExample::\n\n    virtual_node_name = "my-virtual-node"\n    appmesh.VirtualNode.from_virtual_node_attributes(self, "imported-virtual-node",\n        mesh=appmesh.Mesh.from_mesh_name(self, "Mesh", "testMesh"),\n        virtual_node_name=virtual_node_name\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'virtual_node_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualNodeAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualNodeAttributesDefConfig] = pydantic.Field(None)


class VirtualNodeAttributesDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.VirtualNodeBaseProps
class VirtualNodeBasePropsDef(BaseStruct):
    access_log: typing.Optional[models.aws_appmesh.AccessLogDef] = pydantic.Field(None, description='Access Logging Configuration for the virtual node. Default: - No access logging\n')
    backend_defaults: typing.Union[models.aws_appmesh.BackendDefaultsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Default Configuration Virtual Node uses to communicate with Virtual Service. Default: - No Config\n')
    backends: typing.Optional[typing.Sequence[models.aws_appmesh.BackendDef]] = pydantic.Field(None, description='Virtual Services that this is node expected to send outbound traffic to. Default: - No backends\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualNodeListenerDef]] = pydantic.Field(None, description='Initial listener for the virtual node. Default: - No listeners\n')
    service_discovery: typing.Optional[models.aws_appmesh.ServiceDiscoveryDef] = pydantic.Field(None, description='Defines how upstream clients will discover this VirtualNode. Default: - No Service Discovery\n')
    virtual_node_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualNode. Default: - A name is automatically determined\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    vpc = ec2.Vpc(self, "vpc")\n    namespace = cloudmap.PrivateDnsNamespace(self, "test-namespace",\n        vpc=vpc,\n        name="domain.local"\n    )\n    service = namespace.create_service("Svc")\n    node = mesh.add_virtual_node("virtual-node",\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=8081,\n            health_check=appmesh.HealthCheck.http(\n                healthy_threshold=3,\n                interval=Duration.seconds(5),  # minimum\n                path="/health-check-path",\n                timeout=Duration.seconds(2),  # minimum\n                unhealthy_threshold=2\n            )\n        )],\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout")\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_log', 'backend_defaults', 'backends', 'listeners', 'service_discovery', 'virtual_node_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualNodeBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualNodeListenerConfig
class VirtualNodeListenerConfigDef(BaseStruct):
    listener: typing.Union[models.aws_appmesh.CfnVirtualNode_ListenerPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Single listener config for a VirtualNode.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_node_listener_config = appmesh.VirtualNodeListenerConfig(\n        listener=appmesh.CfnVirtualNode.ListenerProperty(\n            port_mapping=appmesh.CfnVirtualNode.PortMappingProperty(\n                port=123,\n                protocol="protocol"\n            ),\n\n            # the properties below are optional\n            connection_pool=appmesh.CfnVirtualNode.VirtualNodeConnectionPoolProperty(\n                grpc=appmesh.CfnVirtualNode.VirtualNodeGrpcConnectionPoolProperty(\n                    max_requests=123\n                ),\n                http=appmesh.CfnVirtualNode.VirtualNodeHttpConnectionPoolProperty(\n                    max_connections=123,\n\n                    # the properties below are optional\n                    max_pending_requests=123\n                ),\n                http2=appmesh.CfnVirtualNode.VirtualNodeHttp2ConnectionPoolProperty(\n                    max_requests=123\n                ),\n                tcp=appmesh.CfnVirtualNode.VirtualNodeTcpConnectionPoolProperty(\n                    max_connections=123\n                )\n            ),\n            health_check=appmesh.CfnVirtualNode.HealthCheckProperty(\n                healthy_threshold=123,\n                interval_millis=123,\n                protocol="protocol",\n                timeout_millis=123,\n                unhealthy_threshold=123,\n\n                # the properties below are optional\n                path="path",\n                port=123\n            ),\n            outlier_detection=appmesh.CfnVirtualNode.OutlierDetectionProperty(\n                base_ejection_duration=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                interval=appmesh.CfnVirtualNode.DurationProperty(\n                    unit="unit",\n                    value=123\n                ),\n                max_ejection_percent=123,\n                max_server_errors=123\n            ),\n            timeout=appmesh.CfnVirtualNode.ListenerTimeoutProperty(\n                grpc=appmesh.CfnVirtualNode.GrpcTimeoutProperty(\n                    idle=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                ),\n                http=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n                    idle=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                ),\n                http2=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n                    idle=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                ),\n                tcp=appmesh.CfnVirtualNode.TcpTimeoutProperty(\n                    idle=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                )\n            ),\n            tls=appmesh.CfnVirtualNode.ListenerTlsProperty(\n                certificate=appmesh.CfnVirtualNode.ListenerTlsCertificateProperty(\n                    acm=appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty(\n                        certificate_arn="certificateArn"\n                    ),\n                    file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                        certificate_chain="certificateChain",\n                        private_key="privateKey"\n                    ),\n                    sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                        secret_name="secretName"\n                    )\n                ),\n                mode="mode",\n\n                # the properties below are optional\n                validation=appmesh.CfnVirtualNode.ListenerTlsValidationContextProperty(\n                    trust=appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty(\n                        file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                            certificate_chain="certificateChain"\n                        ),\n                        sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n\n                    # the properties below are optional\n                    subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                        match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                            exact=["exact"]\n                        )\n                    )\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listener']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualNodeListenerConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualNodeProps
class VirtualNodePropsDef(BaseStruct):
    access_log: typing.Optional[models.aws_appmesh.AccessLogDef] = pydantic.Field(None, description='Access Logging Configuration for the virtual node. Default: - No access logging\n')
    backend_defaults: typing.Union[models.aws_appmesh.BackendDefaultsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Default Configuration Virtual Node uses to communicate with Virtual Service. Default: - No Config\n')
    backends: typing.Optional[typing.Sequence[models.aws_appmesh.BackendDef]] = pydantic.Field(None, description='Virtual Services that this is node expected to send outbound traffic to. Default: - No backends\n')
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualNodeListenerDef]] = pydantic.Field(None, description='Initial listener for the virtual node. Default: - No listeners\n')
    service_discovery: typing.Optional[models.aws_appmesh.ServiceDiscoveryDef] = pydantic.Field(None, description='Defines how upstream clients will discover this VirtualNode. Default: - No Service Discovery\n')
    virtual_node_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualNode. Default: - A name is automatically determined\n')
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualNode belongs to.\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n    # service: cloudmap.Service\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.cloud_map(service),\n        listeners=[appmesh.VirtualNodeListener.http(\n            port=8080,\n            health_check=appmesh.HealthCheck.http(\n                healthy_threshold=3,\n                interval=Duration.seconds(5),\n                path="/ping",\n                timeout=Duration.seconds(2),\n                unhealthy_threshold=2\n            ),\n            timeout=appmesh.HttpTimeout(\n                idle=Duration.seconds(5)\n            )\n        )],\n        backend_defaults=appmesh.BackendDefaults(\n            tls_client_policy=appmesh.TlsClientPolicy(\n                validation=appmesh.TlsValidation(\n                    trust=appmesh.TlsValidationTrust.file("/keys/local_cert_chain.pem")\n                )\n            )\n        ),\n        access_log=appmesh.AccessLog.from_file_path("/dev/stdout")\n    )\n\n    cdk.Tags.of(node).add("Environment", "Dev")\n')
    _init_params: typing.ClassVar[list[str]] = ['access_log', 'backend_defaults', 'backends', 'listeners', 'service_discovery', 'virtual_node_name', 'mesh']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualNodeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualNodePropsDefConfig] = pydantic.Field(None)


class VirtualNodePropsDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.VirtualRouterAttributes
class VirtualRouterAttributesDef(BaseStruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualRouter belongs to.\n')
    virtual_router_name: str = pydantic.Field(..., description='The name of the VirtualRouter.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # mesh: appmesh.Mesh\n\n    virtual_router_attributes = appmesh.VirtualRouterAttributes(\n        mesh=mesh,\n        virtual_router_name="virtualRouterName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'virtual_router_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualRouterAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualRouterAttributesDefConfig] = pydantic.Field(None)


class VirtualRouterAttributesDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.VirtualRouterBaseProps
class VirtualRouterBasePropsDef(BaseStruct):
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualRouterListenerDef]] = pydantic.Field(None, description='Listener specification for the VirtualRouter. Default: - A listener on HTTP port 8080\n')
    virtual_router_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualRouter. Default: - A name is automatically determined\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n\n    router = mesh.add_virtual_router("router",\n        listeners=[appmesh.VirtualRouterListener.http(8080)]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listeners', 'virtual_router_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualRouterBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualRouterListenerConfig
class VirtualRouterListenerConfigDef(BaseStruct):
    listener: typing.Union[models.aws_appmesh.CfnVirtualRouter_VirtualRouterListenerPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Single listener config for a VirtualRouter.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    virtual_router_listener_config = appmesh.VirtualRouterListenerConfig(\n        listener=appmesh.CfnVirtualRouter.VirtualRouterListenerProperty(\n            port_mapping=appmesh.CfnVirtualRouter.PortMappingProperty(\n                port=123,\n                protocol="protocol"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listener']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualRouterListenerConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualRouterProps
class VirtualRouterPropsDef(BaseStruct):
    listeners: typing.Optional[typing.Sequence[models.aws_appmesh.VirtualRouterListenerDef]] = pydantic.Field(None, description='Listener specification for the VirtualRouter. Default: - A listener on HTTP port 8080\n')
    virtual_router_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualRouter. Default: - A name is automatically determined\n')
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualRouter belongs to.\n\n:exampleMetadata: infused\n\nExample::\n\n    # infra_stack: cdk.Stack\n    # app_stack: cdk.Stack\n\n\n    mesh = appmesh.Mesh(infra_stack, "AppMesh",\n        mesh_name="myAwsMesh",\n        egress_filter=appmesh.MeshFilterType.ALLOW_ALL\n    )\n\n    # the VirtualRouter will belong to \'appStack\',\n    # even though the Mesh belongs to \'infraStack\'\n    router = appmesh.VirtualRouter(app_stack, "router",\n        mesh=mesh,  # notice that mesh is a required property when creating a router with the \'new\' statement\n        listeners=[appmesh.VirtualRouterListener.http(8081)]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listeners', 'virtual_router_name', 'mesh']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualRouterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualRouterPropsDefConfig] = pydantic.Field(None)


class VirtualRouterPropsDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.VirtualServiceAttributes
class VirtualServiceAttributesDef(BaseStruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='The Mesh which the VirtualService belongs to.\n')
    virtual_service_name: str = pydantic.Field(..., description='The name of the VirtualService, it is recommended this follows the fully-qualified domain name format.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # mesh: appmesh.Mesh\n\n    virtual_service_attributes = appmesh.VirtualServiceAttributes(\n        mesh=mesh,\n        virtual_service_name="virtualServiceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'virtual_service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualServiceAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualServiceAttributesDefConfig] = pydantic.Field(None)


class VirtualServiceAttributesDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.VirtualServiceBackendOptions
class VirtualServiceBackendOptionsDef(BaseStruct):
    tls_client_policy: typing.Union[models.aws_appmesh.TlsClientPolicyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='TLS properties for Client policy for the backend. Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # mutual_tls_certificate: appmesh.MutualTlsCertificate\n    # subject_alternative_names: appmesh.SubjectAlternativeNames\n    # tls_validation_trust: appmesh.TlsValidationTrust\n\n    virtual_service_backend_options = appmesh.VirtualServiceBackendOptions(\n        tls_client_policy=appmesh.TlsClientPolicy(\n            validation=appmesh.TlsValidation(\n                trust=tls_validation_trust,\n\n                # the properties below are optional\n                subject_alternative_names=subject_alternative_names\n            ),\n\n            # the properties below are optional\n            enforce=False,\n            mutual_tls_certificate=mutual_tls_certificate,\n            ports=[123]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tls_client_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualServiceBackendOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualServiceProps
class VirtualServicePropsDef(BaseStruct):
    virtual_service_provider: models.aws_appmesh.VirtualServiceProviderDef = pydantic.Field(..., description='The VirtualNode or VirtualRouter which the VirtualService uses as its provider.\n')
    virtual_service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VirtualService. It is recommended this follows the fully-qualified domain name format, such as "my-service.default.svc.cluster.local". Example value: ``service.domain.local`` Default: - A name is automatically generated\n\n:exampleMetadata: infused\n\nExample::\n\n    # mesh: appmesh.Mesh\n\n\n    node = appmesh.VirtualNode(self, "node",\n        mesh=mesh,\n        service_discovery=appmesh.ServiceDiscovery.dns("node")\n    )\n\n    virtual_service = appmesh.VirtualService(self, "service-1",\n        virtual_service_provider=appmesh.VirtualServiceProvider.virtual_node(node),\n        virtual_service_name="service1.domain.local"\n    )\n\n    node.add_backend(appmesh.Backend.virtual_service(virtual_service))\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_service_provider', 'virtual_service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.VirtualServiceProviderConfig
class VirtualServiceProviderConfigDef(BaseStruct):
    mesh: typing.Union[models.aws_appmesh.MeshDef] = pydantic.Field(..., description='Mesh the Provider is using. Default: - none\n')
    virtual_node_provider: typing.Union[models.aws_appmesh.CfnVirtualService_VirtualNodeServiceProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Virtual Node based provider. Default: - none\n')
    virtual_router_provider: typing.Union[models.aws_appmesh.CfnVirtualService_VirtualRouterServiceProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Virtual Router based provider. Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # mesh: appmesh.Mesh\n\n    virtual_service_provider_config = appmesh.VirtualServiceProviderConfig(\n        mesh=mesh,\n\n        # the properties below are optional\n        virtual_node_provider=appmesh.CfnVirtualService.VirtualNodeServiceProviderProperty(\n            virtual_node_name="virtualNodeName"\n        ),\n        virtual_router_provider=appmesh.CfnVirtualService.VirtualRouterServiceProviderProperty(\n            virtual_router_name="virtualRouterName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh', 'virtual_node_provider', 'virtual_router_provider']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.VirtualServiceProviderConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VirtualServiceProviderConfigDefConfig] = pydantic.Field(None)


class VirtualServiceProviderConfigDefConfig(pydantic.BaseModel):
    mesh_config: typing.Optional[models._interface_methods.AwsAppmeshIMeshDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.WeightedTarget
class WeightedTargetDef(BaseStruct):
    virtual_node: typing.Union[models.aws_appmesh.VirtualNodeDef] = pydantic.Field(..., description='The VirtualNode the route points to.\n')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='The weight for the target. Default: 1\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    # virtual_node: appmesh.VirtualNode\n\n    weighted_target = appmesh.WeightedTarget(\n        virtual_node=virtual_node,\n\n        # the properties below are optional\n        weight=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['virtual_node', 'weight']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.WeightedTarget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[WeightedTargetDefConfig] = pydantic.Field(None)


class WeightedTargetDefConfig(pydantic.BaseModel):
    virtual_node_config: typing.Optional[models._interface_methods.AwsAppmeshIVirtualNodeDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_appmesh.DnsResponseType
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.GrpcRetryEvent
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.HttpRetryEvent
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.HttpRouteMethod
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.HttpRouteProtocol
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.IpPreference
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.MeshFilterType
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.TcpRetryEvent
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.TlsMode
# skipping emum

#  autogenerated from aws_cdk.aws_appmesh.IGatewayRoute
#  skipping Interface

#  autogenerated from aws_cdk.aws_appmesh.IMesh
#  skipping Interface

#  autogenerated from aws_cdk.aws_appmesh.IRoute
#  skipping Interface

#  autogenerated from aws_cdk.aws_appmesh.IVirtualGateway
#  skipping Interface

#  autogenerated from aws_cdk.aws_appmesh.IVirtualNode
#  skipping Interface

#  autogenerated from aws_cdk.aws_appmesh.IVirtualRouter
#  skipping Interface

#  autogenerated from aws_cdk.aws_appmesh.IVirtualService
#  skipping Interface

#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRoute
class CfnGatewayRouteDef(BaseCfnResource):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh that the resource resides in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The specifications of the gateway route.\n')
    virtual_gateway_name: str = pydantic.Field(..., description='The virtual gateway that the gateway route is associated with.\n')
    gateway_route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the gateway route.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description="The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'virtual_gateway_name', 'gateway_route_name', 'mesh_owner', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['GatewayRouteHostnameMatchProperty', 'GatewayRouteHostnameRewriteProperty', 'GatewayRouteMetadataMatchProperty', 'GatewayRouteRangeMatchProperty', 'GatewayRouteSpecProperty', 'GatewayRouteTargetProperty', 'GatewayRouteVirtualServiceProperty', 'GrpcGatewayRouteActionProperty', 'GrpcGatewayRouteMatchProperty', 'GrpcGatewayRouteMetadataProperty', 'GrpcGatewayRouteProperty', 'GrpcGatewayRouteRewriteProperty', 'HttpGatewayRouteActionProperty', 'HttpGatewayRouteHeaderMatchProperty', 'HttpGatewayRouteHeaderProperty', 'HttpGatewayRouteMatchProperty', 'HttpGatewayRoutePathRewriteProperty', 'HttpGatewayRoutePrefixRewriteProperty', 'HttpGatewayRouteProperty', 'HttpGatewayRouteRewriteProperty', 'HttpPathMatchProperty', 'HttpQueryParameterMatchProperty', 'QueryParameterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnGatewayRouteDefConfig] = pydantic.Field(None)


class CfnGatewayRouteDefConfig(pydantic.BaseModel):
    GatewayRouteHostnameMatchProperty: typing.Optional[list[CfnGatewayRouteDefGatewayroutehostnamematchpropertyParams]] = pydantic.Field(None, description='')
    GatewayRouteHostnameRewriteProperty: typing.Optional[list[CfnGatewayRouteDefGatewayroutehostnamerewritepropertyParams]] = pydantic.Field(None, description='')
    GatewayRouteMetadataMatchProperty: typing.Optional[list[CfnGatewayRouteDefGatewayroutemetadatamatchpropertyParams]] = pydantic.Field(None, description='')
    GatewayRouteRangeMatchProperty: typing.Optional[list[CfnGatewayRouteDefGatewayrouterangematchpropertyParams]] = pydantic.Field(None, description='')
    GatewayRouteSpecProperty: typing.Optional[list[CfnGatewayRouteDefGatewayroutespecpropertyParams]] = pydantic.Field(None, description='')
    GatewayRouteTargetProperty: typing.Optional[list[CfnGatewayRouteDefGatewayroutetargetpropertyParams]] = pydantic.Field(None, description='')
    GatewayRouteVirtualServiceProperty: typing.Optional[list[CfnGatewayRouteDefGatewayroutevirtualservicepropertyParams]] = pydantic.Field(None, description='')
    GrpcGatewayRouteActionProperty: typing.Optional[list[CfnGatewayRouteDefGrpcgatewayrouteactionpropertyParams]] = pydantic.Field(None, description='')
    GrpcGatewayRouteMatchProperty: typing.Optional[list[CfnGatewayRouteDefGrpcgatewayroutematchpropertyParams]] = pydantic.Field(None, description='')
    GrpcGatewayRouteMetadataProperty: typing.Optional[list[CfnGatewayRouteDefGrpcgatewayroutemetadatapropertyParams]] = pydantic.Field(None, description='')
    GrpcGatewayRouteProperty: typing.Optional[list[CfnGatewayRouteDefGrpcgatewayroutepropertyParams]] = pydantic.Field(None, description='')
    GrpcGatewayRouteRewriteProperty: typing.Optional[list[CfnGatewayRouteDefGrpcgatewayrouterewritepropertyParams]] = pydantic.Field(None, description='')
    HttpGatewayRouteActionProperty: typing.Optional[list[CfnGatewayRouteDefHttpgatewayrouteactionpropertyParams]] = pydantic.Field(None, description='')
    HttpGatewayRouteHeaderMatchProperty: typing.Optional[list[CfnGatewayRouteDefHttpgatewayrouteheadermatchpropertyParams]] = pydantic.Field(None, description='')
    HttpGatewayRouteHeaderProperty: typing.Optional[list[CfnGatewayRouteDefHttpgatewayrouteheaderpropertyParams]] = pydantic.Field(None, description='')
    HttpGatewayRouteMatchProperty: typing.Optional[list[CfnGatewayRouteDefHttpgatewayroutematchpropertyParams]] = pydantic.Field(None, description='')
    HttpGatewayRoutePathRewriteProperty: typing.Optional[list[CfnGatewayRouteDefHttpgatewayroutepathrewritepropertyParams]] = pydantic.Field(None, description='')
    HttpGatewayRoutePrefixRewriteProperty: typing.Optional[list[CfnGatewayRouteDefHttpgatewayrouteprefixrewritepropertyParams]] = pydantic.Field(None, description='')
    HttpGatewayRouteProperty: typing.Optional[list[CfnGatewayRouteDefHttpgatewayroutepropertyParams]] = pydantic.Field(None, description='')
    HttpGatewayRouteRewriteProperty: typing.Optional[list[CfnGatewayRouteDefHttpgatewayrouterewritepropertyParams]] = pydantic.Field(None, description='')
    HttpPathMatchProperty: typing.Optional[list[CfnGatewayRouteDefHttppathmatchpropertyParams]] = pydantic.Field(None, description='')
    HttpQueryParameterMatchProperty: typing.Optional[list[CfnGatewayRouteDefHttpqueryparametermatchpropertyParams]] = pydantic.Field(None, description='')
    QueryParameterProperty: typing.Optional[list[CfnGatewayRouteDefQueryparameterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnGatewayRouteDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnGatewayRouteDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnGatewayRouteDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnGatewayRouteDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnGatewayRouteDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnGatewayRouteDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnGatewayRouteDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnGatewayRouteDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnGatewayRouteDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnGatewayRouteDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnGatewayRouteDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnGatewayRouteDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnGatewayRouteDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnGatewayRouteDefGatewayroutehostnamematchpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    suffix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefGatewayroutehostnamerewritepropertyParams(pydantic.BaseModel):
    default_target_hostname: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefGatewayroutemetadatamatchpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    prefix: typing.Optional[str] = pydantic.Field(None, description='')
    range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteRangeMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    regex: typing.Optional[str] = pydantic.Field(None, description='')
    suffix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefGatewayrouterangematchpropertyParams(pydantic.BaseModel):
    end: typing.Union[int, float] = pydantic.Field(..., description='')
    start: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnGatewayRouteDefGatewayroutespecpropertyParams(pydantic.BaseModel):
    grpc_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http2_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefGatewayroutetargetpropertyParams(pydantic.BaseModel):
    virtual_service: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteVirtualServicePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefGatewayroutevirtualservicepropertyParams(pydantic.BaseModel):
    virtual_service_name: str = pydantic.Field(..., description='')
    ...

class CfnGatewayRouteDefGrpcgatewayrouteactionpropertyParams(pydantic.BaseModel):
    target: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteTargetPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    rewrite: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRouteRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefGrpcgatewayroutematchpropertyParams(pydantic.BaseModel):
    hostname: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    metadata: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRouteMetadataPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    service_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefGrpcgatewayroutemetadatapropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    invert: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteMetadataMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefGrpcgatewayroutepropertyParams(pydantic.BaseModel):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GrpcGatewayRouteMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnGatewayRouteDefGrpcgatewayrouterewritepropertyParams(pydantic.BaseModel):
    hostname: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttpgatewayrouteactionpropertyParams(pydantic.BaseModel):
    target: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteTargetPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    rewrite: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttpgatewayrouteheadermatchpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    prefix: typing.Optional[str] = pydantic.Field(None, description='')
    range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteRangeMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    regex: typing.Optional[str] = pydantic.Field(None, description='')
    suffix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttpgatewayrouteheaderpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    invert: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteHeaderMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttpgatewayroutematchpropertyParams(pydantic.BaseModel):
    headers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteHeaderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    hostname: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    method: typing.Optional[str] = pydantic.Field(None, description='')
    path: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpPathMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    prefix: typing.Optional[str] = pydantic.Field(None, description='')
    query_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_QueryParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttpgatewayroutepathrewritepropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttpgatewayrouteprefixrewritepropertyParams(pydantic.BaseModel):
    default_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttpgatewayroutepropertyParams(pydantic.BaseModel):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRouteMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnGatewayRouteDefHttpgatewayrouterewritepropertyParams(pydantic.BaseModel):
    hostname: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteHostnameRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    path: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePathRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    prefix: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpGatewayRoutePrefixRewritePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttppathmatchpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    regex: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefHttpqueryparametermatchpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefQueryparameterpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_HttpQueryParameterMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnGatewayRouteDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGatewayRouteDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGatewayRouteDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGatewayRouteDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGatewayRouteDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGatewayRouteDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGatewayRouteDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGatewayRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGatewayRouteDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGatewayRouteDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGatewayRouteDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnGatewayRouteDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGatewayRouteDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGatewayRouteDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.CfnMesh
class CfnMeshDef(BaseCfnResource):
    mesh_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the service mesh.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnMesh_MeshSpecPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The service mesh specification to apply.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['EgressFilterProperty', 'MeshServiceDiscoveryProperty', 'MeshSpecProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnMesh'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnMeshDefConfig] = pydantic.Field(None)


class CfnMeshDefConfig(pydantic.BaseModel):
    EgressFilterProperty: typing.Optional[list[CfnMeshDefEgressfilterpropertyParams]] = pydantic.Field(None, description='')
    MeshServiceDiscoveryProperty: typing.Optional[list[CfnMeshDefMeshservicediscoverypropertyParams]] = pydantic.Field(None, description='')
    MeshSpecProperty: typing.Optional[list[CfnMeshDefMeshspecpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnMeshDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnMeshDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnMeshDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnMeshDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnMeshDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnMeshDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnMeshDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnMeshDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnMeshDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnMeshDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnMeshDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnMeshDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnMeshDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnMeshDefEgressfilterpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    ...

class CfnMeshDefMeshservicediscoverypropertyParams(pydantic.BaseModel):
    ip_preference: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMeshDefMeshspecpropertyParams(pydantic.BaseModel):
    egress_filter: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnMesh_EgressFilterPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    service_discovery: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnMesh_MeshServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnMeshDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMeshDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMeshDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMeshDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMeshDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMeshDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMeshDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMeshDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMeshDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMeshDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMeshDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnMeshDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMeshDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMeshDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.CfnRoute
class CfnRouteDef(BaseCfnResource):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh to create the route in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_RouteSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The route specification to apply.\n')
    virtual_router_name: str = pydantic.Field(..., description='The name of the virtual router in which to create the route. If the virtual router is in a shared mesh, then you must be the owner of the virtual router resource.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n')
    route_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the route.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'virtual_router_name', 'mesh_owner', 'route_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['DurationProperty', 'GrpcRetryPolicyProperty', 'GrpcRouteActionProperty', 'GrpcRouteMatchProperty', 'GrpcRouteMetadataMatchMethodProperty', 'GrpcRouteMetadataProperty', 'GrpcRouteProperty', 'GrpcTimeoutProperty', 'HeaderMatchMethodProperty', 'HttpPathMatchProperty', 'HttpQueryParameterMatchProperty', 'HttpRetryPolicyProperty', 'HttpRouteActionProperty', 'HttpRouteHeaderProperty', 'HttpRouteMatchProperty', 'HttpRouteProperty', 'HttpTimeoutProperty', 'MatchRangeProperty', 'QueryParameterProperty', 'RouteSpecProperty', 'TcpRouteActionProperty', 'TcpRouteMatchProperty', 'TcpRouteProperty', 'TcpTimeoutProperty', 'WeightedTargetProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRouteDefConfig] = pydantic.Field(None)


class CfnRouteDefConfig(pydantic.BaseModel):
    DurationProperty: typing.Optional[list[CfnRouteDefDurationpropertyParams]] = pydantic.Field(None, description='')
    GrpcRetryPolicyProperty: typing.Optional[list[CfnRouteDefGrpcretrypolicypropertyParams]] = pydantic.Field(None, description='')
    GrpcRouteActionProperty: typing.Optional[list[CfnRouteDefGrpcrouteactionpropertyParams]] = pydantic.Field(None, description='')
    GrpcRouteMatchProperty: typing.Optional[list[CfnRouteDefGrpcroutematchpropertyParams]] = pydantic.Field(None, description='')
    GrpcRouteMetadataMatchMethodProperty: typing.Optional[list[CfnRouteDefGrpcroutemetadatamatchmethodpropertyParams]] = pydantic.Field(None, description='')
    GrpcRouteMetadataProperty: typing.Optional[list[CfnRouteDefGrpcroutemetadatapropertyParams]] = pydantic.Field(None, description='')
    GrpcRouteProperty: typing.Optional[list[CfnRouteDefGrpcroutepropertyParams]] = pydantic.Field(None, description='')
    GrpcTimeoutProperty: typing.Optional[list[CfnRouteDefGrpctimeoutpropertyParams]] = pydantic.Field(None, description='')
    HeaderMatchMethodProperty: typing.Optional[list[CfnRouteDefHeadermatchmethodpropertyParams]] = pydantic.Field(None, description='')
    HttpPathMatchProperty: typing.Optional[list[CfnRouteDefHttppathmatchpropertyParams]] = pydantic.Field(None, description='')
    HttpQueryParameterMatchProperty: typing.Optional[list[CfnRouteDefHttpqueryparametermatchpropertyParams]] = pydantic.Field(None, description='')
    HttpRetryPolicyProperty: typing.Optional[list[CfnRouteDefHttpretrypolicypropertyParams]] = pydantic.Field(None, description='')
    HttpRouteActionProperty: typing.Optional[list[CfnRouteDefHttprouteactionpropertyParams]] = pydantic.Field(None, description='')
    HttpRouteHeaderProperty: typing.Optional[list[CfnRouteDefHttprouteheaderpropertyParams]] = pydantic.Field(None, description='')
    HttpRouteMatchProperty: typing.Optional[list[CfnRouteDefHttproutematchpropertyParams]] = pydantic.Field(None, description='')
    HttpRouteProperty: typing.Optional[list[CfnRouteDefHttproutepropertyParams]] = pydantic.Field(None, description='')
    HttpTimeoutProperty: typing.Optional[list[CfnRouteDefHttptimeoutpropertyParams]] = pydantic.Field(None, description='')
    MatchRangeProperty: typing.Optional[list[CfnRouteDefMatchrangepropertyParams]] = pydantic.Field(None, description='')
    QueryParameterProperty: typing.Optional[list[CfnRouteDefQueryparameterpropertyParams]] = pydantic.Field(None, description='')
    RouteSpecProperty: typing.Optional[list[CfnRouteDefRoutespecpropertyParams]] = pydantic.Field(None, description='')
    TcpRouteActionProperty: typing.Optional[list[CfnRouteDefTcprouteactionpropertyParams]] = pydantic.Field(None, description='')
    TcpRouteMatchProperty: typing.Optional[list[CfnRouteDefTcproutematchpropertyParams]] = pydantic.Field(None, description='')
    TcpRouteProperty: typing.Optional[list[CfnRouteDefTcproutepropertyParams]] = pydantic.Field(None, description='')
    TcpTimeoutProperty: typing.Optional[list[CfnRouteDefTcptimeoutpropertyParams]] = pydantic.Field(None, description='')
    WeightedTargetProperty: typing.Optional[list[CfnRouteDefWeightedtargetpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnRouteDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRouteDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRouteDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRouteDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRouteDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRouteDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRouteDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRouteDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRouteDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRouteDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRouteDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRouteDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRouteDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRouteDefDurationpropertyParams(pydantic.BaseModel):
    unit: str = pydantic.Field(..., description='')
    value: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnRouteDefGrpcretrypolicypropertyParams(pydantic.BaseModel):
    max_retries: typing.Union[int, float] = pydantic.Field(..., description='')
    per_retry_timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    grpc_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    http_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tcp_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnRouteDefGrpcrouteactionpropertyParams(pydantic.BaseModel):
    weighted_targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_WeightedTargetPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnRouteDefGrpcroutematchpropertyParams(pydantic.BaseModel):
    metadata: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRouteMetadataPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    method_name: typing.Optional[str] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    service_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRouteDefGrpcroutemetadatamatchmethodpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    prefix: typing.Optional[str] = pydantic.Field(None, description='')
    range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_MatchRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    regex: typing.Optional[str] = pydantic.Field(None, description='')
    suffix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRouteDefGrpcroutemetadatapropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    invert: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRouteMetadataMatchMethodPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefGrpcroutepropertyParams(pydantic.BaseModel):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRouteMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    retry_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefGrpctimeoutpropertyParams(pydantic.BaseModel):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    per_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefHeadermatchmethodpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    prefix: typing.Optional[str] = pydantic.Field(None, description='')
    range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_MatchRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    regex: typing.Optional[str] = pydantic.Field(None, description='')
    suffix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRouteDefHttppathmatchpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    regex: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRouteDefHttpqueryparametermatchpropertyParams(pydantic.BaseModel):
    exact: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRouteDefHttpretrypolicypropertyParams(pydantic.BaseModel):
    max_retries: typing.Union[int, float] = pydantic.Field(..., description='')
    per_retry_timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    http_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tcp_retry_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnRouteDefHttprouteactionpropertyParams(pydantic.BaseModel):
    weighted_targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_WeightedTargetPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnRouteDefHttprouteheaderpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    invert: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HeaderMatchMethodPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefHttproutematchpropertyParams(pydantic.BaseModel):
    headers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRouteHeaderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    method: typing.Optional[str] = pydantic.Field(None, description='')
    path: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpPathMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    prefix: typing.Optional[str] = pydantic.Field(None, description='')
    query_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_QueryParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    scheme: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRouteDefHttproutepropertyParams(pydantic.BaseModel):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRouteMatchPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    retry_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefHttptimeoutpropertyParams(pydantic.BaseModel):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    per_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefMatchrangepropertyParams(pydantic.BaseModel):
    end: typing.Union[int, float] = pydantic.Field(..., description='')
    start: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnRouteDefQueryparameterpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpQueryParameterMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefRoutespecpropertyParams(pydantic.BaseModel):
    grpc_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_GrpcRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http2_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_HttpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='')
    tcp_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_TcpRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefTcprouteactionpropertyParams(pydantic.BaseModel):
    weighted_targets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_WeightedTargetPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnRouteDefTcproutematchpropertyParams(pydantic.BaseModel):
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefTcproutepropertyParams(pydantic.BaseModel):
    action: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_TcpRouteActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_TcpRouteMatchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_TcpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefTcptimeoutpropertyParams(pydantic.BaseModel):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefWeightedtargetpropertyParams(pydantic.BaseModel):
    virtual_node: str = pydantic.Field(..., description='')
    weight: typing.Union[int, float] = pydantic.Field(..., description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnRouteDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRouteDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRouteDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRouteDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRouteDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRouteDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRouteDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnRouteDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRouteDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGateway
class CfnVirtualGatewayDef(BaseCfnResource):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh that the virtual gateway resides in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewaySpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The specifications of the virtual gateway.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description="The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n')
    virtual_gateway_name: typing.Optional[str] = pydantic.Field(None, description='The name of the virtual gateway.')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'mesh_owner', 'tags', 'virtual_gateway_name']
    _method_names: typing.ClassVar[list[str]] = ['JsonFormatRefProperty', 'LoggingFormatProperty', 'SubjectAlternativeNameMatchersProperty', 'SubjectAlternativeNamesProperty', 'VirtualGatewayAccessLogProperty', 'VirtualGatewayBackendDefaultsProperty', 'VirtualGatewayClientPolicyProperty', 'VirtualGatewayClientPolicyTlsProperty', 'VirtualGatewayClientTlsCertificateProperty', 'VirtualGatewayConnectionPoolProperty', 'VirtualGatewayFileAccessLogProperty', 'VirtualGatewayGrpcConnectionPoolProperty', 'VirtualGatewayHealthCheckPolicyProperty', 'VirtualGatewayHttp2ConnectionPoolProperty', 'VirtualGatewayHttpConnectionPoolProperty', 'VirtualGatewayListenerProperty', 'VirtualGatewayListenerTlsAcmCertificateProperty', 'VirtualGatewayListenerTlsCertificateProperty', 'VirtualGatewayListenerTlsFileCertificateProperty', 'VirtualGatewayListenerTlsProperty', 'VirtualGatewayListenerTlsSdsCertificateProperty', 'VirtualGatewayListenerTlsValidationContextProperty', 'VirtualGatewayListenerTlsValidationContextTrustProperty', 'VirtualGatewayLoggingProperty', 'VirtualGatewayPortMappingProperty', 'VirtualGatewaySpecProperty', 'VirtualGatewayTlsValidationContextAcmTrustProperty', 'VirtualGatewayTlsValidationContextFileTrustProperty', 'VirtualGatewayTlsValidationContextProperty', 'VirtualGatewayTlsValidationContextSdsTrustProperty', 'VirtualGatewayTlsValidationContextTrustProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVirtualGatewayDefConfig] = pydantic.Field(None)


class CfnVirtualGatewayDefConfig(pydantic.BaseModel):
    JsonFormatRefProperty: typing.Optional[list[CfnVirtualGatewayDefJsonformatrefpropertyParams]] = pydantic.Field(None, description='')
    LoggingFormatProperty: typing.Optional[list[CfnVirtualGatewayDefLoggingformatpropertyParams]] = pydantic.Field(None, description='')
    SubjectAlternativeNameMatchersProperty: typing.Optional[list[CfnVirtualGatewayDefSubjectalternativenamematcherspropertyParams]] = pydantic.Field(None, description='')
    SubjectAlternativeNamesProperty: typing.Optional[list[CfnVirtualGatewayDefSubjectalternativenamespropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayAccessLogProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayaccesslogpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayBackendDefaultsProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaybackenddefaultspropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayClientPolicyProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayclientpolicypropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayClientPolicyTlsProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayclientpolicytlspropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayClientTlsCertificateProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayclienttlscertificatepropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayConnectionPoolProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayconnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayFileAccessLogProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayfileaccesslogpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayGrpcConnectionPoolProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaygrpcconnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayHealthCheckPolicyProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayhealthcheckpolicypropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayHttp2ConnectionPoolProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayhttp2ConnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayHttpConnectionPoolProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayhttpconnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayListenerProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaylistenerpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayListenerTlsAcmCertificateProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaylistenertlsacmcertificatepropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayListenerTlsCertificateProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaylistenertlscertificatepropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayListenerTlsFileCertificateProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaylistenertlsfilecertificatepropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayListenerTlsProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaylistenertlspropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayListenerTlsSdsCertificateProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaylistenertlssdscertificatepropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayListenerTlsValidationContextProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaylistenertlsvalidationcontextpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayListenerTlsValidationContextTrustProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaylistenertlsvalidationcontexttrustpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayLoggingProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayloggingpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayPortMappingProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayportmappingpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewaySpecProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewayspecpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayTlsValidationContextAcmTrustProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontextacmtrustpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayTlsValidationContextFileTrustProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontextfiletrustpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayTlsValidationContextProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontextpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayTlsValidationContextSdsTrustProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontextsdstrustpropertyParams]] = pydantic.Field(None, description='')
    VirtualGatewayTlsValidationContextTrustProperty: typing.Optional[list[CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontexttrustpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVirtualGatewayDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVirtualGatewayDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVirtualGatewayDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVirtualGatewayDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVirtualGatewayDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVirtualGatewayDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVirtualGatewayDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVirtualGatewayDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVirtualGatewayDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVirtualGatewayDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVirtualGatewayDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVirtualGatewayDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVirtualGatewayDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVirtualGatewayDefJsonformatrefpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefLoggingformatpropertyParams(pydantic.BaseModel):
    json_: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_JsonFormatRefPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='', alias='json')
    text: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefSubjectalternativenamematcherspropertyParams(pydantic.BaseModel):
    exact: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefSubjectalternativenamespropertyParams(pydantic.BaseModel):
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_SubjectAlternativeNameMatchersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayaccesslogpropertyParams(pydantic.BaseModel):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayFileAccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaybackenddefaultspropertyParams(pydantic.BaseModel):
    client_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayClientPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayclientpolicypropertyParams(pydantic.BaseModel):
    tls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayClientPolicyTlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayclientpolicytlspropertyParams(pydantic.BaseModel):
    validation: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    certificate: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayClientTlsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    enforce: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ports: typing.Union[typing.Sequence[typing.Union[int, float]], typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayclienttlscertificatepropertyParams(pydantic.BaseModel):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsFileCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsSdsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayconnectionpoolpropertyParams(pydantic.BaseModel):
    grpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayGrpcConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayHttpConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http2: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayHttp2ConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayfileaccesslogpropertyParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='')
    format: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_LoggingFormatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaygrpcconnectionpoolpropertyParams(pydantic.BaseModel):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayhealthcheckpolicypropertyParams(pydantic.BaseModel):
    healthy_threshold: typing.Union[int, float] = pydantic.Field(..., description='')
    interval_millis: typing.Union[int, float] = pydantic.Field(..., description='')
    protocol: str = pydantic.Field(..., description='')
    timeout_millis: typing.Union[int, float] = pydantic.Field(..., description='')
    unhealthy_threshold: typing.Union[int, float] = pydantic.Field(..., description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayhttp2ConnectionpoolpropertyParams(pydantic.BaseModel):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayhttpconnectionpoolpropertyParams(pydantic.BaseModel):
    max_connections: typing.Union[int, float] = pydantic.Field(..., description='')
    max_pending_requests: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaylistenerpropertyParams(pydantic.BaseModel):
    port_mapping: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayPortMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    connection_pool: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    health_check: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayHealthCheckPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    tls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaylistenertlsacmcertificatepropertyParams(pydantic.BaseModel):
    certificate_arn: str = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaylistenertlscertificatepropertyParams(pydantic.BaseModel):
    acm: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsAcmCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsFileCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsSdsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaylistenertlsfilecertificatepropertyParams(pydantic.BaseModel):
    certificate_chain: str = pydantic.Field(..., description='')
    private_key: str = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaylistenertlspropertyParams(pydantic.BaseModel):
    certificate: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsCertificatePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    mode: str = pydantic.Field(..., description='')
    validation: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaylistenertlssdscertificatepropertyParams(pydantic.BaseModel):
    secret_name: str = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaylistenertlsvalidationcontextpropertyParams(pydantic.BaseModel):
    trust: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    subject_alternative_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_SubjectAlternativeNamesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaylistenertlsvalidationcontexttrustpropertyParams(pydantic.BaseModel):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextFileTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextSdsTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayloggingpropertyParams(pydantic.BaseModel):
    access_log: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayAccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayportmappingpropertyParams(pydantic.BaseModel):
    port: typing.Union[int, float] = pydantic.Field(..., description='')
    protocol: str = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewayspecpropertyParams(pydantic.BaseModel):
    listeners: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayListenerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    backend_defaults: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayBackendDefaultsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    logging: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayLoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontextacmtrustpropertyParams(pydantic.BaseModel):
    certificate_authority_arns: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontextfiletrustpropertyParams(pydantic.BaseModel):
    certificate_chain: str = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontextpropertyParams(pydantic.BaseModel):
    trust: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    subject_alternative_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_SubjectAlternativeNamesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontextsdstrustpropertyParams(pydantic.BaseModel):
    secret_name: str = pydantic.Field(..., description='')
    ...

class CfnVirtualGatewayDefVirtualgatewaytlsvalidationcontexttrustpropertyParams(pydantic.BaseModel):
    acm: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextAcmTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextFileTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewayTlsValidationContextSdsTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualGatewayDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVirtualGatewayDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualGatewayDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVirtualGatewayDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualGatewayDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVirtualGatewayDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVirtualGatewayDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVirtualGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVirtualGatewayDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVirtualGatewayDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualGatewayDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVirtualGatewayDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVirtualGatewayDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualGatewayDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNode
class CfnVirtualNodeDef(BaseCfnResource):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh to create the virtual node in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The virtual node specification to apply.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n')
    virtual_node_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the virtual node.')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'mesh_owner', 'tags', 'virtual_node_name']
    _method_names: typing.ClassVar[list[str]] = ['AccessLogProperty', 'AwsCloudMapInstanceAttributeProperty', 'AwsCloudMapServiceDiscoveryProperty', 'BackendDefaultsProperty', 'BackendProperty', 'ClientPolicyProperty', 'ClientPolicyTlsProperty', 'ClientTlsCertificateProperty', 'DnsServiceDiscoveryProperty', 'DurationProperty', 'FileAccessLogProperty', 'GrpcTimeoutProperty', 'HealthCheckProperty', 'HttpTimeoutProperty', 'JsonFormatRefProperty', 'ListenerProperty', 'ListenerTimeoutProperty', 'ListenerTlsAcmCertificateProperty', 'ListenerTlsCertificateProperty', 'ListenerTlsFileCertificateProperty', 'ListenerTlsProperty', 'ListenerTlsSdsCertificateProperty', 'ListenerTlsValidationContextProperty', 'ListenerTlsValidationContextTrustProperty', 'LoggingFormatProperty', 'LoggingProperty', 'OutlierDetectionProperty', 'PortMappingProperty', 'ServiceDiscoveryProperty', 'SubjectAlternativeNameMatchersProperty', 'SubjectAlternativeNamesProperty', 'TcpTimeoutProperty', 'TlsValidationContextAcmTrustProperty', 'TlsValidationContextFileTrustProperty', 'TlsValidationContextProperty', 'TlsValidationContextSdsTrustProperty', 'TlsValidationContextTrustProperty', 'VirtualNodeConnectionPoolProperty', 'VirtualNodeGrpcConnectionPoolProperty', 'VirtualNodeHttp2ConnectionPoolProperty', 'VirtualNodeHttpConnectionPoolProperty', 'VirtualNodeSpecProperty', 'VirtualNodeTcpConnectionPoolProperty', 'VirtualServiceBackendProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNode'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVirtualNodeDefConfig] = pydantic.Field(None)


class CfnVirtualNodeDefConfig(pydantic.BaseModel):
    AccessLogProperty: typing.Optional[list[CfnVirtualNodeDefAccesslogpropertyParams]] = pydantic.Field(None, description='')
    AwsCloudMapInstanceAttributeProperty: typing.Optional[list[CfnVirtualNodeDefAwscloudmapinstanceattributepropertyParams]] = pydantic.Field(None, description='')
    AwsCloudMapServiceDiscoveryProperty: typing.Optional[list[CfnVirtualNodeDefAwscloudmapservicediscoverypropertyParams]] = pydantic.Field(None, description='')
    BackendDefaultsProperty: typing.Optional[list[CfnVirtualNodeDefBackenddefaultspropertyParams]] = pydantic.Field(None, description='')
    BackendProperty: typing.Optional[list[CfnVirtualNodeDefBackendpropertyParams]] = pydantic.Field(None, description='')
    ClientPolicyProperty: typing.Optional[list[CfnVirtualNodeDefClientpolicypropertyParams]] = pydantic.Field(None, description='')
    ClientPolicyTlsProperty: typing.Optional[list[CfnVirtualNodeDefClientpolicytlspropertyParams]] = pydantic.Field(None, description='')
    ClientTlsCertificateProperty: typing.Optional[list[CfnVirtualNodeDefClienttlscertificatepropertyParams]] = pydantic.Field(None, description='')
    DnsServiceDiscoveryProperty: typing.Optional[list[CfnVirtualNodeDefDnsservicediscoverypropertyParams]] = pydantic.Field(None, description='')
    DurationProperty: typing.Optional[list[CfnVirtualNodeDefDurationpropertyParams]] = pydantic.Field(None, description='')
    FileAccessLogProperty: typing.Optional[list[CfnVirtualNodeDefFileaccesslogpropertyParams]] = pydantic.Field(None, description='')
    GrpcTimeoutProperty: typing.Optional[list[CfnVirtualNodeDefGrpctimeoutpropertyParams]] = pydantic.Field(None, description='')
    HealthCheckProperty: typing.Optional[list[CfnVirtualNodeDefHealthcheckpropertyParams]] = pydantic.Field(None, description='')
    HttpTimeoutProperty: typing.Optional[list[CfnVirtualNodeDefHttptimeoutpropertyParams]] = pydantic.Field(None, description='')
    JsonFormatRefProperty: typing.Optional[list[CfnVirtualNodeDefJsonformatrefpropertyParams]] = pydantic.Field(None, description='')
    ListenerProperty: typing.Optional[list[CfnVirtualNodeDefListenerpropertyParams]] = pydantic.Field(None, description='')
    ListenerTimeoutProperty: typing.Optional[list[CfnVirtualNodeDefListenertimeoutpropertyParams]] = pydantic.Field(None, description='')
    ListenerTlsAcmCertificateProperty: typing.Optional[list[CfnVirtualNodeDefListenertlsacmcertificatepropertyParams]] = pydantic.Field(None, description='')
    ListenerTlsCertificateProperty: typing.Optional[list[CfnVirtualNodeDefListenertlscertificatepropertyParams]] = pydantic.Field(None, description='')
    ListenerTlsFileCertificateProperty: typing.Optional[list[CfnVirtualNodeDefListenertlsfilecertificatepropertyParams]] = pydantic.Field(None, description='')
    ListenerTlsProperty: typing.Optional[list[CfnVirtualNodeDefListenertlspropertyParams]] = pydantic.Field(None, description='')
    ListenerTlsSdsCertificateProperty: typing.Optional[list[CfnVirtualNodeDefListenertlssdscertificatepropertyParams]] = pydantic.Field(None, description='')
    ListenerTlsValidationContextProperty: typing.Optional[list[CfnVirtualNodeDefListenertlsvalidationcontextpropertyParams]] = pydantic.Field(None, description='')
    ListenerTlsValidationContextTrustProperty: typing.Optional[list[CfnVirtualNodeDefListenertlsvalidationcontexttrustpropertyParams]] = pydantic.Field(None, description='')
    LoggingFormatProperty: typing.Optional[list[CfnVirtualNodeDefLoggingformatpropertyParams]] = pydantic.Field(None, description='')
    LoggingProperty: typing.Optional[list[CfnVirtualNodeDefLoggingpropertyParams]] = pydantic.Field(None, description='')
    OutlierDetectionProperty: typing.Optional[list[CfnVirtualNodeDefOutlierdetectionpropertyParams]] = pydantic.Field(None, description='')
    PortMappingProperty: typing.Optional[list[CfnVirtualNodeDefPortmappingpropertyParams]] = pydantic.Field(None, description='')
    ServiceDiscoveryProperty: typing.Optional[list[CfnVirtualNodeDefServicediscoverypropertyParams]] = pydantic.Field(None, description='')
    SubjectAlternativeNameMatchersProperty: typing.Optional[list[CfnVirtualNodeDefSubjectalternativenamematcherspropertyParams]] = pydantic.Field(None, description='')
    SubjectAlternativeNamesProperty: typing.Optional[list[CfnVirtualNodeDefSubjectalternativenamespropertyParams]] = pydantic.Field(None, description='')
    TcpTimeoutProperty: typing.Optional[list[CfnVirtualNodeDefTcptimeoutpropertyParams]] = pydantic.Field(None, description='')
    TlsValidationContextAcmTrustProperty: typing.Optional[list[CfnVirtualNodeDefTlsvalidationcontextacmtrustpropertyParams]] = pydantic.Field(None, description='')
    TlsValidationContextFileTrustProperty: typing.Optional[list[CfnVirtualNodeDefTlsvalidationcontextfiletrustpropertyParams]] = pydantic.Field(None, description='')
    TlsValidationContextProperty: typing.Optional[list[CfnVirtualNodeDefTlsvalidationcontextpropertyParams]] = pydantic.Field(None, description='')
    TlsValidationContextSdsTrustProperty: typing.Optional[list[CfnVirtualNodeDefTlsvalidationcontextsdstrustpropertyParams]] = pydantic.Field(None, description='')
    TlsValidationContextTrustProperty: typing.Optional[list[CfnVirtualNodeDefTlsvalidationcontexttrustpropertyParams]] = pydantic.Field(None, description='')
    VirtualNodeConnectionPoolProperty: typing.Optional[list[CfnVirtualNodeDefVirtualnodeconnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualNodeGrpcConnectionPoolProperty: typing.Optional[list[CfnVirtualNodeDefVirtualnodegrpcconnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualNodeHttp2ConnectionPoolProperty: typing.Optional[list[CfnVirtualNodeDefVirtualnodehttp2ConnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualNodeHttpConnectionPoolProperty: typing.Optional[list[CfnVirtualNodeDefVirtualnodehttpconnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualNodeSpecProperty: typing.Optional[list[CfnVirtualNodeDefVirtualnodespecpropertyParams]] = pydantic.Field(None, description='')
    VirtualNodeTcpConnectionPoolProperty: typing.Optional[list[CfnVirtualNodeDefVirtualnodetcpconnectionpoolpropertyParams]] = pydantic.Field(None, description='')
    VirtualServiceBackendProperty: typing.Optional[list[CfnVirtualNodeDefVirtualservicebackendpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVirtualNodeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVirtualNodeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVirtualNodeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVirtualNodeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVirtualNodeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVirtualNodeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVirtualNodeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVirtualNodeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVirtualNodeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVirtualNodeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVirtualNodeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVirtualNodeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVirtualNodeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVirtualNodeDefAccesslogpropertyParams(pydantic.BaseModel):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_FileAccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefAwscloudmapinstanceattributepropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefAwscloudmapservicediscoverypropertyParams(pydantic.BaseModel):
    namespace_name: str = pydantic.Field(..., description='')
    service_name: str = pydantic.Field(..., description='')
    attributes: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_AwsCloudMapInstanceAttributePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ip_preference: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefBackenddefaultspropertyParams(pydantic.BaseModel):
    client_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ClientPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefBackendpropertyParams(pydantic.BaseModel):
    virtual_service: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualServiceBackendPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefClientpolicypropertyParams(pydantic.BaseModel):
    tls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ClientPolicyTlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefClientpolicytlspropertyParams(pydantic.BaseModel):
    validation: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    certificate: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ClientTlsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    enforce: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ports: typing.Union[typing.Sequence[typing.Union[int, float]], typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefClienttlscertificatepropertyParams(pydantic.BaseModel):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsFileCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsSdsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefDnsservicediscoverypropertyParams(pydantic.BaseModel):
    hostname: str = pydantic.Field(..., description='')
    ip_preference: typing.Optional[str] = pydantic.Field(None, description='')
    response_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefDurationpropertyParams(pydantic.BaseModel):
    unit: str = pydantic.Field(..., description='')
    value: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefFileaccesslogpropertyParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='')
    format: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_LoggingFormatPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefGrpctimeoutpropertyParams(pydantic.BaseModel):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    per_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefHealthcheckpropertyParams(pydantic.BaseModel):
    healthy_threshold: typing.Union[int, float] = pydantic.Field(..., description='')
    interval_millis: typing.Union[int, float] = pydantic.Field(..., description='')
    protocol: str = pydantic.Field(..., description='')
    timeout_millis: typing.Union[int, float] = pydantic.Field(..., description='')
    unhealthy_threshold: typing.Union[int, float] = pydantic.Field(..., description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefHttptimeoutpropertyParams(pydantic.BaseModel):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    per_request: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefJsonformatrefpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefListenerpropertyParams(pydantic.BaseModel):
    port_mapping: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_PortMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    connection_pool: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    health_check: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_HealthCheckPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    outlier_detection: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_OutlierDetectionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    timeout: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    tls: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefListenertimeoutpropertyParams(pydantic.BaseModel):
    grpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_GrpcTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_HttpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http2: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_HttpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    tcp: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TcpTimeoutPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefListenertlsacmcertificatepropertyParams(pydantic.BaseModel):
    certificate_arn: str = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefListenertlscertificatepropertyParams(pydantic.BaseModel):
    acm: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsAcmCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsFileCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsSdsCertificatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefListenertlsfilecertificatepropertyParams(pydantic.BaseModel):
    certificate_chain: str = pydantic.Field(..., description='')
    private_key: str = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefListenertlspropertyParams(pydantic.BaseModel):
    certificate: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsCertificatePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    mode: str = pydantic.Field(..., description='')
    validation: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsValidationContextPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefListenertlssdscertificatepropertyParams(pydantic.BaseModel):
    secret_name: str = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefListenertlsvalidationcontextpropertyParams(pydantic.BaseModel):
    trust: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerTlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    subject_alternative_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_SubjectAlternativeNamesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefListenertlsvalidationcontexttrustpropertyParams(pydantic.BaseModel):
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextFileTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextSdsTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefLoggingformatpropertyParams(pydantic.BaseModel):
    json_: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_JsonFormatRefPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='', alias='json')
    text: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefLoggingpropertyParams(pydantic.BaseModel):
    access_log: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_AccessLogPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefOutlierdetectionpropertyParams(pydantic.BaseModel):
    base_ejection_duration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    interval: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    max_ejection_percent: typing.Union[int, float] = pydantic.Field(..., description='')
    max_server_errors: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefPortmappingpropertyParams(pydantic.BaseModel):
    port: typing.Union[int, float] = pydantic.Field(..., description='')
    protocol: str = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefServicediscoverypropertyParams(pydantic.BaseModel):
    aws_cloud_map: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_AwsCloudMapServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    dns: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DnsServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefSubjectalternativenamematcherspropertyParams(pydantic.BaseModel):
    exact: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefSubjectalternativenamespropertyParams(pydantic.BaseModel):
    match: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_SubjectAlternativeNameMatchersPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefTcptimeoutpropertyParams(pydantic.BaseModel):
    idle: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_DurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefTlsvalidationcontextacmtrustpropertyParams(pydantic.BaseModel):
    certificate_authority_arns: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefTlsvalidationcontextfiletrustpropertyParams(pydantic.BaseModel):
    certificate_chain: str = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefTlsvalidationcontextpropertyParams(pydantic.BaseModel):
    trust: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextTrustPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    subject_alternative_names: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_SubjectAlternativeNamesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefTlsvalidationcontextsdstrustpropertyParams(pydantic.BaseModel):
    secret_name: str = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefTlsvalidationcontexttrustpropertyParams(pydantic.BaseModel):
    acm: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextAcmTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    file: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextFileTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sds: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_TlsValidationContextSdsTrustPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefVirtualnodeconnectionpoolpropertyParams(pydantic.BaseModel):
    grpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeGrpcConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeHttpConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http2: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeHttp2ConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    tcp: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeTcpConnectionPoolPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefVirtualnodegrpcconnectionpoolpropertyParams(pydantic.BaseModel):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefVirtualnodehttp2ConnectionpoolpropertyParams(pydantic.BaseModel):
    max_requests: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefVirtualnodehttpconnectionpoolpropertyParams(pydantic.BaseModel):
    max_connections: typing.Union[int, float] = pydantic.Field(..., description='')
    max_pending_requests: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefVirtualnodespecpropertyParams(pydantic.BaseModel):
    backend_defaults: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_BackendDefaultsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    backends: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_BackendPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    listeners: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ListenerPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    logging: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_LoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    service_discovery: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ServiceDiscoveryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefVirtualnodetcpconnectionpoolpropertyParams(pydantic.BaseModel):
    max_connections: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnVirtualNodeDefVirtualservicebackendpropertyParams(pydantic.BaseModel):
    virtual_service_name: str = pydantic.Field(..., description='')
    client_policy: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_ClientPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualNodeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVirtualNodeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualNodeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVirtualNodeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualNodeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVirtualNodeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVirtualNodeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVirtualNodeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVirtualNodeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVirtualNodeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualNodeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVirtualNodeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVirtualNodeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualNodeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualRouter
class CfnVirtualRouterDef(BaseCfnResource):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh to create the virtual router in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualRouter_VirtualRouterSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The virtual router specification to apply.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n')
    virtual_router_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the virtual router.')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'mesh_owner', 'tags', 'virtual_router_name']
    _method_names: typing.ClassVar[list[str]] = ['PortMappingProperty', 'VirtualRouterListenerProperty', 'VirtualRouterSpecProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualRouter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVirtualRouterDefConfig] = pydantic.Field(None)


class CfnVirtualRouterDefConfig(pydantic.BaseModel):
    PortMappingProperty: typing.Optional[list[CfnVirtualRouterDefPortmappingpropertyParams]] = pydantic.Field(None, description='')
    VirtualRouterListenerProperty: typing.Optional[list[CfnVirtualRouterDefVirtualrouterlistenerpropertyParams]] = pydantic.Field(None, description='')
    VirtualRouterSpecProperty: typing.Optional[list[CfnVirtualRouterDefVirtualrouterspecpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVirtualRouterDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVirtualRouterDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVirtualRouterDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVirtualRouterDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVirtualRouterDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVirtualRouterDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVirtualRouterDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVirtualRouterDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVirtualRouterDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVirtualRouterDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVirtualRouterDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVirtualRouterDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVirtualRouterDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVirtualRouterDefPortmappingpropertyParams(pydantic.BaseModel):
    port: typing.Union[int, float] = pydantic.Field(..., description='')
    protocol: str = pydantic.Field(..., description='')
    ...

class CfnVirtualRouterDefVirtualrouterlistenerpropertyParams(pydantic.BaseModel):
    port_mapping: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualRouter_PortMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnVirtualRouterDefVirtualrouterspecpropertyParams(pydantic.BaseModel):
    listeners: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualRouter_VirtualRouterListenerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnVirtualRouterDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVirtualRouterDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualRouterDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVirtualRouterDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualRouterDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVirtualRouterDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVirtualRouterDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVirtualRouterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVirtualRouterDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVirtualRouterDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualRouterDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVirtualRouterDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVirtualRouterDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualRouterDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualService
class CfnVirtualServiceDef(BaseCfnResource):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh to create the virtual service in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualService_VirtualServiceSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The virtual service specification to apply.\n')
    virtual_service_name: str = pydantic.Field(..., description='The name to use for the virtual service.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'virtual_service_name', 'mesh_owner', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['VirtualNodeServiceProviderProperty', 'VirtualRouterServiceProviderProperty', 'VirtualServiceProviderProperty', 'VirtualServiceSpecProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVirtualServiceDefConfig] = pydantic.Field(None)


class CfnVirtualServiceDefConfig(pydantic.BaseModel):
    VirtualNodeServiceProviderProperty: typing.Optional[list[CfnVirtualServiceDefVirtualnodeserviceproviderpropertyParams]] = pydantic.Field(None, description='')
    VirtualRouterServiceProviderProperty: typing.Optional[list[CfnVirtualServiceDefVirtualrouterserviceproviderpropertyParams]] = pydantic.Field(None, description='')
    VirtualServiceProviderProperty: typing.Optional[list[CfnVirtualServiceDefVirtualserviceproviderpropertyParams]] = pydantic.Field(None, description='')
    VirtualServiceSpecProperty: typing.Optional[list[CfnVirtualServiceDefVirtualservicespecpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVirtualServiceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVirtualServiceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVirtualServiceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVirtualServiceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVirtualServiceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVirtualServiceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVirtualServiceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVirtualServiceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVirtualServiceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVirtualServiceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVirtualServiceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVirtualServiceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVirtualServiceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVirtualServiceDefVirtualnodeserviceproviderpropertyParams(pydantic.BaseModel):
    virtual_node_name: str = pydantic.Field(..., description='')
    ...

class CfnVirtualServiceDefVirtualrouterserviceproviderpropertyParams(pydantic.BaseModel):
    virtual_router_name: str = pydantic.Field(..., description='')
    ...

class CfnVirtualServiceDefVirtualserviceproviderpropertyParams(pydantic.BaseModel):
    virtual_node: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualService_VirtualNodeServiceProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    virtual_router: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualService_VirtualRouterServiceProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualServiceDefVirtualservicespecpropertyParams(pydantic.BaseModel):
    provider: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualService_VirtualServiceProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVirtualServiceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVirtualServiceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualServiceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVirtualServiceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualServiceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVirtualServiceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVirtualServiceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVirtualServiceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVirtualServiceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVirtualServiceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualServiceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVirtualServiceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVirtualServiceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualServiceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_appmesh.CfnGatewayRouteProps
class CfnGatewayRoutePropsDef(BaseCfnProperty):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh that the resource resides in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnGatewayRoute_GatewayRouteSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The specifications of the gateway route.\n')
    virtual_gateway_name: str = pydantic.Field(..., description='The virtual gateway that the gateway route is associated with.\n')
    gateway_route_name: typing.Optional[str] = pydantic.Field(None, description='The name of the gateway route.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description="The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appmesh-gatewayroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    cfn_gateway_route_props = appmesh.CfnGatewayRouteProps(\n        mesh_name="meshName",\n        spec=appmesh.CfnGatewayRoute.GatewayRouteSpecProperty(\n            grpc_route=appmesh.CfnGatewayRoute.GrpcGatewayRouteProperty(\n                action=appmesh.CfnGatewayRoute.GrpcGatewayRouteActionProperty(\n                    target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                        virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                            virtual_service_name="virtualServiceName"\n                        ),\n\n                        # the properties below are optional\n                        port=123\n                    ),\n\n                    # the properties below are optional\n                    rewrite=appmesh.CfnGatewayRoute.GrpcGatewayRouteRewriteProperty(\n                        hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                            default_target_hostname="defaultTargetHostname"\n                        )\n                    )\n                ),\n                match=appmesh.CfnGatewayRoute.GrpcGatewayRouteMatchProperty(\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                        exact="exact",\n                        suffix="suffix"\n                    ),\n                    metadata=[appmesh.CfnGatewayRoute.GrpcGatewayRouteMetadataProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        invert=False,\n                        match=appmesh.CfnGatewayRoute.GatewayRouteMetadataMatchProperty(\n                            exact="exact",\n                            prefix="prefix",\n                            range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                                end=123,\n                                start=123\n                            ),\n                            regex="regex",\n                            suffix="suffix"\n                        )\n                    )],\n                    port=123,\n                    service_name="serviceName"\n                )\n            ),\n            http2_route=appmesh.CfnGatewayRoute.HttpGatewayRouteProperty(\n                action=appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty(\n                    target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                        virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                            virtual_service_name="virtualServiceName"\n                        ),\n\n                        # the properties below are optional\n                        port=123\n                    ),\n\n                    # the properties below are optional\n                    rewrite=appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n                        hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                            default_target_hostname="defaultTargetHostname"\n                        ),\n                        path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n                            exact="exact"\n                        ),\n                        prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n                            default_prefix="defaultPrefix",\n                            value="value"\n                        )\n                    )\n                ),\n                match=appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty(\n                    headers=[appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        invert=False,\n                        match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n                            exact="exact",\n                            prefix="prefix",\n                            range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                                end=123,\n                                start=123\n                            ),\n                            regex="regex",\n                            suffix="suffix"\n                        )\n                    )],\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                        exact="exact",\n                        suffix="suffix"\n                    ),\n                    method="method",\n                    path=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n                        exact="exact",\n                        regex="regex"\n                    ),\n                    port=123,\n                    prefix="prefix",\n                    query_parameters=[appmesh.CfnGatewayRoute.QueryParameterProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n                            exact="exact"\n                        )\n                    )]\n                )\n            ),\n            http_route=appmesh.CfnGatewayRoute.HttpGatewayRouteProperty(\n                action=appmesh.CfnGatewayRoute.HttpGatewayRouteActionProperty(\n                    target=appmesh.CfnGatewayRoute.GatewayRouteTargetProperty(\n                        virtual_service=appmesh.CfnGatewayRoute.GatewayRouteVirtualServiceProperty(\n                            virtual_service_name="virtualServiceName"\n                        ),\n\n                        # the properties below are optional\n                        port=123\n                    ),\n\n                    # the properties below are optional\n                    rewrite=appmesh.CfnGatewayRoute.HttpGatewayRouteRewriteProperty(\n                        hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameRewriteProperty(\n                            default_target_hostname="defaultTargetHostname"\n                        ),\n                        path=appmesh.CfnGatewayRoute.HttpGatewayRoutePathRewriteProperty(\n                            exact="exact"\n                        ),\n                        prefix=appmesh.CfnGatewayRoute.HttpGatewayRoutePrefixRewriteProperty(\n                            default_prefix="defaultPrefix",\n                            value="value"\n                        )\n                    )\n                ),\n                match=appmesh.CfnGatewayRoute.HttpGatewayRouteMatchProperty(\n                    headers=[appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        invert=False,\n                        match=appmesh.CfnGatewayRoute.HttpGatewayRouteHeaderMatchProperty(\n                            exact="exact",\n                            prefix="prefix",\n                            range=appmesh.CfnGatewayRoute.GatewayRouteRangeMatchProperty(\n                                end=123,\n                                start=123\n                            ),\n                            regex="regex",\n                            suffix="suffix"\n                        )\n                    )],\n                    hostname=appmesh.CfnGatewayRoute.GatewayRouteHostnameMatchProperty(\n                        exact="exact",\n                        suffix="suffix"\n                    ),\n                    method="method",\n                    path=appmesh.CfnGatewayRoute.HttpPathMatchProperty(\n                        exact="exact",\n                        regex="regex"\n                    ),\n                    port=123,\n                    prefix="prefix",\n                    query_parameters=[appmesh.CfnGatewayRoute.QueryParameterProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        match=appmesh.CfnGatewayRoute.HttpQueryParameterMatchProperty(\n                            exact="exact"\n                        )\n                    )]\n                )\n            ),\n            priority=123\n        ),\n        virtual_gateway_name="virtualGatewayName",\n\n        # the properties below are optional\n        gateway_route_name="gatewayRouteName",\n        mesh_owner="meshOwner",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'virtual_gateway_name', 'gateway_route_name', 'mesh_owner', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnGatewayRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnMeshProps
class CfnMeshPropsDef(BaseCfnProperty):
    mesh_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the service mesh.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnMesh_MeshSpecPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The service mesh specification to apply.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appmesh-mesh.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    cfn_mesh_props = appmesh.CfnMeshProps(\n        mesh_name="meshName",\n        spec=appmesh.CfnMesh.MeshSpecProperty(\n            egress_filter=appmesh.CfnMesh.EgressFilterProperty(\n                type="type"\n            ),\n            service_discovery=appmesh.CfnMesh.MeshServiceDiscoveryProperty(\n                ip_preference="ipPreference"\n            )\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnMeshProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnRouteProps
class CfnRoutePropsDef(BaseCfnProperty):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh to create the route in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnRoute_RouteSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The route specification to apply.\n')
    virtual_router_name: str = pydantic.Field(..., description='The name of the virtual router in which to create the route. If the virtual router is in a shared mesh, then you must be the owner of the virtual router resource.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n')
    route_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the route.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appmesh-route.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    cfn_route_props = appmesh.CfnRouteProps(\n        mesh_name="meshName",\n        spec=appmesh.CfnRoute.RouteSpecProperty(\n            grpc_route=appmesh.CfnRoute.GrpcRouteProperty(\n                action=appmesh.CfnRoute.GrpcRouteActionProperty(\n                    weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                        virtual_node="virtualNode",\n                        weight=123,\n\n                        # the properties below are optional\n                        port=123\n                    )]\n                ),\n                match=appmesh.CfnRoute.GrpcRouteMatchProperty(\n                    metadata=[appmesh.CfnRoute.GrpcRouteMetadataProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        invert=False,\n                        match=appmesh.CfnRoute.GrpcRouteMetadataMatchMethodProperty(\n                            exact="exact",\n                            prefix="prefix",\n                            range=appmesh.CfnRoute.MatchRangeProperty(\n                                end=123,\n                                start=123\n                            ),\n                            regex="regex",\n                            suffix="suffix"\n                        )\n                    )],\n                    method_name="methodName",\n                    port=123,\n                    service_name="serviceName"\n                ),\n\n                # the properties below are optional\n                retry_policy=appmesh.CfnRoute.GrpcRetryPolicyProperty(\n                    max_retries=123,\n                    per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n\n                    # the properties below are optional\n                    grpc_retry_events=["grpcRetryEvents"],\n                    http_retry_events=["httpRetryEvents"],\n                    tcp_retry_events=["tcpRetryEvents"]\n                ),\n                timeout=appmesh.CfnRoute.GrpcTimeoutProperty(\n                    idle=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                )\n            ),\n            http2_route=appmesh.CfnRoute.HttpRouteProperty(\n                action=appmesh.CfnRoute.HttpRouteActionProperty(\n                    weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                        virtual_node="virtualNode",\n                        weight=123,\n\n                        # the properties below are optional\n                        port=123\n                    )]\n                ),\n                match=appmesh.CfnRoute.HttpRouteMatchProperty(\n                    headers=[appmesh.CfnRoute.HttpRouteHeaderProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        invert=False,\n                        match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                            exact="exact",\n                            prefix="prefix",\n                            range=appmesh.CfnRoute.MatchRangeProperty(\n                                end=123,\n                                start=123\n                            ),\n                            regex="regex",\n                            suffix="suffix"\n                        )\n                    )],\n                    method="method",\n                    path=appmesh.CfnRoute.HttpPathMatchProperty(\n                        exact="exact",\n                        regex="regex"\n                    ),\n                    port=123,\n                    prefix="prefix",\n                    query_parameters=[appmesh.CfnRoute.QueryParameterProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                            exact="exact"\n                        )\n                    )],\n                    scheme="scheme"\n                ),\n\n                # the properties below are optional\n                retry_policy=appmesh.CfnRoute.HttpRetryPolicyProperty(\n                    max_retries=123,\n                    per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n\n                    # the properties below are optional\n                    http_retry_events=["httpRetryEvents"],\n                    tcp_retry_events=["tcpRetryEvents"]\n                ),\n                timeout=appmesh.CfnRoute.HttpTimeoutProperty(\n                    idle=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                )\n            ),\n            http_route=appmesh.CfnRoute.HttpRouteProperty(\n                action=appmesh.CfnRoute.HttpRouteActionProperty(\n                    weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                        virtual_node="virtualNode",\n                        weight=123,\n\n                        # the properties below are optional\n                        port=123\n                    )]\n                ),\n                match=appmesh.CfnRoute.HttpRouteMatchProperty(\n                    headers=[appmesh.CfnRoute.HttpRouteHeaderProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        invert=False,\n                        match=appmesh.CfnRoute.HeaderMatchMethodProperty(\n                            exact="exact",\n                            prefix="prefix",\n                            range=appmesh.CfnRoute.MatchRangeProperty(\n                                end=123,\n                                start=123\n                            ),\n                            regex="regex",\n                            suffix="suffix"\n                        )\n                    )],\n                    method="method",\n                    path=appmesh.CfnRoute.HttpPathMatchProperty(\n                        exact="exact",\n                        regex="regex"\n                    ),\n                    port=123,\n                    prefix="prefix",\n                    query_parameters=[appmesh.CfnRoute.QueryParameterProperty(\n                        name="name",\n\n                        # the properties below are optional\n                        match=appmesh.CfnRoute.HttpQueryParameterMatchProperty(\n                            exact="exact"\n                        )\n                    )],\n                    scheme="scheme"\n                ),\n\n                # the properties below are optional\n                retry_policy=appmesh.CfnRoute.HttpRetryPolicyProperty(\n                    max_retries=123,\n                    per_retry_timeout=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n\n                    # the properties below are optional\n                    http_retry_events=["httpRetryEvents"],\n                    tcp_retry_events=["tcpRetryEvents"]\n                ),\n                timeout=appmesh.CfnRoute.HttpTimeoutProperty(\n                    idle=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    per_request=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                )\n            ),\n            priority=123,\n            tcp_route=appmesh.CfnRoute.TcpRouteProperty(\n                action=appmesh.CfnRoute.TcpRouteActionProperty(\n                    weighted_targets=[appmesh.CfnRoute.WeightedTargetProperty(\n                        virtual_node="virtualNode",\n                        weight=123,\n\n                        # the properties below are optional\n                        port=123\n                    )]\n                ),\n\n                # the properties below are optional\n                match=appmesh.CfnRoute.TcpRouteMatchProperty(\n                    port=123\n                ),\n                timeout=appmesh.CfnRoute.TcpTimeoutProperty(\n                    idle=appmesh.CfnRoute.DurationProperty(\n                        unit="unit",\n                        value=123\n                    )\n                )\n            )\n        ),\n        virtual_router_name="virtualRouterName",\n\n        # the properties below are optional\n        mesh_owner="meshOwner",\n        route_name="routeName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'virtual_router_name', 'mesh_owner', 'route_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualGatewayProps
class CfnVirtualGatewayPropsDef(BaseCfnProperty):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh that the virtual gateway resides in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualGateway_VirtualGatewaySpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The specifications of the virtual gateway.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description="The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n')
    virtual_gateway_name: typing.Optional[str] = pydantic.Field(None, description='The name of the virtual gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appmesh-virtualgateway.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    cfn_virtual_gateway_props = appmesh.CfnVirtualGatewayProps(\n        mesh_name="meshName",\n        spec=appmesh.CfnVirtualGateway.VirtualGatewaySpecProperty(\n            listeners=[appmesh.CfnVirtualGateway.VirtualGatewayListenerProperty(\n                port_mapping=appmesh.CfnVirtualGateway.VirtualGatewayPortMappingProperty(\n                    port=123,\n                    protocol="protocol"\n                ),\n\n                # the properties below are optional\n                connection_pool=appmesh.CfnVirtualGateway.VirtualGatewayConnectionPoolProperty(\n                    grpc=appmesh.CfnVirtualGateway.VirtualGatewayGrpcConnectionPoolProperty(\n                        max_requests=123\n                    ),\n                    http=appmesh.CfnVirtualGateway.VirtualGatewayHttpConnectionPoolProperty(\n                        max_connections=123,\n\n                        # the properties below are optional\n                        max_pending_requests=123\n                    ),\n                    http2=appmesh.CfnVirtualGateway.VirtualGatewayHttp2ConnectionPoolProperty(\n                        max_requests=123\n                    )\n                ),\n                health_check=appmesh.CfnVirtualGateway.VirtualGatewayHealthCheckPolicyProperty(\n                    healthy_threshold=123,\n                    interval_millis=123,\n                    protocol="protocol",\n                    timeout_millis=123,\n                    unhealthy_threshold=123,\n\n                    # the properties below are optional\n                    path="path",\n                    port=123\n                ),\n                tls=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsProperty(\n                    certificate=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsCertificateProperty(\n                        acm=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsAcmCertificateProperty(\n                            certificate_arn="certificateArn"\n                        ),\n                        file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                            certificate_chain="certificateChain",\n                            private_key="privateKey"\n                        ),\n                        sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n                    mode="mode",\n\n                    # the properties below are optional\n                    validation=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextProperty(\n                        trust=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsValidationContextTrustProperty(\n                            file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                                certificate_chain="certificateChain"\n                            ),\n                            sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n\n                        # the properties below are optional\n                        subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                            match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                                exact=["exact"]\n                            )\n                        )\n                    )\n                )\n            )],\n\n            # the properties below are optional\n            backend_defaults=appmesh.CfnVirtualGateway.VirtualGatewayBackendDefaultsProperty(\n                client_policy=appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyProperty(\n                    tls=appmesh.CfnVirtualGateway.VirtualGatewayClientPolicyTlsProperty(\n                        validation=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextProperty(\n                            trust=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextTrustProperty(\n                                acm=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextAcmTrustProperty(\n                                    certificate_authority_arns=["certificateAuthorityArns"]\n                                ),\n                                file=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextFileTrustProperty(\n                                    certificate_chain="certificateChain"\n                                ),\n                                sds=appmesh.CfnVirtualGateway.VirtualGatewayTlsValidationContextSdsTrustProperty(\n                                    secret_name="secretName"\n                                )\n                            ),\n\n                            # the properties below are optional\n                            subject_alternative_names=appmesh.CfnVirtualGateway.SubjectAlternativeNamesProperty(\n                                match=appmesh.CfnVirtualGateway.SubjectAlternativeNameMatchersProperty(\n                                    exact=["exact"]\n                                )\n                            )\n                        ),\n\n                        # the properties below are optional\n                        certificate=appmesh.CfnVirtualGateway.VirtualGatewayClientTlsCertificateProperty(\n                            file=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsFileCertificateProperty(\n                                certificate_chain="certificateChain",\n                                private_key="privateKey"\n                            ),\n                            sds=appmesh.CfnVirtualGateway.VirtualGatewayListenerTlsSdsCertificateProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n                        enforce=False,\n                        ports=[123]\n                    )\n                )\n            ),\n            logging=appmesh.CfnVirtualGateway.VirtualGatewayLoggingProperty(\n                access_log=appmesh.CfnVirtualGateway.VirtualGatewayAccessLogProperty(\n                    file=appmesh.CfnVirtualGateway.VirtualGatewayFileAccessLogProperty(\n                        path="path",\n\n                        # the properties below are optional\n                        format=appmesh.CfnVirtualGateway.LoggingFormatProperty(\n                            json=[appmesh.CfnVirtualGateway.JsonFormatRefProperty(\n                                key="key",\n                                value="value"\n                            )],\n                            text="text"\n                        )\n                    )\n                )\n            )\n        ),\n\n        # the properties below are optional\n        mesh_owner="meshOwner",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        virtual_gateway_name="virtualGatewayName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'mesh_owner', 'tags', 'virtual_gateway_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualNodeProps
class CfnVirtualNodePropsDef(BaseCfnProperty):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh to create the virtual node in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualNode_VirtualNodeSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The virtual node specification to apply.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n')
    virtual_node_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the virtual node.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appmesh-virtualnode.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    cfn_virtual_node_props = appmesh.CfnVirtualNodeProps(\n        mesh_name="meshName",\n        spec=appmesh.CfnVirtualNode.VirtualNodeSpecProperty(\n            backend_defaults=appmesh.CfnVirtualNode.BackendDefaultsProperty(\n                client_policy=appmesh.CfnVirtualNode.ClientPolicyProperty(\n                    tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n                        validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                            trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                                acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                                    certificate_authority_arns=["certificateAuthorityArns"]\n                                ),\n                                file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                                    certificate_chain="certificateChain"\n                                ),\n                                sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                                    secret_name="secretName"\n                                )\n                            ),\n\n                            # the properties below are optional\n                            subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                                match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                                    exact=["exact"]\n                                )\n                            )\n                        ),\n\n                        # the properties below are optional\n                        certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                            file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                                certificate_chain="certificateChain",\n                                private_key="privateKey"\n                            ),\n                            sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n                        enforce=False,\n                        ports=[123]\n                    )\n                )\n            ),\n            backends=[appmesh.CfnVirtualNode.BackendProperty(\n                virtual_service=appmesh.CfnVirtualNode.VirtualServiceBackendProperty(\n                    virtual_service_name="virtualServiceName",\n\n                    # the properties below are optional\n                    client_policy=appmesh.CfnVirtualNode.ClientPolicyProperty(\n                        tls=appmesh.CfnVirtualNode.ClientPolicyTlsProperty(\n                            validation=appmesh.CfnVirtualNode.TlsValidationContextProperty(\n                                trust=appmesh.CfnVirtualNode.TlsValidationContextTrustProperty(\n                                    acm=appmesh.CfnVirtualNode.TlsValidationContextAcmTrustProperty(\n                                        certificate_authority_arns=["certificateAuthorityArns"]\n                                    ),\n                                    file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                                        certificate_chain="certificateChain"\n                                    ),\n                                    sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                                        secret_name="secretName"\n                                    )\n                                ),\n\n                                # the properties below are optional\n                                subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                                    match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                                        exact=["exact"]\n                                    )\n                                )\n                            ),\n\n                            # the properties below are optional\n                            certificate=appmesh.CfnVirtualNode.ClientTlsCertificateProperty(\n                                file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                                    certificate_chain="certificateChain",\n                                    private_key="privateKey"\n                                ),\n                                sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                                    secret_name="secretName"\n                                )\n                            ),\n                            enforce=False,\n                            ports=[123]\n                        )\n                    )\n                )\n            )],\n            listeners=[appmesh.CfnVirtualNode.ListenerProperty(\n                port_mapping=appmesh.CfnVirtualNode.PortMappingProperty(\n                    port=123,\n                    protocol="protocol"\n                ),\n\n                # the properties below are optional\n                connection_pool=appmesh.CfnVirtualNode.VirtualNodeConnectionPoolProperty(\n                    grpc=appmesh.CfnVirtualNode.VirtualNodeGrpcConnectionPoolProperty(\n                        max_requests=123\n                    ),\n                    http=appmesh.CfnVirtualNode.VirtualNodeHttpConnectionPoolProperty(\n                        max_connections=123,\n\n                        # the properties below are optional\n                        max_pending_requests=123\n                    ),\n                    http2=appmesh.CfnVirtualNode.VirtualNodeHttp2ConnectionPoolProperty(\n                        max_requests=123\n                    ),\n                    tcp=appmesh.CfnVirtualNode.VirtualNodeTcpConnectionPoolProperty(\n                        max_connections=123\n                    )\n                ),\n                health_check=appmesh.CfnVirtualNode.HealthCheckProperty(\n                    healthy_threshold=123,\n                    interval_millis=123,\n                    protocol="protocol",\n                    timeout_millis=123,\n                    unhealthy_threshold=123,\n\n                    # the properties below are optional\n                    path="path",\n                    port=123\n                ),\n                outlier_detection=appmesh.CfnVirtualNode.OutlierDetectionProperty(\n                    base_ejection_duration=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    interval=appmesh.CfnVirtualNode.DurationProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    max_ejection_percent=123,\n                    max_server_errors=123\n                ),\n                timeout=appmesh.CfnVirtualNode.ListenerTimeoutProperty(\n                    grpc=appmesh.CfnVirtualNode.GrpcTimeoutProperty(\n                        idle=appmesh.CfnVirtualNode.DurationProperty(\n                            unit="unit",\n                            value=123\n                        ),\n                        per_request=appmesh.CfnVirtualNode.DurationProperty(\n                            unit="unit",\n                            value=123\n                        )\n                    ),\n                    http=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n                        idle=appmesh.CfnVirtualNode.DurationProperty(\n                            unit="unit",\n                            value=123\n                        ),\n                        per_request=appmesh.CfnVirtualNode.DurationProperty(\n                            unit="unit",\n                            value=123\n                        )\n                    ),\n                    http2=appmesh.CfnVirtualNode.HttpTimeoutProperty(\n                        idle=appmesh.CfnVirtualNode.DurationProperty(\n                            unit="unit",\n                            value=123\n                        ),\n                        per_request=appmesh.CfnVirtualNode.DurationProperty(\n                            unit="unit",\n                            value=123\n                        )\n                    ),\n                    tcp=appmesh.CfnVirtualNode.TcpTimeoutProperty(\n                        idle=appmesh.CfnVirtualNode.DurationProperty(\n                            unit="unit",\n                            value=123\n                        )\n                    )\n                ),\n                tls=appmesh.CfnVirtualNode.ListenerTlsProperty(\n                    certificate=appmesh.CfnVirtualNode.ListenerTlsCertificateProperty(\n                        acm=appmesh.CfnVirtualNode.ListenerTlsAcmCertificateProperty(\n                            certificate_arn="certificateArn"\n                        ),\n                        file=appmesh.CfnVirtualNode.ListenerTlsFileCertificateProperty(\n                            certificate_chain="certificateChain",\n                            private_key="privateKey"\n                        ),\n                        sds=appmesh.CfnVirtualNode.ListenerTlsSdsCertificateProperty(\n                            secret_name="secretName"\n                        )\n                    ),\n                    mode="mode",\n\n                    # the properties below are optional\n                    validation=appmesh.CfnVirtualNode.ListenerTlsValidationContextProperty(\n                        trust=appmesh.CfnVirtualNode.ListenerTlsValidationContextTrustProperty(\n                            file=appmesh.CfnVirtualNode.TlsValidationContextFileTrustProperty(\n                                certificate_chain="certificateChain"\n                            ),\n                            sds=appmesh.CfnVirtualNode.TlsValidationContextSdsTrustProperty(\n                                secret_name="secretName"\n                            )\n                        ),\n\n                        # the properties below are optional\n                        subject_alternative_names=appmesh.CfnVirtualNode.SubjectAlternativeNamesProperty(\n                            match=appmesh.CfnVirtualNode.SubjectAlternativeNameMatchersProperty(\n                                exact=["exact"]\n                            )\n                        )\n                    )\n                )\n            )],\n            logging=appmesh.CfnVirtualNode.LoggingProperty(\n                access_log=appmesh.CfnVirtualNode.AccessLogProperty(\n                    file=appmesh.CfnVirtualNode.FileAccessLogProperty(\n                        path="path",\n\n                        # the properties below are optional\n                        format=appmesh.CfnVirtualNode.LoggingFormatProperty(\n                            json=[appmesh.CfnVirtualNode.JsonFormatRefProperty(\n                                key="key",\n                                value="value"\n                            )],\n                            text="text"\n                        )\n                    )\n                )\n            ),\n            service_discovery=appmesh.CfnVirtualNode.ServiceDiscoveryProperty(\n                aws_cloud_map=appmesh.CfnVirtualNode.AwsCloudMapServiceDiscoveryProperty(\n                    namespace_name="namespaceName",\n                    service_name="serviceName",\n\n                    # the properties below are optional\n                    attributes=[appmesh.CfnVirtualNode.AwsCloudMapInstanceAttributeProperty(\n                        key="key",\n                        value="value"\n                    )],\n                    ip_preference="ipPreference"\n                ),\n                dns=appmesh.CfnVirtualNode.DnsServiceDiscoveryProperty(\n                    hostname="hostname",\n\n                    # the properties below are optional\n                    ip_preference="ipPreference",\n                    response_type="responseType"\n                )\n            )\n        ),\n\n        # the properties below are optional\n        mesh_owner="meshOwner",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        virtual_node_name="virtualNodeName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'mesh_owner', 'tags', 'virtual_node_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualNodeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualRouterProps
class CfnVirtualRouterPropsDef(BaseCfnProperty):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh to create the virtual router in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualRouter_VirtualRouterSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The virtual router specification to apply.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n')
    virtual_router_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the virtual router.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appmesh-virtualrouter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    cfn_virtual_router_props = appmesh.CfnVirtualRouterProps(\n        mesh_name="meshName",\n        spec=appmesh.CfnVirtualRouter.VirtualRouterSpecProperty(\n            listeners=[appmesh.CfnVirtualRouter.VirtualRouterListenerProperty(\n                port_mapping=appmesh.CfnVirtualRouter.PortMappingProperty(\n                    port=123,\n                    protocol="protocol"\n                )\n            )]\n        ),\n\n        # the properties below are optional\n        mesh_owner="meshOwner",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        virtual_router_name="virtualRouterName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'mesh_owner', 'tags', 'virtual_router_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualRouterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_appmesh.CfnVirtualServiceProps
class CfnVirtualServicePropsDef(BaseCfnProperty):
    mesh_name: str = pydantic.Field(..., description='The name of the service mesh to create the virtual service in.\n')
    spec: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_appmesh.CfnVirtualService_VirtualServiceSpecPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The virtual service specification to apply.\n')
    virtual_service_name: str = pydantic.Field(..., description='The name to use for the virtual service.\n')
    mesh_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see `Working with shared meshes <https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appmesh-virtualservice.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_appmesh as appmesh\n\n    cfn_virtual_service_props = appmesh.CfnVirtualServiceProps(\n        mesh_name="meshName",\n        spec=appmesh.CfnVirtualService.VirtualServiceSpecProperty(\n            provider=appmesh.CfnVirtualService.VirtualServiceProviderProperty(\n                virtual_node=appmesh.CfnVirtualService.VirtualNodeServiceProviderProperty(\n                    virtual_node_name="virtualNodeName"\n                ),\n                virtual_router=appmesh.CfnVirtualService.VirtualRouterServiceProviderProperty(\n                    virtual_router_name="virtualRouterName"\n                )\n            )\n        ),\n        virtual_service_name="virtualServiceName",\n\n        # the properties below are optional\n        mesh_owner="meshOwner",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mesh_name', 'spec', 'virtual_service_name', 'mesh_owner', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_appmesh.CfnVirtualServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    AccessLog: typing.Optional[dict[str, AccessLogDef]] = pydantic.Field(None)
    Backend: typing.Optional[dict[str, BackendDef]] = pydantic.Field(None)
    GatewayRouteHostnameMatch: typing.Optional[dict[str, GatewayRouteHostnameMatchDef]] = pydantic.Field(None)
    GatewayRouteSpec: typing.Optional[dict[str, GatewayRouteSpecDef]] = pydantic.Field(None)
    HeaderMatch: typing.Optional[dict[str, HeaderMatchDef]] = pydantic.Field(None)
    HealthCheck: typing.Optional[dict[str, HealthCheckDef]] = pydantic.Field(None)
    HttpGatewayRoutePathMatch: typing.Optional[dict[str, HttpGatewayRoutePathMatchDef]] = pydantic.Field(None)
    HttpRoutePathMatch: typing.Optional[dict[str, HttpRoutePathMatchDef]] = pydantic.Field(None)
    LoggingFormat: typing.Optional[dict[str, LoggingFormatDef]] = pydantic.Field(None)
    MutualTlsCertificate: typing.Optional[dict[str, MutualTlsCertificateDef]] = pydantic.Field(None)
    MutualTlsValidationTrust: typing.Optional[dict[str, MutualTlsValidationTrustDef]] = pydantic.Field(None)
    QueryParameterMatch: typing.Optional[dict[str, QueryParameterMatchDef]] = pydantic.Field(None)
    RouteSpec: typing.Optional[dict[str, RouteSpecDef]] = pydantic.Field(None)
    ServiceDiscovery: typing.Optional[dict[str, ServiceDiscoveryDef]] = pydantic.Field(None)
    SubjectAlternativeNames: typing.Optional[dict[str, SubjectAlternativeNamesDef]] = pydantic.Field(None)
    TlsCertificate: typing.Optional[dict[str, TlsCertificateDef]] = pydantic.Field(None)
    TlsValidationTrust: typing.Optional[dict[str, TlsValidationTrustDef]] = pydantic.Field(None)
    VirtualGatewayListener: typing.Optional[dict[str, VirtualGatewayListenerDef]] = pydantic.Field(None)
    VirtualNodeListener: typing.Optional[dict[str, VirtualNodeListenerDef]] = pydantic.Field(None)
    VirtualRouterListener: typing.Optional[dict[str, VirtualRouterListenerDef]] = pydantic.Field(None)
    VirtualServiceProvider: typing.Optional[dict[str, VirtualServiceProviderDef]] = pydantic.Field(None)
    GatewayRoute: typing.Optional[dict[str, GatewayRouteDef]] = pydantic.Field(None)
    Mesh: typing.Optional[dict[str, MeshDef]] = pydantic.Field(None)
    Route: typing.Optional[dict[str, RouteDef]] = pydantic.Field(None)
    VirtualGateway: typing.Optional[dict[str, VirtualGatewayDef]] = pydantic.Field(None)
    VirtualNode: typing.Optional[dict[str, VirtualNodeDef]] = pydantic.Field(None)
    VirtualRouter: typing.Optional[dict[str, VirtualRouterDef]] = pydantic.Field(None)
    VirtualService: typing.Optional[dict[str, VirtualServiceDef]] = pydantic.Field(None)
    AccessLogConfig: typing.Optional[dict[str, AccessLogConfigDef]] = pydantic.Field(None)
    BackendConfig: typing.Optional[dict[str, BackendConfigDef]] = pydantic.Field(None)
    BackendDefaults: typing.Optional[dict[str, BackendDefaultsDef]] = pydantic.Field(None)
    CfnGatewayRoute_GatewayRouteHostnameMatchProperty: typing.Optional[dict[str, CfnGatewayRoute_GatewayRouteHostnameMatchPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GatewayRouteHostnameRewriteProperty: typing.Optional[dict[str, CfnGatewayRoute_GatewayRouteHostnameRewritePropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GatewayRouteMetadataMatchProperty: typing.Optional[dict[str, CfnGatewayRoute_GatewayRouteMetadataMatchPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GatewayRouteRangeMatchProperty: typing.Optional[dict[str, CfnGatewayRoute_GatewayRouteRangeMatchPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GatewayRouteSpecProperty: typing.Optional[dict[str, CfnGatewayRoute_GatewayRouteSpecPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GatewayRouteTargetProperty: typing.Optional[dict[str, CfnGatewayRoute_GatewayRouteTargetPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GatewayRouteVirtualServiceProperty: typing.Optional[dict[str, CfnGatewayRoute_GatewayRouteVirtualServicePropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GrpcGatewayRouteActionProperty: typing.Optional[dict[str, CfnGatewayRoute_GrpcGatewayRouteActionPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GrpcGatewayRouteMatchProperty: typing.Optional[dict[str, CfnGatewayRoute_GrpcGatewayRouteMatchPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GrpcGatewayRouteMetadataProperty: typing.Optional[dict[str, CfnGatewayRoute_GrpcGatewayRouteMetadataPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GrpcGatewayRouteProperty: typing.Optional[dict[str, CfnGatewayRoute_GrpcGatewayRoutePropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_GrpcGatewayRouteRewriteProperty: typing.Optional[dict[str, CfnGatewayRoute_GrpcGatewayRouteRewritePropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpGatewayRouteActionProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpGatewayRouteActionPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpGatewayRouteHeaderMatchProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpGatewayRouteHeaderMatchPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpGatewayRouteHeaderProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpGatewayRouteHeaderPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpGatewayRouteMatchProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpGatewayRouteMatchPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpGatewayRoutePathRewriteProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpGatewayRoutePathRewritePropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpGatewayRoutePrefixRewriteProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpGatewayRoutePrefixRewritePropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpGatewayRouteProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpGatewayRoutePropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpGatewayRouteRewriteProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpGatewayRouteRewritePropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpPathMatchProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpPathMatchPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_HttpQueryParameterMatchProperty: typing.Optional[dict[str, CfnGatewayRoute_HttpQueryParameterMatchPropertyDef]] = pydantic.Field(None)
    CfnGatewayRoute_QueryParameterProperty: typing.Optional[dict[str, CfnGatewayRoute_QueryParameterPropertyDef]] = pydantic.Field(None)
    CfnMesh_EgressFilterProperty: typing.Optional[dict[str, CfnMesh_EgressFilterPropertyDef]] = pydantic.Field(None)
    CfnMesh_MeshServiceDiscoveryProperty: typing.Optional[dict[str, CfnMesh_MeshServiceDiscoveryPropertyDef]] = pydantic.Field(None)
    CfnMesh_MeshSpecProperty: typing.Optional[dict[str, CfnMesh_MeshSpecPropertyDef]] = pydantic.Field(None)
    CfnRoute_DurationProperty: typing.Optional[dict[str, CfnRoute_DurationPropertyDef]] = pydantic.Field(None)
    CfnRoute_GrpcRetryPolicyProperty: typing.Optional[dict[str, CfnRoute_GrpcRetryPolicyPropertyDef]] = pydantic.Field(None)
    CfnRoute_GrpcRouteActionProperty: typing.Optional[dict[str, CfnRoute_GrpcRouteActionPropertyDef]] = pydantic.Field(None)
    CfnRoute_GrpcRouteMatchProperty: typing.Optional[dict[str, CfnRoute_GrpcRouteMatchPropertyDef]] = pydantic.Field(None)
    CfnRoute_GrpcRouteMetadataMatchMethodProperty: typing.Optional[dict[str, CfnRoute_GrpcRouteMetadataMatchMethodPropertyDef]] = pydantic.Field(None)
    CfnRoute_GrpcRouteMetadataProperty: typing.Optional[dict[str, CfnRoute_GrpcRouteMetadataPropertyDef]] = pydantic.Field(None)
    CfnRoute_GrpcRouteProperty: typing.Optional[dict[str, CfnRoute_GrpcRoutePropertyDef]] = pydantic.Field(None)
    CfnRoute_GrpcTimeoutProperty: typing.Optional[dict[str, CfnRoute_GrpcTimeoutPropertyDef]] = pydantic.Field(None)
    CfnRoute_HeaderMatchMethodProperty: typing.Optional[dict[str, CfnRoute_HeaderMatchMethodPropertyDef]] = pydantic.Field(None)
    CfnRoute_HttpPathMatchProperty: typing.Optional[dict[str, CfnRoute_HttpPathMatchPropertyDef]] = pydantic.Field(None)
    CfnRoute_HttpQueryParameterMatchProperty: typing.Optional[dict[str, CfnRoute_HttpQueryParameterMatchPropertyDef]] = pydantic.Field(None)
    CfnRoute_HttpRetryPolicyProperty: typing.Optional[dict[str, CfnRoute_HttpRetryPolicyPropertyDef]] = pydantic.Field(None)
    CfnRoute_HttpRouteActionProperty: typing.Optional[dict[str, CfnRoute_HttpRouteActionPropertyDef]] = pydantic.Field(None)
    CfnRoute_HttpRouteHeaderProperty: typing.Optional[dict[str, CfnRoute_HttpRouteHeaderPropertyDef]] = pydantic.Field(None)
    CfnRoute_HttpRouteMatchProperty: typing.Optional[dict[str, CfnRoute_HttpRouteMatchPropertyDef]] = pydantic.Field(None)
    CfnRoute_HttpRouteProperty: typing.Optional[dict[str, CfnRoute_HttpRoutePropertyDef]] = pydantic.Field(None)
    CfnRoute_HttpTimeoutProperty: typing.Optional[dict[str, CfnRoute_HttpTimeoutPropertyDef]] = pydantic.Field(None)
    CfnRoute_MatchRangeProperty: typing.Optional[dict[str, CfnRoute_MatchRangePropertyDef]] = pydantic.Field(None)
    CfnRoute_QueryParameterProperty: typing.Optional[dict[str, CfnRoute_QueryParameterPropertyDef]] = pydantic.Field(None)
    CfnRoute_RouteSpecProperty: typing.Optional[dict[str, CfnRoute_RouteSpecPropertyDef]] = pydantic.Field(None)
    CfnRoute_TcpRouteActionProperty: typing.Optional[dict[str, CfnRoute_TcpRouteActionPropertyDef]] = pydantic.Field(None)
    CfnRoute_TcpRouteMatchProperty: typing.Optional[dict[str, CfnRoute_TcpRouteMatchPropertyDef]] = pydantic.Field(None)
    CfnRoute_TcpRouteProperty: typing.Optional[dict[str, CfnRoute_TcpRoutePropertyDef]] = pydantic.Field(None)
    CfnRoute_TcpTimeoutProperty: typing.Optional[dict[str, CfnRoute_TcpTimeoutPropertyDef]] = pydantic.Field(None)
    CfnRoute_WeightedTargetProperty: typing.Optional[dict[str, CfnRoute_WeightedTargetPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_JsonFormatRefProperty: typing.Optional[dict[str, CfnVirtualGateway_JsonFormatRefPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_LoggingFormatProperty: typing.Optional[dict[str, CfnVirtualGateway_LoggingFormatPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_SubjectAlternativeNameMatchersProperty: typing.Optional[dict[str, CfnVirtualGateway_SubjectAlternativeNameMatchersPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_SubjectAlternativeNamesProperty: typing.Optional[dict[str, CfnVirtualGateway_SubjectAlternativeNamesPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayAccessLogProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayAccessLogPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayBackendDefaultsProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayBackendDefaultsPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayClientPolicyProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayClientPolicyPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayClientPolicyTlsProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayClientPolicyTlsPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayClientTlsCertificateProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayClientTlsCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayFileAccessLogProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayFileAccessLogPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayGrpcConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayGrpcConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayHealthCheckPolicyProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayHealthCheckPolicyPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayHttp2ConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayHttp2ConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayHttpConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayHttpConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayListenerProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayListenerPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayListenerTlsAcmCertificateProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayListenerTlsAcmCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayListenerTlsCertificateProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayListenerTlsCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayListenerTlsFileCertificateProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayListenerTlsFileCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayListenerTlsProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayListenerTlsPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayListenerTlsSdsCertificateProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayListenerTlsSdsCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextTrustProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayListenerTlsValidationContextTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayLoggingProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayLoggingPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayPortMappingProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayPortMappingPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewaySpecProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewaySpecPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayTlsValidationContextAcmTrustProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayTlsValidationContextAcmTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayTlsValidationContextFileTrustProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayTlsValidationContextFileTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayTlsValidationContextProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayTlsValidationContextPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayTlsValidationContextSdsTrustProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayTlsValidationContextSdsTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualGateway_VirtualGatewayTlsValidationContextTrustProperty: typing.Optional[dict[str, CfnVirtualGateway_VirtualGatewayTlsValidationContextTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_AccessLogProperty: typing.Optional[dict[str, CfnVirtualNode_AccessLogPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_AwsCloudMapInstanceAttributeProperty: typing.Optional[dict[str, CfnVirtualNode_AwsCloudMapInstanceAttributePropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_AwsCloudMapServiceDiscoveryProperty: typing.Optional[dict[str, CfnVirtualNode_AwsCloudMapServiceDiscoveryPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_BackendDefaultsProperty: typing.Optional[dict[str, CfnVirtualNode_BackendDefaultsPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_BackendProperty: typing.Optional[dict[str, CfnVirtualNode_BackendPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ClientPolicyProperty: typing.Optional[dict[str, CfnVirtualNode_ClientPolicyPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ClientPolicyTlsProperty: typing.Optional[dict[str, CfnVirtualNode_ClientPolicyTlsPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ClientTlsCertificateProperty: typing.Optional[dict[str, CfnVirtualNode_ClientTlsCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_DnsServiceDiscoveryProperty: typing.Optional[dict[str, CfnVirtualNode_DnsServiceDiscoveryPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_DurationProperty: typing.Optional[dict[str, CfnVirtualNode_DurationPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_FileAccessLogProperty: typing.Optional[dict[str, CfnVirtualNode_FileAccessLogPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_GrpcTimeoutProperty: typing.Optional[dict[str, CfnVirtualNode_GrpcTimeoutPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_HealthCheckProperty: typing.Optional[dict[str, CfnVirtualNode_HealthCheckPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_HttpTimeoutProperty: typing.Optional[dict[str, CfnVirtualNode_HttpTimeoutPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_JsonFormatRefProperty: typing.Optional[dict[str, CfnVirtualNode_JsonFormatRefPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerTimeoutProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerTimeoutPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerTlsAcmCertificateProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerTlsAcmCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerTlsCertificateProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerTlsCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerTlsFileCertificateProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerTlsFileCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerTlsProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerTlsPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerTlsSdsCertificateProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerTlsSdsCertificatePropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerTlsValidationContextProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerTlsValidationContextPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ListenerTlsValidationContextTrustProperty: typing.Optional[dict[str, CfnVirtualNode_ListenerTlsValidationContextTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_LoggingFormatProperty: typing.Optional[dict[str, CfnVirtualNode_LoggingFormatPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_LoggingProperty: typing.Optional[dict[str, CfnVirtualNode_LoggingPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_OutlierDetectionProperty: typing.Optional[dict[str, CfnVirtualNode_OutlierDetectionPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_PortMappingProperty: typing.Optional[dict[str, CfnVirtualNode_PortMappingPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_ServiceDiscoveryProperty: typing.Optional[dict[str, CfnVirtualNode_ServiceDiscoveryPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_SubjectAlternativeNameMatchersProperty: typing.Optional[dict[str, CfnVirtualNode_SubjectAlternativeNameMatchersPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_SubjectAlternativeNamesProperty: typing.Optional[dict[str, CfnVirtualNode_SubjectAlternativeNamesPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_TcpTimeoutProperty: typing.Optional[dict[str, CfnVirtualNode_TcpTimeoutPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_TlsValidationContextAcmTrustProperty: typing.Optional[dict[str, CfnVirtualNode_TlsValidationContextAcmTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_TlsValidationContextFileTrustProperty: typing.Optional[dict[str, CfnVirtualNode_TlsValidationContextFileTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_TlsValidationContextProperty: typing.Optional[dict[str, CfnVirtualNode_TlsValidationContextPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_TlsValidationContextSdsTrustProperty: typing.Optional[dict[str, CfnVirtualNode_TlsValidationContextSdsTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_TlsValidationContextTrustProperty: typing.Optional[dict[str, CfnVirtualNode_TlsValidationContextTrustPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_VirtualNodeConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualNode_VirtualNodeConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_VirtualNodeGrpcConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualNode_VirtualNodeGrpcConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_VirtualNodeHttp2ConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualNode_VirtualNodeHttp2ConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_VirtualNodeHttpConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualNode_VirtualNodeHttpConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_VirtualNodeSpecProperty: typing.Optional[dict[str, CfnVirtualNode_VirtualNodeSpecPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_VirtualNodeTcpConnectionPoolProperty: typing.Optional[dict[str, CfnVirtualNode_VirtualNodeTcpConnectionPoolPropertyDef]] = pydantic.Field(None)
    CfnVirtualNode_VirtualServiceBackendProperty: typing.Optional[dict[str, CfnVirtualNode_VirtualServiceBackendPropertyDef]] = pydantic.Field(None)
    CfnVirtualRouter_PortMappingProperty: typing.Optional[dict[str, CfnVirtualRouter_PortMappingPropertyDef]] = pydantic.Field(None)
    CfnVirtualRouter_VirtualRouterListenerProperty: typing.Optional[dict[str, CfnVirtualRouter_VirtualRouterListenerPropertyDef]] = pydantic.Field(None)
    CfnVirtualRouter_VirtualRouterSpecProperty: typing.Optional[dict[str, CfnVirtualRouter_VirtualRouterSpecPropertyDef]] = pydantic.Field(None)
    CfnVirtualService_VirtualNodeServiceProviderProperty: typing.Optional[dict[str, CfnVirtualService_VirtualNodeServiceProviderPropertyDef]] = pydantic.Field(None)
    CfnVirtualService_VirtualRouterServiceProviderProperty: typing.Optional[dict[str, CfnVirtualService_VirtualRouterServiceProviderPropertyDef]] = pydantic.Field(None)
    CfnVirtualService_VirtualServiceProviderProperty: typing.Optional[dict[str, CfnVirtualService_VirtualServiceProviderPropertyDef]] = pydantic.Field(None)
    CfnVirtualService_VirtualServiceSpecProperty: typing.Optional[dict[str, CfnVirtualService_VirtualServiceSpecPropertyDef]] = pydantic.Field(None)
    CommonGatewayRouteSpecOptions: typing.Optional[dict[str, CommonGatewayRouteSpecOptionsDef]] = pydantic.Field(None)
    GatewayRouteAttributes: typing.Optional[dict[str, GatewayRouteAttributesDef]] = pydantic.Field(None)
    GatewayRouteBaseProps: typing.Optional[dict[str, GatewayRouteBasePropsDef]] = pydantic.Field(None)
    GatewayRouteHostnameMatchConfig: typing.Optional[dict[str, GatewayRouteHostnameMatchConfigDef]] = pydantic.Field(None)
    GatewayRouteProps: typing.Optional[dict[str, GatewayRoutePropsDef]] = pydantic.Field(None)
    GatewayRouteSpecConfig: typing.Optional[dict[str, GatewayRouteSpecConfigDef]] = pydantic.Field(None)
    GrpcConnectionPool: typing.Optional[dict[str, GrpcConnectionPoolDef]] = pydantic.Field(None)
    GrpcGatewayListenerOptions: typing.Optional[dict[str, GrpcGatewayListenerOptionsDef]] = pydantic.Field(None)
    GrpcGatewayRouteMatch: typing.Optional[dict[str, GrpcGatewayRouteMatchDef]] = pydantic.Field(None)
    GrpcGatewayRouteSpecOptions: typing.Optional[dict[str, GrpcGatewayRouteSpecOptionsDef]] = pydantic.Field(None)
    GrpcHealthCheckOptions: typing.Optional[dict[str, GrpcHealthCheckOptionsDef]] = pydantic.Field(None)
    GrpcRetryPolicy: typing.Optional[dict[str, GrpcRetryPolicyDef]] = pydantic.Field(None)
    GrpcRouteMatch: typing.Optional[dict[str, GrpcRouteMatchDef]] = pydantic.Field(None)
    GrpcRouteSpecOptions: typing.Optional[dict[str, GrpcRouteSpecOptionsDef]] = pydantic.Field(None)
    GrpcTimeout: typing.Optional[dict[str, GrpcTimeoutDef]] = pydantic.Field(None)
    GrpcVirtualNodeListenerOptions: typing.Optional[dict[str, GrpcVirtualNodeListenerOptionsDef]] = pydantic.Field(None)
    HeaderMatchConfig: typing.Optional[dict[str, HeaderMatchConfigDef]] = pydantic.Field(None)
    HealthCheckBindOptions: typing.Optional[dict[str, HealthCheckBindOptionsDef]] = pydantic.Field(None)
    HealthCheckConfig: typing.Optional[dict[str, HealthCheckConfigDef]] = pydantic.Field(None)
    Http2ConnectionPool: typing.Optional[dict[str, Http2ConnectionPoolDef]] = pydantic.Field(None)
    Http2GatewayListenerOptions: typing.Optional[dict[str, Http2GatewayListenerOptionsDef]] = pydantic.Field(None)
    Http2VirtualNodeListenerOptions: typing.Optional[dict[str, Http2VirtualNodeListenerOptionsDef]] = pydantic.Field(None)
    HttpConnectionPool: typing.Optional[dict[str, HttpConnectionPoolDef]] = pydantic.Field(None)
    HttpGatewayListenerOptions: typing.Optional[dict[str, HttpGatewayListenerOptionsDef]] = pydantic.Field(None)
    HttpGatewayRouteMatch: typing.Optional[dict[str, HttpGatewayRouteMatchDef]] = pydantic.Field(None)
    HttpGatewayRoutePathMatchConfig: typing.Optional[dict[str, HttpGatewayRoutePathMatchConfigDef]] = pydantic.Field(None)
    HttpGatewayRouteSpecOptions: typing.Optional[dict[str, HttpGatewayRouteSpecOptionsDef]] = pydantic.Field(None)
    HttpHealthCheckOptions: typing.Optional[dict[str, HttpHealthCheckOptionsDef]] = pydantic.Field(None)
    HttpRetryPolicy: typing.Optional[dict[str, HttpRetryPolicyDef]] = pydantic.Field(None)
    HttpRouteMatch: typing.Optional[dict[str, HttpRouteMatchDef]] = pydantic.Field(None)
    HttpRoutePathMatchConfig: typing.Optional[dict[str, HttpRoutePathMatchConfigDef]] = pydantic.Field(None)
    HttpRouteSpecOptions: typing.Optional[dict[str, HttpRouteSpecOptionsDef]] = pydantic.Field(None)
    HttpTimeout: typing.Optional[dict[str, HttpTimeoutDef]] = pydantic.Field(None)
    HttpVirtualNodeListenerOptions: typing.Optional[dict[str, HttpVirtualNodeListenerOptionsDef]] = pydantic.Field(None)
    ListenerTlsOptions: typing.Optional[dict[str, ListenerTlsOptionsDef]] = pydantic.Field(None)
    LoggingFormatConfig: typing.Optional[dict[str, LoggingFormatConfigDef]] = pydantic.Field(None)
    MeshProps: typing.Optional[dict[str, MeshPropsDef]] = pydantic.Field(None)
    MeshServiceDiscovery: typing.Optional[dict[str, MeshServiceDiscoveryDef]] = pydantic.Field(None)
    MutualTlsValidation: typing.Optional[dict[str, MutualTlsValidationDef]] = pydantic.Field(None)
    OutlierDetection: typing.Optional[dict[str, OutlierDetectionDef]] = pydantic.Field(None)
    QueryParameterMatchConfig: typing.Optional[dict[str, QueryParameterMatchConfigDef]] = pydantic.Field(None)
    RouteAttributes: typing.Optional[dict[str, RouteAttributesDef]] = pydantic.Field(None)
    RouteBaseProps: typing.Optional[dict[str, RouteBasePropsDef]] = pydantic.Field(None)
    RouteProps: typing.Optional[dict[str, RoutePropsDef]] = pydantic.Field(None)
    RouteSpecConfig: typing.Optional[dict[str, RouteSpecConfigDef]] = pydantic.Field(None)
    RouteSpecOptionsBase: typing.Optional[dict[str, RouteSpecOptionsBaseDef]] = pydantic.Field(None)
    ServiceDiscoveryConfig: typing.Optional[dict[str, ServiceDiscoveryConfigDef]] = pydantic.Field(None)
    SubjectAlternativeNamesMatcherConfig: typing.Optional[dict[str, SubjectAlternativeNamesMatcherConfigDef]] = pydantic.Field(None)
    TcpConnectionPool: typing.Optional[dict[str, TcpConnectionPoolDef]] = pydantic.Field(None)
    TcpHealthCheckOptions: typing.Optional[dict[str, TcpHealthCheckOptionsDef]] = pydantic.Field(None)
    TcpRouteSpecOptions: typing.Optional[dict[str, TcpRouteSpecOptionsDef]] = pydantic.Field(None)
    TcpTimeout: typing.Optional[dict[str, TcpTimeoutDef]] = pydantic.Field(None)
    TcpVirtualNodeListenerOptions: typing.Optional[dict[str, TcpVirtualNodeListenerOptionsDef]] = pydantic.Field(None)
    TlsCertificateConfig: typing.Optional[dict[str, TlsCertificateConfigDef]] = pydantic.Field(None)
    TlsClientPolicy: typing.Optional[dict[str, TlsClientPolicyDef]] = pydantic.Field(None)
    TlsValidation: typing.Optional[dict[str, TlsValidationDef]] = pydantic.Field(None)
    TlsValidationTrustConfig: typing.Optional[dict[str, TlsValidationTrustConfigDef]] = pydantic.Field(None)
    VirtualGatewayAttributes: typing.Optional[dict[str, VirtualGatewayAttributesDef]] = pydantic.Field(None)
    VirtualGatewayBaseProps: typing.Optional[dict[str, VirtualGatewayBasePropsDef]] = pydantic.Field(None)
    VirtualGatewayListenerConfig: typing.Optional[dict[str, VirtualGatewayListenerConfigDef]] = pydantic.Field(None)
    VirtualGatewayProps: typing.Optional[dict[str, VirtualGatewayPropsDef]] = pydantic.Field(None)
    VirtualNodeAttributes: typing.Optional[dict[str, VirtualNodeAttributesDef]] = pydantic.Field(None)
    VirtualNodeBaseProps: typing.Optional[dict[str, VirtualNodeBasePropsDef]] = pydantic.Field(None)
    VirtualNodeListenerConfig: typing.Optional[dict[str, VirtualNodeListenerConfigDef]] = pydantic.Field(None)
    VirtualNodeProps: typing.Optional[dict[str, VirtualNodePropsDef]] = pydantic.Field(None)
    VirtualRouterAttributes: typing.Optional[dict[str, VirtualRouterAttributesDef]] = pydantic.Field(None)
    VirtualRouterBaseProps: typing.Optional[dict[str, VirtualRouterBasePropsDef]] = pydantic.Field(None)
    VirtualRouterListenerConfig: typing.Optional[dict[str, VirtualRouterListenerConfigDef]] = pydantic.Field(None)
    VirtualRouterProps: typing.Optional[dict[str, VirtualRouterPropsDef]] = pydantic.Field(None)
    VirtualServiceAttributes: typing.Optional[dict[str, VirtualServiceAttributesDef]] = pydantic.Field(None)
    VirtualServiceBackendOptions: typing.Optional[dict[str, VirtualServiceBackendOptionsDef]] = pydantic.Field(None)
    VirtualServiceProps: typing.Optional[dict[str, VirtualServicePropsDef]] = pydantic.Field(None)
    VirtualServiceProviderConfig: typing.Optional[dict[str, VirtualServiceProviderConfigDef]] = pydantic.Field(None)
    WeightedTarget: typing.Optional[dict[str, WeightedTargetDef]] = pydantic.Field(None)
    CfnGatewayRoute: typing.Optional[dict[str, CfnGatewayRouteDef]] = pydantic.Field(None)
    CfnMesh: typing.Optional[dict[str, CfnMeshDef]] = pydantic.Field(None)
    CfnRoute: typing.Optional[dict[str, CfnRouteDef]] = pydantic.Field(None)
    CfnVirtualGateway: typing.Optional[dict[str, CfnVirtualGatewayDef]] = pydantic.Field(None)
    CfnVirtualNode: typing.Optional[dict[str, CfnVirtualNodeDef]] = pydantic.Field(None)
    CfnVirtualRouter: typing.Optional[dict[str, CfnVirtualRouterDef]] = pydantic.Field(None)
    CfnVirtualService: typing.Optional[dict[str, CfnVirtualServiceDef]] = pydantic.Field(None)
    CfnGatewayRouteProps: typing.Optional[dict[str, CfnGatewayRoutePropsDef]] = pydantic.Field(None)
    CfnMeshProps: typing.Optional[dict[str, CfnMeshPropsDef]] = pydantic.Field(None)
    CfnRouteProps: typing.Optional[dict[str, CfnRoutePropsDef]] = pydantic.Field(None)
    CfnVirtualGatewayProps: typing.Optional[dict[str, CfnVirtualGatewayPropsDef]] = pydantic.Field(None)
    CfnVirtualNodeProps: typing.Optional[dict[str, CfnVirtualNodePropsDef]] = pydantic.Field(None)
    CfnVirtualRouterProps: typing.Optional[dict[str, CfnVirtualRouterPropsDef]] = pydantic.Field(None)
    CfnVirtualServiceProps: typing.Optional[dict[str, CfnVirtualServicePropsDef]] = pydantic.Field(None)
    ...
