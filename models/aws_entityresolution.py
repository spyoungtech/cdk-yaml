from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.IdMappingTechniquesProperty
class CfnIdMappingWorkflow_IdMappingTechniquesPropertyDef(BaseStruct):
    id_mapping_type: typing.Optional[str] = pydantic.Field(None, description='The type of ID mapping.\n')
    provider_properties: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_ProviderPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object which defines any additional configurations required by the provider service.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-idmappingworkflow-idmappingtechniques.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    id_mapping_techniques_property = entityresolution.CfnIdMappingWorkflow.IdMappingTechniquesProperty(\n        id_mapping_type="idMappingType",\n        provider_properties=entityresolution.CfnIdMappingWorkflow.ProviderPropertiesProperty(\n            provider_service_arn="providerServiceArn",\n\n            # the properties below are optional\n            intermediate_source_configuration=entityresolution.CfnIdMappingWorkflow.IntermediateSourceConfigurationProperty(\n                intermediate_s3_path="intermediateS3Path"\n            ),\n            provider_configuration={\n                "provider_configuration_key": "providerConfiguration"\n            }\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['id_mapping_type', 'provider_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.IdMappingTechniquesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.IdMappingWorkflowInputSourceProperty
class CfnIdMappingWorkflow_IdMappingWorkflowInputSourcePropertyDef(BaseStruct):
    input_source_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An AWS Glue table ARN for the input source table.\n')
    schema_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN (Amazon Resource Name) that AWS Entity Resolution generated for the ``SchemaMapping`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-idmappingworkflow-idmappingworkflowinputsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    id_mapping_workflow_input_source_property = entityresolution.CfnIdMappingWorkflow.IdMappingWorkflowInputSourceProperty(\n        input_source_arn="inputSourceArn",\n        schema_arn="schemaArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input_source_arn', 'schema_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.IdMappingWorkflowInputSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.IdMappingWorkflowOutputSourceProperty
class CfnIdMappingWorkflow_IdMappingWorkflowOutputSourcePropertyDef(BaseStruct):
    output_s3_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The S3 path to which AWS Entity Resolution will write the output table.\n')
    kms_arn: typing.Optional[str] = pydantic.Field(None, description='Customer AWS KMS ARN for encryption at rest. If not provided, system will use an AWS Entity Resolution managed KMS key.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-idmappingworkflow-idmappingworkflowoutputsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    id_mapping_workflow_output_source_property = entityresolution.CfnIdMappingWorkflow.IdMappingWorkflowOutputSourceProperty(\n        output_s3_path="outputS3Path",\n\n        # the properties below are optional\n        kms_arn="kmsArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['output_s3_path', 'kms_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.IdMappingWorkflowOutputSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.IntermediateSourceConfigurationProperty
class CfnIdMappingWorkflow_IntermediateSourceConfigurationPropertyDef(BaseStruct):
    intermediate_s3_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon S3 location (bucket and prefix). For example: ``s3://provider_bucket/DOC-EXAMPLE-BUCKET``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-idmappingworkflow-intermediatesourceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    intermediate_source_configuration_property = entityresolution.CfnIdMappingWorkflow.IntermediateSourceConfigurationProperty(\n        intermediate_s3_path="intermediateS3Path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['intermediate_s3_path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.IntermediateSourceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.ProviderPropertiesProperty
class CfnIdMappingWorkflow_ProviderPropertiesPropertyDef(BaseStruct):
    provider_service_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the provider service.\n')
    intermediate_source_configuration: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_IntermediateSourceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.\n")
    provider_configuration: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The required configuration fields to use with the provider service.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-idmappingworkflow-providerproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    provider_properties_property = entityresolution.CfnIdMappingWorkflow.ProviderPropertiesProperty(\n        provider_service_arn="providerServiceArn",\n\n        # the properties below are optional\n        intermediate_source_configuration=entityresolution.CfnIdMappingWorkflow.IntermediateSourceConfigurationProperty(\n            intermediate_s3_path="intermediateS3Path"\n        ),\n        provider_configuration={\n            "provider_configuration_key": "providerConfiguration"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['provider_service_arn', 'intermediate_source_configuration', 'provider_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnIdMappingWorkflow.ProviderPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow.InputSourceProperty
class CfnMatchingWorkflow_InputSourcePropertyDef(BaseStruct):
    input_source_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An object containing ``InputSourceARN`` , ``SchemaName`` , and ``ApplyNormalization`` .\n')
    schema_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the schema.\n')
    apply_normalization: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an ``AttributeType`` of ``PHONE_NUMBER`` , and the data in the input table is in a format of 1234567890, AWS Entity Resolution will normalize this field in the output to (123)-456-7890.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-matchingworkflow-inputsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    input_source_property = entityresolution.CfnMatchingWorkflow.InputSourceProperty(\n        input_source_arn="inputSourceArn",\n        schema_arn="schemaArn",\n\n        # the properties below are optional\n        apply_normalization=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input_source_arn', 'schema_arn', 'apply_normalization']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow.InputSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow.IntermediateSourceConfigurationProperty
class CfnMatchingWorkflow_IntermediateSourceConfigurationPropertyDef(BaseStruct):
    intermediate_s3_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon S3 location (bucket and prefix). For example: ``s3://provider_bucket/DOC-EXAMPLE-BUCKET``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-matchingworkflow-intermediatesourceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    intermediate_source_configuration_property = entityresolution.CfnMatchingWorkflow.IntermediateSourceConfigurationProperty(\n        intermediate_s3_path="intermediateS3Path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['intermediate_s3_path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow.IntermediateSourceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow.OutputAttributeProperty
class CfnMatchingWorkflow_OutputAttributePropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name of a column to be written to the output. This must be an ``InputField`` name in the schema mapping.\n')
    hashed: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables the ability to hash the column values in the output.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-matchingworkflow-outputattribute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    output_attribute_property = entityresolution.CfnMatchingWorkflow.OutputAttributeProperty(\n        name="name",\n\n        # the properties below are optional\n        hashed=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'hashed']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow.OutputAttributeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow.OutputSourceProperty
class CfnMatchingWorkflow_OutputSourcePropertyDef(BaseStruct):
    output: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_OutputAttributePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``OutputAttribute`` objects, each of which have the fields ``Name`` and ``Hashed`` . Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.\n')
    output_s3_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The S3 path to which AWS Entity Resolution will write the output table.\n')
    apply_normalization: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an ``AttributeType`` of ``PHONE_NUMBER`` , and the data in the input table is in a format of 1234567890, AWS Entity Resolution will normalize this field in the output to (123)-456-7890.\n')
    kms_arn: typing.Optional[str] = pydantic.Field(None, description='Customer KMS ARN for encryption at rest. If not provided, system will use an AWS Entity Resolution managed KMS key.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-matchingworkflow-outputsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    output_source_property = entityresolution.CfnMatchingWorkflow.OutputSourceProperty(\n        output=[entityresolution.CfnMatchingWorkflow.OutputAttributeProperty(\n            name="name",\n\n            # the properties below are optional\n            hashed=False\n        )],\n        output_s3_path="outputS3Path",\n\n        # the properties below are optional\n        apply_normalization=False,\n        kms_arn="kmsArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['output', 'output_s3_path', 'apply_normalization', 'kms_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow.OutputSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow.ProviderPropertiesProperty
class CfnMatchingWorkflow_ProviderPropertiesPropertyDef(BaseStruct):
    provider_service_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the provider service.\n')
    intermediate_source_configuration: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_IntermediateSourceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.\n")
    provider_configuration: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The required configuration fields to use with the provider service.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-matchingworkflow-providerproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    provider_properties_property = entityresolution.CfnMatchingWorkflow.ProviderPropertiesProperty(\n        provider_service_arn="providerServiceArn",\n\n        # the properties below are optional\n        intermediate_source_configuration=entityresolution.CfnMatchingWorkflow.IntermediateSourceConfigurationProperty(\n            intermediate_s3_path="intermediateS3Path"\n        ),\n        provider_configuration={\n            "provider_configuration_key": "providerConfiguration"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['provider_service_arn', 'intermediate_source_configuration', 'provider_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow.ProviderPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow.ResolutionTechniquesProperty
class CfnMatchingWorkflow_ResolutionTechniquesPropertyDef(BaseStruct):
    provider_properties: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_ProviderPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties of the provider service.\n')
    resolution_type: typing.Optional[str] = pydantic.Field(None, description='The type of matching. There are two types of matching: ``RULE_MATCHING`` and ``ML_MATCHING`` .\n')
    rule_based_properties: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_RuleBasedPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object which defines the list of matching rules to run and has a field ``Rules`` , which is a list of rule objects.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-matchingworkflow-resolutiontechniques.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    resolution_techniques_property = entityresolution.CfnMatchingWorkflow.ResolutionTechniquesProperty(\n        provider_properties=entityresolution.CfnMatchingWorkflow.ProviderPropertiesProperty(\n            provider_service_arn="providerServiceArn",\n\n            # the properties below are optional\n            intermediate_source_configuration=entityresolution.CfnMatchingWorkflow.IntermediateSourceConfigurationProperty(\n                intermediate_s3_path="intermediateS3Path"\n            ),\n            provider_configuration={\n                "provider_configuration_key": "providerConfiguration"\n            }\n        ),\n        resolution_type="resolutionType",\n        rule_based_properties=entityresolution.CfnMatchingWorkflow.RuleBasedPropertiesProperty(\n            attribute_matching_model="attributeMatchingModel",\n            rules=[entityresolution.CfnMatchingWorkflow.RuleProperty(\n                matching_keys=["matchingKeys"],\n                rule_name="ruleName"\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['provider_properties', 'resolution_type', 'rule_based_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow.ResolutionTechniquesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow.RuleBasedPropertiesProperty
class CfnMatchingWorkflow_RuleBasedPropertiesPropertyDef(BaseStruct):
    attribute_matching_model: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The comparison type. You can either choose ``ONE_TO_ONE`` or ``MANY_TO_MANY`` as the AttributeMatchingModel. When choosing ``MANY_TO_MANY`` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the ``Email`` field of Profile A and the value of ``BusinessEmail`` field of Profile B matches, the two profiles are matched on the ``Email`` type. When choosing ``ONE_TO_ONE`` ,the system can only match if the sub-types are exact matches. For example, only when the value of the ``Email`` field of Profile A and the value of the ``Email`` field of Profile B matches, the two profiles are matched on the ``Email`` type.\n')
    rules: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_RulePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``Rule`` objects, each of which have fields ``RuleName`` and ``MatchingKeys`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-matchingworkflow-rulebasedproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    rule_based_properties_property = entityresolution.CfnMatchingWorkflow.RuleBasedPropertiesProperty(\n        attribute_matching_model="attributeMatchingModel",\n        rules=[entityresolution.CfnMatchingWorkflow.RuleProperty(\n            matching_keys=["matchingKeys"],\n            rule_name="ruleName"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attribute_matching_model', 'rules']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow.RuleBasedPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow.RuleProperty
class CfnMatchingWorkflow_RulePropertyDef(BaseStruct):
    matching_keys: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``MatchingKeys`` . The ``MatchingKeys`` must have been defined in the ``SchemaMapping`` . Two records are considered to match according to this rule if all of the ``MatchingKeys`` match.\n')
    rule_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the matching rule.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-matchingworkflow-rule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    rule_property = entityresolution.CfnMatchingWorkflow.RuleProperty(\n        matching_keys=["matchingKeys"],\n        rule_name="ruleName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['matching_keys', 'rule_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow.RuleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnSchemaMapping.SchemaInputAttributeProperty
class CfnSchemaMapping_SchemaInputAttributePropertyDef(BaseStruct):
    field_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A string containing the field name.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the attribute, selected from a list of values.\n')
    group_name: typing.Optional[str] = pydantic.Field(None, description='Instruct AWS Entity Resolution to combine several columns into a unified column with the identical attribute type. For example, when working with columns such as first_name, middle_name, and last_name, assigning them a common ``GroupName`` will prompt AWS Entity Resolution to concatenate them into a single value.\n')
    match_key: typing.Optional[str] = pydantic.Field(None, description="A key that allows grouping of multiple input attributes into a unified matching group. For example, let's consider a scenario where the source table contains various addresses, such as ``business_address`` and ``shipping_address`` . By assigning the ``MatchKey`` *Address* to both attributes, AWS Entity Resolution will match records across these fields to create a consolidated matching group. If no ``MatchKey`` is specified for a column, it won't be utilized for matching purposes but will still be included in the output table.\n")
    sub_type: typing.Optional[str] = pydantic.Field(None, description='The subtype of the attribute, selected from a list of values.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-entityresolution-schemamapping-schemainputattribute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    schema_input_attribute_property = entityresolution.CfnSchemaMapping.SchemaInputAttributeProperty(\n        field_name="fieldName",\n        type="type",\n\n        # the properties below are optional\n        group_name="groupName",\n        match_key="matchKey",\n        sub_type="subType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['field_name', 'type', 'group_name', 'match_key', 'sub_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnSchemaMapping.SchemaInputAttributeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnIdMappingWorkflow
class CfnIdMappingWorkflowDef(BaseCfnResource):
    id_mapping_techniques: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingTechniquesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='An object which defines the ``idMappingType`` and the ``providerProperties`` .\n')
    input_source_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingWorkflowInputSourcePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``InputSource`` objects, which have the fields ``InputSourceARN`` and ``SchemaName`` .\n')
    output_source_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingWorkflowOutputSourcePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``IdMappingWorkflowOutputSource`` objects, each of which contains fields ``OutputS3Path`` and ``Output`` .\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role. AWS Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.\n')
    workflow_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name of the workflow. There can't be multiple ``IdMappingWorkflows`` with the same name.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the workflow.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.')
    _init_params: typing.ClassVar[list[str]] = ['id_mapping_techniques', 'input_source_config', 'output_source_config', 'role_arn', 'workflow_name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['IdMappingTechniquesProperty', 'IdMappingWorkflowInputSourceProperty', 'IdMappingWorkflowOutputSourceProperty', 'IntermediateSourceConfigurationProperty', 'ProviderPropertiesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnIdMappingWorkflow'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_entityresolution.CfnIdMappingWorkflowDefConfig] = pydantic.Field(None)


class CfnIdMappingWorkflowDefConfig(pydantic.BaseModel):
    IdMappingTechniquesProperty: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefIdmappingtechniquespropertyParams]] = pydantic.Field(None, description='')
    IdMappingWorkflowInputSourceProperty: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefIdmappingworkflowinputsourcepropertyParams]] = pydantic.Field(None, description='')
    IdMappingWorkflowOutputSourceProperty: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefIdmappingworkflowoutputsourcepropertyParams]] = pydantic.Field(None, description='')
    IntermediateSourceConfigurationProperty: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefIntermediatesourceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ProviderPropertiesProperty: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefProviderpropertiespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_entityresolution.CfnIdMappingWorkflowDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnIdMappingWorkflowDefIdmappingtechniquespropertyParams(pydantic.BaseModel):
    id_mapping_type: typing.Optional[str] = pydantic.Field(None, description='')
    provider_properties: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_ProviderPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIdMappingWorkflowDefIdmappingworkflowinputsourcepropertyParams(pydantic.BaseModel):
    input_source_arn: str = pydantic.Field(..., description='')
    schema_arn: str = pydantic.Field(..., description='')
    ...

class CfnIdMappingWorkflowDefIdmappingworkflowoutputsourcepropertyParams(pydantic.BaseModel):
    output_s3_path: str = pydantic.Field(..., description='')
    kms_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIdMappingWorkflowDefIntermediatesourceconfigurationpropertyParams(pydantic.BaseModel):
    intermediate_s3_path: str = pydantic.Field(..., description='')
    ...

class CfnIdMappingWorkflowDefProviderpropertiespropertyParams(pydantic.BaseModel):
    provider_service_arn: str = pydantic.Field(..., description='')
    intermediate_source_configuration: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_IntermediateSourceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    provider_configuration: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnIdMappingWorkflowDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIdMappingWorkflowDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIdMappingWorkflowDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIdMappingWorkflowDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIdMappingWorkflowDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIdMappingWorkflowDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIdMappingWorkflowDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIdMappingWorkflowDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIdMappingWorkflowDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIdMappingWorkflowDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIdMappingWorkflowDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnIdMappingWorkflowDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIdMappingWorkflowDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIdMappingWorkflowDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflow
class CfnMatchingWorkflowDef(BaseCfnResource):
    input_source_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_InputSourcePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``InputSource`` objects, which have the fields ``InputSourceARN`` and ``SchemaName`` .\n')
    output_source_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_OutputSourcePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``OutputSource`` objects, each of which contains fields ``OutputS3Path`` , ``ApplyNormalization`` , and ``Output`` .\n')
    resolution_techniques: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_ResolutionTechniquesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='An object which defines the ``resolutionType`` and the ``ruleBasedProperties`` .\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role. AWS Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.\n')
    workflow_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name of the workflow. There can't be multiple ``MatchingWorkflows`` with the same name.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the workflow.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.')
    _init_params: typing.ClassVar[list[str]] = ['input_source_config', 'output_source_config', 'resolution_techniques', 'role_arn', 'workflow_name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['InputSourceProperty', 'IntermediateSourceConfigurationProperty', 'OutputAttributeProperty', 'OutputSourceProperty', 'ProviderPropertiesProperty', 'ResolutionTechniquesProperty', 'RuleBasedPropertiesProperty', 'RuleProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflow'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_entityresolution.CfnMatchingWorkflowDefConfig] = pydantic.Field(None)


class CfnMatchingWorkflowDefConfig(pydantic.BaseModel):
    InputSourceProperty: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefInputsourcepropertyParams]] = pydantic.Field(None, description='')
    IntermediateSourceConfigurationProperty: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefIntermediatesourceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    OutputAttributeProperty: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefOutputattributepropertyParams]] = pydantic.Field(None, description='')
    OutputSourceProperty: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefOutputsourcepropertyParams]] = pydantic.Field(None, description='')
    ProviderPropertiesProperty: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefProviderpropertiespropertyParams]] = pydantic.Field(None, description='')
    ResolutionTechniquesProperty: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefResolutiontechniquespropertyParams]] = pydantic.Field(None, description='')
    RuleBasedPropertiesProperty: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefRulebasedpropertiespropertyParams]] = pydantic.Field(None, description='')
    RuleProperty: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefRulepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_entityresolution.CfnMatchingWorkflowDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnMatchingWorkflowDefInputsourcepropertyParams(pydantic.BaseModel):
    input_source_arn: str = pydantic.Field(..., description='')
    schema_arn: str = pydantic.Field(..., description='')
    apply_normalization: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnMatchingWorkflowDefIntermediatesourceconfigurationpropertyParams(pydantic.BaseModel):
    intermediate_s3_path: str = pydantic.Field(..., description='')
    ...

class CfnMatchingWorkflowDefOutputattributepropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    hashed: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnMatchingWorkflowDefOutputsourcepropertyParams(pydantic.BaseModel):
    output: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_OutputAttributePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    output_s3_path: str = pydantic.Field(..., description='')
    apply_normalization: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    kms_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMatchingWorkflowDefProviderpropertiespropertyParams(pydantic.BaseModel):
    provider_service_arn: str = pydantic.Field(..., description='')
    intermediate_source_configuration: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_IntermediateSourceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    provider_configuration: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnMatchingWorkflowDefResolutiontechniquespropertyParams(pydantic.BaseModel):
    provider_properties: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_ProviderPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    resolution_type: typing.Optional[str] = pydantic.Field(None, description='')
    rule_based_properties: typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_RuleBasedPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnMatchingWorkflowDefRulebasedpropertiespropertyParams(pydantic.BaseModel):
    attribute_matching_model: str = pydantic.Field(..., description='')
    rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_RulePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnMatchingWorkflowDefRulepropertyParams(pydantic.BaseModel):
    matching_keys: typing.Sequence[str] = pydantic.Field(..., description='')
    rule_name: str = pydantic.Field(..., description='')
    ...

class CfnMatchingWorkflowDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMatchingWorkflowDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMatchingWorkflowDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMatchingWorkflowDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMatchingWorkflowDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMatchingWorkflowDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMatchingWorkflowDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMatchingWorkflowDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMatchingWorkflowDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMatchingWorkflowDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMatchingWorkflowDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMatchingWorkflowDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMatchingWorkflowDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMatchingWorkflowDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_entityresolution.CfnSchemaMapping
class CfnSchemaMappingDef(BaseCfnResource):
    mapped_input_fields: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnSchemaMapping_SchemaInputAttributePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``MappedInputFields`` . Each ``MappedInputField`` corresponds to a column the source data table, and contains column name plus additional information that AWS Entity Resolution uses for matching.\n')
    schema_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name of the schema. There can't be multiple ``SchemaMappings`` with the same name.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the schema.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.')
    _init_params: typing.ClassVar[list[str]] = ['mapped_input_fields', 'schema_name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['SchemaInputAttributeProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnSchemaMapping'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_entityresolution.CfnSchemaMappingDefConfig] = pydantic.Field(None)


class CfnSchemaMappingDefConfig(pydantic.BaseModel):
    SchemaInputAttributeProperty: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefSchemainputattributepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_entityresolution.CfnSchemaMappingDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSchemaMappingDefSchemainputattributepropertyParams(pydantic.BaseModel):
    field_name: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    group_name: typing.Optional[str] = pydantic.Field(None, description='')
    match_key: typing.Optional[str] = pydantic.Field(None, description='')
    sub_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSchemaMappingDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSchemaMappingDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSchemaMappingDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSchemaMappingDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSchemaMappingDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSchemaMappingDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSchemaMappingDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSchemaMappingDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSchemaMappingDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSchemaMappingDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSchemaMappingDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSchemaMappingDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSchemaMappingDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSchemaMappingDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_entityresolution.CfnIdMappingWorkflowProps
class CfnIdMappingWorkflowPropsDef(BaseCfnProperty):
    id_mapping_techniques: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingTechniquesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='An object which defines the ``idMappingType`` and the ``providerProperties`` .\n')
    input_source_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingWorkflowInputSourcePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``InputSource`` objects, which have the fields ``InputSourceARN`` and ``SchemaName`` .\n')
    output_source_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingWorkflowOutputSourcePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``IdMappingWorkflowOutputSource`` objects, each of which contains fields ``OutputS3Path`` and ``Output`` .\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role. AWS Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.\n')
    workflow_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name of the workflow. There can't be multiple ``IdMappingWorkflows`` with the same name.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the workflow.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-entityresolution-idmappingworkflow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    cfn_id_mapping_workflow_props = entityresolution.CfnIdMappingWorkflowProps(\n        id_mapping_techniques=entityresolution.CfnIdMappingWorkflow.IdMappingTechniquesProperty(\n            id_mapping_type="idMappingType",\n            provider_properties=entityresolution.CfnIdMappingWorkflow.ProviderPropertiesProperty(\n                provider_service_arn="providerServiceArn",\n\n                # the properties below are optional\n                intermediate_source_configuration=entityresolution.CfnIdMappingWorkflow.IntermediateSourceConfigurationProperty(\n                    intermediate_s3_path="intermediateS3Path"\n                ),\n                provider_configuration={\n                    "provider_configuration_key": "providerConfiguration"\n                }\n            )\n        ),\n        input_source_config=[entityresolution.CfnIdMappingWorkflow.IdMappingWorkflowInputSourceProperty(\n            input_source_arn="inputSourceArn",\n            schema_arn="schemaArn"\n        )],\n        output_source_config=[entityresolution.CfnIdMappingWorkflow.IdMappingWorkflowOutputSourceProperty(\n            output_s3_path="outputS3Path",\n\n            # the properties below are optional\n            kms_arn="kmsArn"\n        )],\n        role_arn="roleArn",\n        workflow_name="workflowName",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['id_mapping_techniques', 'input_source_config', 'output_source_config', 'role_arn', 'workflow_name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnIdMappingWorkflowProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnMatchingWorkflowProps
class CfnMatchingWorkflowPropsDef(BaseCfnProperty):
    input_source_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_InputSourcePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``InputSource`` objects, which have the fields ``InputSourceARN`` and ``SchemaName`` .\n')
    output_source_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_OutputSourcePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``OutputSource`` objects, each of which contains fields ``OutputS3Path`` , ``ApplyNormalization`` , and ``Output`` .\n')
    resolution_techniques: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_entityresolution.CfnMatchingWorkflow_ResolutionTechniquesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='An object which defines the ``resolutionType`` and the ``ruleBasedProperties`` .\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role. AWS Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.\n')
    workflow_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name of the workflow. There can't be multiple ``MatchingWorkflows`` with the same name.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the workflow.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-entityresolution-matchingworkflow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    cfn_matching_workflow_props = entityresolution.CfnMatchingWorkflowProps(\n        input_source_config=[entityresolution.CfnMatchingWorkflow.InputSourceProperty(\n            input_source_arn="inputSourceArn",\n            schema_arn="schemaArn",\n\n            # the properties below are optional\n            apply_normalization=False\n        )],\n        output_source_config=[entityresolution.CfnMatchingWorkflow.OutputSourceProperty(\n            output=[entityresolution.CfnMatchingWorkflow.OutputAttributeProperty(\n                name="name",\n\n                # the properties below are optional\n                hashed=False\n            )],\n            output_s3_path="outputS3Path",\n\n            # the properties below are optional\n            apply_normalization=False,\n            kms_arn="kmsArn"\n        )],\n        resolution_techniques=entityresolution.CfnMatchingWorkflow.ResolutionTechniquesProperty(\n            provider_properties=entityresolution.CfnMatchingWorkflow.ProviderPropertiesProperty(\n                provider_service_arn="providerServiceArn",\n\n                # the properties below are optional\n                intermediate_source_configuration=entityresolution.CfnMatchingWorkflow.IntermediateSourceConfigurationProperty(\n                    intermediate_s3_path="intermediateS3Path"\n                ),\n                provider_configuration={\n                    "provider_configuration_key": "providerConfiguration"\n                }\n            ),\n            resolution_type="resolutionType",\n            rule_based_properties=entityresolution.CfnMatchingWorkflow.RuleBasedPropertiesProperty(\n                attribute_matching_model="attributeMatchingModel",\n                rules=[entityresolution.CfnMatchingWorkflow.RuleProperty(\n                    matching_keys=["matchingKeys"],\n                    rule_name="ruleName"\n                )]\n            )\n        ),\n        role_arn="roleArn",\n        workflow_name="workflowName",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input_source_config', 'output_source_config', 'resolution_techniques', 'role_arn', 'workflow_name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnMatchingWorkflowProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_entityresolution.CfnSchemaMappingProps
class CfnSchemaMappingPropsDef(BaseCfnProperty):
    mapped_input_fields: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_entityresolution.CfnSchemaMapping_SchemaInputAttributePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of ``MappedInputFields`` . Each ``MappedInputField`` corresponds to a column the source data table, and contains column name plus additional information that AWS Entity Resolution uses for matching.\n')
    schema_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name of the schema. There can't be multiple ``SchemaMappings`` with the same name.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the schema.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-entityresolution-schemamapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_entityresolution as entityresolution\n\n    cfn_schema_mapping_props = entityresolution.CfnSchemaMappingProps(\n        mapped_input_fields=[entityresolution.CfnSchemaMapping.SchemaInputAttributeProperty(\n            field_name="fieldName",\n            type="type",\n\n            # the properties below are optional\n            group_name="groupName",\n            match_key="matchKey",\n            sub_type="subType"\n        )],\n        schema_name="schemaName",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mapped_input_fields', 'schema_name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_entityresolution.CfnSchemaMappingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnIdMappingWorkflow_IdMappingTechniquesProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingTechniquesPropertyDef]] = pydantic.Field(None)
    CfnIdMappingWorkflow_IdMappingWorkflowInputSourceProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingWorkflowInputSourcePropertyDef]] = pydantic.Field(None)
    CfnIdMappingWorkflow_IdMappingWorkflowOutputSourceProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnIdMappingWorkflow_IdMappingWorkflowOutputSourcePropertyDef]] = pydantic.Field(None)
    CfnIdMappingWorkflow_IntermediateSourceConfigurationProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnIdMappingWorkflow_IntermediateSourceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnIdMappingWorkflow_ProviderPropertiesProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnIdMappingWorkflow_ProviderPropertiesPropertyDef]] = pydantic.Field(None)
    CfnMatchingWorkflow_InputSourceProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflow_InputSourcePropertyDef]] = pydantic.Field(None)
    CfnMatchingWorkflow_IntermediateSourceConfigurationProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflow_IntermediateSourceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnMatchingWorkflow_OutputAttributeProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflow_OutputAttributePropertyDef]] = pydantic.Field(None)
    CfnMatchingWorkflow_OutputSourceProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflow_OutputSourcePropertyDef]] = pydantic.Field(None)
    CfnMatchingWorkflow_ProviderPropertiesProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflow_ProviderPropertiesPropertyDef]] = pydantic.Field(None)
    CfnMatchingWorkflow_ResolutionTechniquesProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflow_ResolutionTechniquesPropertyDef]] = pydantic.Field(None)
    CfnMatchingWorkflow_RuleBasedPropertiesProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflow_RuleBasedPropertiesPropertyDef]] = pydantic.Field(None)
    CfnMatchingWorkflow_RuleProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflow_RulePropertyDef]] = pydantic.Field(None)
    CfnSchemaMapping_SchemaInputAttributeProperty: typing.Optional[dict[str, models.aws_entityresolution.CfnSchemaMapping_SchemaInputAttributePropertyDef]] = pydantic.Field(None)
    CfnIdMappingWorkflow: typing.Optional[dict[str, models.aws_entityresolution.CfnIdMappingWorkflowDef]] = pydantic.Field(None)
    CfnMatchingWorkflow: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflowDef]] = pydantic.Field(None)
    CfnSchemaMapping: typing.Optional[dict[str, models.aws_entityresolution.CfnSchemaMappingDef]] = pydantic.Field(None)
    CfnIdMappingWorkflowProps: typing.Optional[dict[str, models.aws_entityresolution.CfnIdMappingWorkflowPropsDef]] = pydantic.Field(None)
    CfnMatchingWorkflowProps: typing.Optional[dict[str, models.aws_entityresolution.CfnMatchingWorkflowPropsDef]] = pydantic.Field(None)
    CfnSchemaMappingProps: typing.Optional[dict[str, models.aws_entityresolution.CfnSchemaMappingPropsDef]] = pydantic.Field(None)
    ...

import models
