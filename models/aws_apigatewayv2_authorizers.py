from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.HttpIamAuthorizer
class HttpIamAuthorizerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.HttpIamAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDefConfig] = pydantic.Field(None)


class HttpIamAuthorizerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDefBindParams]] = pydantic.Field(None, description='Bind this authorizer to a specified Http route.')

class HttpIamAuthorizerDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.HttpRouteDef] = pydantic.Field(..., description='The route to which the authorizer is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The scope for any constructs created as part of the bind.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.HttpJwtAuthorizer
class HttpJwtAuthorizerDef(BaseClass):
    jwt_issuer: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The base domain of the identity provider that issues JWT.\n')
    jwt_audience: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='The name of the authorizer. Default: - same value as ``id`` passed in the constructor\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The identity source for which authorization is requested. Default: ['$request.header.Authorization']")
    _init_params: typing.ClassVar[list[str]] = ['jwt_issuer', 'jwt_audience', 'authorizer_name', 'identity_source']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.HttpJwtAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDefConfig] = pydantic.Field(None)


class HttpJwtAuthorizerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDefBindParams]] = pydantic.Field(None, description='Bind this authorizer to a specified Http route.')

class HttpJwtAuthorizerDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.HttpRouteDef] = pydantic.Field(..., description='The route to which the authorizer is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The scope for any constructs created as part of the bind.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.HttpLambdaAuthorizer
class HttpLambdaAuthorizerDef(BaseClass):
    handler: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='Friendly authorizer name. Default: - same value as ``id`` passed in the constructor.\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The identity source for which authorization is requested. Default: ['$request.header.Authorization']\n")
    response_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigatewayv2_authorizers.HttpLambdaResponseType]] = pydantic.Field(None, description='The types of responses the lambda can return. If HttpLambdaResponseType.SIMPLE is included then response format 2.0 will be used. Default: [HttpLambdaResponseType.IAM]\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to ``Duration.seconds(0)``. Default: Duration.minutes(5)')
    _init_params: typing.ClassVar[list[str]] = ['handler', 'authorizer_name', 'identity_source', 'response_types', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.HttpLambdaAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDefConfig] = pydantic.Field(None)


class HttpLambdaAuthorizerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDefBindParams]] = pydantic.Field(None, description='Bind this authorizer to a specified Http route.')

class HttpLambdaAuthorizerDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.HttpRouteDef] = pydantic.Field(..., description='The route to which the authorizer is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The scope for any constructs created as part of the bind.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizer
class HttpUserPoolAuthorizerDef(BaseClass):
    pool: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cognito.UserPoolDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The user pool to use for authorization.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='Friendly name of the authorizer. Default: - same value as ``id`` passed in the constructor\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The identity source for which authorization is requested. Default: ['$request.header.Authorization']\n")
    user_pool_clients: typing.Optional[typing.Sequence[typing.Union[models.aws_cognito.UserPoolClientDef]]] = pydantic.Field(None, description='The user pool clients that should be used to authorize requests with the user pool. Default: - a new client will be created for the given user pool\n')
    user_pool_region: typing.Optional[str] = pydantic.Field(None, description='The AWS region in which the user pool is present. Default: - same region as the Route the authorizer is attached to.')
    _init_params: typing.ClassVar[list[str]] = ['pool', 'authorizer_name', 'identity_source', 'user_pool_clients', 'user_pool_region']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDefConfig] = pydantic.Field(None)


class HttpUserPoolAuthorizerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDefBindParams]] = pydantic.Field(None, description='Bind this authorizer to a specified Http route.')

class HttpUserPoolAuthorizerDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.HttpRouteDef] = pydantic.Field(..., description='The route to which the authorizer is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The scope for any constructs created as part of the bind.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.WebSocketIamAuthorizer
class WebSocketIamAuthorizerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.WebSocketIamAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2_authorizers.WebSocketIamAuthorizerDefConfig] = pydantic.Field(None)


class WebSocketIamAuthorizerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2_authorizers.WebSocketIamAuthorizerDefBindParams]] = pydantic.Field(None, description='Bind this authorizer to a specified WebSocket route.')

class WebSocketIamAuthorizerDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.WebSocketRouteDef] = pydantic.Field(..., description='The route to which the authorizer is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The scope for any constructs created as part of the bind.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizer
class WebSocketLambdaAuthorizerDef(BaseClass):
    handler: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='The name of the authorizer. Default: - same value as ``id`` passed in the constructor.\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The identity source for which authorization is requested. Request parameter match ``'route.request.querystring|header.[a-zA-z0-9._-]+'``. Staged variable match ``'stageVariables.[a-zA-Z0-9._-]+'``. Context parameter match ``'context.[a-zA-Z0-9._-]+'``. Default: ['route.request.header.Authorization']")
    _init_params: typing.ClassVar[list[str]] = ['handler', 'authorizer_name', 'identity_source']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerDefConfig] = pydantic.Field(None)


class WebSocketLambdaAuthorizerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerDefBindParams]] = pydantic.Field(None, description='Bind this authorizer to a specified WebSocket route.')

class WebSocketLambdaAuthorizerDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.WebSocketRouteDef] = pydantic.Field(..., description='The route to which the authorizer is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The scope for any constructs created as part of the bind.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.HttpJwtAuthorizerProps
class HttpJwtAuthorizerPropsDef(BaseStruct):
    jwt_audience: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='The name of the authorizer. Default: - same value as ``id`` passed in the constructor\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The identity source for which authorization is requested. Default: [\'$request.header.Authorization\']\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_apigatewayv2_authorizers import HttpJwtAuthorizer\n    from aws_cdk.aws_apigatewayv2_integrations import HttpUrlIntegration\n\n\n    issuer = "https://test.us.auth0.com"\n    authorizer = HttpJwtAuthorizer("BooksAuthorizer", issuer,\n        jwt_audience=["3131231"]\n    )\n\n    api = apigwv2.HttpApi(self, "HttpApi")\n\n    api.add_routes(\n        integration=HttpUrlIntegration("BooksIntegration", "https://get-books-proxy.example.com"),\n        path="/books",\n        authorizer=authorizer\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['jwt_audience', 'authorizer_name', 'identity_source']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.HttpJwtAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerProps
class HttpLambdaAuthorizerPropsDef(BaseStruct):
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='Friendly authorizer name. Default: - same value as ``id`` passed in the constructor.\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The identity source for which authorization is requested. Default: ['$request.header.Authorization']\n")
    response_types: typing.Optional[typing.Sequence[aws_cdk.aws_apigatewayv2_authorizers.HttpLambdaResponseType]] = pydantic.Field(None, description='The types of responses the lambda can return. If HttpLambdaResponseType.SIMPLE is included then response format 2.0 will be used. Default: [HttpLambdaResponseType.IAM]\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Disable caching by setting this to ``Duration.seconds(0)``. Default: Duration.minutes(5)\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_apigatewayv2_authorizers import HttpLambdaAuthorizer, HttpLambdaResponseType\n    from aws_cdk.aws_apigatewayv2_integrations import HttpUrlIntegration\n\n    # This function handles your auth logic\n    # auth_handler: lambda.Function\n\n\n    authorizer = HttpLambdaAuthorizer("BooksAuthorizer", auth_handler,\n        response_types=[HttpLambdaResponseType.SIMPLE]\n    )\n\n    api = apigwv2.HttpApi(self, "HttpApi")\n\n    api.add_routes(\n        integration=HttpUrlIntegration("BooksIntegration", "https://get-books-proxy.example.com"),\n        path="/books",\n        authorizer=authorizer\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_name', 'identity_source', 'response_types', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerProps
class HttpUserPoolAuthorizerPropsDef(BaseStruct):
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='Friendly name of the authorizer. Default: - same value as ``id`` passed in the constructor\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The identity source for which authorization is requested. Default: ['$request.header.Authorization']\n")
    user_pool_clients: typing.Optional[typing.Sequence[typing.Union[models.aws_cognito.UserPoolClientDef]]] = pydantic.Field(None, description='The user pool clients that should be used to authorize requests with the user pool. Default: - a new client will be created for the given user pool\n')
    user_pool_region: typing.Optional[str] = pydantic.Field(None, description='The AWS region in which the user pool is present. Default: - same region as the Route the authorizer is attached to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2_authorizers as apigatewayv2_authorizers\n    from aws_cdk import aws_cognito as cognito\n\n    # user_pool_client: cognito.UserPoolClient\n\n    http_user_pool_authorizer_props = apigatewayv2_authorizers.HttpUserPoolAuthorizerProps(\n        authorizer_name="authorizerName",\n        identity_source=["identitySource"],\n        user_pool_clients=[user_pool_client],\n        user_pool_region="userPoolRegion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_name', 'identity_source', 'user_pool_clients', 'user_pool_region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerProps
class WebSocketLambdaAuthorizerPropsDef(BaseStruct):
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='The name of the authorizer. Default: - same value as ``id`` passed in the constructor.\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The identity source for which authorization is requested. Request parameter match ``\'route.request.querystring|header.[a-zA-z0-9._-]+\'``. Staged variable match ``\'stageVariables.[a-zA-Z0-9._-]+\'``. Context parameter match ``\'context.[a-zA-Z0-9._-]+\'``. Default: [\'route.request.header.Authorization\']\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2_authorizers as apigatewayv2_authorizers\n\n    web_socket_lambda_authorizer_props = apigatewayv2_authorizers.WebSocketLambdaAuthorizerProps(\n        authorizer_name="authorizerName",\n        identity_source=["identitySource"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_name', 'identity_source']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2_authorizers.HttpLambdaResponseType
# skipping emum

class ModuleModel(pydantic.BaseModel):
    HttpIamAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDef]] = pydantic.Field(None)
    HttpJwtAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDef]] = pydantic.Field(None)
    HttpLambdaAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDef]] = pydantic.Field(None)
    HttpUserPoolAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDef]] = pydantic.Field(None)
    WebSocketIamAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.WebSocketIamAuthorizerDef]] = pydantic.Field(None)
    WebSocketLambdaAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerDef]] = pydantic.Field(None)
    HttpJwtAuthorizerProps: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerPropsDef]] = pydantic.Field(None)
    HttpLambdaAuthorizerProps: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerPropsDef]] = pydantic.Field(None)
    HttpUserPoolAuthorizerProps: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerPropsDef]] = pydantic.Field(None)
    WebSocketLambdaAuthorizerProps: typing.Optional[dict[str, models.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerPropsDef]] = pydantic.Field(None)
    ...

import models
