from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_mediatailor.CfnChannel.DashPlaylistSettingsProperty
class CfnChannel_DashPlaylistSettingsPropertyDef(BaseStruct):
    manifest_window_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The total duration (in seconds) of each manifest. Minimum value: ``30`` seconds. Maximum value: ``3600`` seconds. Default: - 0\n')
    min_buffer_time_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: ``2`` seconds. Maximum value: ``60`` seconds. Default: - 0\n')
    min_update_period_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: ``2`` seconds. Maximum value: ``60`` seconds. Default: - 0\n')
    suggested_presentation_delay_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: ``2`` seconds. Maximum value: ``60`` seconds. Default: - 0\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-channel-dashplaylistsettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    dash_playlist_settings_property = mediatailor.CfnChannel.DashPlaylistSettingsProperty(\n        manifest_window_seconds=123,\n        min_buffer_time_seconds=123,\n        min_update_period_seconds=123,\n        suggested_presentation_delay_seconds=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['manifest_window_seconds', 'min_buffer_time_seconds', 'min_update_period_seconds', 'suggested_presentation_delay_seconds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannel.DashPlaylistSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnChannel.HlsPlaylistSettingsProperty
class CfnChannel_HlsPlaylistSettingsPropertyDef(BaseStruct):
    ad_markup_type: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Determines the type of SCTE 35 tags to use in ad markup. Specify ``DATERANGE`` to use ``DATERANGE`` tags (for live or VOD content). Specify ``SCTE35_ENHANCED`` to use ``EXT-X-CUE-OUT`` and ``EXT-X-CUE-IN`` tags (for VOD content only).\n')
    manifest_window_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The total duration (in seconds) of each manifest. Minimum value: ``30`` seconds. Maximum value: ``3600`` seconds. Default: - 0\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-channel-hlsplaylistsettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    hls_playlist_settings_property = mediatailor.CfnChannel.HlsPlaylistSettingsProperty(\n        ad_markup_type=["adMarkupType"],\n        manifest_window_seconds=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ad_markup_type', 'manifest_window_seconds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannel.HlsPlaylistSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnChannel.LogConfigurationForChannelProperty
class CfnChannel_LogConfigurationForChannelPropertyDef(BaseStruct):
    log_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The log types.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-channel-logconfigurationforchannel.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    log_configuration_for_channel_property = mediatailor.CfnChannel.LogConfigurationForChannelProperty(\n        log_types=["logTypes"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['log_types']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannel.LogConfigurationForChannelProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnChannel.RequestOutputItemProperty
class CfnChannel_RequestOutputItemPropertyDef(BaseStruct):
    manifest_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the manifest for the channel. The name appears in the ``PlaybackUrl`` .\n')
    source_group: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A string used to match which ``HttpPackageConfiguration`` is used for each ``VodSource`` .\n')
    dash_playlist_settings: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_DashPlaylistSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='DASH manifest configuration parameters.\n')
    hls_playlist_settings: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_HlsPlaylistSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='HLS playlist configuration parameters.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-channel-requestoutputitem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    request_output_item_property = mediatailor.CfnChannel.RequestOutputItemProperty(\n        manifest_name="manifestName",\n        source_group="sourceGroup",\n\n        # the properties below are optional\n        dash_playlist_settings=mediatailor.CfnChannel.DashPlaylistSettingsProperty(\n            manifest_window_seconds=123,\n            min_buffer_time_seconds=123,\n            min_update_period_seconds=123,\n            suggested_presentation_delay_seconds=123\n        ),\n        hls_playlist_settings=mediatailor.CfnChannel.HlsPlaylistSettingsProperty(\n            ad_markup_type=["adMarkupType"],\n            manifest_window_seconds=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['manifest_name', 'source_group', 'dash_playlist_settings', 'hls_playlist_settings']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannel.RequestOutputItemProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnChannel.SlateSourceProperty
class CfnChannel_SlateSourcePropertyDef(BaseStruct):
    source_location_name: typing.Optional[str] = pydantic.Field(None, description='The name of the source location where the slate VOD source is stored.\n')
    vod_source_name: typing.Optional[str] = pydantic.Field(None, description='The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-channel-slatesource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    slate_source_property = mediatailor.CfnChannel.SlateSourceProperty(\n        source_location_name="sourceLocationName",\n        vod_source_name="vodSourceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source_location_name', 'vod_source_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannel.SlateSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnLiveSource.HttpPackageConfigurationProperty
class CfnLiveSource_HttpPackageConfigurationPropertyDef(BaseStruct):
    path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The relative path to the URL for this VOD source. This is combined with ``SourceLocation::HttpConfiguration::BaseUrl`` to form a valid URL.\n')
    source_group: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the source group. This has to match one of the ``Channel::Outputs::SourceGroup`` .\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The streaming protocol for this package configuration. Supported values are ``HLS`` and ``DASH`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-livesource-httppackageconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    http_package_configuration_property = mediatailor.CfnLiveSource.HttpPackageConfigurationProperty(\n        path="path",\n        source_group="sourceGroup",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['path', 'source_group', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnLiveSource.HttpPackageConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.AdMarkerPassthroughProperty
class CfnPlaybackConfiguration_AdMarkerPassthroughPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables ad marker passthrough for your configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-playbackconfiguration-admarkerpassthrough.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    ad_marker_passthrough_property = mediatailor.CfnPlaybackConfiguration.AdMarkerPassthroughProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.AdMarkerPassthroughProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.AvailSuppressionProperty
class CfnPlaybackConfiguration_AvailSuppressionPropertyDef(BaseStruct):
    mode: typing.Optional[str] = pydantic.Field(None, description="Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to ``BEHIND_LIVE_EDGE`` , ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window. When Mode is set to ``AFTER_LIVE_EDGE`` , ad suppression is active and MediaTailor won't fill ad breaks that are within the live edge plus the avail suppression value.\n")
    value: typing.Optional[str] = pydantic.Field(None, description='A live edge offset time in HH:MM:SS. MediaTailor won\'t fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won\'t fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won\'t fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won\'t fill ad breaks on or behind 45 minutes behind the live edge.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-playbackconfiguration-availsuppression.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    avail_suppression_property = mediatailor.CfnPlaybackConfiguration.AvailSuppressionProperty(\n        mode="mode",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mode', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.AvailSuppressionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.BumperProperty
class CfnPlaybackConfiguration_BumperPropertyDef(BaseStruct):
    end_url: typing.Optional[str] = pydantic.Field(None, description='The URL for the end bumper asset.\n')
    start_url: typing.Optional[str] = pydantic.Field(None, description='The URL for the start bumper asset.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-playbackconfiguration-bumper.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    bumper_property = mediatailor.CfnPlaybackConfiguration.BumperProperty(\n        end_url="endUrl",\n        start_url="startUrl"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['end_url', 'start_url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.BumperProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.CdnConfigurationProperty
class CfnPlaybackConfiguration_CdnConfigurationPropertyDef(BaseStruct):
    ad_segment_url_prefix: typing.Optional[str] = pydantic.Field(None, description="A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor. ** .amazonaws.com. Then specify the rule's name in this ``AdSegmentUrlPrefix`` . When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.\n")
    content_segment_url_prefix: typing.Optional[str] = pydantic.Field(None, description='A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule\'s name in this ``ContentSegmentUrlPrefix`` . When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-playbackconfiguration-cdnconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    cdn_configuration_property = mediatailor.CfnPlaybackConfiguration.CdnConfigurationProperty(\n        ad_segment_url_prefix="adSegmentUrlPrefix",\n        content_segment_url_prefix="contentSegmentUrlPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ad_segment_url_prefix', 'content_segment_url_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.CdnConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.DashConfigurationProperty
class CfnPlaybackConfiguration_DashConfigurationPropertyDef(BaseStruct):
    manifest_endpoint_prefix: typing.Optional[str] = pydantic.Field(None, description='The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.\n')
    mpd_location: typing.Optional[str] = pydantic.Field(None, description="The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are ``DISABLED`` and ``EMT_DEFAULT`` . The ``EMT_DEFAULT`` setting enables the inclusion of the tag and is the default value.\n")
    origin_manifest_type: typing.Optional[str] = pydantic.Field(None, description='The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to ``SINGLE_PERIOD`` . The default setting is ``MULTI_PERIOD`` . For multi-period manifests, omit this setting or set it to ``MULTI_PERIOD`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-playbackconfiguration-dashconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    dash_configuration_property = mediatailor.CfnPlaybackConfiguration.DashConfigurationProperty(\n        manifest_endpoint_prefix="manifestEndpointPrefix",\n        mpd_location="mpdLocation",\n        origin_manifest_type="originManifestType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['manifest_endpoint_prefix', 'mpd_location', 'origin_manifest_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.DashConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.HlsConfigurationProperty
class CfnPlaybackConfiguration_HlsConfigurationPropertyDef(BaseStruct):
    manifest_endpoint_prefix: typing.Optional[str] = pydantic.Field(None, description='The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-playbackconfiguration-hlsconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    hls_configuration_property = mediatailor.CfnPlaybackConfiguration.HlsConfigurationProperty(\n        manifest_endpoint_prefix="manifestEndpointPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['manifest_endpoint_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.HlsConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.LivePreRollConfigurationProperty
class CfnPlaybackConfiguration_LivePreRollConfigurationPropertyDef(BaseStruct):
    ad_decision_server_url: typing.Optional[str] = pydantic.Field(None, description='The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.\n')
    max_duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won\'t play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-playbackconfiguration-liveprerollconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    live_pre_roll_configuration_property = mediatailor.CfnPlaybackConfiguration.LivePreRollConfigurationProperty(\n        ad_decision_server_url="adDecisionServerUrl",\n        max_duration_seconds=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ad_decision_server_url', 'max_duration_seconds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.LivePreRollConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.ManifestProcessingRulesProperty
class CfnPlaybackConfiguration_ManifestProcessingRulesPropertyDef(BaseStruct):
    ad_marker_passthrough: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_AdMarkerPassthroughPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='For HLS, when set to ``true`` , MediaTailor passes through ``EXT-X-CUE-IN`` , ``EXT-X-CUE-OUT`` , and ``EXT-X-SPLICEPOINT-SCTE35`` ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if ``EXT-X-CUE-OUT`` has a value of ``60`` , but no ads are filled for that ad break, MediaTailor will not set the value to ``0`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-playbackconfiguration-manifestprocessingrules.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    manifest_processing_rules_property = mediatailor.CfnPlaybackConfiguration.ManifestProcessingRulesProperty(\n        ad_marker_passthrough=mediatailor.CfnPlaybackConfiguration.AdMarkerPassthroughProperty(\n            enabled=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ad_marker_passthrough']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration.ManifestProcessingRulesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnSourceLocation.AccessConfigurationProperty
class CfnSourceLocation_AccessConfigurationPropertyDef(BaseStruct):
    access_type: typing.Optional[str] = pydantic.Field(None, description='The type of authentication used to access content from ``HttpConfiguration::BaseUrl`` on your source location. Accepted value: ``S3_SIGV4`` . ``S3_SIGV4`` - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name. Before you can use ``S3_SIGV4`` , you must meet these requirements: • You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide. • The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations. • The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.\n')
    secrets_manager_access_token_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_SecretsManagerAccessTokenConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='AWS Secrets Manager access token configuration parameters.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-sourcelocation-accessconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    access_configuration_property = mediatailor.CfnSourceLocation.AccessConfigurationProperty(\n        access_type="accessType",\n        secrets_manager_access_token_configuration=mediatailor.CfnSourceLocation.SecretsManagerAccessTokenConfigurationProperty(\n            header_name="headerName",\n            secret_arn="secretArn",\n            secret_string_key="secretStringKey"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_type', 'secrets_manager_access_token_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnSourceLocation.AccessConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnSourceLocation.DefaultSegmentDeliveryConfigurationProperty
class CfnSourceLocation_DefaultSegmentDeliveryConfigurationPropertyDef(BaseStruct):
    base_url: typing.Optional[str] = pydantic.Field(None, description='The hostname of the server that will be used to serve segments. This string must include the protocol, such as *https://* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-sourcelocation-defaultsegmentdeliveryconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    default_segment_delivery_configuration_property = mediatailor.CfnSourceLocation.DefaultSegmentDeliveryConfigurationProperty(\n        base_url="baseUrl"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnSourceLocation.DefaultSegmentDeliveryConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnSourceLocation.HttpConfigurationProperty
class CfnSourceLocation_HttpConfigurationPropertyDef(BaseStruct):
    base_url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The base URL for the source location host server. This string must include the protocol, such as *https://* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-sourcelocation-httpconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    http_configuration_property = mediatailor.CfnSourceLocation.HttpConfigurationProperty(\n        base_url="baseUrl"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnSourceLocation.HttpConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnSourceLocation.SecretsManagerAccessTokenConfigurationProperty
class CfnSourceLocation_SecretsManagerAccessTokenConfigurationPropertyDef(BaseStruct):
    header_name: typing.Optional[str] = pydantic.Field(None, description='The name of the HTTP header used to supply the access token in requests to the source location.\n')
    secret_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.\n')
    secret_string_key: typing.Optional[str] = pydantic.Field(None, description='The AWS Secrets Manager `SecretString <https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html>`_ key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-sourcelocation-secretsmanageraccesstokenconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    secrets_manager_access_token_configuration_property = mediatailor.CfnSourceLocation.SecretsManagerAccessTokenConfigurationProperty(\n        header_name="headerName",\n        secret_arn="secretArn",\n        secret_string_key="secretStringKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['header_name', 'secret_arn', 'secret_string_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnSourceLocation.SecretsManagerAccessTokenConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnSourceLocation.SegmentDeliveryConfigurationProperty
class CfnSourceLocation_SegmentDeliveryConfigurationPropertyDef(BaseStruct):
    base_url: typing.Optional[str] = pydantic.Field(None, description="The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as ``https://example.com/some/path`` . To use a relative URL specify the relative path, such as ``/some/path*`` .\n")
    name: typing.Optional[str] = pydantic.Field(None, description='A unique identifier used to distinguish between multiple segment delivery configurations in a source location.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-sourcelocation-segmentdeliveryconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    segment_delivery_configuration_property = mediatailor.CfnSourceLocation.SegmentDeliveryConfigurationProperty(\n        base_url="baseUrl",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_url', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnSourceLocation.SegmentDeliveryConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnVodSource.HttpPackageConfigurationProperty
class CfnVodSource_HttpPackageConfigurationPropertyDef(BaseStruct):
    path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The relative path to the URL for this VOD source. This is combined with ``SourceLocation::HttpConfiguration::BaseUrl`` to form a valid URL.\n')
    source_group: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the source group. This has to match one of the ``Channel::Outputs::SourceGroup`` .\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The streaming protocol for this package configuration. Supported values are ``HLS`` and ``DASH`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mediatailor-vodsource-httppackageconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    http_package_configuration_property = mediatailor.CfnVodSource.HttpPackageConfigurationProperty(\n        path="path",\n        source_group="sourceGroup",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['path', 'source_group', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnVodSource.HttpPackageConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnChannel
class CfnChannelDef(BaseCfnResource):
    channel_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the channel.\n')
    outputs: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_RequestOutputItemPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The channel's output properties.\n")
    playback_mode: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of playback mode for this channel. ``LINEAR`` - Programs play back-to-back only once. ``LOOP`` - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.\n')
    filler_slate: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_SlateSourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the ``LINEAR`` ``PlaybackMode`` . MediaTailor doesn't support filler slate for channels using the ``LOOP`` ``PlaybackMode`` .\n")
    log_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_LogConfigurationForChannelPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The log configuration.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .\n')
    tier: typing.Optional[str] = pydantic.Field(None, description='The tier for this channel. STANDARD tier channels can contain live programs.')
    _init_params: typing.ClassVar[list[str]] = ['channel_name', 'outputs', 'playback_mode', 'filler_slate', 'log_configuration', 'tags', 'tier']
    _method_names: typing.ClassVar[list[str]] = ['DashPlaylistSettingsProperty', 'HlsPlaylistSettingsProperty', 'LogConfigurationForChannelProperty', 'RequestOutputItemProperty', 'SlateSourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnChannelDefConfig] = pydantic.Field(None)


class CfnChannelDefConfig(pydantic.BaseModel):
    DashPlaylistSettingsProperty: typing.Optional[list[CfnChannelDefDashplaylistsettingspropertyParams]] = pydantic.Field(None, description='')
    HlsPlaylistSettingsProperty: typing.Optional[list[CfnChannelDefHlsplaylistsettingspropertyParams]] = pydantic.Field(None, description='')
    LogConfigurationForChannelProperty: typing.Optional[list[CfnChannelDefLogconfigurationforchannelpropertyParams]] = pydantic.Field(None, description='')
    RequestOutputItemProperty: typing.Optional[list[CfnChannelDefRequestoutputitempropertyParams]] = pydantic.Field(None, description='')
    SlateSourceProperty: typing.Optional[list[CfnChannelDefSlatesourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnChannelDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnChannelDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnChannelDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnChannelDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnChannelDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnChannelDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnChannelDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnChannelDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnChannelDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnChannelDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnChannelDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnChannelDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnChannelDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnChannelDefDashplaylistsettingspropertyParams(pydantic.BaseModel):
    manifest_window_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min_buffer_time_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min_update_period_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    suggested_presentation_delay_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnChannelDefHlsplaylistsettingspropertyParams(pydantic.BaseModel):
    ad_markup_type: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    manifest_window_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnChannelDefLogconfigurationforchannelpropertyParams(pydantic.BaseModel):
    log_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnChannelDefRequestoutputitempropertyParams(pydantic.BaseModel):
    manifest_name: str = pydantic.Field(..., description='')
    source_group: str = pydantic.Field(..., description='')
    dash_playlist_settings: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_DashPlaylistSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    hls_playlist_settings: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_HlsPlaylistSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnChannelDefSlatesourcepropertyParams(pydantic.BaseModel):
    source_location_name: typing.Optional[str] = pydantic.Field(None, description='')
    vod_source_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnChannelDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnChannelDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnChannelDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnChannelDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnChannelDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnChannelDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnChannelDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnChannelDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnChannelDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnChannelDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnChannelDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnChannelDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnChannelDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnChannelDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediatailor.CfnChannelPolicy
class CfnChannelPolicyDef(BaseCfnResource):
    channel_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the channel associated with this Channel Policy.\n')
    policy: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM policy for the channel. IAM policies are used to control access to your channel.')
    _init_params: typing.ClassVar[list[str]] = ['channel_name', 'policy']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannelPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnChannelPolicyDefConfig] = pydantic.Field(None)


class CfnChannelPolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnChannelPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnChannelPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnChannelPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnChannelPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnChannelPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnChannelPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnChannelPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnChannelPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnChannelPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnChannelPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnChannelPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnChannelPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnChannelPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnChannelPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnChannelPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnChannelPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnChannelPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnChannelPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnChannelPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnChannelPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnChannelPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnChannelPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnChannelPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnChannelPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnChannelPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnChannelPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnChannelPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediatailor.CfnLiveSource
class CfnLiveSourceDef(BaseCfnResource):
    http_package_configurations: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnLiveSource_HttpPackageConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP package configurations for the live source.\n')
    live_source_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name that's used to refer to a live source.\n")
    source_location_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the source location.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['http_package_configurations', 'live_source_name', 'source_location_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['HttpPackageConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnLiveSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLiveSourceDefConfig] = pydantic.Field(None)


class CfnLiveSourceDefConfig(pydantic.BaseModel):
    HttpPackageConfigurationProperty: typing.Optional[list[CfnLiveSourceDefHttppackageconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnLiveSourceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLiveSourceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLiveSourceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLiveSourceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLiveSourceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLiveSourceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLiveSourceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLiveSourceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLiveSourceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLiveSourceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLiveSourceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLiveSourceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLiveSourceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLiveSourceDefHttppackageconfigurationpropertyParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='')
    source_group: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnLiveSourceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLiveSourceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLiveSourceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLiveSourceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLiveSourceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLiveSourceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLiveSourceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLiveSourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLiveSourceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLiveSourceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLiveSourceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLiveSourceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLiveSourceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLiveSourceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfiguration
class CfnPlaybackConfigurationDef(BaseCfnResource):
    ad_decision_server_url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the playback configuration.\n')
    video_content_source_url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.\n')
    avail_suppression: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_AvailSuppressionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see `Ad Suppression <https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html>`_ .\n')
    bumper: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_BumperPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see `Bumpers <https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html>`_ .\n')
    cdn_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_CdnConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.\n')
    configuration_aliases: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Any], None] = pydantic.Field(None, description='The player parameters and aliases used as dynamic variables during session initialization. For more information, see `Domain Variables <https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html>`_ .\n')
    dash_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_DashConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for a DASH source.\n')
    hls_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_HlsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for HLS content.\n')
    live_pre_roll_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_LivePreRollConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for pre-roll ad insertion.\n')
    manifest_processing_rules: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_ManifestProcessingRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.\n')
    personalization_threshold_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to *ad replacement* in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see `Ad Behavior in AWS Elemental MediaTailor <https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html>`_ .\n')
    slate_ad_url: typing.Optional[str] = pydantic.Field(None, description="The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .\n')
    transcode_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.')
    _init_params: typing.ClassVar[list[str]] = ['ad_decision_server_url', 'name', 'video_content_source_url', 'avail_suppression', 'bumper', 'cdn_configuration', 'configuration_aliases', 'dash_configuration', 'hls_configuration', 'live_pre_roll_configuration', 'manifest_processing_rules', 'personalization_threshold_seconds', 'slate_ad_url', 'tags', 'transcode_profile_name']
    _method_names: typing.ClassVar[list[str]] = ['AdMarkerPassthroughProperty', 'AvailSuppressionProperty', 'BumperProperty', 'CdnConfigurationProperty', 'DashConfigurationProperty', 'HlsConfigurationProperty', 'LivePreRollConfigurationProperty', 'ManifestProcessingRulesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPlaybackConfigurationDefConfig] = pydantic.Field(None)


class CfnPlaybackConfigurationDefConfig(pydantic.BaseModel):
    AdMarkerPassthroughProperty: typing.Optional[list[CfnPlaybackConfigurationDefAdmarkerpassthroughpropertyParams]] = pydantic.Field(None, description='')
    AvailSuppressionProperty: typing.Optional[list[CfnPlaybackConfigurationDefAvailsuppressionpropertyParams]] = pydantic.Field(None, description='')
    BumperProperty: typing.Optional[list[CfnPlaybackConfigurationDefBumperpropertyParams]] = pydantic.Field(None, description='')
    CdnConfigurationProperty: typing.Optional[list[CfnPlaybackConfigurationDefCdnconfigurationpropertyParams]] = pydantic.Field(None, description='')
    DashConfigurationProperty: typing.Optional[list[CfnPlaybackConfigurationDefDashconfigurationpropertyParams]] = pydantic.Field(None, description='')
    HlsConfigurationProperty: typing.Optional[list[CfnPlaybackConfigurationDefHlsconfigurationpropertyParams]] = pydantic.Field(None, description='')
    LivePreRollConfigurationProperty: typing.Optional[list[CfnPlaybackConfigurationDefLiveprerollconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ManifestProcessingRulesProperty: typing.Optional[list[CfnPlaybackConfigurationDefManifestprocessingrulespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnPlaybackConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPlaybackConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPlaybackConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPlaybackConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPlaybackConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPlaybackConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPlaybackConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPlaybackConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPlaybackConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPlaybackConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPlaybackConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPlaybackConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPlaybackConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPlaybackConfigurationDefAdmarkerpassthroughpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnPlaybackConfigurationDefAvailsuppressionpropertyParams(pydantic.BaseModel):
    mode: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPlaybackConfigurationDefBumperpropertyParams(pydantic.BaseModel):
    end_url: typing.Optional[str] = pydantic.Field(None, description='')
    start_url: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPlaybackConfigurationDefCdnconfigurationpropertyParams(pydantic.BaseModel):
    ad_segment_url_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    content_segment_url_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPlaybackConfigurationDefDashconfigurationpropertyParams(pydantic.BaseModel):
    manifest_endpoint_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    mpd_location: typing.Optional[str] = pydantic.Field(None, description='')
    origin_manifest_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPlaybackConfigurationDefHlsconfigurationpropertyParams(pydantic.BaseModel):
    manifest_endpoint_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPlaybackConfigurationDefLiveprerollconfigurationpropertyParams(pydantic.BaseModel):
    ad_decision_server_url: typing.Optional[str] = pydantic.Field(None, description='')
    max_duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnPlaybackConfigurationDefManifestprocessingrulespropertyParams(pydantic.BaseModel):
    ad_marker_passthrough: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_AdMarkerPassthroughPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPlaybackConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPlaybackConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPlaybackConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPlaybackConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPlaybackConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPlaybackConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPlaybackConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPlaybackConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPlaybackConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPlaybackConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPlaybackConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPlaybackConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPlaybackConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPlaybackConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediatailor.CfnSourceLocation
class CfnSourceLocationDef(BaseCfnResource):
    http_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_HttpConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP configuration for the source location.\n')
    source_location_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the source location.\n')
    access_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_AccessConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The access configuration for the source location.\n')
    default_segment_delivery_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_DefaultSegmentDeliveryConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default segment delivery configuration.\n')
    segment_delivery_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_SegmentDeliveryConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The segment delivery configurations for the source location.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['http_configuration', 'source_location_name', 'access_configuration', 'default_segment_delivery_configuration', 'segment_delivery_configurations', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AccessConfigurationProperty', 'DefaultSegmentDeliveryConfigurationProperty', 'HttpConfigurationProperty', 'SecretsManagerAccessTokenConfigurationProperty', 'SegmentDeliveryConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnSourceLocation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSourceLocationDefConfig] = pydantic.Field(None)


class CfnSourceLocationDefConfig(pydantic.BaseModel):
    AccessConfigurationProperty: typing.Optional[list[CfnSourceLocationDefAccessconfigurationpropertyParams]] = pydantic.Field(None, description='')
    DefaultSegmentDeliveryConfigurationProperty: typing.Optional[list[CfnSourceLocationDefDefaultsegmentdeliveryconfigurationpropertyParams]] = pydantic.Field(None, description='')
    HttpConfigurationProperty: typing.Optional[list[CfnSourceLocationDefHttpconfigurationpropertyParams]] = pydantic.Field(None, description='')
    SecretsManagerAccessTokenConfigurationProperty: typing.Optional[list[CfnSourceLocationDefSecretsmanageraccesstokenconfigurationpropertyParams]] = pydantic.Field(None, description='')
    SegmentDeliveryConfigurationProperty: typing.Optional[list[CfnSourceLocationDefSegmentdeliveryconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnSourceLocationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSourceLocationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSourceLocationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSourceLocationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSourceLocationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSourceLocationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSourceLocationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSourceLocationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSourceLocationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSourceLocationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSourceLocationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSourceLocationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSourceLocationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSourceLocationDefAccessconfigurationpropertyParams(pydantic.BaseModel):
    access_type: typing.Optional[str] = pydantic.Field(None, description='')
    secrets_manager_access_token_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_SecretsManagerAccessTokenConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnSourceLocationDefDefaultsegmentdeliveryconfigurationpropertyParams(pydantic.BaseModel):
    base_url: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSourceLocationDefHttpconfigurationpropertyParams(pydantic.BaseModel):
    base_url: str = pydantic.Field(..., description='')
    ...

class CfnSourceLocationDefSecretsmanageraccesstokenconfigurationpropertyParams(pydantic.BaseModel):
    header_name: typing.Optional[str] = pydantic.Field(None, description='')
    secret_arn: typing.Optional[str] = pydantic.Field(None, description='')
    secret_string_key: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSourceLocationDefSegmentdeliveryconfigurationpropertyParams(pydantic.BaseModel):
    base_url: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSourceLocationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSourceLocationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSourceLocationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSourceLocationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSourceLocationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSourceLocationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSourceLocationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSourceLocationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSourceLocationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSourceLocationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSourceLocationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSourceLocationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSourceLocationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSourceLocationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediatailor.CfnVodSource
class CfnVodSourceDef(BaseCfnResource):
    http_package_configurations: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnVodSource_HttpPackageConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP package configurations for the VOD source.\n')
    source_location_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the source location that the VOD source is associated with.\n')
    vod_source_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the VOD source.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['http_package_configurations', 'source_location_name', 'vod_source_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['HttpPackageConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnVodSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVodSourceDefConfig] = pydantic.Field(None)


class CfnVodSourceDefConfig(pydantic.BaseModel):
    HttpPackageConfigurationProperty: typing.Optional[list[CfnVodSourceDefHttppackageconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVodSourceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVodSourceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVodSourceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVodSourceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVodSourceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVodSourceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVodSourceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVodSourceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVodSourceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVodSourceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVodSourceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVodSourceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVodSourceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVodSourceDefHttppackageconfigurationpropertyParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='')
    source_group: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnVodSourceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVodSourceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVodSourceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVodSourceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVodSourceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVodSourceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVodSourceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVodSourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVodSourceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVodSourceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVodSourceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnVodSourceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVodSourceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVodSourceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_mediatailor.CfnChannelPolicyProps
class CfnChannelPolicyPropsDef(BaseCfnProperty):
    channel_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the channel associated with this Channel Policy.\n')
    policy: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM policy for the channel. IAM policies are used to control access to your channel.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediatailor-channelpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    # policy: Any\n\n    cfn_channel_policy_props = mediatailor.CfnChannelPolicyProps(\n        channel_name="channelName",\n        policy=policy\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['channel_name', 'policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannelPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnChannelProps
class CfnChannelPropsDef(BaseCfnProperty):
    channel_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the channel.\n')
    outputs: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_RequestOutputItemPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The channel's output properties.\n")
    playback_mode: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of playback mode for this channel. ``LINEAR`` - Programs play back-to-back only once. ``LOOP`` - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.\n')
    filler_slate: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_SlateSourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the ``LINEAR`` ``PlaybackMode`` . MediaTailor doesn't support filler slate for channels using the ``LOOP`` ``PlaybackMode`` .\n")
    log_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnChannel_LogConfigurationForChannelPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The log configuration.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .\n')
    tier: typing.Optional[str] = pydantic.Field(None, description='The tier for this channel. STANDARD tier channels can contain live programs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediatailor-channel.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    cfn_channel_props = mediatailor.CfnChannelProps(\n        channel_name="channelName",\n        outputs=[mediatailor.CfnChannel.RequestOutputItemProperty(\n            manifest_name="manifestName",\n            source_group="sourceGroup",\n\n            # the properties below are optional\n            dash_playlist_settings=mediatailor.CfnChannel.DashPlaylistSettingsProperty(\n                manifest_window_seconds=123,\n                min_buffer_time_seconds=123,\n                min_update_period_seconds=123,\n                suggested_presentation_delay_seconds=123\n            ),\n            hls_playlist_settings=mediatailor.CfnChannel.HlsPlaylistSettingsProperty(\n                ad_markup_type=["adMarkupType"],\n                manifest_window_seconds=123\n            )\n        )],\n        playback_mode="playbackMode",\n\n        # the properties below are optional\n        filler_slate=mediatailor.CfnChannel.SlateSourceProperty(\n            source_location_name="sourceLocationName",\n            vod_source_name="vodSourceName"\n        ),\n        log_configuration=mediatailor.CfnChannel.LogConfigurationForChannelProperty(\n            log_types=["logTypes"]\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        tier="tier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['channel_name', 'outputs', 'playback_mode', 'filler_slate', 'log_configuration', 'tags', 'tier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnChannelProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnLiveSourceProps
class CfnLiveSourcePropsDef(BaseCfnProperty):
    http_package_configurations: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnLiveSource_HttpPackageConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP package configurations for the live source.\n')
    live_source_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name that's used to refer to a live source.\n")
    source_location_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the source location.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediatailor-livesource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    cfn_live_source_props = mediatailor.CfnLiveSourceProps(\n        http_package_configurations=[mediatailor.CfnLiveSource.HttpPackageConfigurationProperty(\n            path="path",\n            source_group="sourceGroup",\n            type="type"\n        )],\n        live_source_name="liveSourceName",\n        source_location_name="sourceLocationName",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_package_configurations', 'live_source_name', 'source_location_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnLiveSourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnPlaybackConfigurationProps
class CfnPlaybackConfigurationPropsDef(BaseCfnProperty):
    ad_decision_server_url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the playback configuration.\n')
    video_content_source_url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.\n')
    avail_suppression: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_AvailSuppressionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see `Ad Suppression <https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html>`_ .\n')
    bumper: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_BumperPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see `Bumpers <https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html>`_ .\n')
    cdn_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_CdnConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.\n')
    configuration_aliases: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Any], None] = pydantic.Field(None, description='The player parameters and aliases used as dynamic variables during session initialization. For more information, see `Domain Variables <https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html>`_ .\n')
    dash_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_DashConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for a DASH source.\n')
    hls_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_HlsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for HLS content.\n')
    live_pre_roll_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_LivePreRollConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for pre-roll ad insertion.\n')
    manifest_processing_rules: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnPlaybackConfiguration_ManifestProcessingRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.\n')
    personalization_threshold_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to *ad replacement* in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see `Ad Behavior in AWS Elemental MediaTailor <https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html>`_ .\n')
    slate_ad_url: typing.Optional[str] = pydantic.Field(None, description="The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .\n')
    transcode_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediatailor-playbackconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    # configuration_aliases: Any\n\n    cfn_playback_configuration_props = mediatailor.CfnPlaybackConfigurationProps(\n        ad_decision_server_url="adDecisionServerUrl",\n        name="name",\n        video_content_source_url="videoContentSourceUrl",\n\n        # the properties below are optional\n        avail_suppression=mediatailor.CfnPlaybackConfiguration.AvailSuppressionProperty(\n            mode="mode",\n            value="value"\n        ),\n        bumper=mediatailor.CfnPlaybackConfiguration.BumperProperty(\n            end_url="endUrl",\n            start_url="startUrl"\n        ),\n        cdn_configuration=mediatailor.CfnPlaybackConfiguration.CdnConfigurationProperty(\n            ad_segment_url_prefix="adSegmentUrlPrefix",\n            content_segment_url_prefix="contentSegmentUrlPrefix"\n        ),\n        configuration_aliases={\n            "configuration_aliases_key": configuration_aliases\n        },\n        dash_configuration=mediatailor.CfnPlaybackConfiguration.DashConfigurationProperty(\n            manifest_endpoint_prefix="manifestEndpointPrefix",\n            mpd_location="mpdLocation",\n            origin_manifest_type="originManifestType"\n        ),\n        hls_configuration=mediatailor.CfnPlaybackConfiguration.HlsConfigurationProperty(\n            manifest_endpoint_prefix="manifestEndpointPrefix"\n        ),\n        live_pre_roll_configuration=mediatailor.CfnPlaybackConfiguration.LivePreRollConfigurationProperty(\n            ad_decision_server_url="adDecisionServerUrl",\n            max_duration_seconds=123\n        ),\n        manifest_processing_rules=mediatailor.CfnPlaybackConfiguration.ManifestProcessingRulesProperty(\n            ad_marker_passthrough=mediatailor.CfnPlaybackConfiguration.AdMarkerPassthroughProperty(\n                enabled=False\n            )\n        ),\n        personalization_threshold_seconds=123,\n        slate_ad_url="slateAdUrl",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        transcode_profile_name="transcodeProfileName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ad_decision_server_url', 'name', 'video_content_source_url', 'avail_suppression', 'bumper', 'cdn_configuration', 'configuration_aliases', 'dash_configuration', 'hls_configuration', 'live_pre_roll_configuration', 'manifest_processing_rules', 'personalization_threshold_seconds', 'slate_ad_url', 'tags', 'transcode_profile_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnPlaybackConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnSourceLocationProps
class CfnSourceLocationPropsDef(BaseCfnProperty):
    http_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_HttpConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP configuration for the source location.\n')
    source_location_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the source location.\n')
    access_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_AccessConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The access configuration for the source location.\n')
    default_segment_delivery_configuration: typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_DefaultSegmentDeliveryConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default segment delivery configuration.\n')
    segment_delivery_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnSourceLocation_SegmentDeliveryConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The segment delivery configurations for the source location.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediatailor-sourcelocation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    cfn_source_location_props = mediatailor.CfnSourceLocationProps(\n        http_configuration=mediatailor.CfnSourceLocation.HttpConfigurationProperty(\n            base_url="baseUrl"\n        ),\n        source_location_name="sourceLocationName",\n\n        # the properties below are optional\n        access_configuration=mediatailor.CfnSourceLocation.AccessConfigurationProperty(\n            access_type="accessType",\n            secrets_manager_access_token_configuration=mediatailor.CfnSourceLocation.SecretsManagerAccessTokenConfigurationProperty(\n                header_name="headerName",\n                secret_arn="secretArn",\n                secret_string_key="secretStringKey"\n            )\n        ),\n        default_segment_delivery_configuration=mediatailor.CfnSourceLocation.DefaultSegmentDeliveryConfigurationProperty(\n            base_url="baseUrl"\n        ),\n        segment_delivery_configurations=[mediatailor.CfnSourceLocation.SegmentDeliveryConfigurationProperty(\n            base_url="baseUrl",\n            name="name"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_configuration', 'source_location_name', 'access_configuration', 'default_segment_delivery_configuration', 'segment_delivery_configurations', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnSourceLocationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_mediatailor.CfnVodSourceProps
class CfnVodSourcePropsDef(BaseCfnProperty):
    http_package_configurations: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_mediatailor.CfnVodSource_HttpPackageConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP package configurations for the VOD source.\n')
    source_location_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the source location that the VOD source is associated with.\n')
    vod_source_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the VOD source.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see `Tagging AWS Elemental MediaTailor Resources <https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mediatailor-vodsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_mediatailor as mediatailor\n\n    cfn_vod_source_props = mediatailor.CfnVodSourceProps(\n        http_package_configurations=[mediatailor.CfnVodSource.HttpPackageConfigurationProperty(\n            path="path",\n            source_group="sourceGroup",\n            type="type"\n        )],\n        source_location_name="sourceLocationName",\n        vod_source_name="vodSourceName",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_package_configurations', 'source_location_name', 'vod_source_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_mediatailor.CfnVodSourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnChannel_DashPlaylistSettingsProperty: typing.Optional[dict[str, CfnChannel_DashPlaylistSettingsPropertyDef]] = pydantic.Field(None)
    CfnChannel_HlsPlaylistSettingsProperty: typing.Optional[dict[str, CfnChannel_HlsPlaylistSettingsPropertyDef]] = pydantic.Field(None)
    CfnChannel_LogConfigurationForChannelProperty: typing.Optional[dict[str, CfnChannel_LogConfigurationForChannelPropertyDef]] = pydantic.Field(None)
    CfnChannel_RequestOutputItemProperty: typing.Optional[dict[str, CfnChannel_RequestOutputItemPropertyDef]] = pydantic.Field(None)
    CfnChannel_SlateSourceProperty: typing.Optional[dict[str, CfnChannel_SlateSourcePropertyDef]] = pydantic.Field(None)
    CfnLiveSource_HttpPackageConfigurationProperty: typing.Optional[dict[str, CfnLiveSource_HttpPackageConfigurationPropertyDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration_AdMarkerPassthroughProperty: typing.Optional[dict[str, CfnPlaybackConfiguration_AdMarkerPassthroughPropertyDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration_AvailSuppressionProperty: typing.Optional[dict[str, CfnPlaybackConfiguration_AvailSuppressionPropertyDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration_BumperProperty: typing.Optional[dict[str, CfnPlaybackConfiguration_BumperPropertyDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration_CdnConfigurationProperty: typing.Optional[dict[str, CfnPlaybackConfiguration_CdnConfigurationPropertyDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration_DashConfigurationProperty: typing.Optional[dict[str, CfnPlaybackConfiguration_DashConfigurationPropertyDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration_HlsConfigurationProperty: typing.Optional[dict[str, CfnPlaybackConfiguration_HlsConfigurationPropertyDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration_LivePreRollConfigurationProperty: typing.Optional[dict[str, CfnPlaybackConfiguration_LivePreRollConfigurationPropertyDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration_ManifestProcessingRulesProperty: typing.Optional[dict[str, CfnPlaybackConfiguration_ManifestProcessingRulesPropertyDef]] = pydantic.Field(None)
    CfnSourceLocation_AccessConfigurationProperty: typing.Optional[dict[str, CfnSourceLocation_AccessConfigurationPropertyDef]] = pydantic.Field(None)
    CfnSourceLocation_DefaultSegmentDeliveryConfigurationProperty: typing.Optional[dict[str, CfnSourceLocation_DefaultSegmentDeliveryConfigurationPropertyDef]] = pydantic.Field(None)
    CfnSourceLocation_HttpConfigurationProperty: typing.Optional[dict[str, CfnSourceLocation_HttpConfigurationPropertyDef]] = pydantic.Field(None)
    CfnSourceLocation_SecretsManagerAccessTokenConfigurationProperty: typing.Optional[dict[str, CfnSourceLocation_SecretsManagerAccessTokenConfigurationPropertyDef]] = pydantic.Field(None)
    CfnSourceLocation_SegmentDeliveryConfigurationProperty: typing.Optional[dict[str, CfnSourceLocation_SegmentDeliveryConfigurationPropertyDef]] = pydantic.Field(None)
    CfnVodSource_HttpPackageConfigurationProperty: typing.Optional[dict[str, CfnVodSource_HttpPackageConfigurationPropertyDef]] = pydantic.Field(None)
    CfnChannel: typing.Optional[dict[str, CfnChannelDef]] = pydantic.Field(None)
    CfnChannelPolicy: typing.Optional[dict[str, CfnChannelPolicyDef]] = pydantic.Field(None)
    CfnLiveSource: typing.Optional[dict[str, CfnLiveSourceDef]] = pydantic.Field(None)
    CfnPlaybackConfiguration: typing.Optional[dict[str, CfnPlaybackConfigurationDef]] = pydantic.Field(None)
    CfnSourceLocation: typing.Optional[dict[str, CfnSourceLocationDef]] = pydantic.Field(None)
    CfnVodSource: typing.Optional[dict[str, CfnVodSourceDef]] = pydantic.Field(None)
    CfnChannelPolicyProps: typing.Optional[dict[str, CfnChannelPolicyPropsDef]] = pydantic.Field(None)
    CfnChannelProps: typing.Optional[dict[str, CfnChannelPropsDef]] = pydantic.Field(None)
    CfnLiveSourceProps: typing.Optional[dict[str, CfnLiveSourcePropsDef]] = pydantic.Field(None)
    CfnPlaybackConfigurationProps: typing.Optional[dict[str, CfnPlaybackConfigurationPropsDef]] = pydantic.Field(None)
    CfnSourceLocationProps: typing.Optional[dict[str, CfnSourceLocationPropsDef]] = pydantic.Field(None)
    CfnVodSourceProps: typing.Optional[dict[str, CfnVodSourcePropsDef]] = pydantic.Field(None)
    ...
