from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_codedeploy.AllAtOnceTrafficRouting
class AllAtOnceTrafficRoutingDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['all_at_once', 'time_based_canary', 'time_based_linear']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.AllAtOnceTrafficRouting'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.AllAtOnceTrafficRoutingDefConfig] = pydantic.Field(None)


class AllAtOnceTrafficRoutingDefConfig(pydantic.BaseModel):
    all_at_once: typing.Optional[list[models.aws_codedeploy.AllAtOnceTrafficRoutingDefAllAtOnceParams]] = pydantic.Field(None, description='Shifts 100% of traffic in a single shift.')
    bind: typing.Optional[list[models.aws_codedeploy.AllAtOnceTrafficRoutingDefBindParams]] = pydantic.Field(None, description='Return a TrafficRoutingConfig of type ``AllAtOnce``.')
    time_based_canary: typing.Optional[list[models.aws_codedeploy.AllAtOnceTrafficRoutingDefTimeBasedCanaryParams]] = pydantic.Field(None, description='Shifts a specified percentage of traffic, waits for a specified amount of time, then shifts the rest of traffic.')
    time_based_linear: typing.Optional[list[models.aws_codedeploy.AllAtOnceTrafficRoutingDefTimeBasedLinearParams]] = pydantic.Field(None, description='Keeps shifting a specified percentage of traffic until reaching 100%, waiting for a specified amount of time in between each traffic shift.')

class AllAtOnceTrafficRoutingDefAllAtOnceParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...

class AllAtOnceTrafficRoutingDefBindParams(pydantic.BaseModel):
    ...

class AllAtOnceTrafficRoutingDefTimeBasedCanaryParams(pydantic.BaseModel):
    interval: models.DurationDef = pydantic.Field(..., description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[int, float] = pydantic.Field(..., description='The percentage to increase traffic on each traffic shift.')
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...

class AllAtOnceTrafficRoutingDefTimeBasedLinearParams(pydantic.BaseModel):
    interval: models.DurationDef = pydantic.Field(..., description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[int, float] = pydantic.Field(..., description='The percentage to increase traffic on each traffic shift.')
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codedeploy.BaseDeploymentConfig
class BaseDeploymentConfigDef(BaseClass):
    compute_platform: typing.Optional[aws_cdk.aws_codedeploy.ComputePlatform] = pydantic.Field(None, description='The destination compute platform for the deployment. Default: ComputePlatform.Server\n')
    minimum_healthy_hosts: typing.Optional[models.aws_codedeploy.MinimumHealthyHostsDef] = pydantic.Field(None, description='Minimum number of healthy hosts. Default: None\n')
    traffic_routing: typing.Optional[models.aws_codedeploy.TrafficRoutingDef] = pydantic.Field(None, description='The configuration that specifies how traffic is shifted during a deployment. Only applicable to ECS and Lambda deployments, and must not be specified for Server deployments. Default: None\n')
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['compute_platform', 'minimum_healthy_hosts', 'traffic_routing', 'deployment_config_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_deployment_config_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.BaseDeploymentConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_deployment_config_name']
    ...


    from_deployment_config_name: typing.Optional[models.aws_codedeploy.BaseDeploymentConfigDefFromDeploymentConfigNameParams] = pydantic.Field(None, description='Import a custom Deployment Configuration for a Deployment Group defined outside the CDK.')
    resource_config: typing.Optional[models.aws_codedeploy.BaseDeploymentConfigDefConfig] = pydantic.Field(None)


class BaseDeploymentConfigDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class BaseDeploymentConfigDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class BaseDeploymentConfigDefFromDeploymentConfigNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    deployment_config_name: str = pydantic.Field(..., description='the name of the referenced custom Deployment Configuration.\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.InstanceTagSet
class InstanceTagSetDef(BaseClass):
    instance_tag_groups: list[typing.Mapping[str, list[str]]] = pydantic.Field(REQUIRED_INIT_PARAM)
    _init_params: typing.ClassVar[list[str]] = ['instance_tag_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.InstanceTagSet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.LoadBalancer
class LoadBalancerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['application', 'classic', 'network']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LoadBalancer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.LoadBalancerDefConfig] = pydantic.Field(None)


class LoadBalancerDefConfig(pydantic.BaseModel):
    application: typing.Optional[list[models.aws_codedeploy.LoadBalancerDefApplicationParams]] = pydantic.Field(None, description='Creates a new CodeDeploy load balancer from an Application Load Balancer Target Group.')
    classic: typing.Optional[list[models.aws_codedeploy.LoadBalancerDefClassicParams]] = pydantic.Field(None, description='Creates a new CodeDeploy load balancer from a Classic ELB Load Balancer.')
    network: typing.Optional[list[models.aws_codedeploy.LoadBalancerDefNetworkParams]] = pydantic.Field(None, description='Creates a new CodeDeploy load balancer from a Network Load Balancer Target Group.')

class LoadBalancerDefApplicationParams(pydantic.BaseModel):
    alb_target_group: typing.Union[models.aws_elasticloadbalancingv2.ApplicationTargetGroupDef] = pydantic.Field(..., description='an ALB Target Group.')
    return_config: typing.Optional[list[models.aws_codedeploy.LoadBalancerDefConfig]] = pydantic.Field(None)
    ...

class LoadBalancerDefClassicParams(pydantic.BaseModel):
    load_balancer: models.aws_elasticloadbalancing.LoadBalancerDef = pydantic.Field(..., description='a classic ELB Load Balancer.')
    return_config: typing.Optional[list[models.aws_codedeploy.LoadBalancerDefConfig]] = pydantic.Field(None)
    ...

class LoadBalancerDefNetworkParams(pydantic.BaseModel):
    nlb_target_group: typing.Union[models.aws_elasticloadbalancingv2.NetworkTargetGroupDef] = pydantic.Field(..., description='an NLB Target Group.')
    return_config: typing.Optional[list[models.aws_codedeploy.LoadBalancerDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codedeploy.MinimumHealthyHosts
class MinimumHealthyHostsDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['count', 'percentage']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.MinimumHealthyHosts'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.MinimumHealthyHostsDefConfig] = pydantic.Field(None)


class MinimumHealthyHostsDefConfig(pydantic.BaseModel):
    count: typing.Optional[list[models.aws_codedeploy.MinimumHealthyHostsDefCountParams]] = pydantic.Field(None, description='The minimum healhty hosts threshold expressed as an absolute number.')
    percentage: typing.Optional[list[models.aws_codedeploy.MinimumHealthyHostsDefPercentageParams]] = pydantic.Field(None, description='The minmum healhty hosts threshold expressed as a percentage of the fleet.')

class MinimumHealthyHostsDefCountParams(pydantic.BaseModel):
    value: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_codedeploy.MinimumHealthyHostsDefConfig]] = pydantic.Field(None)
    ...

class MinimumHealthyHostsDefPercentageParams(pydantic.BaseModel):
    value: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_codedeploy.MinimumHealthyHostsDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codedeploy.TimeBasedCanaryTrafficRouting
class TimeBasedCanaryTrafficRoutingDef(BaseClass):
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of time between traffic shifts.')
    percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage to increase traffic on each traffic shift.')
    _init_params: typing.ClassVar[list[str]] = ['interval', 'percentage']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['all_at_once', 'time_based_canary', 'time_based_linear']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.TimeBasedCanaryTrafficRouting'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.TimeBasedCanaryTrafficRoutingDefConfig] = pydantic.Field(None)


class TimeBasedCanaryTrafficRoutingDefConfig(pydantic.BaseModel):
    all_at_once: typing.Optional[list[models.aws_codedeploy.TimeBasedCanaryTrafficRoutingDefAllAtOnceParams]] = pydantic.Field(None, description='Shifts 100% of traffic in a single shift.')
    bind: typing.Optional[list[models.aws_codedeploy.TimeBasedCanaryTrafficRoutingDefBindParams]] = pydantic.Field(None, description='Return a TrafficRoutingConfig of type ``TimeBasedCanary``.')
    time_based_canary: typing.Optional[list[models.aws_codedeploy.TimeBasedCanaryTrafficRoutingDefTimeBasedCanaryParams]] = pydantic.Field(None, description='Shifts a specified percentage of traffic, waits for a specified amount of time, then shifts the rest of traffic.')
    time_based_linear: typing.Optional[list[models.aws_codedeploy.TimeBasedCanaryTrafficRoutingDefTimeBasedLinearParams]] = pydantic.Field(None, description='Keeps shifting a specified percentage of traffic until reaching 100%, waiting for a specified amount of time in between each traffic shift.')
    interval_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)

class TimeBasedCanaryTrafficRoutingDefAllAtOnceParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...

class TimeBasedCanaryTrafficRoutingDefBindParams(pydantic.BaseModel):
    ...

class TimeBasedCanaryTrafficRoutingDefTimeBasedCanaryParams(pydantic.BaseModel):
    interval: models.DurationDef = pydantic.Field(..., description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[int, float] = pydantic.Field(..., description='The percentage to increase traffic on each traffic shift.')
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...

class TimeBasedCanaryTrafficRoutingDefTimeBasedLinearParams(pydantic.BaseModel):
    interval: models.DurationDef = pydantic.Field(..., description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[int, float] = pydantic.Field(..., description='The percentage to increase traffic on each traffic shift.')
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codedeploy.TimeBasedLinearTrafficRouting
class TimeBasedLinearTrafficRoutingDef(BaseClass):
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of time between traffic shifts.')
    percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage to increase traffic on each traffic shift.')
    _init_params: typing.ClassVar[list[str]] = ['interval', 'percentage']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['all_at_once', 'time_based_canary', 'time_based_linear']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.TimeBasedLinearTrafficRouting'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.TimeBasedLinearTrafficRoutingDefConfig] = pydantic.Field(None)


class TimeBasedLinearTrafficRoutingDefConfig(pydantic.BaseModel):
    all_at_once: typing.Optional[list[models.aws_codedeploy.TimeBasedLinearTrafficRoutingDefAllAtOnceParams]] = pydantic.Field(None, description='Shifts 100% of traffic in a single shift.')
    bind: typing.Optional[list[models.aws_codedeploy.TimeBasedLinearTrafficRoutingDefBindParams]] = pydantic.Field(None, description='Return a TrafficRoutingConfig of type ``TimeBasedLinear``.')
    time_based_canary: typing.Optional[list[models.aws_codedeploy.TimeBasedLinearTrafficRoutingDefTimeBasedCanaryParams]] = pydantic.Field(None, description='Shifts a specified percentage of traffic, waits for a specified amount of time, then shifts the rest of traffic.')
    time_based_linear: typing.Optional[list[models.aws_codedeploy.TimeBasedLinearTrafficRoutingDefTimeBasedLinearParams]] = pydantic.Field(None, description='Keeps shifting a specified percentage of traffic until reaching 100%, waiting for a specified amount of time in between each traffic shift.')
    interval_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)

class TimeBasedLinearTrafficRoutingDefAllAtOnceParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...

class TimeBasedLinearTrafficRoutingDefBindParams(pydantic.BaseModel):
    ...

class TimeBasedLinearTrafficRoutingDefTimeBasedCanaryParams(pydantic.BaseModel):
    interval: models.DurationDef = pydantic.Field(..., description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[int, float] = pydantic.Field(..., description='The percentage to increase traffic on each traffic shift.')
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...

class TimeBasedLinearTrafficRoutingDefTimeBasedLinearParams(pydantic.BaseModel):
    interval: models.DurationDef = pydantic.Field(..., description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[int, float] = pydantic.Field(..., description='The percentage to increase traffic on each traffic shift.')
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codedeploy.TrafficRouting
class TrafficRoutingDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['all_at_once', 'time_based_canary', 'time_based_linear']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.TrafficRouting'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.TrafficRoutingDefConfig] = pydantic.Field(None)


class TrafficRoutingDefConfig(pydantic.BaseModel):
    all_at_once: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefAllAtOnceParams]] = pydantic.Field(None, description='Shifts 100% of traffic in a single shift.')
    bind: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefBindParams]] = pydantic.Field(None, description='Returns the traffic routing configuration.')
    time_based_canary: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefTimeBasedCanaryParams]] = pydantic.Field(None, description='Shifts a specified percentage of traffic, waits for a specified amount of time, then shifts the rest of traffic.')
    time_based_linear: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefTimeBasedLinearParams]] = pydantic.Field(None, description='Keeps shifting a specified percentage of traffic until reaching 100%, waiting for a specified amount of time in between each traffic shift.')

class TrafficRoutingDefAllAtOnceParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...

class TrafficRoutingDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class TrafficRoutingDefTimeBasedCanaryParams(pydantic.BaseModel):
    interval: models.DurationDef = pydantic.Field(..., description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[int, float] = pydantic.Field(..., description='The percentage to increase traffic on each traffic shift.')
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...

class TrafficRoutingDefTimeBasedLinearParams(pydantic.BaseModel):
    interval: models.DurationDef = pydantic.Field(..., description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[int, float] = pydantic.Field(..., description='The percentage to increase traffic on each traffic shift.')
    return_config: typing.Optional[list[models.aws_codedeploy.TrafficRoutingDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codedeploy.CustomLambdaDeploymentConfig
class CustomLambdaDeploymentConfigDef(BaseConstruct):
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='(deprecated) The interval, in number of minutes: - For LINEAR, how frequently additional traffic is shifted - For CANARY, how long to shift traffic before the full deployment.\n')
    percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='(deprecated) The integer percentage of traffic to shift: - For LINEAR, the percentage to shift every interval - For CANARY, the percentage to shift until the interval passes, before the full deployment.\n')
    type: typing.Union[aws_cdk.aws_codedeploy.CustomLambdaDeploymentConfigType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='(deprecated) The type of deployment config, either CANARY or LINEAR.\n')
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='(deprecated) The verbatim name of the deployment config. Must be unique per account/region. Other parameters cannot be updated if this name is provided. Default: - automatically generated name\n\n:stability: deprecated\n')
    _init_params: typing.ClassVar[list[str]] = ['interval', 'percentage', 'type', 'deployment_config_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CustomLambdaDeploymentConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.CustomLambdaDeploymentConfigDefConfig] = pydantic.Field(None)


class CustomLambdaDeploymentConfigDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class CustomLambdaDeploymentConfigDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.EcsApplication
class EcsApplicationDef(BaseConstruct):
    application_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Application. Default: an auto-generated name will be used')
    _init_params: typing.ClassVar[list[str]] = ['application_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_ecs_application_arn', 'from_ecs_application_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.EcsApplication'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_ecs_application_arn', 'from_ecs_application_name']
    ...


    from_ecs_application_arn: typing.Optional[models.aws_codedeploy.EcsApplicationDefFromEcsApplicationArnParams] = pydantic.Field(None, description='Import an Application defined either outside the CDK, or in a different CDK Stack, by ARN.')
    from_ecs_application_name: typing.Optional[models.aws_codedeploy.EcsApplicationDefFromEcsApplicationNameParams] = pydantic.Field(None, description="Import an Application defined either outside the CDK, or in a different CDK Stack.\nThe Application's account and region are assumed to be the same as the stack it is being imported\ninto. If not, use ``fromEcsApplicationArn``.")
    resource_config: typing.Optional[models.aws_codedeploy.EcsApplicationDefConfig] = pydantic.Field(None)


class EcsApplicationDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class EcsApplicationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class EcsApplicationDefFromEcsApplicationArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    ecs_application_arn: str = pydantic.Field(..., description='the ARN of the application to import.\n')
    ...

class EcsApplicationDefFromEcsApplicationNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    ecs_application_name: str = pydantic.Field(..., description='the name of the application to import.\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.EcsDeploymentConfig
class EcsDeploymentConfigDef(BaseConstruct):
    traffic_routing: typing.Optional[models.aws_codedeploy.TrafficRoutingDef] = pydantic.Field(None, description="The configuration that specifies how traffic is shifted from the 'blue' target group to the 'green' target group during a deployment. Default: AllAtOnce\n")
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['traffic_routing', 'deployment_config_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_deployment_config_name', 'from_ecs_deployment_config_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.EcsDeploymentConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_deployment_config_name', 'from_ecs_deployment_config_name']
    ...


    from_deployment_config_name: typing.Optional[models.aws_codedeploy.EcsDeploymentConfigDefFromDeploymentConfigNameParams] = pydantic.Field(None, description='Import a custom Deployment Configuration for a Deployment Group defined outside the CDK.')
    from_ecs_deployment_config_name: typing.Optional[models.aws_codedeploy.EcsDeploymentConfigDefFromEcsDeploymentConfigNameParams] = pydantic.Field(None, description='Import a custom Deployment Configuration for an ECS Deployment Group defined outside the CDK.')
    resource_config: typing.Optional[models.aws_codedeploy.EcsDeploymentConfigDefConfig] = pydantic.Field(None)


class EcsDeploymentConfigDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class EcsDeploymentConfigDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class EcsDeploymentConfigDefFromDeploymentConfigNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    deployment_config_name: str = pydantic.Field(..., description='the name of the referenced custom Deployment Configuration.\n')
    ...

class EcsDeploymentConfigDefFromEcsDeploymentConfigNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    ecs_deployment_config_name: str = pydantic.Field(..., description='the name of the referenced custom Deployment Configuration.\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.EcsDeploymentGroup
class EcsDeploymentGroupDef(BaseConstruct):
    blue_green_deployment_config: typing.Union[_REQUIRED_INIT_PARAM, models.aws_codedeploy.EcsBlueGreenDeploymentConfigDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration options for blue-green ECS deployments.\n')
    service: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ecs.BaseServiceDef, models.aws_ecs.Ec2ServiceDef, models.aws_ecs.ExternalServiceDef, models.aws_ecs.FargateServiceDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ECS service to deploy with this Deployment Group.\n')
    alarms: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]]] = pydantic.Field(None, description='The CloudWatch alarms associated with this Deployment Group. CodeDeploy will stop (and optionally roll back) a deployment if during it any of the alarms trigger. Alarms can also be added after the Deployment Group is created using the ``#addAlarm`` method. Default: []\n')
    application: typing.Optional[typing.Union[models.aws_codedeploy.EcsApplicationDef]] = pydantic.Field(None, description='The reference to the CodeDeploy ECS Application that this Deployment Group belongs to. Default: One will be created for you.\n')
    auto_rollback: typing.Union[models.aws_codedeploy.AutoRollbackConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The auto-rollback configuration for this Deployment Group. Default: - default AutoRollbackConfig.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.EcsDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: EcsDeploymentConfig.ALL_AT_ONCE\n')
    deployment_group_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Deployment Group. Default: An auto-generated name will be used.\n')
    ignore_poll_alarms_failure: typing.Optional[bool] = pydantic.Field(None, description='Whether to continue a deployment even if fetching the alarm status from CloudWatch failed. Default: false\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The service Role of this Deployment Group. Default: - A new Role will be created.')
    _init_params: typing.ClassVar[list[str]] = ['blue_green_deployment_config', 'service', 'alarms', 'application', 'auto_rollback', 'deployment_config', 'deployment_group_name', 'ignore_poll_alarms_failure', 'role']
    _method_names: typing.ClassVar[list[str]] = ['add_alarm', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_ecs_deployment_group_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.EcsDeploymentGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_ecs_deployment_group_attributes']
    ...


    from_ecs_deployment_group_attributes: typing.Optional[models.aws_codedeploy.EcsDeploymentGroupDefFromEcsDeploymentGroupAttributesParams] = pydantic.Field(None, description='Reference an ECS Deployment Group defined outside the CDK app.\nAccount and region for the DeploymentGroup are taken from the application.')
    resource_config: typing.Optional[models.aws_codedeploy.EcsDeploymentGroupDefConfig] = pydantic.Field(None)


class EcsDeploymentGroupDefConfig(pydantic.BaseModel):
    add_alarm: typing.Optional[list[models.aws_codedeploy.EcsDeploymentGroupDefAddAlarmParams]] = pydantic.Field(None, description='Associates an additional alarm with this Deployment Group.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    application_config: typing.Optional[models._interface_methods.AwsCodedeployIEcsApplicationDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)

class EcsDeploymentGroupDefAddAlarmParams(pydantic.BaseModel):
    alarm: typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef] = pydantic.Field(..., description='the alarm to associate with this Deployment Group.')
    ...

class EcsDeploymentGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class EcsDeploymentGroupDefFromEcsDeploymentGroupAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    application: typing.Union[models.aws_codedeploy.EcsApplicationDef] = pydantic.Field(..., description='The reference to the CodeDeploy ECS Application that this Deployment Group belongs to.\n')
    deployment_group_name: str = pydantic.Field(..., description='The physical, human-readable name of the CodeDeploy ECS Deployment Group that we are referencing.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.EcsDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: EcsDeploymentConfig.ALL_AT_ONCE\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.LambdaApplication
class LambdaApplicationDef(BaseConstruct):
    application_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Application. Default: an auto-generated name will be used')
    _init_params: typing.ClassVar[list[str]] = ['application_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_lambda_application_arn', 'from_lambda_application_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LambdaApplication'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_lambda_application_arn', 'from_lambda_application_name']
    ...


    from_lambda_application_arn: typing.Optional[models.aws_codedeploy.LambdaApplicationDefFromLambdaApplicationArnParams] = pydantic.Field(None, description='Import an Application defined either outside the CDK, or in a different CDK Stack, by ARN.')
    from_lambda_application_name: typing.Optional[models.aws_codedeploy.LambdaApplicationDefFromLambdaApplicationNameParams] = pydantic.Field(None, description="Import an Application defined either outside the CDK, or in a different CDK Stack.\nThe Application's account and region are assumed to be the same as the stack it is being imported\ninto. If not, use ``fromLambdaApplicationArn``.")
    resource_config: typing.Optional[models.aws_codedeploy.LambdaApplicationDefConfig] = pydantic.Field(None)


class LambdaApplicationDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class LambdaApplicationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class LambdaApplicationDefFromLambdaApplicationArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    lambda_application_arn: str = pydantic.Field(..., description='the ARN of the application to import.\n')
    ...

class LambdaApplicationDefFromLambdaApplicationNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    lambda_application_name: str = pydantic.Field(..., description='the name of the application to import.\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.LambdaDeploymentConfig
class LambdaDeploymentConfigDef(BaseConstruct):
    traffic_routing: typing.Optional[models.aws_codedeploy.TrafficRoutingDef] = pydantic.Field(None, description="The configuration that specifies how traffic is shifted from the 'blue' target group to the 'green' target group during a deployment. Default: AllAtOnce\n")
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['traffic_routing', 'deployment_config_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_deployment_config_name', 'from_lambda_deployment_config_name', 'import_']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LambdaDeploymentConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_deployment_config_name', 'from_lambda_deployment_config_name', 'import_']
    ...


    from_deployment_config_name: typing.Optional[models.aws_codedeploy.LambdaDeploymentConfigDefFromDeploymentConfigNameParams] = pydantic.Field(None, description='Import a custom Deployment Configuration for a Deployment Group defined outside the CDK.')
    from_lambda_deployment_config_name: typing.Optional[models.aws_codedeploy.LambdaDeploymentConfigDefFromLambdaDeploymentConfigNameParams] = pydantic.Field(None, description='Import a Deployment Configuration for a Lambda Deployment Group defined outside the CDK.')
    import_: typing.Optional[models.aws_codedeploy.LambdaDeploymentConfigDefImportParams] = pydantic.Field(None, description='(deprecated) Import a Deployment Configuration for a Lambda Deployment Group defined outside the CDK.')
    resource_config: typing.Optional[models.aws_codedeploy.LambdaDeploymentConfigDefConfig] = pydantic.Field(None)


class LambdaDeploymentConfigDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class LambdaDeploymentConfigDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class LambdaDeploymentConfigDefFromDeploymentConfigNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    deployment_config_name: str = pydantic.Field(..., description='the name of the referenced custom Deployment Configuration.\n')
    ...

class LambdaDeploymentConfigDefFromLambdaDeploymentConfigNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    lambda_deployment_config_name: str = pydantic.Field(..., description='the name of the Lambda Deployment Configuration to import.\n')
    ...

class LambdaDeploymentConfigDefImportParams(pydantic.BaseModel):
    deployment_config_name: str = pydantic.Field(..., description='The physical, human-readable name of the custom CodeDeploy Lambda Deployment Configuration that we are referencing.\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.LambdaDeploymentGroup
class LambdaDeploymentGroupDef(BaseConstruct):
    alias: typing.Union[models.aws_lambda.AliasDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Lambda Alias to shift traffic. Updating the version of the alias will trigger a CodeDeploy deployment. [disable-awslint:ref-via-interface] since we need to modify the alias CFN resource update policy\n')
    alarms: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]]] = pydantic.Field(None, description='The CloudWatch alarms associated with this Deployment Group. CodeDeploy will stop (and optionally roll back) a deployment if during it any of the alarms trigger. Alarms can also be added after the Deployment Group is created using the ``#addAlarm`` method. Default: []\n')
    application: typing.Optional[typing.Union[models.aws_codedeploy.LambdaApplicationDef]] = pydantic.Field(None, description='The reference to the CodeDeploy Lambda Application that this Deployment Group belongs to. Default: - One will be created for you.\n')
    auto_rollback: typing.Union[models.aws_codedeploy.AutoRollbackConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The auto-rollback configuration for this Deployment Group. Default: - default AutoRollbackConfig.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.CustomLambdaDeploymentConfigDef, models.aws_codedeploy.LambdaDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: LambdaDeploymentConfig.CANARY_10PERCENT_5MINUTES\n')
    deployment_group_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Deployment Group. Default: - An auto-generated name will be used.\n')
    ignore_poll_alarms_failure: typing.Optional[bool] = pydantic.Field(None, description='Whether to continue a deployment even if fetching the alarm status from CloudWatch failed. Default: false\n')
    post_hook: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The Lambda function to run after traffic routing starts. Default: - None.\n')
    pre_hook: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The Lambda function to run before traffic routing starts. Default: - None.\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The service Role of this Deployment Group. Default: - A new Role will be created.')
    _init_params: typing.ClassVar[list[str]] = ['alias', 'alarms', 'application', 'auto_rollback', 'deployment_config', 'deployment_group_name', 'ignore_poll_alarms_failure', 'post_hook', 'pre_hook', 'role']
    _method_names: typing.ClassVar[list[str]] = ['add_alarm', 'add_post_hook', 'add_pre_hook', 'apply_removal_policy', 'grant_put_lifecycle_event_hook_execution_status']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_lambda_deployment_group_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LambdaDeploymentGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_lambda_deployment_group_attributes']
    ...


    from_lambda_deployment_group_attributes: typing.Optional[models.aws_codedeploy.LambdaDeploymentGroupDefFromLambdaDeploymentGroupAttributesParams] = pydantic.Field(None, description='Import an Lambda Deployment Group defined either outside the CDK app, or in a different AWS region.\nAccount and region for the DeploymentGroup are taken from the application.')
    resource_config: typing.Optional[models.aws_codedeploy.LambdaDeploymentGroupDefConfig] = pydantic.Field(None)


class LambdaDeploymentGroupDefConfig(pydantic.BaseModel):
    add_alarm: typing.Optional[list[models.aws_codedeploy.LambdaDeploymentGroupDefAddAlarmParams]] = pydantic.Field(None, description='Associates an additional alarm with this Deployment Group.')
    add_post_hook: typing.Optional[list[models.aws_codedeploy.LambdaDeploymentGroupDefAddPostHookParams]] = pydantic.Field(None, description='Associate a function to run after deployment completes.')
    add_pre_hook: typing.Optional[list[models.aws_codedeploy.LambdaDeploymentGroupDefAddPreHookParams]] = pydantic.Field(None, description='Associate a function to run before deployment begins.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_put_lifecycle_event_hook_execution_status: typing.Optional[list[models.aws_codedeploy.LambdaDeploymentGroupDefGrantPutLifecycleEventHookExecutionStatusParams]] = pydantic.Field(None, description='Grant a principal permission to codedeploy:PutLifecycleEventHookExecutionStatus on this deployment group resource.')
    application_config: typing.Optional[models._interface_methods.AwsCodedeployILambdaApplicationDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)

class LambdaDeploymentGroupDefAddAlarmParams(pydantic.BaseModel):
    alarm: typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef] = pydantic.Field(..., description='the alarm to associate with this Deployment Group.')
    ...

class LambdaDeploymentGroupDefAddPostHookParams(pydantic.BaseModel):
    post_hook: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description='function to run after deployment completes.\n\n:throws: an error if a post-hook function is already configured\n')
    ...

class LambdaDeploymentGroupDefAddPreHookParams(pydantic.BaseModel):
    pre_hook: typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(..., description='function to run before deployment beings.\n\n:throws: an error if a pre-hook function is already configured\n')
    ...

class LambdaDeploymentGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class LambdaDeploymentGroupDefFromLambdaDeploymentGroupAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    application: typing.Union[models.aws_codedeploy.LambdaApplicationDef] = pydantic.Field(..., description='The reference to the CodeDeploy Lambda Application that this Deployment Group belongs to.\n')
    deployment_group_name: str = pydantic.Field(..., description='The physical, human-readable name of the CodeDeploy Lambda Deployment Group that we are referencing.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.CustomLambdaDeploymentConfigDef, models.aws_codedeploy.LambdaDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: LambdaDeploymentConfig.CANARY_10PERCENT_5MINUTES\n')
    ...

class LambdaDeploymentGroupDefGrantPutLifecycleEventHookExecutionStatusParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='to grant permission to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codedeploy.ServerApplication
class ServerApplicationDef(BaseConstruct):
    application_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Application. Default: an auto-generated name will be used')
    _init_params: typing.ClassVar[list[str]] = ['application_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_server_application_arn', 'from_server_application_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.ServerApplication'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_server_application_arn', 'from_server_application_name']
    ...


    from_server_application_arn: typing.Optional[models.aws_codedeploy.ServerApplicationDefFromServerApplicationArnParams] = pydantic.Field(None, description='Import an Application defined either outside the CDK, or in a different CDK Stack, by ARN.')
    from_server_application_name: typing.Optional[models.aws_codedeploy.ServerApplicationDefFromServerApplicationNameParams] = pydantic.Field(None, description="Import an Application defined either outside the CDK app, or in a different region.\nThe Application's account and region are assumed to be the same as the stack it is being imported\ninto. If not, use ``fromServerApplicationArn``.")
    resource_config: typing.Optional[models.aws_codedeploy.ServerApplicationDefConfig] = pydantic.Field(None)


class ServerApplicationDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ServerApplicationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ServerApplicationDefFromServerApplicationArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    server_application_arn: str = pydantic.Field(..., description='the ARN of the application to import.\n')
    ...

class ServerApplicationDefFromServerApplicationNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    server_application_name: str = pydantic.Field(..., description='the name of the application to import.\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.ServerDeploymentConfig
class ServerDeploymentConfigDef(BaseConstruct):
    minimum_healthy_hosts: typing.Union[models.aws_codedeploy.MinimumHealthyHostsDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Minimum number of healthy hosts.\n')
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['minimum_healthy_hosts', 'deployment_config_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_deployment_config_name', 'from_server_deployment_config_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.ServerDeploymentConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_deployment_config_name', 'from_server_deployment_config_name']
    ...


    from_deployment_config_name: typing.Optional[models.aws_codedeploy.ServerDeploymentConfigDefFromDeploymentConfigNameParams] = pydantic.Field(None, description='Import a custom Deployment Configuration for a Deployment Group defined outside the CDK.')
    from_server_deployment_config_name: typing.Optional[models.aws_codedeploy.ServerDeploymentConfigDefFromServerDeploymentConfigNameParams] = pydantic.Field(None, description='Import a custom Deployment Configuration for an EC2/on-premise Deployment Group defined either outside the CDK app, or in a different region.')
    resource_config: typing.Optional[models.aws_codedeploy.ServerDeploymentConfigDefConfig] = pydantic.Field(None)


class ServerDeploymentConfigDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ServerDeploymentConfigDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ServerDeploymentConfigDefFromDeploymentConfigNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    deployment_config_name: str = pydantic.Field(..., description='the name of the referenced custom Deployment Configuration.\n')
    ...

class ServerDeploymentConfigDefFromServerDeploymentConfigNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    server_deployment_config_name: str = pydantic.Field(..., description='the properties of the referenced custom Deployment Configuration.\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.ServerDeploymentGroup
class ServerDeploymentGroupDef(BaseConstruct):
    alarms: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]]] = pydantic.Field(None, description='The CloudWatch alarms associated with this Deployment Group. CodeDeploy will stop (and optionally roll back) a deployment if during it any of the alarms trigger. Alarms can also be added after the Deployment Group is created using the ``#addAlarm`` method. Default: []\n')
    application: typing.Optional[typing.Union[models.aws_codedeploy.ServerApplicationDef]] = pydantic.Field(None, description='The CodeDeploy EC2/on-premise Application this Deployment Group belongs to. Default: - A new Application will be created.\n')
    auto_rollback: typing.Union[models.aws_codedeploy.AutoRollbackConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The auto-rollback configuration for this Deployment Group. Default: - default AutoRollbackConfig.\n')
    auto_scaling_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.AutoScalingGroupDef]]] = pydantic.Field(None, description='The auto-scaling groups belonging to this Deployment Group. Auto-scaling groups can also be added after the Deployment Group is created using the ``#addAutoScalingGroup`` method. [disable-awslint:ref-via-interface] is needed because we update userdata for ASGs to install the codedeploy agent. Default: []\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.ServerDeploymentConfigDef]] = pydantic.Field(None, description='The EC2/on-premise Deployment Configuration to use for this Deployment Group. Default: ServerDeploymentConfig#OneAtATime\n')
    deployment_group_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Deployment Group. Default: - An auto-generated name will be used.\n')
    ec2_instance_tags: typing.Optional[models.aws_codedeploy.InstanceTagSetDef] = pydantic.Field(None, description='All EC2 instances matching the given set of tags when a deployment occurs will be added to this Deployment Group. Default: - No additional EC2 instances will be added to the Deployment Group.\n')
    ignore_poll_alarms_failure: typing.Optional[bool] = pydantic.Field(None, description='Whether to continue a deployment even if fetching the alarm status from CloudWatch failed. Default: false\n')
    install_agent: typing.Optional[bool] = pydantic.Field(None, description="If you've provided any auto-scaling groups with the ``#autoScalingGroups`` property, you can set this property to add User Data that installs the CodeDeploy agent on the instances. Default: true\n")
    load_balancer: typing.Optional[models.aws_codedeploy.LoadBalancerDef] = pydantic.Field(None, description='(deprecated) The load balancer to place in front of this Deployment Group. Can be created from either a classic Elastic Load Balancer, or an Application Load Balancer / Network Load Balancer Target Group. Default: - Deployment Group will not have a load balancer defined.\n')
    load_balancers: typing.Optional[typing.Sequence[models.aws_codedeploy.LoadBalancerDef]] = pydantic.Field(None, description='CodeDeploy supports the deployment to multiple load balancers. Specify either multiple Classic Load Balancers, or Application Load Balancers / Network Load Balancers Target Groups. Default: - Deployment Group will not have load balancers defined.\n')
    on_premise_instance_tags: typing.Optional[models.aws_codedeploy.InstanceTagSetDef] = pydantic.Field(None, description='All on-premise instances matching the given set of tags when a deployment occurs will be added to this Deployment Group. Default: - No additional on-premise instances will be added to the Deployment Group.\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The service Role of this Deployment Group. Default: - A new Role will be created.')
    _init_params: typing.ClassVar[list[str]] = ['alarms', 'application', 'auto_rollback', 'auto_scaling_groups', 'deployment_config', 'deployment_group_name', 'ec2_instance_tags', 'ignore_poll_alarms_failure', 'install_agent', 'load_balancer', 'load_balancers', 'on_premise_instance_tags', 'role']
    _method_names: typing.ClassVar[list[str]] = ['add_alarm', 'add_auto_scaling_group', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_server_deployment_group_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.ServerDeploymentGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_server_deployment_group_attributes']
    ...


    from_server_deployment_group_attributes: typing.Optional[models.aws_codedeploy.ServerDeploymentGroupDefFromServerDeploymentGroupAttributesParams] = pydantic.Field(None, description='Import an EC2/on-premise Deployment Group defined either outside the CDK app, or in a different region.')
    resource_config: typing.Optional[models.aws_codedeploy.ServerDeploymentGroupDefConfig] = pydantic.Field(None)


class ServerDeploymentGroupDefConfig(pydantic.BaseModel):
    add_alarm: typing.Optional[list[models.aws_codedeploy.ServerDeploymentGroupDefAddAlarmParams]] = pydantic.Field(None, description='Associates an additional alarm with this Deployment Group.')
    add_auto_scaling_group: typing.Optional[list[models.aws_codedeploy.ServerDeploymentGroupDefAddAutoScalingGroupParams]] = pydantic.Field(None, description='Adds an additional auto-scaling group to this Deployment Group.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    application_config: typing.Optional[models._interface_methods.AwsCodedeployIServerApplicationDefConfig] = pydantic.Field(None)

class ServerDeploymentGroupDefAddAlarmParams(pydantic.BaseModel):
    alarm: typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef] = pydantic.Field(..., description='the alarm to associate with this Deployment Group.')
    ...

class ServerDeploymentGroupDefAddAutoScalingGroupParams(pydantic.BaseModel):
    asg: models.aws_autoscaling.AutoScalingGroupDef = pydantic.Field(..., description='the auto-scaling group to add to this Deployment Group. [disable-awslint:ref-via-interface] is needed in order to install the code deploy agent by updating the ASGs user data.')
    ...

class ServerDeploymentGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ServerDeploymentGroupDefFromServerDeploymentGroupAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the parent Construct for this new Construct.\n')
    id: str = pydantic.Field(..., description='the logical ID of this new Construct.\n')
    application: typing.Union[models.aws_codedeploy.ServerApplicationDef] = pydantic.Field(..., description='The reference to the CodeDeploy EC2/on-premise Application that this Deployment Group belongs to.\n')
    deployment_group_name: str = pydantic.Field(..., description='The physical, human-readable name of the CodeDeploy EC2/on-premise Deployment Group that we are referencing.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.ServerDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: ServerDeploymentConfig#OneAtATime\n')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.AutoRollbackConfig
class AutoRollbackConfigDef(BaseStruct):
    deployment_in_alarm: typing.Optional[bool] = pydantic.Field(None, description="Whether to automatically roll back a deployment during which one of the configured CloudWatch alarms for this Deployment Group went off. Default: true if you've provided any Alarms with the ``alarms`` property, false otherwise\n")
    failed_deployment: typing.Optional[bool] = pydantic.Field(None, description='Whether to automatically roll back a deployment that fails. Default: true\n')
    stopped_deployment: typing.Optional[bool] = pydantic.Field(None, description='Whether to automatically roll back a deployment that was manually stopped. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_autoscaling as autoscaling\n    import aws_cdk.aws_cloudwatch as cloudwatch\n\n    # application: codedeploy.ServerApplication\n    # asg: autoscaling.AutoScalingGroup\n    # alarm: cloudwatch.Alarm\n\n    deployment_group = codedeploy.ServerDeploymentGroup(self, "CodeDeployDeploymentGroup",\n        application=application,\n        deployment_group_name="MyDeploymentGroup",\n        auto_scaling_groups=[asg],\n        # adds User Data that installs the CodeDeploy agent on your auto-scaling groups hosts\n        # default: true\n        install_agent=True,\n        # adds EC2 instances matching tags\n        ec2_instance_tags=codedeploy.InstanceTagSet({\n            # any instance with tags satisfying\n            # key1=v1 or key1=v2 or key2 (any value) or value v3 (any key)\n            # will match this group\n            "key1": ["v1", "v2"],\n            "key2": [],\n            "": ["v3"]\n        }),\n        # adds on-premise instances matching tags\n        on_premise_instance_tags=codedeploy.InstanceTagSet({\n            "key1": ["v1", "v2"]\n        }, {\n            "key2": ["v3"]\n        }),\n        # CloudWatch alarms\n        alarms=[alarm],\n        # whether to ignore failure to fetch the status of alarms from CloudWatch\n        # default: false\n        ignore_poll_alarms_failure=False,\n        # auto-rollback configuration\n        auto_rollback=codedeploy.AutoRollbackConfig(\n            failed_deployment=True,  # default: true\n            stopped_deployment=True,  # default: false\n            deployment_in_alarm=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_in_alarm', 'failed_deployment', 'stopped_deployment']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.AutoRollbackConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.BaseDeploymentConfigOptions
class BaseDeploymentConfigOptionsDef(BaseStruct):
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    base_deployment_config_options = codedeploy.BaseDeploymentConfigOptions(\n        deployment_config_name="deploymentConfigName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_config_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.BaseDeploymentConfigOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.BaseDeploymentConfigProps
class BaseDeploymentConfigPropsDef(BaseStruct):
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name\n')
    compute_platform: typing.Optional[aws_cdk.aws_codedeploy.ComputePlatform] = pydantic.Field(None, description='The destination compute platform for the deployment. Default: ComputePlatform.Server\n')
    minimum_healthy_hosts: typing.Optional[models.aws_codedeploy.MinimumHealthyHostsDef] = pydantic.Field(None, description='Minimum number of healthy hosts. Default: None\n')
    traffic_routing: typing.Optional[models.aws_codedeploy.TrafficRoutingDef] = pydantic.Field(None, description='The configuration that specifies how traffic is shifted during a deployment. Only applicable to ECS and Lambda deployments, and must not be specified for Server deployments. Default: None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    # minimum_healthy_hosts: codedeploy.MinimumHealthyHosts\n    # traffic_routing: codedeploy.TrafficRouting\n\n    base_deployment_config_props = codedeploy.BaseDeploymentConfigProps(\n        compute_platform=codedeploy.ComputePlatform.SERVER,\n        deployment_config_name="deploymentConfigName",\n        minimum_healthy_hosts=minimum_healthy_hosts,\n        traffic_routing=traffic_routing\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_config_name', 'compute_platform', 'minimum_healthy_hosts', 'traffic_routing']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.BaseDeploymentConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.BaseTrafficShiftingConfigProps
class BaseTrafficShiftingConfigPropsDef(BaseStruct):
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage to increase traffic on each traffic shift.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    base_traffic_shifting_config_props = codedeploy.BaseTrafficShiftingConfigProps(\n        interval=cdk.Duration.minutes(30),\n        percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['interval', 'percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.BaseTrafficShiftingConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.BaseTrafficShiftingConfigPropsDefConfig] = pydantic.Field(None)


class BaseTrafficShiftingConfigPropsDefConfig(pydantic.BaseModel):
    interval_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.CanaryTrafficRoutingConfig
class CanaryTrafficRoutingConfigDef(BaseStruct):
    canary_interval: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of minutes between the first and second traffic shifts of a ``TimeBasedCanary`` deployment.\n')
    canary_percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage of traffic to shift in the first increment of a ``TimeBasedCanary`` deployment.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    canary_traffic_routing_config = codedeploy.CanaryTrafficRoutingConfig(\n        canary_interval=123,\n        canary_percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['canary_interval', 'canary_percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CanaryTrafficRoutingConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentConfig.MinimumHealthyHostsProperty
class CfnDeploymentConfig_MinimumHealthyHostsPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum healthy instance type:. - HOST_COUNT: The minimum number of healthy instance as an absolute value. - FLEET_PERCENT: The minimum number of healthy instance as a percentage of the total number of instance in the deployment. In an example of nine instance, if a HOST_COUNT of six is specified, deploy to up to three instances at a time. The deployment is successful if six or more instances are deployed to successfully. Otherwise, the deployment fails. If a FLEET_PERCENT of 40 is specified, deploy to up to five instance at a time. The deployment is successful if four or more instance are deployed to successfully. Otherwise, the deployment fails. .. epigraph:: In a call to ``GetDeploymentConfig`` , CodeDeployDefault.OneAtATime returns a minimum healthy instance type of MOST_CONCURRENCY and a value of 1. This means a deployment to only one instance at a time. (You cannot set the type to MOST_CONCURRENCY, only to HOST_COUNT or FLEET_PERCENT.) In addition, with CodeDeployDefault.OneAtATime, AWS CodeDeploy attempts to ensure that all instances but one are kept in a healthy state during the deployment. Although this allows one instance at a time to be taken offline for a new deployment, it also means that if the deployment to the last instance fails, the overall deployment is still successful. For more information, see `AWS CodeDeploy Instance Health <https://docs.aws.amazon.com//codedeploy/latest/userguide/instances-health.html>`_ in the *AWS CodeDeploy User Guide* .\n')
    value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum healthy instance value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentconfig-minimumhealthyhosts.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    minimum_healthy_hosts_property = codedeploy.CfnDeploymentConfig.MinimumHealthyHostsProperty(\n        type="type",\n        value=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentConfig.MinimumHealthyHostsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentConfig.TimeBasedCanaryProperty
class CfnDeploymentConfig_TimeBasedCanaryPropertyDef(BaseStruct):
    canary_interval: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of minutes between the first and second traffic shifts of a ``TimeBasedCanary`` deployment.\n')
    canary_percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage of traffic to shift in the first increment of a ``TimeBasedCanary`` deployment.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentconfig-timebasedcanary.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    time_based_canary_property = codedeploy.CfnDeploymentConfig.TimeBasedCanaryProperty(\n        canary_interval=123,\n        canary_percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['canary_interval', 'canary_percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentConfig.TimeBasedCanaryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentConfig.TimeBasedLinearProperty
class CfnDeploymentConfig_TimeBasedLinearPropertyDef(BaseStruct):
    linear_interval: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of minutes between each incremental traffic shift of a ``TimeBasedLinear`` deployment.\n')
    linear_percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage of traffic that is shifted at the start of each increment of a ``TimeBasedLinear`` deployment.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentconfig-timebasedlinear.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    time_based_linear_property = codedeploy.CfnDeploymentConfig.TimeBasedLinearProperty(\n        linear_interval=123,\n        linear_percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['linear_interval', 'linear_percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentConfig.TimeBasedLinearProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentConfig.TrafficRoutingConfigProperty
class CfnDeploymentConfig_TrafficRoutingConfigPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of traffic shifting ( ``TimeBasedCanary`` or ``TimeBasedLinear`` ) used by a deployment configuration.\n')
    time_based_canary: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentConfig_TimeBasedCanaryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="A configuration that shifts traffic from one version of a Lambda function or ECS task set to another in two increments. The original and target Lambda function versions or ECS task sets are specified in the deployment's AppSpec file.\n")
    time_based_linear: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentConfig_TimeBasedLinearPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A configuration that shifts traffic from one version of a Lambda function or Amazon ECS task set to another in equal increments, with an equal number of minutes between each increment. The original and target Lambda function versions or Amazon ECS task sets are specified in the deployment\'s AppSpec file.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentconfig-trafficroutingconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    traffic_routing_config_property = codedeploy.CfnDeploymentConfig.TrafficRoutingConfigProperty(\n        type="type",\n\n        # the properties below are optional\n        time_based_canary=codedeploy.CfnDeploymentConfig.TimeBasedCanaryProperty(\n            canary_interval=123,\n            canary_percentage=123\n        ),\n        time_based_linear=codedeploy.CfnDeploymentConfig.TimeBasedLinearProperty(\n            linear_interval=123,\n            linear_percentage=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'time_based_canary', 'time_based_linear']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentConfig.TrafficRoutingConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.AlarmConfigurationProperty
class CfnDeploymentGroup_AlarmConfigurationPropertyDef(BaseStruct):
    alarms: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_AlarmPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of alarms configured for the deployment or deployment group. A maximum of 10 alarms can be added.\n')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the alarm configuration is enabled.\n')
    ignore_poll_alarm_failure: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether a deployment should continue if information about the current state of alarms cannot be retrieved from Amazon CloudWatch . The default value is ``false`` . - ``true`` : The deployment proceeds even if alarm status information can\'t be retrieved from CloudWatch . - ``false`` : The deployment stops if alarm status information can\'t be retrieved from CloudWatch .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-alarmconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    alarm_configuration_property = codedeploy.CfnDeploymentGroup.AlarmConfigurationProperty(\n        alarms=[codedeploy.CfnDeploymentGroup.AlarmProperty(\n            name="name"\n        )],\n        enabled=False,\n        ignore_poll_alarm_failure=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alarms', 'enabled', 'ignore_poll_alarm_failure']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.AlarmConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.AlarmProperty
class CfnDeploymentGroup_AlarmPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the alarm. Maximum length is 255 characters. Each alarm name can be used only once in a list of alarms.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-alarm.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    alarm_property = codedeploy.CfnDeploymentGroup.AlarmProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.AlarmProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.AutoRollbackConfigurationProperty
class CfnDeploymentGroup_AutoRollbackConfigurationPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether a defined automatic rollback configuration is currently enabled.\n')
    events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The event type or types that trigger a rollback. Valid values are ``DEPLOYMENT_FAILURE`` , ``DEPLOYMENT_STOP_ON_ALARM`` , or ``DEPLOYMENT_STOP_ON_REQUEST`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-autorollbackconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    auto_rollback_configuration_property = codedeploy.CfnDeploymentGroup.AutoRollbackConfigurationProperty(\n        enabled=False,\n        events=["events"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'events']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.AutoRollbackConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.BlueGreenDeploymentConfigurationProperty
class CfnDeploymentGroup_BlueGreenDeploymentConfigurationPropertyDef(BaseStruct):
    deployment_ready_option: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_DeploymentReadyOptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the action to take when newly provisioned instances are ready to receive traffic in a blue/green deployment.\n')
    green_fleet_provisioning_option: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_GreenFleetProvisioningOptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about how instances are provisioned for a replacement environment in a blue/green deployment.\n')
    terminate_blue_instances_on_deployment_success: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_BlueInstanceTerminationOptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about whether to terminate instances in the original fleet during a blue/green deployment.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-bluegreendeploymentconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    blue_green_deployment_configuration_property = codedeploy.CfnDeploymentGroup.BlueGreenDeploymentConfigurationProperty(\n        deployment_ready_option=codedeploy.CfnDeploymentGroup.DeploymentReadyOptionProperty(\n            action_on_timeout="actionOnTimeout",\n            wait_time_in_minutes=123\n        ),\n        green_fleet_provisioning_option=codedeploy.CfnDeploymentGroup.GreenFleetProvisioningOptionProperty(\n            action="action"\n        ),\n        terminate_blue_instances_on_deployment_success=codedeploy.CfnDeploymentGroup.BlueInstanceTerminationOptionProperty(\n            action="action",\n            termination_wait_time_in_minutes=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_ready_option', 'green_fleet_provisioning_option', 'terminate_blue_instances_on_deployment_success']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.BlueGreenDeploymentConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.BlueInstanceTerminationOptionProperty
class CfnDeploymentGroup_BlueInstanceTerminationOptionPropertyDef(BaseStruct):
    action: typing.Optional[str] = pydantic.Field(None, description='The action to take on instances in the original environment after a successful blue/green deployment. - ``TERMINATE`` : Instances are terminated after a specified wait time. - ``KEEP_ALIVE`` : Instances are left running after they are deregistered from the load balancer and removed from the deployment group.\n')
    termination_wait_time_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='For an Amazon EC2 deployment, the number of minutes to wait after a successful blue/green deployment before terminating instances from the original environment. For an Amazon ECS deployment, the number of minutes before deleting the original (blue) task set. During an Amazon ECS deployment, CodeDeploy shifts traffic from the original (blue) task set to a replacement (green) task set. The maximum setting is 2880 minutes (2 days).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-blueinstanceterminationoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    blue_instance_termination_option_property = codedeploy.CfnDeploymentGroup.BlueInstanceTerminationOptionProperty(\n        action="action",\n        termination_wait_time_in_minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'termination_wait_time_in_minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.BlueInstanceTerminationOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.DeploymentProperty
class CfnDeploymentGroup_DeploymentPropertyDef(BaseStruct):
    revision: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_RevisionLocationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Information about the location of stored application artifacts and the service from which to retrieve them.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A comment about the deployment.\n')
    ignore_application_stop_failures: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If true, then if an ``ApplicationStop`` , ``BeforeBlockTraffic`` , or ``AfterBlockTraffic`` deployment lifecycle event to an instance fails, then the deployment continues to the next deployment lifecycle event. For example, if ``ApplicationStop`` fails, the deployment continues with DownloadBundle. If ``BeforeBlockTraffic`` fails, the deployment continues with ``BlockTraffic`` . If ``AfterBlockTraffic`` fails, the deployment continues with ``ApplicationStop`` . If false or not specified, then if a lifecycle event fails during a deployment to an instance, that deployment fails. If deployment to that instance is part of an overall deployment and the number of healthy hosts is not less than the minimum number of healthy hosts, then a deployment to the next instance is attempted. During a deployment, the AWS CodeDeploy agent runs the scripts specified for ``ApplicationStop`` , ``BeforeBlockTraffic`` , and ``AfterBlockTraffic`` in the AppSpec file from the previous successful deployment. (All other scripts are run from the AppSpec file in the current deployment.) If one of these scripts contains an error and does not run successfully, the deployment can fail. If the cause of the failure is a script from the last successful deployment that will never run successfully, create a new deployment and use ``ignoreApplicationStopFailures`` to specify that the ``ApplicationStop`` , ``BeforeBlockTraffic`` , and ``AfterBlockTraffic`` failures should be ignored.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-deployment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    deployment_property = codedeploy.CfnDeploymentGroup.DeploymentProperty(\n        revision=codedeploy.CfnDeploymentGroup.RevisionLocationProperty(\n            git_hub_location=codedeploy.CfnDeploymentGroup.GitHubLocationProperty(\n                commit_id="commitId",\n                repository="repository"\n            ),\n            revision_type="revisionType",\n            s3_location=codedeploy.CfnDeploymentGroup.S3LocationProperty(\n                bucket="bucket",\n                key="key",\n\n                # the properties below are optional\n                bundle_type="bundleType",\n                e_tag="eTag",\n                version="version"\n            )\n        ),\n\n        # the properties below are optional\n        description="description",\n        ignore_application_stop_failures=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['revision', 'description', 'ignore_application_stop_failures']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.DeploymentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.DeploymentReadyOptionProperty
class CfnDeploymentGroup_DeploymentReadyOptionPropertyDef(BaseStruct):
    action_on_timeout: typing.Optional[str] = pydantic.Field(None, description='Information about when to reroute traffic from an original environment to a replacement environment in a blue/green deployment. - CONTINUE_DEPLOYMENT: Register new instances with the load balancer immediately after the new application revision is installed on the instances in the replacement environment. - STOP_DEPLOYMENT: Do not register new instances with a load balancer unless traffic rerouting is started using `ContinueDeployment <https://docs.aws.amazon.com/codedeploy/latest/APIReference/API_ContinueDeployment.html>`_ . If traffic rerouting is not started before the end of the specified wait period, the deployment status is changed to Stopped.\n')
    wait_time_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='The number of minutes to wait before the status of a blue/green deployment is changed to Stopped if rerouting is not started manually. Applies only to the ``STOP_DEPLOYMENT`` option for ``actionOnTimeout`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-deploymentreadyoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    deployment_ready_option_property = codedeploy.CfnDeploymentGroup.DeploymentReadyOptionProperty(\n        action_on_timeout="actionOnTimeout",\n        wait_time_in_minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action_on_timeout', 'wait_time_in_minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.DeploymentReadyOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.DeploymentStyleProperty
class CfnDeploymentGroup_DeploymentStylePropertyDef(BaseStruct):
    deployment_option: typing.Optional[str] = pydantic.Field(None, description='Indicates whether to route deployment traffic behind a load balancer. .. epigraph:: An Amazon EC2 Application Load Balancer or Network Load Balancer is required for an Amazon ECS deployment.\n')
    deployment_type: typing.Optional[str] = pydantic.Field(None, description='Indicates whether to run an in-place or blue/green deployment.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-deploymentstyle.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    deployment_style_property = codedeploy.CfnDeploymentGroup.DeploymentStyleProperty(\n        deployment_option="deploymentOption",\n        deployment_type="deploymentType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_option', 'deployment_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.DeploymentStyleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.EC2TagFilterProperty
class CfnDeploymentGroup_EC2TagFilterPropertyDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description='The tag filter key.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The tag filter type:. - ``KEY_ONLY`` : Key only. - ``VALUE_ONLY`` : Value only. - ``KEY_AND_VALUE`` : Key and value.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The tag filter value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-ec2tagfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    e_c2_tag_filter_property = codedeploy.CfnDeploymentGroup.EC2TagFilterProperty(\n        key="key",\n        type="type",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'type', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.EC2TagFilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.EC2TagSetListObjectProperty
class CfnDeploymentGroup_EC2TagSetListObjectPropertyDef(BaseStruct):
    ec2_tag_group: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_EC2TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list that contains other lists of Amazon EC2 instance tag groups. For an instance to be included in the deployment group, it must be identified by all of the tag groups in the list.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-ec2tagsetlistobject.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    e_c2_tag_set_list_object_property = codedeploy.CfnDeploymentGroup.EC2TagSetListObjectProperty(\n        ec2_tag_group=[codedeploy.CfnDeploymentGroup.EC2TagFilterProperty(\n            key="key",\n            type="type",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ec2_tag_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.EC2TagSetListObjectProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.EC2TagSetProperty
class CfnDeploymentGroup_EC2TagSetPropertyDef(BaseStruct):
    ec2_tag_set_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_EC2TagSetListObjectPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The Amazon EC2 tags that are already applied to Amazon EC2 instances that you want to include in the deployment group. CodeDeploy includes all Amazon EC2 instances identified by any of the tags you specify in this deployment group. Duplicates are not allowed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-ec2tagset.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    e_c2_tag_set_property = codedeploy.CfnDeploymentGroup.EC2TagSetProperty(\n        ec2_tag_set_list=[codedeploy.CfnDeploymentGroup.EC2TagSetListObjectProperty(\n            ec2_tag_group=[codedeploy.CfnDeploymentGroup.EC2TagFilterProperty(\n                key="key",\n                type="type",\n                value="value"\n            )]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ec2_tag_set_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.EC2TagSetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.ECSServiceProperty
class CfnDeploymentGroup_ECSServicePropertyDef(BaseStruct):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the cluster that the Amazon ECS service is associated with.\n')
    service_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the target Amazon ECS service.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-ecsservice.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    e_cSService_property = codedeploy.CfnDeploymentGroup.ECSServiceProperty(\n        cluster_name="clusterName",\n        service_name="serviceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.ECSServiceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.ELBInfoProperty
class CfnDeploymentGroup_ELBInfoPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='For blue/green deployments, the name of the load balancer that is used to route traffic from original instances to replacement instances in a blue/green deployment. For in-place deployments, the name of the load balancer that instances are deregistered from so they are not serving traffic during a deployment, and then re-registered with after the deployment is complete. .. epigraph:: AWS CloudFormation supports blue/green deployments on AWS Lambda compute platforms only.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-elbinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    e_lBInfo_property = codedeploy.CfnDeploymentGroup.ELBInfoProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.ELBInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.GitHubLocationProperty
class CfnDeploymentGroup_GitHubLocationPropertyDef(BaseStruct):
    commit_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The SHA1 commit ID of the GitHub commit that represents the bundled artifacts for the application revision.\n')
    repository: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The GitHub account and repository pair that stores a reference to the commit that represents the bundled artifacts for the application revision. Specify the value as ``account/repository`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-githublocation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    git_hub_location_property = codedeploy.CfnDeploymentGroup.GitHubLocationProperty(\n        commit_id="commitId",\n        repository="repository"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['commit_id', 'repository']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.GitHubLocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.GreenFleetProvisioningOptionProperty
class CfnDeploymentGroup_GreenFleetProvisioningOptionPropertyDef(BaseStruct):
    action: typing.Optional[str] = pydantic.Field(None, description='The method used to add instances to a replacement environment. - ``DISCOVER_EXISTING`` : Use instances that already exist or will be created manually. - ``COPY_AUTO_SCALING_GROUP`` : Use settings from a specified Auto Scaling group to define and create instances in a new Auto Scaling group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-greenfleetprovisioningoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    green_fleet_provisioning_option_property = codedeploy.CfnDeploymentGroup.GreenFleetProvisioningOptionProperty(\n        action="action"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.GreenFleetProvisioningOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.LoadBalancerInfoProperty
class CfnDeploymentGroup_LoadBalancerInfoPropertyDef(BaseStruct):
    elb_info_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_ELBInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="An array that contains information about the load balancers to use for load balancing in a deployment. If you're using Classic Load Balancers, specify those load balancers in this array. .. epigraph:: You can add up to 10 load balancers to the array. > If you're using Application Load Balancers or Network Load Balancers, use the ``targetGroupInfoList`` array instead of this one.\n")
    target_group_info_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TargetGroupInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="An array that contains information about the target groups to use for load balancing in a deployment. If you're using Application Load Balancers and Network Load Balancers, specify their associated target groups in this array. .. epigraph:: You can add up to 10 target groups to the array. > If you're using Classic Load Balancers, use the ``elbInfoList`` array instead of this one.\n")
    target_group_pair_info_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TargetGroupPairInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The target group pair information. This is an array of ``TargeGroupPairInfo`` objects with a maximum size of one.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-loadbalancerinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    load_balancer_info_property = codedeploy.CfnDeploymentGroup.LoadBalancerInfoProperty(\n        elb_info_list=[codedeploy.CfnDeploymentGroup.ELBInfoProperty(\n            name="name"\n        )],\n        target_group_info_list=[codedeploy.CfnDeploymentGroup.TargetGroupInfoProperty(\n            name="name"\n        )],\n        target_group_pair_info_list=[codedeploy.CfnDeploymentGroup.TargetGroupPairInfoProperty(\n            prod_traffic_route=codedeploy.CfnDeploymentGroup.TrafficRouteProperty(\n                listener_arns=["listenerArns"]\n            ),\n            target_groups=[codedeploy.CfnDeploymentGroup.TargetGroupInfoProperty(\n                name="name"\n            )],\n            test_traffic_route=codedeploy.CfnDeploymentGroup.TrafficRouteProperty(\n                listener_arns=["listenerArns"]\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['elb_info_list', 'target_group_info_list', 'target_group_pair_info_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.LoadBalancerInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.OnPremisesTagSetListObjectProperty
class CfnDeploymentGroup_OnPremisesTagSetListObjectPropertyDef(BaseStruct):
    on_premises_tag_group: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about groups of on-premises instance tags.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-onpremisestagsetlistobject.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    on_premises_tag_set_list_object_property = codedeploy.CfnDeploymentGroup.OnPremisesTagSetListObjectProperty(\n        on_premises_tag_group=[codedeploy.CfnDeploymentGroup.TagFilterProperty(\n            key="key",\n            type="type",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['on_premises_tag_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.OnPremisesTagSetListObjectProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.OnPremisesTagSetProperty
class CfnDeploymentGroup_OnPremisesTagSetPropertyDef(BaseStruct):
    on_premises_tag_set_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_OnPremisesTagSetListObjectPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list that contains other lists of on-premises instance tag groups. For an instance to be included in the deployment group, it must be identified by all of the tag groups in the list. Duplicates are not allowed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-onpremisestagset.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    on_premises_tag_set_property = codedeploy.CfnDeploymentGroup.OnPremisesTagSetProperty(\n        on_premises_tag_set_list=[codedeploy.CfnDeploymentGroup.OnPremisesTagSetListObjectProperty(\n            on_premises_tag_group=[codedeploy.CfnDeploymentGroup.TagFilterProperty(\n                key="key",\n                type="type",\n                value="value"\n            )]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['on_premises_tag_set_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.OnPremisesTagSetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.RevisionLocationProperty
class CfnDeploymentGroup_RevisionLocationPropertyDef(BaseStruct):
    git_hub_location: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_GitHubLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the location of application artifacts stored in GitHub.\n')
    revision_type: typing.Optional[str] = pydantic.Field(None, description='The type of application revision:. - S3: An application revision stored in Amazon S3. - GitHub: An application revision stored in GitHub (EC2/On-premises deployments only). - String: A YAML-formatted or JSON-formatted string ( AWS Lambda deployments only). - AppSpecContent: An ``AppSpecContent`` object that contains the contents of an AppSpec file for an AWS Lambda or Amazon ECS deployment. The content is formatted as JSON or YAML stored as a RawString.\n')
    s3_location: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_S3LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the location of a revision stored in Amazon S3.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-revisionlocation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    revision_location_property = codedeploy.CfnDeploymentGroup.RevisionLocationProperty(\n        git_hub_location=codedeploy.CfnDeploymentGroup.GitHubLocationProperty(\n            commit_id="commitId",\n            repository="repository"\n        ),\n        revision_type="revisionType",\n        s3_location=codedeploy.CfnDeploymentGroup.S3LocationProperty(\n            bucket="bucket",\n            key="key",\n\n            # the properties below are optional\n            bundle_type="bundleType",\n            e_tag="eTag",\n            version="version"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['git_hub_location', 'revision_type', 's3_location']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.RevisionLocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.S3LocationProperty
class CfnDeploymentGroup_S3LocationPropertyDef(BaseStruct):
    bucket: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Amazon S3 bucket where the application revision is stored.\n')
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Amazon S3 object that represents the bundled artifacts for the application revision.\n')
    bundle_type: typing.Optional[str] = pydantic.Field(None, description='The file type of the application revision. Must be one of the following:. - JSON - tar: A tar archive file. - tgz: A compressed tar archive file. - YAML - zip: A zip archive file.\n')
    e_tag: typing.Optional[str] = pydantic.Field(None, description='The ETag of the Amazon S3 object that represents the bundled artifacts for the application revision. If the ETag is not specified as an input parameter, ETag validation of the object is skipped.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='A specific version of the Amazon S3 object that represents the bundled artifacts for the application revision. If the version is not specified, the system uses the most recent version by default.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-s3location.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    s3_location_property = codedeploy.CfnDeploymentGroup.S3LocationProperty(\n        bucket="bucket",\n        key="key",\n\n        # the properties below are optional\n        bundle_type="bundleType",\n        e_tag="eTag",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'key', 'bundle_type', 'e_tag', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.S3LocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.TagFilterProperty
class CfnDeploymentGroup_TagFilterPropertyDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description='The on-premises instance tag filter key.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The on-premises instance tag filter type:. - KEY_ONLY: Key only. - VALUE_ONLY: Value only. - KEY_AND_VALUE: Key and value.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The on-premises instance tag filter value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-tagfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    tag_filter_property = codedeploy.CfnDeploymentGroup.TagFilterProperty(\n        key="key",\n        type="type",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'type', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.TagFilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.TargetGroupInfoProperty
class CfnDeploymentGroup_TargetGroupInfoPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='For blue/green deployments, the name of the target group that instances in the original environment are deregistered from, and instances in the replacement environment registered with. For in-place deployments, the name of the target group that instances are deregistered from, so they are not serving traffic during a deployment, and then re-registered with after the deployment completes. No duplicates allowed. .. epigraph:: AWS CloudFormation supports blue/green deployments on AWS Lambda compute platforms only. This value cannot exceed 32 characters, so you should use the ``Name`` property of the target group, or the ``TargetGroupName`` attribute with the ``Fn::GetAtt`` intrinsic function, as shown in the following example. Don\'t use the group\'s Amazon Resource Name (ARN) or ``TargetGroupFullName`` attribute.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-targetgroupinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    target_group_info_property = codedeploy.CfnDeploymentGroup.TargetGroupInfoProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.TargetGroupInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.TargetGroupPairInfoProperty
class CfnDeploymentGroup_TargetGroupPairInfoPropertyDef(BaseStruct):
    prod_traffic_route: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TrafficRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The path used by a load balancer to route production traffic when an Amazon ECS deployment is complete.\n')
    target_groups: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TargetGroupInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One pair of target groups. One is associated with the original task set. The second is associated with the task set that serves traffic after the deployment is complete.\n')
    test_traffic_route: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TrafficRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An optional path used by a load balancer to route test traffic after an Amazon ECS deployment. Validation can occur while test traffic is served during a deployment.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-targetgrouppairinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    target_group_pair_info_property = codedeploy.CfnDeploymentGroup.TargetGroupPairInfoProperty(\n        prod_traffic_route=codedeploy.CfnDeploymentGroup.TrafficRouteProperty(\n            listener_arns=["listenerArns"]\n        ),\n        target_groups=[codedeploy.CfnDeploymentGroup.TargetGroupInfoProperty(\n            name="name"\n        )],\n        test_traffic_route=codedeploy.CfnDeploymentGroup.TrafficRouteProperty(\n            listener_arns=["listenerArns"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['prod_traffic_route', 'target_groups', 'test_traffic_route']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.TargetGroupPairInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.TrafficRouteProperty
class CfnDeploymentGroup_TrafficRoutePropertyDef(BaseStruct):
    listener_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of one listener. The listener identifies the route between a target group and a load balancer. This is an array of strings with a maximum size of one.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-trafficroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    traffic_route_property = codedeploy.CfnDeploymentGroup.TrafficRouteProperty(\n        listener_arns=["listenerArns"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listener_arns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.TrafficRouteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup.TriggerConfigProperty
class CfnDeploymentGroup_TriggerConfigPropertyDef(BaseStruct):
    trigger_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The event type or types that trigger notifications.\n')
    trigger_name: typing.Optional[str] = pydantic.Field(None, description='The name of the notification trigger.\n')
    trigger_target_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Amazon Simple Notification Service topic through which notifications about deployment or instance events are sent.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-triggerconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    trigger_config_property = codedeploy.CfnDeploymentGroup.TriggerConfigProperty(\n        trigger_events=["triggerEvents"],\n        trigger_name="triggerName",\n        trigger_target_arn="triggerTargetArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['trigger_events', 'trigger_name', 'trigger_target_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup.TriggerConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CustomLambdaDeploymentConfigProps
class CustomLambdaDeploymentConfigPropsDef(BaseStruct):
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='(deprecated) The interval, in number of minutes: - For LINEAR, how frequently additional traffic is shifted - For CANARY, how long to shift traffic before the full deployment.\n')
    percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='(deprecated) The integer percentage of traffic to shift: - For LINEAR, the percentage to shift every interval - For CANARY, the percentage to shift until the interval passes, before the full deployment.\n')
    type: typing.Union[aws_cdk.aws_codedeploy.CustomLambdaDeploymentConfigType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='(deprecated) The type of deployment config, either CANARY or LINEAR.\n')
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='(deprecated) The verbatim name of the deployment config. Must be unique per account/region. Other parameters cannot be updated if this name is provided. Default: - automatically generated name\n\n:deprecated: Use ``LambdaDeploymentConfig``\n\n:stability: deprecated\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    custom_lambda_deployment_config_props = codedeploy.CustomLambdaDeploymentConfigProps(\n        interval=cdk.Duration.minutes(30),\n        percentage=123,\n        type=codedeploy.CustomLambdaDeploymentConfigType.CANARY,\n\n        # the properties below are optional\n        deployment_config_name="deploymentConfigName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['interval', 'percentage', 'type', 'deployment_config_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CustomLambdaDeploymentConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.CustomLambdaDeploymentConfigPropsDefConfig] = pydantic.Field(None)


class CustomLambdaDeploymentConfigPropsDefConfig(pydantic.BaseModel):
    interval_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.EcsApplicationProps
class EcsApplicationPropsDef(BaseStruct):
    application_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Application. Default: an auto-generated name will be used\n\n:exampleMetadata: infused\n\nExample::\n\n    application = codedeploy.EcsApplication(self, "CodeDeployApplication",\n        application_name="MyApplication"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.EcsApplicationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.EcsBlueGreenDeploymentConfig
class EcsBlueGreenDeploymentConfigDef(BaseStruct):
    blue_target_group: typing.Union[_REQUIRED_INIT_PARAM, models.aws_elasticloadbalancingv2.TargetGroupBaseDef, models.aws_elasticloadbalancingv2.ApplicationTargetGroupDef, models.aws_elasticloadbalancingv2.NetworkTargetGroupDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The target group that will be associated with the 'blue' ECS task set during a blue-green deployment.\n")
    green_target_group: typing.Union[_REQUIRED_INIT_PARAM, models.aws_elasticloadbalancingv2.TargetGroupBaseDef, models.aws_elasticloadbalancingv2.ApplicationTargetGroupDef, models.aws_elasticloadbalancingv2.NetworkTargetGroupDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The target group that will be associated with the 'green' ECS task set during a blue-green deployment.\n")
    listener: typing.Union[_REQUIRED_INIT_PARAM, models.aws_elasticloadbalancingv2.BaseListenerDef, models.aws_elasticloadbalancingv2.ApplicationListenerDef, models.aws_elasticloadbalancingv2.NetworkListenerDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The load balancer listener used to serve production traffic and to shift production traffic from the 'blue' ECS task set to the 'green' ECS task set during a blue-green deployment.\n")
    deployment_approval_wait_time: typing.Optional[models.DurationDef] = pydantic.Field(None, description="Specify how long CodeDeploy waits for approval to continue a blue-green deployment before it stops the deployment. After provisioning the 'green' ECS task set and re-routing test traffic, CodeDeploy can wait for approval before continuing the deployment and re-routing production traffic. During this wait time, validation such as manual testing or running integration tests can occur using the test traffic port, prior to exposing the new 'green' task set to production traffic. To approve the deployment, validation steps use the CodeDeploy [ContinueDeployment API(https://docs.aws.amazon.com/codedeploy/latest/APIReference/API_ContinueDeployment.html). If the ContinueDeployment API is not called within the wait time period, CodeDeploy will stop the deployment. By default, CodeDeploy will not wait for deployment approval. After re-routing test traffic to the 'green' ECS task set and running any 'AfterAllowTestTraffic' and 'BeforeAllowTraffic' lifecycle hooks, the deployment will immediately re-route production traffic to the 'green' ECS task set. Default: 0\n")
    termination_wait_time: typing.Optional[models.DurationDef] = pydantic.Field(None, description="Specify how long CodeDeploy waits before it terminates the original 'blue' ECS task set when a blue-green deployment is complete. During this wait time, CodeDeploy will continue to monitor any CloudWatch alarms specified for the deployment group, and the deployment group can be configured to automatically roll back if those alarms fire. Once CodeDeploy begins to terminate the 'blue' ECS task set, the deployment can no longer be rolled back, manually or automatically. By default, the deployment will immediately terminate the 'blue' ECS task set after production traffic is successfully routed to the 'green' ECS task set. Default: 0\n")
    test_listener: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.BaseListenerDef, models.aws_elasticloadbalancingv2.ApplicationListenerDef, models.aws_elasticloadbalancingv2.NetworkListenerDef]] = pydantic.Field(None, description='The load balancer listener used to route test traffic to the \'green\' ECS task set during a blue-green deployment. During a blue-green deployment, validation can occur after test traffic has been re-routed and before production traffic has been re-routed to the \'green\' ECS task set. You can specify one or more Lambda funtions in the deployment\'s AppSpec file that run during the AfterAllowTestTraffic hook. The functions can run validation tests. If a validation test fails, a deployment rollback is triggered. If the validation tests succeed, the next hook in the deployment lifecycle, BeforeAllowTraffic, is triggered. If a test listener is not specified, the deployment will proceed to routing the production listener to the \'green\' ECS task set and will skip the AfterAllowTestTraffic hook. Default: No test listener will be added\n\n:see: https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-ecs\n:exampleMetadata: infused\n\nExample::\n\n    # my_application: codedeploy.EcsApplication\n    # cluster: ecs.Cluster\n    # task_definition: ecs.FargateTaskDefinition\n    # blue_target_group: elbv2.ITargetGroup\n    # green_target_group: elbv2.ITargetGroup\n    # listener: elbv2.IApplicationListener\n\n\n    service = ecs.FargateService(self, "Service",\n        cluster=cluster,\n        task_definition=task_definition,\n        deployment_controller=ecs.DeploymentController(\n            type=ecs.DeploymentControllerType.CODE_DEPLOY\n        )\n    )\n\n    codedeploy.EcsDeploymentGroup(self, "BlueGreenDG",\n        service=service,\n        blue_green_deployment_config=codedeploy.EcsBlueGreenDeploymentConfig(\n            blue_target_group=blue_target_group,\n            green_target_group=green_target_group,\n            listener=listener\n        ),\n        deployment_config=codedeploy.EcsDeploymentConfig.CANARY_10PERCENT_5MINUTES\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['blue_target_group', 'green_target_group', 'listener', 'deployment_approval_wait_time', 'termination_wait_time', 'test_listener']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.EcsBlueGreenDeploymentConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.EcsBlueGreenDeploymentConfigDefConfig] = pydantic.Field(None)


class EcsBlueGreenDeploymentConfigDefConfig(pydantic.BaseModel):
    listener_config: typing.Optional[models._interface_methods.AwsElasticloadbalancingv2IListenerDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.EcsDeploymentConfigProps
class EcsDeploymentConfigPropsDef(BaseStruct):
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name\n')
    traffic_routing: typing.Optional[models.aws_codedeploy.TrafficRoutingDef] = pydantic.Field(None, description='The configuration that specifies how traffic is shifted from the \'blue\' target group to the \'green\' target group during a deployment. Default: AllAtOnce\n\n:exampleMetadata: infused\n\nExample::\n\n    codedeploy.EcsDeploymentConfig(self, "CustomConfig",\n        traffic_routing=codedeploy.TimeBasedCanaryTrafficRouting(\n            interval=Duration.minutes(15),\n            percentage=5\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_config_name', 'traffic_routing']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.EcsDeploymentConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.EcsDeploymentGroupAttributes
class EcsDeploymentGroupAttributesDef(BaseStruct):
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_codedeploy.EcsApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The reference to the CodeDeploy ECS Application that this Deployment Group belongs to.\n')
    deployment_group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The physical, human-readable name of the CodeDeploy ECS Deployment Group that we are referencing.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.EcsDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: EcsDeploymentConfig.ALL_AT_ONCE\n\n:see: EcsDeploymentGroup#fromEcsDeploymentGroupAttributes\n:exampleMetadata: infused\n\nExample::\n\n    # application: codedeploy.EcsApplication\n\n    deployment_group = codedeploy.EcsDeploymentGroup.from_ecs_deployment_group_attributes(self, "ExistingCodeDeployDeploymentGroup",\n        application=application,\n        deployment_group_name="MyExistingDeploymentGroup"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application', 'deployment_group_name', 'deployment_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.EcsDeploymentGroupAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.EcsDeploymentGroupProps
class EcsDeploymentGroupPropsDef(BaseStruct):
    blue_green_deployment_config: typing.Union[_REQUIRED_INIT_PARAM, models.aws_codedeploy.EcsBlueGreenDeploymentConfigDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration options for blue-green ECS deployments.\n')
    service: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ecs.BaseServiceDef, models.aws_ecs.Ec2ServiceDef, models.aws_ecs.ExternalServiceDef, models.aws_ecs.FargateServiceDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ECS service to deploy with this Deployment Group.\n')
    alarms: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]]] = pydantic.Field(None, description='The CloudWatch alarms associated with this Deployment Group. CodeDeploy will stop (and optionally roll back) a deployment if during it any of the alarms trigger. Alarms can also be added after the Deployment Group is created using the ``#addAlarm`` method. Default: []\n')
    application: typing.Optional[typing.Union[models.aws_codedeploy.EcsApplicationDef]] = pydantic.Field(None, description='The reference to the CodeDeploy ECS Application that this Deployment Group belongs to. Default: One will be created for you.\n')
    auto_rollback: typing.Union[models.aws_codedeploy.AutoRollbackConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The auto-rollback configuration for this Deployment Group. Default: - default AutoRollbackConfig.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.EcsDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: EcsDeploymentConfig.ALL_AT_ONCE\n')
    deployment_group_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Deployment Group. Default: An auto-generated name will be used.\n')
    ignore_poll_alarms_failure: typing.Optional[bool] = pydantic.Field(None, description='Whether to continue a deployment even if fetching the alarm status from CloudWatch failed. Default: false\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The service Role of this Deployment Group. Default: - A new Role will be created.\n\n:exampleMetadata: infused\n\nExample::\n\n    # my_application: codedeploy.EcsApplication\n    # cluster: ecs.Cluster\n    # task_definition: ecs.FargateTaskDefinition\n    # blue_target_group: elbv2.ITargetGroup\n    # green_target_group: elbv2.ITargetGroup\n    # listener: elbv2.IApplicationListener\n\n\n    service = ecs.FargateService(self, "Service",\n        cluster=cluster,\n        task_definition=task_definition,\n        deployment_controller=ecs.DeploymentController(\n            type=ecs.DeploymentControllerType.CODE_DEPLOY\n        )\n    )\n\n    codedeploy.EcsDeploymentGroup(self, "BlueGreenDG",\n        service=service,\n        blue_green_deployment_config=codedeploy.EcsBlueGreenDeploymentConfig(\n            blue_target_group=blue_target_group,\n            green_target_group=green_target_group,\n            listener=listener\n        ),\n        deployment_config=codedeploy.EcsDeploymentConfig.CANARY_10PERCENT_5MINUTES\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['blue_green_deployment_config', 'service', 'alarms', 'application', 'auto_rollback', 'deployment_config', 'deployment_group_name', 'ignore_poll_alarms_failure', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.EcsDeploymentGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.EcsDeploymentGroupPropsDefConfig] = pydantic.Field(None)


class EcsDeploymentGroupPropsDefConfig(pydantic.BaseModel):
    service_config: typing.Optional[models._interface_methods.AwsEcsIBaseServiceDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.LambdaApplicationProps
class LambdaApplicationPropsDef(BaseStruct):
    application_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Application. Default: an auto-generated name will be used\n\n:exampleMetadata: infused\n\nExample::\n\n    application = codedeploy.LambdaApplication(self, "CodeDeployApplication",\n        application_name="MyApplication"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LambdaApplicationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.LambdaDeploymentConfigImportProps
class LambdaDeploymentConfigImportPropsDef(BaseStruct):
    deployment_config_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The physical, human-readable name of the custom CodeDeploy Lambda Deployment Configuration that we are referencing.\n\n:see: LambdaDeploymentConfig# import\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    lambda_deployment_config_import_props = codedeploy.LambdaDeploymentConfigImportProps(\n        deployment_config_name="deploymentConfigName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_config_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LambdaDeploymentConfigImportProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.LambdaDeploymentConfigProps
class LambdaDeploymentConfigPropsDef(BaseStruct):
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name\n')
    traffic_routing: typing.Optional[models.aws_codedeploy.TrafficRoutingDef] = pydantic.Field(None, description='The configuration that specifies how traffic is shifted from the \'blue\' target group to the \'green\' target group during a deployment. Default: AllAtOnce\n\n:exampleMetadata: infused\n\nExample::\n\n    # application: codedeploy.LambdaApplication\n    # alias: lambda.Alias\n    config = codedeploy.LambdaDeploymentConfig(self, "CustomConfig",\n        traffic_routing=codedeploy.TimeBasedCanaryTrafficRouting(\n            interval=Duration.minutes(15),\n            percentage=5\n        )\n    )\n    deployment_group = codedeploy.LambdaDeploymentGroup(self, "BlueGreenDeployment",\n        application=application,\n        alias=alias,\n        deployment_config=config\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_config_name', 'traffic_routing']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LambdaDeploymentConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.LambdaDeploymentGroupAttributes
class LambdaDeploymentGroupAttributesDef(BaseStruct):
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_codedeploy.LambdaApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The reference to the CodeDeploy Lambda Application that this Deployment Group belongs to.\n')
    deployment_group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The physical, human-readable name of the CodeDeploy Lambda Deployment Group that we are referencing.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.CustomLambdaDeploymentConfigDef, models.aws_codedeploy.LambdaDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: LambdaDeploymentConfig.CANARY_10PERCENT_5MINUTES\n\n:see: LambdaDeploymentGroup#fromLambdaDeploymentGroupAttributes\n:exampleMetadata: infused\n\nExample::\n\n    # application: codedeploy.LambdaApplication\n\n    deployment_group = codedeploy.LambdaDeploymentGroup.from_lambda_deployment_group_attributes(self, "ExistingCodeDeployDeploymentGroup",\n        application=application,\n        deployment_group_name="MyExistingDeploymentGroup"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application', 'deployment_group_name', 'deployment_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LambdaDeploymentGroupAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.LambdaDeploymentGroupAttributesDefConfig] = pydantic.Field(None)


class LambdaDeploymentGroupAttributesDefConfig(pydantic.BaseModel):
    application_config: typing.Optional[models._interface_methods.AwsCodedeployILambdaApplicationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.LambdaDeploymentGroupProps
class LambdaDeploymentGroupPropsDef(BaseStruct):
    alias: typing.Union[models.aws_lambda.AliasDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Lambda Alias to shift traffic. Updating the version of the alias will trigger a CodeDeploy deployment. [disable-awslint:ref-via-interface] since we need to modify the alias CFN resource update policy\n')
    alarms: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]]] = pydantic.Field(None, description='The CloudWatch alarms associated with this Deployment Group. CodeDeploy will stop (and optionally roll back) a deployment if during it any of the alarms trigger. Alarms can also be added after the Deployment Group is created using the ``#addAlarm`` method. Default: []\n')
    application: typing.Optional[typing.Union[models.aws_codedeploy.LambdaApplicationDef]] = pydantic.Field(None, description='The reference to the CodeDeploy Lambda Application that this Deployment Group belongs to. Default: - One will be created for you.\n')
    auto_rollback: typing.Union[models.aws_codedeploy.AutoRollbackConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The auto-rollback configuration for this Deployment Group. Default: - default AutoRollbackConfig.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.CustomLambdaDeploymentConfigDef, models.aws_codedeploy.LambdaDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: LambdaDeploymentConfig.CANARY_10PERCENT_5MINUTES\n')
    deployment_group_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Deployment Group. Default: - An auto-generated name will be used.\n')
    ignore_poll_alarms_failure: typing.Optional[bool] = pydantic.Field(None, description='Whether to continue a deployment even if fetching the alarm status from CloudWatch failed. Default: false\n')
    post_hook: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The Lambda function to run after traffic routing starts. Default: - None.\n')
    pre_hook: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The Lambda function to run before traffic routing starts. Default: - None.\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The service Role of this Deployment Group. Default: - A new Role will be created.\n\n:exampleMetadata: infused\n\nExample::\n\n    # my_application: codedeploy.LambdaApplication\n    # func: lambda.Function\n\n    version = func.current_version\n    version1_alias = lambda_.Alias(self, "alias",\n        alias_name="prod",\n        version=version\n    )\n\n    deployment_group = codedeploy.LambdaDeploymentGroup(self, "BlueGreenDeployment",\n        application=my_application,  # optional property: one will be created for you if not provided\n        alias=version1_alias,\n        deployment_config=codedeploy.LambdaDeploymentConfig.LINEAR_10PERCENT_EVERY_1MINUTE\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alias', 'alarms', 'application', 'auto_rollback', 'deployment_config', 'deployment_group_name', 'ignore_poll_alarms_failure', 'post_hook', 'pre_hook', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LambdaDeploymentGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.LambdaDeploymentGroupPropsDefConfig] = pydantic.Field(None)


class LambdaDeploymentGroupPropsDefConfig(pydantic.BaseModel):
    alias_config: typing.Optional[models.aws_lambda.AliasDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.LinearTrafficRoutingConfig
class LinearTrafficRoutingConfigDef(BaseStruct):
    linear_interval: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of minutes between each incremental traffic shift of a ``TimeBasedLinear`` deployment.\n')
    linear_percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage of traffic that is shifted at the start of each increment of a ``TimeBasedLinear`` deployment.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    linear_traffic_routing_config = codedeploy.LinearTrafficRoutingConfig(\n        linear_interval=123,\n        linear_percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['linear_interval', 'linear_percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.LinearTrafficRoutingConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.ServerApplicationProps
class ServerApplicationPropsDef(BaseStruct):
    application_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Application. Default: an auto-generated name will be used\n\n:exampleMetadata: infused\n\nExample::\n\n    application = codedeploy.ServerApplication(self, "CodeDeployApplication",\n        application_name="MyApplication"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.ServerApplicationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.ServerDeploymentConfigProps
class ServerDeploymentConfigPropsDef(BaseStruct):
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the Deployment Configuration. Default: - automatically generated name\n')
    minimum_healthy_hosts: typing.Union[models.aws_codedeploy.MinimumHealthyHostsDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Minimum number of healthy hosts.\n\n:exampleMetadata: infused\n\nExample::\n\n    deployment_config = codedeploy.ServerDeploymentConfig(self, "DeploymentConfiguration",\n        deployment_config_name="MyDeploymentConfiguration",  # optional property\n        # one of these is required, but both cannot be specified at the same time\n        minimum_healthy_hosts=codedeploy.MinimumHealthyHosts.count(2)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deployment_config_name', 'minimum_healthy_hosts']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.ServerDeploymentConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.ServerDeploymentConfigPropsDefConfig] = pydantic.Field(None)


class ServerDeploymentConfigPropsDefConfig(pydantic.BaseModel):
    minimum_healthy_hosts_config: typing.Optional[models.aws_codedeploy.MinimumHealthyHostsDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.ServerDeploymentGroupAttributes
class ServerDeploymentGroupAttributesDef(BaseStruct):
    application: typing.Union[_REQUIRED_INIT_PARAM, models.aws_codedeploy.ServerApplicationDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The reference to the CodeDeploy EC2/on-premise Application that this Deployment Group belongs to.\n')
    deployment_group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The physical, human-readable name of the CodeDeploy EC2/on-premise Deployment Group that we are referencing.\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.ServerDeploymentConfigDef]] = pydantic.Field(None, description='The Deployment Configuration this Deployment Group uses. Default: ServerDeploymentConfig#OneAtATime\n\n:see: ServerDeploymentGroup# import\n:exampleMetadata: infused\n\nExample::\n\n    # application: codedeploy.ServerApplication\n\n    deployment_group = codedeploy.ServerDeploymentGroup.from_server_deployment_group_attributes(self, "ExistingCodeDeployDeploymentGroup",\n        application=application,\n        deployment_group_name="MyExistingDeploymentGroup"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application', 'deployment_group_name', 'deployment_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.ServerDeploymentGroupAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.ServerDeploymentGroupAttributesDefConfig] = pydantic.Field(None)


class ServerDeploymentGroupAttributesDefConfig(pydantic.BaseModel):
    application_config: typing.Optional[models._interface_methods.AwsCodedeployIServerApplicationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.ServerDeploymentGroupProps
class ServerDeploymentGroupPropsDef(BaseStruct):
    alarms: typing.Optional[typing.Sequence[typing.Union[models.aws_cloudwatch.AlarmBaseDef, models.aws_cloudwatch.AlarmDef, models.aws_cloudwatch.CompositeAlarmDef]]] = pydantic.Field(None, description='The CloudWatch alarms associated with this Deployment Group. CodeDeploy will stop (and optionally roll back) a deployment if during it any of the alarms trigger. Alarms can also be added after the Deployment Group is created using the ``#addAlarm`` method. Default: []\n')
    application: typing.Optional[typing.Union[models.aws_codedeploy.ServerApplicationDef]] = pydantic.Field(None, description='The CodeDeploy EC2/on-premise Application this Deployment Group belongs to. Default: - A new Application will be created.\n')
    auto_rollback: typing.Union[models.aws_codedeploy.AutoRollbackConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The auto-rollback configuration for this Deployment Group. Default: - default AutoRollbackConfig.\n')
    auto_scaling_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.AutoScalingGroupDef]]] = pydantic.Field(None, description='The auto-scaling groups belonging to this Deployment Group. Auto-scaling groups can also be added after the Deployment Group is created using the ``#addAutoScalingGroup`` method. [disable-awslint:ref-via-interface] is needed because we update userdata for ASGs to install the codedeploy agent. Default: []\n')
    deployment_config: typing.Optional[typing.Union[models.aws_codedeploy.ServerDeploymentConfigDef]] = pydantic.Field(None, description='The EC2/on-premise Deployment Configuration to use for this Deployment Group. Default: ServerDeploymentConfig#OneAtATime\n')
    deployment_group_name: typing.Optional[str] = pydantic.Field(None, description='The physical, human-readable name of the CodeDeploy Deployment Group. Default: - An auto-generated name will be used.\n')
    ec2_instance_tags: typing.Optional[models.aws_codedeploy.InstanceTagSetDef] = pydantic.Field(None, description='All EC2 instances matching the given set of tags when a deployment occurs will be added to this Deployment Group. Default: - No additional EC2 instances will be added to the Deployment Group.\n')
    ignore_poll_alarms_failure: typing.Optional[bool] = pydantic.Field(None, description='Whether to continue a deployment even if fetching the alarm status from CloudWatch failed. Default: false\n')
    install_agent: typing.Optional[bool] = pydantic.Field(None, description="If you've provided any auto-scaling groups with the ``#autoScalingGroups`` property, you can set this property to add User Data that installs the CodeDeploy agent on the instances. Default: true\n")
    load_balancer: typing.Optional[models.aws_codedeploy.LoadBalancerDef] = pydantic.Field(None, description='(deprecated) The load balancer to place in front of this Deployment Group. Can be created from either a classic Elastic Load Balancer, or an Application Load Balancer / Network Load Balancer Target Group. Default: - Deployment Group will not have a load balancer defined.\n')
    load_balancers: typing.Optional[typing.Sequence[models.aws_codedeploy.LoadBalancerDef]] = pydantic.Field(None, description='CodeDeploy supports the deployment to multiple load balancers. Specify either multiple Classic Load Balancers, or Application Load Balancers / Network Load Balancers Target Groups. Default: - Deployment Group will not have load balancers defined.\n')
    on_premise_instance_tags: typing.Optional[models.aws_codedeploy.InstanceTagSetDef] = pydantic.Field(None, description='All on-premise instances matching the given set of tags when a deployment occurs will be added to this Deployment Group. Default: - No additional on-premise instances will be added to the Deployment Group.\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The service Role of this Deployment Group. Default: - A new Role will be created.\n\n:exampleMetadata: infused\n\nExample::\n\n    # alb: elbv2.ApplicationLoadBalancer\n\n    listener = alb.add_listener("Listener", port=80)\n    target_group = listener.add_targets("Fleet", port=80)\n\n    deployment_group = codedeploy.ServerDeploymentGroup(self, "DeploymentGroup",\n        load_balancer=codedeploy.LoadBalancer.application(target_group)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alarms', 'application', 'auto_rollback', 'auto_scaling_groups', 'deployment_config', 'deployment_group_name', 'ec2_instance_tags', 'ignore_poll_alarms_failure', 'install_agent', 'load_balancer', 'load_balancers', 'on_premise_instance_tags', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.ServerDeploymentGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.TimeBasedCanaryTrafficRoutingProps
class TimeBasedCanaryTrafficRoutingPropsDef(BaseStruct):
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage to increase traffic on each traffic shift.\n\n:exampleMetadata: infused\n\nExample::\n\n    config = codedeploy.LambdaDeploymentConfig(self, "CustomConfig",\n        traffic_routing=codedeploy.TimeBasedCanaryTrafficRouting(\n            interval=Duration.minutes(15),\n            percentage=5\n        ),\n        deployment_config_name="MyDeploymentConfig"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['interval', 'percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.TimeBasedCanaryTrafficRoutingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.TimeBasedCanaryTrafficRoutingPropsDefConfig] = pydantic.Field(None)


class TimeBasedCanaryTrafficRoutingPropsDefConfig(pydantic.BaseModel):
    interval_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.TimeBasedLinearTrafficRoutingProps
class TimeBasedLinearTrafficRoutingPropsDef(BaseStruct):
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of time between traffic shifts.\n')
    percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage to increase traffic on each traffic shift.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    time_based_linear_traffic_routing_props = codedeploy.TimeBasedLinearTrafficRoutingProps(\n        interval=cdk.Duration.minutes(30),\n        percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['interval', 'percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.TimeBasedLinearTrafficRoutingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.TimeBasedLinearTrafficRoutingPropsDefConfig] = pydantic.Field(None)


class TimeBasedLinearTrafficRoutingPropsDefConfig(pydantic.BaseModel):
    interval_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codedeploy.TrafficRoutingConfig
class TrafficRoutingConfigDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of traffic shifting ( ``TimeBasedCanary`` or ``TimeBasedLinear`` ) used by a deployment configuration.\n')
    time_based_canary: typing.Union[models.aws_codedeploy.CanaryTrafficRoutingConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A configuration that shifts traffic from one version of a Lambda function or ECS task set to another in two increments. Default: none\n')
    time_based_linear: typing.Union[models.aws_codedeploy.LinearTrafficRoutingConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A configuration that shifts traffic from one version of a Lambda function or Amazon ECS task set to another in equal increments, with an equal number of minutes between each increment. Default: none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    traffic_routing_config = codedeploy.TrafficRoutingConfig(\n        type="type",\n\n        # the properties below are optional\n        time_based_canary=codedeploy.CanaryTrafficRoutingConfig(\n            canary_interval=123,\n            canary_percentage=123\n        ),\n        time_based_linear=codedeploy.LinearTrafficRoutingConfig(\n            linear_interval=123,\n            linear_percentage=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'time_based_canary', 'time_based_linear']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.TrafficRoutingConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.ComputePlatform
# skipping emum

#  autogenerated from aws_cdk.aws_codedeploy.CustomLambdaDeploymentConfigType
# skipping emum

#  autogenerated from aws_cdk.aws_codedeploy.LoadBalancerGeneration
# skipping emum

#  autogenerated from aws_cdk.aws_codedeploy.IBaseDeploymentConfig
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.IEcsApplication
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.IEcsDeploymentConfig
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.IEcsDeploymentGroup
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.ILambdaApplication
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.ILambdaDeploymentConfig
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.ILambdaDeploymentGroup
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.IServerApplication
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.IServerDeploymentConfig
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.IServerDeploymentGroup
#  skipping Interface

#  autogenerated from aws_cdk.aws_codedeploy.CfnApplication
class CfnApplicationDef(BaseCfnResource):
    application_name: typing.Optional[str] = pydantic.Field(None, description="A name for the application. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the application name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: Updates to ``ApplicationName`` are not supported.\n")
    compute_platform: typing.Optional[str] = pydantic.Field(None, description='The compute platform that CodeDeploy deploys the application to.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to CodeDeploy applications to help you organize and categorize them. Each tag consists of a key and an optional value, both of which you define.')
    _init_params: typing.ClassVar[list[str]] = ['application_name', 'compute_platform', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnApplication'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.CfnApplicationDefConfig] = pydantic.Field(None)


class CfnApplicationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_codedeploy.CfnApplicationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnApplicationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnApplicationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApplicationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnApplicationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApplicationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnApplicationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnApplicationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnApplicationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnApplicationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnApplicationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApplicationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnApplicationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnApplicationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApplicationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentConfig
class CfnDeploymentConfigDef(BaseCfnResource):
    compute_platform: typing.Optional[str] = pydantic.Field(None, description='The destination platform type for the deployment ( ``Lambda`` , ``Server`` , or ``ECS`` ).\n')
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description="A name for the deployment configuration. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the deployment configuration name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    minimum_healthy_hosts: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentConfig_MinimumHealthyHostsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum number of healthy instances that should be available at any time during the deployment. There are two parameters expected in the input: type and value. The type parameter takes either of the following values: - HOST_COUNT: The value parameter represents the minimum number of healthy instances as an absolute value. - FLEET_PERCENT: The value parameter represents the minimum number of healthy instances as a percentage of the total number of instances in the deployment. If you specify FLEET_PERCENT, at the start of the deployment, AWS CodeDeploy converts the percentage to the equivalent number of instance and rounds up fractional instances. The value parameter takes an integer. For example, to set a minimum of 95% healthy instance, specify a type of FLEET_PERCENT and a value of 95. For more information about instance health, see `CodeDeploy Instance Health <https://docs.aws.amazon.com/codedeploy/latest/userguide/instances-health.html>`_ in the AWS CodeDeploy User Guide.\n')
    traffic_routing_config: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentConfig_TrafficRoutingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration that specifies how the deployment traffic is routed.')
    _init_params: typing.ClassVar[list[str]] = ['compute_platform', 'deployment_config_name', 'minimum_healthy_hosts', 'traffic_routing_config']
    _method_names: typing.ClassVar[list[str]] = ['MinimumHealthyHostsProperty', 'TimeBasedCanaryProperty', 'TimeBasedLinearProperty', 'TrafficRoutingConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.CfnDeploymentConfigDefConfig] = pydantic.Field(None)


class CfnDeploymentConfigDefConfig(pydantic.BaseModel):
    MinimumHealthyHostsProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefMinimumhealthyhostspropertyParams]] = pydantic.Field(None, description='')
    TimeBasedCanaryProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefTimebasedcanarypropertyParams]] = pydantic.Field(None, description='')
    TimeBasedLinearProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefTimebasedlinearpropertyParams]] = pydantic.Field(None, description='')
    TrafficRoutingConfigProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefTrafficroutingconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_codedeploy.CfnDeploymentConfigDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDeploymentConfigDefMinimumhealthyhostspropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    value: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnDeploymentConfigDefTimebasedcanarypropertyParams(pydantic.BaseModel):
    canary_interval: typing.Union[int, float] = pydantic.Field(..., description='')
    canary_percentage: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnDeploymentConfigDefTimebasedlinearpropertyParams(pydantic.BaseModel):
    linear_interval: typing.Union[int, float] = pydantic.Field(..., description='')
    linear_percentage: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnDeploymentConfigDefTrafficroutingconfigpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    time_based_canary: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentConfig_TimeBasedCanaryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    time_based_linear: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentConfig_TimeBasedLinearPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentConfigDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeploymentConfigDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentConfigDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeploymentConfigDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentConfigDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeploymentConfigDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeploymentConfigDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeploymentConfigDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeploymentConfigDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeploymentConfigDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentConfigDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDeploymentConfigDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeploymentConfigDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentConfigDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroup
class CfnDeploymentGroupDef(BaseCfnResource):
    application_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of an existing CodeDeploy application to associate this deployment group with.\n')
    service_role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="A service role Amazon Resource Name (ARN) that grants CodeDeploy permission to make calls to AWS services on your behalf. For more information, see `Create a Service Role for AWS CodeDeploy <https://docs.aws.amazon.com/codedeploy/latest/userguide/getting-started-create-service-role.html>`_ in the *AWS CodeDeploy User Guide* . .. epigraph:: In some cases, you might need to add a dependency on the service role's policy. For more information, see IAM role policy in `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ .\n")
    alarm_configuration: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_AlarmConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the Amazon CloudWatch alarms that are associated with the deployment group.\n')
    auto_rollback_configuration: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_AutoRollbackConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Information about the automatic rollback configuration that is associated with the deployment group. If you specify this property, don't specify the ``Deployment`` property.\n")
    auto_scaling_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of associated Auto Scaling groups that CodeDeploy automatically deploys revisions to when new instances are created. Duplicates are not allowed.\n')
    blue_green_deployment_configuration: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_BlueGreenDeploymentConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about blue/green deployment options for a deployment group.\n')
    deployment: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_DeploymentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The application revision to deploy to this deployment group. If you specify this property, your target application revision is deployed as soon as the provisioning process is complete. If you specify this property, don't specify the ``AutoRollbackConfiguration`` property.\n")
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='A deployment configuration name or a predefined configuration name. With predefined configurations, you can deploy application revisions to one instance at a time ( ``CodeDeployDefault.OneAtATime`` ), half of the instances at a time ( ``CodeDeployDefault.HalfAtATime`` ), or all the instances at once ( ``CodeDeployDefault.AllAtOnce`` ). For more information and valid values, see `Working with Deployment Configurations <https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-configurations.html>`_ in the *AWS CodeDeploy User Guide* .\n')
    deployment_group_name: typing.Optional[str] = pydantic.Field(None, description="A name for the deployment group. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the deployment group name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    deployment_style: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_DeploymentStylePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Attributes that determine the type of deployment to run and whether to route deployment traffic behind a load balancer. If you specify this property with a blue/green deployment type, don't specify the ``AutoScalingGroups`` , ``LoadBalancerInfo`` , or ``Deployment`` properties. .. epigraph:: For blue/green deployments, AWS CloudFormation supports deployments on Lambda compute platforms only. You can perform Amazon ECS blue/green deployments using ``AWS::CodeDeploy::BlueGreen`` hook. See `Perform Amazon ECS blue/green deployments through CodeDeploy using AWS CloudFormation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/blue-green.html>`_ for more information.\n")
    ec2_tag_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_EC2TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The Amazon EC2 tags that are already applied to Amazon EC2 instances that you want to include in the deployment group. CodeDeploy includes all Amazon EC2 instances identified by any of the tags you specify in this deployment group. Duplicates are not allowed. You can specify ``EC2TagFilters`` or ``Ec2TagSet`` , but not both.\n')
    ec2_tag_set: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_EC2TagSetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about groups of tags applied to Amazon EC2 instances. The deployment group includes only Amazon EC2 instances identified by all the tag groups. Cannot be used in the same call as ``ec2TagFilter`` .\n')
    ecs_services: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_ECSServicePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The target Amazon ECS services in the deployment group. This applies only to deployment groups that use the Amazon ECS compute platform. A target Amazon ECS service is specified as an Amazon ECS cluster and service name pair using the format ``<clustername>:<servicename>`` .\n')
    load_balancer_info: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_LoadBalancerInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the load balancer to use in a deployment. For more information, see `Integrating CodeDeploy with Elastic Load Balancing <https://docs.aws.amazon.com/codedeploy/latest/userguide/integrations-aws-elastic-load-balancing.html>`_ in the *AWS CodeDeploy User Guide* .\n')
    on_premises_instance_tag_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The on-premises instance tags already applied to on-premises instances that you want to include in the deployment group. CodeDeploy includes all on-premises instances identified by any of the tags you specify in this deployment group. To register on-premises instances with CodeDeploy , see `Working with On-Premises Instances for CodeDeploy <https://docs.aws.amazon.com/codedeploy/latest/userguide/instances-on-premises.html>`_ in the *AWS CodeDeploy User Guide* . Duplicates are not allowed. You can specify ``OnPremisesInstanceTagFilters`` or ``OnPremisesInstanceTagSet`` , but not both.\n')
    on_premises_tag_set: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_OnPremisesTagSetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about groups of tags applied to on-premises instances. The deployment group includes only on-premises instances identified by all the tag groups. You can specify ``OnPremisesInstanceTagFilters`` or ``OnPremisesInstanceTagSet`` , but not both.\n')
    outdated_instances_strategy: typing.Optional[str] = pydantic.Field(None, description="Indicates what happens when new Amazon EC2 instances are launched mid-deployment and do not receive the deployed application revision. If this option is set to ``UPDATE`` or is unspecified, CodeDeploy initiates one or more 'auto-update outdated instances' deployments to apply the deployed application revision to the new Amazon EC2 instances. If this option is set to ``IGNORE`` , CodeDeploy does not initiate a deployment to update the new Amazon EC2 instances. This may result in instances having different revisions.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to CodeDeploy deployment groups to help you organize and categorize them. Each tag consists of a key and an optional value, both of which you define.\n')
    trigger_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TriggerConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about triggers associated with the deployment group. Duplicates are not allowed')
    _init_params: typing.ClassVar[list[str]] = ['application_name', 'service_role_arn', 'alarm_configuration', 'auto_rollback_configuration', 'auto_scaling_groups', 'blue_green_deployment_configuration', 'deployment', 'deployment_config_name', 'deployment_group_name', 'deployment_style', 'ec2_tag_filters', 'ec2_tag_set', 'ecs_services', 'load_balancer_info', 'on_premises_instance_tag_filters', 'on_premises_tag_set', 'outdated_instances_strategy', 'tags', 'trigger_configurations']
    _method_names: typing.ClassVar[list[str]] = ['AlarmConfigurationProperty', 'AlarmProperty', 'AutoRollbackConfigurationProperty', 'BlueGreenDeploymentConfigurationProperty', 'BlueInstanceTerminationOptionProperty', 'DeploymentProperty', 'DeploymentReadyOptionProperty', 'DeploymentStyleProperty', 'EC2TagFilterProperty', 'EC2TagSetListObjectProperty', 'EC2TagSetProperty', 'ECSServiceProperty', 'ELBInfoProperty', 'GitHubLocationProperty', 'GreenFleetProvisioningOptionProperty', 'LoadBalancerInfoProperty', 'OnPremisesTagSetListObjectProperty', 'OnPremisesTagSetProperty', 'RevisionLocationProperty', 'S3LocationProperty', 'TagFilterProperty', 'TargetGroupInfoProperty', 'TargetGroupPairInfoProperty', 'TrafficRouteProperty', 'TriggerConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codedeploy.CfnDeploymentGroupDefConfig] = pydantic.Field(None)


class CfnDeploymentGroupDefConfig(pydantic.BaseModel):
    AlarmConfigurationProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAlarmconfigurationpropertyParams]] = pydantic.Field(None, description='')
    AlarmProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAlarmpropertyParams]] = pydantic.Field(None, description='')
    AutoRollbackConfigurationProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAutorollbackconfigurationpropertyParams]] = pydantic.Field(None, description='')
    BlueGreenDeploymentConfigurationProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefBluegreendeploymentconfigurationpropertyParams]] = pydantic.Field(None, description='')
    BlueInstanceTerminationOptionProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefBlueinstanceterminationoptionpropertyParams]] = pydantic.Field(None, description='')
    DeploymentProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefDeploymentpropertyParams]] = pydantic.Field(None, description='')
    DeploymentReadyOptionProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefDeploymentreadyoptionpropertyParams]] = pydantic.Field(None, description='')
    DeploymentStyleProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefDeploymentstylepropertyParams]] = pydantic.Field(None, description='')
    EC2TagFilterProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefEc2TagfilterpropertyParams]] = pydantic.Field(None, description='')
    EC2TagSetListObjectProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefEc2TagsetlistobjectpropertyParams]] = pydantic.Field(None, description='')
    EC2TagSetProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefEc2TagsetpropertyParams]] = pydantic.Field(None, description='')
    ECSServiceProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefEcsservicepropertyParams]] = pydantic.Field(None, description='')
    ELBInfoProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefElbinfopropertyParams]] = pydantic.Field(None, description='')
    GitHubLocationProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefGithublocationpropertyParams]] = pydantic.Field(None, description='')
    GreenFleetProvisioningOptionProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefGreenfleetprovisioningoptionpropertyParams]] = pydantic.Field(None, description='')
    LoadBalancerInfoProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefLoadbalancerinfopropertyParams]] = pydantic.Field(None, description='')
    OnPremisesTagSetListObjectProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefOnpremisestagsetlistobjectpropertyParams]] = pydantic.Field(None, description='')
    OnPremisesTagSetProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefOnpremisestagsetpropertyParams]] = pydantic.Field(None, description='')
    RevisionLocationProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefRevisionlocationpropertyParams]] = pydantic.Field(None, description='')
    S3LocationProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefS3LocationpropertyParams]] = pydantic.Field(None, description='')
    TagFilterProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefTagfilterpropertyParams]] = pydantic.Field(None, description='')
    TargetGroupInfoProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefTargetgroupinfopropertyParams]] = pydantic.Field(None, description='')
    TargetGroupPairInfoProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefTargetgrouppairinfopropertyParams]] = pydantic.Field(None, description='')
    TrafficRouteProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefTrafficroutepropertyParams]] = pydantic.Field(None, description='')
    TriggerConfigProperty: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefTriggerconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_codedeploy.CfnDeploymentGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDeploymentGroupDefAlarmconfigurationpropertyParams(pydantic.BaseModel):
    alarms: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_AlarmPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ignore_poll_alarm_failure: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefAlarmpropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefAutorollbackconfigurationpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefBluegreendeploymentconfigurationpropertyParams(pydantic.BaseModel):
    deployment_ready_option: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_DeploymentReadyOptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    green_fleet_provisioning_option: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_GreenFleetProvisioningOptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    terminate_blue_instances_on_deployment_success: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_BlueInstanceTerminationOptionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefBlueinstanceterminationoptionpropertyParams(pydantic.BaseModel):
    action: typing.Optional[str] = pydantic.Field(None, description='')
    termination_wait_time_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefDeploymentpropertyParams(pydantic.BaseModel):
    revision: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_RevisionLocationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    ignore_application_stop_failures: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefDeploymentreadyoptionpropertyParams(pydantic.BaseModel):
    action_on_timeout: typing.Optional[str] = pydantic.Field(None, description='')
    wait_time_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefDeploymentstylepropertyParams(pydantic.BaseModel):
    deployment_option: typing.Optional[str] = pydantic.Field(None, description='')
    deployment_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefEc2TagfilterpropertyParams(pydantic.BaseModel):
    key: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefEc2TagsetlistobjectpropertyParams(pydantic.BaseModel):
    ec2_tag_group: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_EC2TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefEc2TagsetpropertyParams(pydantic.BaseModel):
    ec2_tag_set_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_EC2TagSetListObjectPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefEcsservicepropertyParams(pydantic.BaseModel):
    cluster_name: str = pydantic.Field(..., description='')
    service_name: str = pydantic.Field(..., description='')
    ...

class CfnDeploymentGroupDefElbinfopropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefGithublocationpropertyParams(pydantic.BaseModel):
    commit_id: str = pydantic.Field(..., description='')
    repository: str = pydantic.Field(..., description='')
    ...

class CfnDeploymentGroupDefGreenfleetprovisioningoptionpropertyParams(pydantic.BaseModel):
    action: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefLoadbalancerinfopropertyParams(pydantic.BaseModel):
    elb_info_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_ELBInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    target_group_info_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TargetGroupInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    target_group_pair_info_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TargetGroupPairInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefOnpremisestagsetlistobjectpropertyParams(pydantic.BaseModel):
    on_premises_tag_group: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefOnpremisestagsetpropertyParams(pydantic.BaseModel):
    on_premises_tag_set_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_OnPremisesTagSetListObjectPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefRevisionlocationpropertyParams(pydantic.BaseModel):
    git_hub_location: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_GitHubLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    revision_type: typing.Optional[str] = pydantic.Field(None, description='')
    s3_location: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_S3LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefS3LocationpropertyParams(pydantic.BaseModel):
    bucket: str = pydantic.Field(..., description='')
    key: str = pydantic.Field(..., description='')
    bundle_type: typing.Optional[str] = pydantic.Field(None, description='')
    e_tag: typing.Optional[str] = pydantic.Field(None, description='')
    version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefTagfilterpropertyParams(pydantic.BaseModel):
    key: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefTargetgroupinfopropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefTargetgrouppairinfopropertyParams(pydantic.BaseModel):
    prod_traffic_route: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TrafficRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    target_groups: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TargetGroupInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    test_traffic_route: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TrafficRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefTrafficroutepropertyParams(pydantic.BaseModel):
    listener_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefTriggerconfigpropertyParams(pydantic.BaseModel):
    trigger_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    trigger_name: typing.Optional[str] = pydantic.Field(None, description='')
    trigger_target_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeploymentGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeploymentGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeploymentGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeploymentGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeploymentGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeploymentGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeploymentGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeploymentGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDeploymentGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeploymentGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_codedeploy.CfnApplicationProps
class CfnApplicationPropsDef(BaseCfnProperty):
    application_name: typing.Optional[str] = pydantic.Field(None, description="A name for the application. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the application name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: Updates to ``ApplicationName`` are not supported.\n")
    compute_platform: typing.Optional[str] = pydantic.Field(None, description='The compute platform that CodeDeploy deploys the application to.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to CodeDeploy applications to help you organize and categorize them. Each tag consists of a key and an optional value, both of which you define.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codedeploy-application.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    cfn_application_props = codedeploy.CfnApplicationProps(\n        application_name="applicationName",\n        compute_platform="computePlatform",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_name', 'compute_platform', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnApplicationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentConfigProps
class CfnDeploymentConfigPropsDef(BaseCfnProperty):
    compute_platform: typing.Optional[str] = pydantic.Field(None, description='The destination platform type for the deployment ( ``Lambda`` , ``Server`` , or ``ECS`` ).\n')
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description="A name for the deployment configuration. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the deployment configuration name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    minimum_healthy_hosts: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentConfig_MinimumHealthyHostsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum number of healthy instances that should be available at any time during the deployment. There are two parameters expected in the input: type and value. The type parameter takes either of the following values: - HOST_COUNT: The value parameter represents the minimum number of healthy instances as an absolute value. - FLEET_PERCENT: The value parameter represents the minimum number of healthy instances as a percentage of the total number of instances in the deployment. If you specify FLEET_PERCENT, at the start of the deployment, AWS CodeDeploy converts the percentage to the equivalent number of instance and rounds up fractional instances. The value parameter takes an integer. For example, to set a minimum of 95% healthy instance, specify a type of FLEET_PERCENT and a value of 95. For more information about instance health, see `CodeDeploy Instance Health <https://docs.aws.amazon.com/codedeploy/latest/userguide/instances-health.html>`_ in the AWS CodeDeploy User Guide.\n')
    traffic_routing_config: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentConfig_TrafficRoutingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration that specifies how the deployment traffic is routed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codedeploy-deploymentconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    cfn_deployment_config_props = codedeploy.CfnDeploymentConfigProps(\n        compute_platform="computePlatform",\n        deployment_config_name="deploymentConfigName",\n        minimum_healthy_hosts=codedeploy.CfnDeploymentConfig.MinimumHealthyHostsProperty(\n            type="type",\n            value=123\n        ),\n        traffic_routing_config=codedeploy.CfnDeploymentConfig.TrafficRoutingConfigProperty(\n            type="type",\n\n            # the properties below are optional\n            time_based_canary=codedeploy.CfnDeploymentConfig.TimeBasedCanaryProperty(\n                canary_interval=123,\n                canary_percentage=123\n            ),\n            time_based_linear=codedeploy.CfnDeploymentConfig.TimeBasedLinearProperty(\n                linear_interval=123,\n                linear_percentage=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['compute_platform', 'deployment_config_name', 'minimum_healthy_hosts', 'traffic_routing_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codedeploy.CfnDeploymentGroupProps
class CfnDeploymentGroupPropsDef(BaseCfnProperty):
    application_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of an existing CodeDeploy application to associate this deployment group with.\n')
    service_role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="A service role Amazon Resource Name (ARN) that grants CodeDeploy permission to make calls to AWS services on your behalf. For more information, see `Create a Service Role for AWS CodeDeploy <https://docs.aws.amazon.com/codedeploy/latest/userguide/getting-started-create-service-role.html>`_ in the *AWS CodeDeploy User Guide* . .. epigraph:: In some cases, you might need to add a dependency on the service role's policy. For more information, see IAM role policy in `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ .\n")
    alarm_configuration: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_AlarmConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the Amazon CloudWatch alarms that are associated with the deployment group.\n')
    auto_rollback_configuration: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_AutoRollbackConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Information about the automatic rollback configuration that is associated with the deployment group. If you specify this property, don't specify the ``Deployment`` property.\n")
    auto_scaling_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of associated Auto Scaling groups that CodeDeploy automatically deploys revisions to when new instances are created. Duplicates are not allowed.\n')
    blue_green_deployment_configuration: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_BlueGreenDeploymentConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about blue/green deployment options for a deployment group.\n')
    deployment: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_DeploymentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The application revision to deploy to this deployment group. If you specify this property, your target application revision is deployed as soon as the provisioning process is complete. If you specify this property, don't specify the ``AutoRollbackConfiguration`` property.\n")
    deployment_config_name: typing.Optional[str] = pydantic.Field(None, description='A deployment configuration name or a predefined configuration name. With predefined configurations, you can deploy application revisions to one instance at a time ( ``CodeDeployDefault.OneAtATime`` ), half of the instances at a time ( ``CodeDeployDefault.HalfAtATime`` ), or all the instances at once ( ``CodeDeployDefault.AllAtOnce`` ). For more information and valid values, see `Working with Deployment Configurations <https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-configurations.html>`_ in the *AWS CodeDeploy User Guide* .\n')
    deployment_group_name: typing.Optional[str] = pydantic.Field(None, description="A name for the deployment group. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the deployment group name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    deployment_style: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_DeploymentStylePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Attributes that determine the type of deployment to run and whether to route deployment traffic behind a load balancer. If you specify this property with a blue/green deployment type, don't specify the ``AutoScalingGroups`` , ``LoadBalancerInfo`` , or ``Deployment`` properties. .. epigraph:: For blue/green deployments, AWS CloudFormation supports deployments on Lambda compute platforms only. You can perform Amazon ECS blue/green deployments using ``AWS::CodeDeploy::BlueGreen`` hook. See `Perform Amazon ECS blue/green deployments through CodeDeploy using AWS CloudFormation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/blue-green.html>`_ for more information.\n")
    ec2_tag_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_EC2TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The Amazon EC2 tags that are already applied to Amazon EC2 instances that you want to include in the deployment group. CodeDeploy includes all Amazon EC2 instances identified by any of the tags you specify in this deployment group. Duplicates are not allowed. You can specify ``EC2TagFilters`` or ``Ec2TagSet`` , but not both.\n')
    ec2_tag_set: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_EC2TagSetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about groups of tags applied to Amazon EC2 instances. The deployment group includes only Amazon EC2 instances identified by all the tag groups. Cannot be used in the same call as ``ec2TagFilter`` .\n')
    ecs_services: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_ECSServicePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The target Amazon ECS services in the deployment group. This applies only to deployment groups that use the Amazon ECS compute platform. A target Amazon ECS service is specified as an Amazon ECS cluster and service name pair using the format ``<clustername>:<servicename>`` .\n')
    load_balancer_info: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_LoadBalancerInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the load balancer to use in a deployment. For more information, see `Integrating CodeDeploy with Elastic Load Balancing <https://docs.aws.amazon.com/codedeploy/latest/userguide/integrations-aws-elastic-load-balancing.html>`_ in the *AWS CodeDeploy User Guide* .\n')
    on_premises_instance_tag_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The on-premises instance tags already applied to on-premises instances that you want to include in the deployment group. CodeDeploy includes all on-premises instances identified by any of the tags you specify in this deployment group. To register on-premises instances with CodeDeploy , see `Working with On-Premises Instances for CodeDeploy <https://docs.aws.amazon.com/codedeploy/latest/userguide/instances-on-premises.html>`_ in the *AWS CodeDeploy User Guide* . Duplicates are not allowed. You can specify ``OnPremisesInstanceTagFilters`` or ``OnPremisesInstanceTagSet`` , but not both.\n')
    on_premises_tag_set: typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_OnPremisesTagSetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about groups of tags applied to on-premises instances. The deployment group includes only on-premises instances identified by all the tag groups. You can specify ``OnPremisesInstanceTagFilters`` or ``OnPremisesInstanceTagSet`` , but not both.\n')
    outdated_instances_strategy: typing.Optional[str] = pydantic.Field(None, description="Indicates what happens when new Amazon EC2 instances are launched mid-deployment and do not receive the deployed application revision. If this option is set to ``UPDATE`` or is unspecified, CodeDeploy initiates one or more 'auto-update outdated instances' deployments to apply the deployed application revision to the new Amazon EC2 instances. If this option is set to ``IGNORE`` , CodeDeploy does not initiate a deployment to update the new Amazon EC2 instances. This may result in instances having different revisions.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to CodeDeploy deployment groups to help you organize and categorize them. Each tag consists of a key and an optional value, both of which you define.\n')
    trigger_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codedeploy.CfnDeploymentGroup_TriggerConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about triggers associated with the deployment group. Duplicates are not allowed\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codedeploy-deploymentgroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codedeploy as codedeploy\n\n    cfn_deployment_group_props = codedeploy.CfnDeploymentGroupProps(\n        application_name="applicationName",\n        service_role_arn="serviceRoleArn",\n\n        # the properties below are optional\n        alarm_configuration=codedeploy.CfnDeploymentGroup.AlarmConfigurationProperty(\n            alarms=[codedeploy.CfnDeploymentGroup.AlarmProperty(\n                name="name"\n            )],\n            enabled=False,\n            ignore_poll_alarm_failure=False\n        ),\n        auto_rollback_configuration=codedeploy.CfnDeploymentGroup.AutoRollbackConfigurationProperty(\n            enabled=False,\n            events=["events"]\n        ),\n        auto_scaling_groups=["autoScalingGroups"],\n        blue_green_deployment_configuration=codedeploy.CfnDeploymentGroup.BlueGreenDeploymentConfigurationProperty(\n            deployment_ready_option=codedeploy.CfnDeploymentGroup.DeploymentReadyOptionProperty(\n                action_on_timeout="actionOnTimeout",\n                wait_time_in_minutes=123\n            ),\n            green_fleet_provisioning_option=codedeploy.CfnDeploymentGroup.GreenFleetProvisioningOptionProperty(\n                action="action"\n            ),\n            terminate_blue_instances_on_deployment_success=codedeploy.CfnDeploymentGroup.BlueInstanceTerminationOptionProperty(\n                action="action",\n                termination_wait_time_in_minutes=123\n            )\n        ),\n        deployment=codedeploy.CfnDeploymentGroup.DeploymentProperty(\n            revision=codedeploy.CfnDeploymentGroup.RevisionLocationProperty(\n                git_hub_location=codedeploy.CfnDeploymentGroup.GitHubLocationProperty(\n                    commit_id="commitId",\n                    repository="repository"\n                ),\n                revision_type="revisionType",\n                s3_location=codedeploy.CfnDeploymentGroup.S3LocationProperty(\n                    bucket="bucket",\n                    key="key",\n\n                    # the properties below are optional\n                    bundle_type="bundleType",\n                    e_tag="eTag",\n                    version="version"\n                )\n            ),\n\n            # the properties below are optional\n            description="description",\n            ignore_application_stop_failures=False\n        ),\n        deployment_config_name="deploymentConfigName",\n        deployment_group_name="deploymentGroupName",\n        deployment_style=codedeploy.CfnDeploymentGroup.DeploymentStyleProperty(\n            deployment_option="deploymentOption",\n            deployment_type="deploymentType"\n        ),\n        ec2_tag_filters=[codedeploy.CfnDeploymentGroup.EC2TagFilterProperty(\n            key="key",\n            type="type",\n            value="value"\n        )],\n        ec2_tag_set=codedeploy.CfnDeploymentGroup.EC2TagSetProperty(\n            ec2_tag_set_list=[codedeploy.CfnDeploymentGroup.EC2TagSetListObjectProperty(\n                ec2_tag_group=[codedeploy.CfnDeploymentGroup.EC2TagFilterProperty(\n                    key="key",\n                    type="type",\n                    value="value"\n                )]\n            )]\n        ),\n        ecs_services=[codedeploy.CfnDeploymentGroup.ECSServiceProperty(\n            cluster_name="clusterName",\n            service_name="serviceName"\n        )],\n        load_balancer_info=codedeploy.CfnDeploymentGroup.LoadBalancerInfoProperty(\n            elb_info_list=[codedeploy.CfnDeploymentGroup.ELBInfoProperty(\n                name="name"\n            )],\n            target_group_info_list=[codedeploy.CfnDeploymentGroup.TargetGroupInfoProperty(\n                name="name"\n            )],\n            target_group_pair_info_list=[codedeploy.CfnDeploymentGroup.TargetGroupPairInfoProperty(\n                prod_traffic_route=codedeploy.CfnDeploymentGroup.TrafficRouteProperty(\n                    listener_arns=["listenerArns"]\n                ),\n                target_groups=[codedeploy.CfnDeploymentGroup.TargetGroupInfoProperty(\n                    name="name"\n                )],\n                test_traffic_route=codedeploy.CfnDeploymentGroup.TrafficRouteProperty(\n                    listener_arns=["listenerArns"]\n                )\n            )]\n        ),\n        on_premises_instance_tag_filters=[codedeploy.CfnDeploymentGroup.TagFilterProperty(\n            key="key",\n            type="type",\n            value="value"\n        )],\n        on_premises_tag_set=codedeploy.CfnDeploymentGroup.OnPremisesTagSetProperty(\n            on_premises_tag_set_list=[codedeploy.CfnDeploymentGroup.OnPremisesTagSetListObjectProperty(\n                on_premises_tag_group=[codedeploy.CfnDeploymentGroup.TagFilterProperty(\n                    key="key",\n                    type="type",\n                    value="value"\n                )]\n            )]\n        ),\n        outdated_instances_strategy="outdatedInstancesStrategy",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        trigger_configurations=[codedeploy.CfnDeploymentGroup.TriggerConfigProperty(\n            trigger_events=["triggerEvents"],\n            trigger_name="triggerName",\n            trigger_target_arn="triggerTargetArn"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_name', 'service_role_arn', 'alarm_configuration', 'auto_rollback_configuration', 'auto_scaling_groups', 'blue_green_deployment_configuration', 'deployment', 'deployment_config_name', 'deployment_group_name', 'deployment_style', 'ec2_tag_filters', 'ec2_tag_set', 'ecs_services', 'load_balancer_info', 'on_premises_instance_tag_filters', 'on_premises_tag_set', 'outdated_instances_strategy', 'tags', 'trigger_configurations']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codedeploy.CfnDeploymentGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    AllAtOnceTrafficRouting: typing.Optional[dict[str, models.aws_codedeploy.AllAtOnceTrafficRoutingDef]] = pydantic.Field(None)
    BaseDeploymentConfig: typing.Optional[dict[str, models.aws_codedeploy.BaseDeploymentConfigDef]] = pydantic.Field(None)
    InstanceTagSet: typing.Optional[dict[str, models.aws_codedeploy.InstanceTagSetDef]] = pydantic.Field(None)
    LoadBalancer: typing.Optional[dict[str, models.aws_codedeploy.LoadBalancerDef]] = pydantic.Field(None)
    MinimumHealthyHosts: typing.Optional[dict[str, models.aws_codedeploy.MinimumHealthyHostsDef]] = pydantic.Field(None)
    TimeBasedCanaryTrafficRouting: typing.Optional[dict[str, models.aws_codedeploy.TimeBasedCanaryTrafficRoutingDef]] = pydantic.Field(None)
    TimeBasedLinearTrafficRouting: typing.Optional[dict[str, models.aws_codedeploy.TimeBasedLinearTrafficRoutingDef]] = pydantic.Field(None)
    TrafficRouting: typing.Optional[dict[str, models.aws_codedeploy.TrafficRoutingDef]] = pydantic.Field(None)
    CustomLambdaDeploymentConfig: typing.Optional[dict[str, models.aws_codedeploy.CustomLambdaDeploymentConfigDef]] = pydantic.Field(None)
    EcsApplication: typing.Optional[dict[str, models.aws_codedeploy.EcsApplicationDef]] = pydantic.Field(None)
    EcsDeploymentConfig: typing.Optional[dict[str, models.aws_codedeploy.EcsDeploymentConfigDef]] = pydantic.Field(None)
    EcsDeploymentGroup: typing.Optional[dict[str, models.aws_codedeploy.EcsDeploymentGroupDef]] = pydantic.Field(None)
    LambdaApplication: typing.Optional[dict[str, models.aws_codedeploy.LambdaApplicationDef]] = pydantic.Field(None)
    LambdaDeploymentConfig: typing.Optional[dict[str, models.aws_codedeploy.LambdaDeploymentConfigDef]] = pydantic.Field(None)
    LambdaDeploymentGroup: typing.Optional[dict[str, models.aws_codedeploy.LambdaDeploymentGroupDef]] = pydantic.Field(None)
    ServerApplication: typing.Optional[dict[str, models.aws_codedeploy.ServerApplicationDef]] = pydantic.Field(None)
    ServerDeploymentConfig: typing.Optional[dict[str, models.aws_codedeploy.ServerDeploymentConfigDef]] = pydantic.Field(None)
    ServerDeploymentGroup: typing.Optional[dict[str, models.aws_codedeploy.ServerDeploymentGroupDef]] = pydantic.Field(None)
    AutoRollbackConfig: typing.Optional[dict[str, models.aws_codedeploy.AutoRollbackConfigDef]] = pydantic.Field(None)
    BaseDeploymentConfigOptions: typing.Optional[dict[str, models.aws_codedeploy.BaseDeploymentConfigOptionsDef]] = pydantic.Field(None)
    BaseDeploymentConfigProps: typing.Optional[dict[str, models.aws_codedeploy.BaseDeploymentConfigPropsDef]] = pydantic.Field(None)
    BaseTrafficShiftingConfigProps: typing.Optional[dict[str, models.aws_codedeploy.BaseTrafficShiftingConfigPropsDef]] = pydantic.Field(None)
    CanaryTrafficRoutingConfig: typing.Optional[dict[str, models.aws_codedeploy.CanaryTrafficRoutingConfigDef]] = pydantic.Field(None)
    CfnDeploymentConfig_MinimumHealthyHostsProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentConfig_MinimumHealthyHostsPropertyDef]] = pydantic.Field(None)
    CfnDeploymentConfig_TimeBasedCanaryProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentConfig_TimeBasedCanaryPropertyDef]] = pydantic.Field(None)
    CfnDeploymentConfig_TimeBasedLinearProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentConfig_TimeBasedLinearPropertyDef]] = pydantic.Field(None)
    CfnDeploymentConfig_TrafficRoutingConfigProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentConfig_TrafficRoutingConfigPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_AlarmConfigurationProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_AlarmConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_AlarmProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_AlarmPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_AutoRollbackConfigurationProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_AutoRollbackConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_BlueGreenDeploymentConfigurationProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_BlueGreenDeploymentConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_BlueInstanceTerminationOptionProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_BlueInstanceTerminationOptionPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_DeploymentProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_DeploymentPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_DeploymentReadyOptionProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_DeploymentReadyOptionPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_DeploymentStyleProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_DeploymentStylePropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_EC2TagFilterProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_EC2TagFilterPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_EC2TagSetListObjectProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_EC2TagSetListObjectPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_EC2TagSetProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_EC2TagSetPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_ECSServiceProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_ECSServicePropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_ELBInfoProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_ELBInfoPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_GitHubLocationProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_GitHubLocationPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_GreenFleetProvisioningOptionProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_GreenFleetProvisioningOptionPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_LoadBalancerInfoProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_LoadBalancerInfoPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_OnPremisesTagSetListObjectProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_OnPremisesTagSetListObjectPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_OnPremisesTagSetProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_OnPremisesTagSetPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_RevisionLocationProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_RevisionLocationPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_S3LocationProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_S3LocationPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_TagFilterProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_TagFilterPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_TargetGroupInfoProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_TargetGroupInfoPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_TargetGroupPairInfoProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_TargetGroupPairInfoPropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_TrafficRouteProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_TrafficRoutePropertyDef]] = pydantic.Field(None)
    CfnDeploymentGroup_TriggerConfigProperty: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroup_TriggerConfigPropertyDef]] = pydantic.Field(None)
    CustomLambdaDeploymentConfigProps: typing.Optional[dict[str, models.aws_codedeploy.CustomLambdaDeploymentConfigPropsDef]] = pydantic.Field(None)
    EcsApplicationProps: typing.Optional[dict[str, models.aws_codedeploy.EcsApplicationPropsDef]] = pydantic.Field(None)
    EcsBlueGreenDeploymentConfig: typing.Optional[dict[str, models.aws_codedeploy.EcsBlueGreenDeploymentConfigDef]] = pydantic.Field(None)
    EcsDeploymentConfigProps: typing.Optional[dict[str, models.aws_codedeploy.EcsDeploymentConfigPropsDef]] = pydantic.Field(None)
    EcsDeploymentGroupAttributes: typing.Optional[dict[str, models.aws_codedeploy.EcsDeploymentGroupAttributesDef]] = pydantic.Field(None)
    EcsDeploymentGroupProps: typing.Optional[dict[str, models.aws_codedeploy.EcsDeploymentGroupPropsDef]] = pydantic.Field(None)
    LambdaApplicationProps: typing.Optional[dict[str, models.aws_codedeploy.LambdaApplicationPropsDef]] = pydantic.Field(None)
    LambdaDeploymentConfigImportProps: typing.Optional[dict[str, models.aws_codedeploy.LambdaDeploymentConfigImportPropsDef]] = pydantic.Field(None)
    LambdaDeploymentConfigProps: typing.Optional[dict[str, models.aws_codedeploy.LambdaDeploymentConfigPropsDef]] = pydantic.Field(None)
    LambdaDeploymentGroupAttributes: typing.Optional[dict[str, models.aws_codedeploy.LambdaDeploymentGroupAttributesDef]] = pydantic.Field(None)
    LambdaDeploymentGroupProps: typing.Optional[dict[str, models.aws_codedeploy.LambdaDeploymentGroupPropsDef]] = pydantic.Field(None)
    LinearTrafficRoutingConfig: typing.Optional[dict[str, models.aws_codedeploy.LinearTrafficRoutingConfigDef]] = pydantic.Field(None)
    ServerApplicationProps: typing.Optional[dict[str, models.aws_codedeploy.ServerApplicationPropsDef]] = pydantic.Field(None)
    ServerDeploymentConfigProps: typing.Optional[dict[str, models.aws_codedeploy.ServerDeploymentConfigPropsDef]] = pydantic.Field(None)
    ServerDeploymentGroupAttributes: typing.Optional[dict[str, models.aws_codedeploy.ServerDeploymentGroupAttributesDef]] = pydantic.Field(None)
    ServerDeploymentGroupProps: typing.Optional[dict[str, models.aws_codedeploy.ServerDeploymentGroupPropsDef]] = pydantic.Field(None)
    TimeBasedCanaryTrafficRoutingProps: typing.Optional[dict[str, models.aws_codedeploy.TimeBasedCanaryTrafficRoutingPropsDef]] = pydantic.Field(None)
    TimeBasedLinearTrafficRoutingProps: typing.Optional[dict[str, models.aws_codedeploy.TimeBasedLinearTrafficRoutingPropsDef]] = pydantic.Field(None)
    TrafficRoutingConfig: typing.Optional[dict[str, models.aws_codedeploy.TrafficRoutingConfigDef]] = pydantic.Field(None)
    CfnApplication: typing.Optional[dict[str, models.aws_codedeploy.CfnApplicationDef]] = pydantic.Field(None)
    CfnDeploymentConfig: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentConfigDef]] = pydantic.Field(None)
    CfnDeploymentGroup: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroupDef]] = pydantic.Field(None)
    CfnApplicationProps: typing.Optional[dict[str, models.aws_codedeploy.CfnApplicationPropsDef]] = pydantic.Field(None)
    CfnDeploymentConfigProps: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentConfigPropsDef]] = pydantic.Field(None)
    CfnDeploymentGroupProps: typing.Optional[dict[str, models.aws_codedeploy.CfnDeploymentGroupPropsDef]] = pydantic.Field(None)
    ...

import models
