from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.cloud_assembly_schema.Manifest
class ManifestDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['load_assembly_manifest', 'load_asset_manifest', 'load_integ_manifest', 'save_assembly_manifest', 'save_asset_manifest', 'save_integ_manifest', 'version']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.Manifest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['load_assembly_manifest', 'load_asset_manifest', 'load_integ_manifest']
    ...


    load_assembly_manifest: typing.Optional[models.cloud_assembly_schema.ManifestDefLoadAssemblyManifestParams] = pydantic.Field(None, description='Load and validates the cloud assembly manifest from file.')
    load_asset_manifest: typing.Optional[models.cloud_assembly_schema.ManifestDefLoadAssetManifestParams] = pydantic.Field(None, description='Load and validates the asset manifest from file.')
    load_integ_manifest: typing.Optional[models.cloud_assembly_schema.ManifestDefLoadIntegManifestParams] = pydantic.Field(None, description='Load and validates the integ manifest from file.')
    resource_config: typing.Optional[models.cloud_assembly_schema.ManifestDefConfig] = pydantic.Field(None)


class ManifestDefConfig(pydantic.BaseModel):
    save_assembly_manifest: typing.Optional[list[models.cloud_assembly_schema.ManifestDefSaveAssemblyManifestParams]] = pydantic.Field(None, description='Validates and saves the cloud assembly manifest to file.')
    save_asset_manifest: typing.Optional[list[models.cloud_assembly_schema.ManifestDefSaveAssetManifestParams]] = pydantic.Field(None, description='Validates and saves the asset manifest to file.')
    save_integ_manifest: typing.Optional[list[models.cloud_assembly_schema.ManifestDefSaveIntegManifestParams]] = pydantic.Field(None, description='Validates and saves the integ manifest to file.')
    version: typing.Optional[bool] = pydantic.Field(None, description='Fetch the current schema version number.')

class ManifestDefLoadAssemblyManifestParams(pydantic.BaseModel):
    file_path: str = pydantic.Field(..., description='- path to the manifest file.\n')
    skip_enum_check: typing.Optional[bool] = pydantic.Field(None, description="Skip enum checks. This means you may read enum values you don't know about yet. Make sure to always check the values of enums you encounter in the manifest. Default: false\n")
    skip_version_check: typing.Optional[bool] = pydantic.Field(None, description='Skip the version check. This means you may read a newer cloud assembly than the CX API is designed to support, and your application may not be aware of all features that in use in the Cloud Assembly. Default: false\n')
    topo_sort: typing.Optional[bool] = pydantic.Field(None, description='Topologically sort all artifacts. This parameter is only respected by the constructor of ``CloudAssembly``. The property lives here for backwards compatibility reasons. Default: true')
    ...

class ManifestDefLoadAssetManifestParams(pydantic.BaseModel):
    file_path: str = pydantic.Field(..., description='- path to the manifest file.')
    ...

class ManifestDefLoadIntegManifestParams(pydantic.BaseModel):
    file_path: str = pydantic.Field(..., description='- path to the manifest file.')
    ...

class ManifestDefSaveAssemblyManifestParams(pydantic.BaseModel):
    manifest: typing.Union[models.cloud_assembly_schema.AssemblyManifestDef, dict[str, typing.Any]] = pydantic.Field(..., description='- manifest.\n')
    file_path: str = pydantic.Field(..., description='- output file path.')
    ...

class ManifestDefSaveAssetManifestParams(pydantic.BaseModel):
    manifest: typing.Union[models.cloud_assembly_schema.AssetManifestDef, dict[str, typing.Any]] = pydantic.Field(..., description='- manifest.\n')
    file_path: str = pydantic.Field(..., description='- output file path.')
    ...

class ManifestDefSaveIntegManifestParams(pydantic.BaseModel):
    manifest: typing.Union[models.cloud_assembly_schema.IntegManifestDef, dict[str, typing.Any]] = pydantic.Field(..., description='- manifest.\n')
    file_path: str = pydantic.Field(..., description='- output file path.')
    ...


#  autogenerated from aws_cdk.cloud_assembly_schema.AmiContextQuery
class AmiContextQueryDef(BaseStruct):
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Account to query.\n')
    filters: typing.Union[typing.Mapping[str, typing.Sequence[str]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Filters to DescribeImages call.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Region to query.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n')
    owners: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Owners to DescribeImages call. Default: - All owners\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    ami_context_query = cloud_assembly_schema.AmiContextQuery(\n        account="account",\n        filters={\n            "filters_key": ["filters"]\n        },\n        region="region",\n\n        # the properties below are optional\n        lookup_role_arn="lookupRoleArn",\n        owners=["owners"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'filters', 'region', 'lookup_role_arn', 'owners']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.AmiContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.ArtifactManifest
class ArtifactManifestDef(BaseStruct):
    type: typing.Union[aws_cdk.cloud_assembly_schema.ArtifactType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    artifact_manifest = cloud_assembly_schema.ArtifactManifest(\n        type=cloud_assembly_schema.ArtifactType.NONE,\n\n        # the properties below are optional\n        dependencies=["dependencies"],\n        display_name="displayName",\n        environment="environment",\n        metadata={\n            "metadata_key": [cloud_assembly_schema.MetadataEntry(\n                type="type",\n\n                # the properties below are optional\n                data="data",\n                trace=["trace"]\n            )]\n        },\n        properties=cloud_assembly_schema.AwsCloudFormationStackProperties(\n            template_file="templateFile",\n\n            # the properties below are optional\n            assume_role_arn="assumeRoleArn",\n            assume_role_external_id="assumeRoleExternalId",\n            bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n            cloud_formation_execution_role_arn="cloudFormationExecutionRoleArn",\n            lookup_role=cloud_assembly_schema.BootstrapRole(\n                arn="arn",\n\n                # the properties below are optional\n                assume_role_external_id="assumeRoleExternalId",\n                bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n                requires_bootstrap_stack_version=123\n            ),\n            parameters={\n                "parameters_key": "parameters"\n            },\n            requires_bootstrap_stack_version=123,\n            stack_name="stackName",\n            stack_template_asset_object_url="stackTemplateAssetObjectUrl",\n            tags={\n                "tags_key": "tags"\n            },\n            termination_protection=False,\n            validate_on_synth=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'dependencies', 'display_name', 'environment', 'metadata', 'properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.ArtifactManifest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.AssemblyManifest
class AssemblyManifestDef(BaseStruct):
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Protocol version.\n')
    artifacts: typing.Optional[typing.Mapping[str, typing.Union[models.cloud_assembly_schema.ArtifactManifestDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The set of artifacts in this assembly. Default: - no artifacts.\n')
    missing: typing.Optional[typing.Sequence[typing.Union[models.cloud_assembly_schema.MissingContextDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Missing context information. If this field has values, it means that the cloud assembly is not complete and should not be deployed. Default: - no missing context.\n')
    runtime: typing.Union[models.cloud_assembly_schema.RuntimeInfoDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Runtime information. Default: - no info.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    assembly_manifest = cloud_assembly_schema.AssemblyManifest(\n        version="version",\n\n        # the properties below are optional\n        artifacts={\n            "artifacts_key": cloud_assembly_schema.ArtifactManifest(\n                type=cloud_assembly_schema.ArtifactType.NONE,\n\n                # the properties below are optional\n                dependencies=["dependencies"],\n                display_name="displayName",\n                environment="environment",\n                metadata={\n                    "metadata_key": [cloud_assembly_schema.MetadataEntry(\n                        type="type",\n\n                        # the properties below are optional\n                        data="data",\n                        trace=["trace"]\n                    )]\n                },\n                properties=cloud_assembly_schema.AwsCloudFormationStackProperties(\n                    template_file="templateFile",\n\n                    # the properties below are optional\n                    assume_role_arn="assumeRoleArn",\n                    assume_role_external_id="assumeRoleExternalId",\n                    bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n                    cloud_formation_execution_role_arn="cloudFormationExecutionRoleArn",\n                    lookup_role=cloud_assembly_schema.BootstrapRole(\n                        arn="arn",\n\n                        # the properties below are optional\n                        assume_role_external_id="assumeRoleExternalId",\n                        bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n                        requires_bootstrap_stack_version=123\n                    ),\n                    parameters={\n                        "parameters_key": "parameters"\n                    },\n                    requires_bootstrap_stack_version=123,\n                    stack_name="stackName",\n                    stack_template_asset_object_url="stackTemplateAssetObjectUrl",\n                    tags={\n                        "tags_key": "tags"\n                    },\n                    termination_protection=False,\n                    validate_on_synth=False\n                )\n            )\n        },\n        missing=[cloud_assembly_schema.MissingContext(\n            key="key",\n            props=cloud_assembly_schema.AmiContextQuery(\n                account="account",\n                filters={\n                    "filters_key": ["filters"]\n                },\n                region="region",\n\n                # the properties below are optional\n                lookup_role_arn="lookupRoleArn",\n                owners=["owners"]\n            ),\n            provider=cloud_assembly_schema.ContextProvider.AMI_PROVIDER\n        )],\n        runtime=cloud_assembly_schema.RuntimeInfo(\n            libraries={\n                "libraries_key": "libraries"\n            }\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'artifacts', 'missing', 'runtime']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.AssemblyManifest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.AssetManifest
class AssetManifestDef(BaseStruct):
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Version of the manifest.\n')
    docker_images: typing.Optional[typing.Mapping[str, typing.Union[models.cloud_assembly_schema.DockerImageAssetDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The Docker image assets in this manifest. Default: - No Docker images\n')
    files: typing.Optional[typing.Mapping[str, typing.Union[models.cloud_assembly_schema.FileAssetDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The file assets in this manifest. Default: - No files\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    asset_manifest = cloud_assembly_schema.AssetManifest(\n        version="version",\n\n        # the properties below are optional\n        docker_images={\n            "docker_images_key": cloud_assembly_schema.DockerImageAsset(\n                destinations={\n                    "destinations_key": cloud_assembly_schema.DockerImageDestination(\n                        image_tag="imageTag",\n                        repository_name="repositoryName",\n\n                        # the properties below are optional\n                        assume_role_arn="assumeRoleArn",\n                        assume_role_external_id="assumeRoleExternalId",\n                        region="region"\n                    )\n                },\n                source=cloud_assembly_schema.DockerImageSource(\n                    cache_disabled=False,\n                    cache_from=[cloud_assembly_schema.DockerCacheOption(\n                        type="type",\n\n                        # the properties below are optional\n                        params={\n                            "params_key": "params"\n                        }\n                    )],\n                    cache_to=cloud_assembly_schema.DockerCacheOption(\n                        type="type",\n\n                        # the properties below are optional\n                        params={\n                            "params_key": "params"\n                        }\n                    ),\n                    directory="directory",\n                    docker_build_args={\n                        "docker_build_args_key": "dockerBuildArgs"\n                    },\n                    docker_build_secrets={\n                        "docker_build_secrets_key": "dockerBuildSecrets"\n                    },\n                    docker_build_ssh="dockerBuildSsh",\n                    docker_build_target="dockerBuildTarget",\n                    docker_file="dockerFile",\n                    docker_outputs=["dockerOutputs"],\n                    executable=["executable"],\n                    network_mode="networkMode",\n                    platform="platform"\n                )\n            )\n        },\n        files={\n            "files_key": cloud_assembly_schema.FileAsset(\n                destinations={\n                    "destinations_key": cloud_assembly_schema.FileDestination(\n                        bucket_name="bucketName",\n                        object_key="objectKey",\n\n                        # the properties below are optional\n                        assume_role_arn="assumeRoleArn",\n                        assume_role_external_id="assumeRoleExternalId",\n                        region="region"\n                    )\n                },\n                source=cloud_assembly_schema.FileSource(\n                    executable=["executable"],\n                    packaging=cloud_assembly_schema.FileAssetPackaging.FILE,\n                    path="path"\n                )\n            )\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'docker_images', 'files']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.AssetManifest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.AssetManifestOptions
class AssetManifestOptionsDef(BaseStruct):
    bootstrap_stack_version_ssm_parameter: typing.Optional[str] = pydantic.Field(None, description="SSM parameter where the bootstrap stack version number can be found. - If this value is not set, the bootstrap stack name must be known at deployment time so the stack version can be looked up from the stack outputs. - If this value is set, the bootstrap stack can have any name because we won't need to look it up. Default: - Bootstrap stack version number looked up\n")
    requires_bootstrap_stack_version: typing.Union[int, float, None] = pydantic.Field(None, description='Version of bootstrap stack required to deploy this stack. Default: - Version 1 (basic modern bootstrap stack)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    asset_manifest_options = cloud_assembly_schema.AssetManifestOptions(\n        bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n        requires_bootstrap_stack_version=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bootstrap_stack_version_ssm_parameter', 'requires_bootstrap_stack_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.AssetManifestOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.AssetManifestProperties
class AssetManifestPropertiesDef(BaseStruct):
    bootstrap_stack_version_ssm_parameter: typing.Optional[str] = pydantic.Field(None, description="SSM parameter where the bootstrap stack version number can be found. - If this value is not set, the bootstrap stack name must be known at deployment time so the stack version can be looked up from the stack outputs. - If this value is set, the bootstrap stack can have any name because we won't need to look it up. Default: - Bootstrap stack version number looked up\n")
    requires_bootstrap_stack_version: typing.Union[int, float, None] = pydantic.Field(None, description='Version of bootstrap stack required to deploy this stack. Default: - Version 1 (basic modern bootstrap stack)\n')
    file: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Filename of the asset manifest.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    asset_manifest_properties = cloud_assembly_schema.AssetManifestProperties(\n        file="file",\n\n        # the properties below are optional\n        bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n        requires_bootstrap_stack_version=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bootstrap_stack_version_ssm_parameter', 'requires_bootstrap_stack_version', 'file']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.AssetManifestProperties'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.AvailabilityZonesContextQuery
class AvailabilityZonesContextQueryDef(BaseStruct):
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    availability_zones_context_query = cloud_assembly_schema.AvailabilityZonesContextQuery(\n        account="account",\n        region="region",\n\n        # the properties below are optional\n        lookup_role_arn="lookupRoleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'region', 'lookup_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.AvailabilityZonesContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.AwsCloudFormationStackProperties
class AwsCloudFormationStackPropertiesDef(BaseStruct):
    template_file: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A file relative to the assembly root which contains the CloudFormation template for this stack.\n')
    assume_role_arn: typing.Optional[str] = pydantic.Field(None, description='The role that needs to be assumed to deploy the stack. Default: - No role is assumed (current credentials are used)\n')
    assume_role_external_id: typing.Optional[str] = pydantic.Field(None, description='External ID to use when assuming role for cloudformation deployments. Default: - No external ID\n')
    bootstrap_stack_version_ssm_parameter: typing.Optional[str] = pydantic.Field(None, description="SSM parameter where the bootstrap stack version number can be found. Only used if ``requiresBootstrapStackVersion`` is set. - If this value is not set, the bootstrap stack name must be known at deployment time so the stack version can be looked up from the stack outputs. - If this value is set, the bootstrap stack can have any name because we won't need to look it up. Default: - Bootstrap stack version number looked up\n")
    cloud_formation_execution_role_arn: typing.Optional[str] = pydantic.Field(None, description='The role that is passed to CloudFormation to execute the change set. Default: - No role is passed (currently assumed role/credentials are used)\n')
    lookup_role: typing.Union[models.cloud_assembly_schema.BootstrapRoleDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The role to use to look up values from the target AWS account. Default: - No role is assumed (current credentials are used)\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Values for CloudFormation stack parameters that should be passed when the stack is deployed. Default: - No parameters\n')
    requires_bootstrap_stack_version: typing.Union[int, float, None] = pydantic.Field(None, description='Version of bootstrap stack required to deploy this stack. Default: - No bootstrap stack required\n')
    stack_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the CloudFormation stack. Default: - name derived from artifact ID\n')
    stack_template_asset_object_url: typing.Optional[str] = pydantic.Field(None, description='If the stack template has already been included in the asset manifest, its asset URL. Default: - Not uploaded yet, upload just before deploying\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Values for CloudFormation stack tags that should be passed when the stack is deployed. Default: - No tags\n')
    termination_protection: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable termination protection for this stack. Default: false\n')
    validate_on_synth: typing.Optional[bool] = pydantic.Field(None, description='Whether this stack should be validated by the CLI after synthesis. Default: - false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    aws_cloud_formation_stack_properties = cloud_assembly_schema.AwsCloudFormationStackProperties(\n        template_file="templateFile",\n\n        # the properties below are optional\n        assume_role_arn="assumeRoleArn",\n        assume_role_external_id="assumeRoleExternalId",\n        bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n        cloud_formation_execution_role_arn="cloudFormationExecutionRoleArn",\n        lookup_role=cloud_assembly_schema.BootstrapRole(\n            arn="arn",\n\n            # the properties below are optional\n            assume_role_external_id="assumeRoleExternalId",\n            bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n            requires_bootstrap_stack_version=123\n        ),\n        parameters={\n            "parameters_key": "parameters"\n        },\n        requires_bootstrap_stack_version=123,\n        stack_name="stackName",\n        stack_template_asset_object_url="stackTemplateAssetObjectUrl",\n        tags={\n            "tags_key": "tags"\n        },\n        termination_protection=False,\n        validate_on_synth=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['template_file', 'assume_role_arn', 'assume_role_external_id', 'bootstrap_stack_version_ssm_parameter', 'cloud_formation_execution_role_arn', 'lookup_role', 'parameters', 'requires_bootstrap_stack_version', 'stack_name', 'stack_template_asset_object_url', 'tags', 'termination_protection', 'validate_on_synth']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.AwsCloudFormationStackProperties'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.AwsDestination
class AwsDestinationDef(BaseStruct):
    assume_role_arn: typing.Optional[str] = pydantic.Field(None, description='The role that needs to be assumed while publishing this asset. Default: - No role will be assumed\n')
    assume_role_external_id: typing.Optional[str] = pydantic.Field(None, description='The ExternalId that needs to be supplied while assuming this role. Default: - No ExternalId will be supplied\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region where this asset will need to be published. Default: - Current region\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    aws_destination = cloud_assembly_schema.AwsDestination(\n        assume_role_arn="assumeRoleArn",\n        assume_role_external_id="assumeRoleExternalId",\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assume_role_arn', 'assume_role_external_id', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.AwsDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.BootstrapRole
class BootstrapRoleDef(BaseStruct):
    arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the IAM role created as part of bootrapping e.g. lookupRoleArn.\n')
    assume_role_external_id: typing.Optional[str] = pydantic.Field(None, description='External ID to use when assuming the bootstrap role. Default: - No external ID\n')
    bootstrap_stack_version_ssm_parameter: typing.Optional[str] = pydantic.Field(None, description='Name of SSM parameter with bootstrap stack version. Default: - Discover SSM parameter by reading stack\n')
    requires_bootstrap_stack_version: typing.Union[int, float, None] = pydantic.Field(None, description='Version of bootstrap stack required to use this role. Default: - No bootstrap stack required\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    bootstrap_role = cloud_assembly_schema.BootstrapRole(\n        arn="arn",\n\n        # the properties below are optional\n        assume_role_external_id="assumeRoleExternalId",\n        bootstrap_stack_version_ssm_parameter="bootstrapStackVersionSsmParameter",\n        requires_bootstrap_stack_version=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn', 'assume_role_external_id', 'bootstrap_stack_version_ssm_parameter', 'requires_bootstrap_stack_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.BootstrapRole'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.CdkCommand
class CdkCommandDef(BaseStruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to run this command as part of the workflow This can be used if you only want to test some of the workflow for example enable ``synth`` and disable ``deploy`` & ``destroy`` in order to limit the test to synthesis. Default: true\n')
    expected_message: typing.Optional[str] = pydantic.Field(None, description='This can be used in combination with ``expectedError`` to validate that a specific message is returned. Default: - do not validate message\n')
    expect_error: typing.Optional[bool] = pydantic.Field(None, description='If the runner should expect this command to fail. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    cdk_command = cloud_assembly_schema.CdkCommand(\n        enabled=False,\n        expected_message="expectedMessage",\n        expect_error=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'expected_message', 'expect_error']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.CdkCommand'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.CdkCommands
class CdkCommandsDef(BaseStruct):
    deploy: typing.Union[models.cloud_assembly_schema.DeployCommandDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options to for the cdk deploy command. Default: - default deploy options\n')
    destroy: typing.Union[models.cloud_assembly_schema.DestroyCommandDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options to for the cdk destroy command. Default: - default destroy options\n\n:exampleMetadata: infused\n\nExample::\n\n    app = App()\n\n    stack_under_test = Stack(app, "StackUnderTest")\n\n    stack = Stack(app, "stack")\n\n    test_case = IntegTest(app, "CustomizedDeploymentWorkflow",\n        test_cases=[stack_under_test],\n        diff_assets=True,\n        stack_update_workflow=True,\n        cdk_command_options=CdkCommands(\n            deploy=DeployCommand(\n                args=DeployOptions(\n                    require_approval=RequireApproval.NEVER,\n                    json=True\n                )\n            ),\n            destroy=DestroyCommand(\n                args=DestroyOptions(\n                    force=True\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deploy', 'destroy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.CdkCommands'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.ContainerImageAssetCacheOption
class ContainerImageAssetCacheOptionDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of cache to use. Refer to https://docs.docker.com/build/cache/backends/ for full list of backends. Default: - unspecified\n')
    params: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Any parameters to pass into the docker cache backend configuration. Refer to https://docs.docker.com/build/cache/backends/ for cache backend configuration. Default: {} No options provided\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    container_image_asset_cache_option = cloud_assembly_schema.ContainerImageAssetCacheOption(\n        type="type",\n\n        # the properties below are optional\n        params={\n            "params_key": "params"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'params']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.ContainerImageAssetCacheOption'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.ContainerImageAssetMetadataEntry
class ContainerImageAssetMetadataEntryDef(BaseStruct):
    packaging: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Type of asset.\n')
    path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Path on disk to the asset.\n')
    source_hash: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The hash of the asset source.\n')
    build_args: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Build args to pass to the ``docker build`` command. Default: no build args are passed\n')
    build_secrets: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Build secrets to pass to the ``docker build`` command. Default: no build secrets are passed\n')
    build_ssh: typing.Optional[str] = pydantic.Field(None, description='SSH agent socket or keys to pass to the ``docker build`` command. Default: no ssh arg is passed\n')
    cache_disabled: typing.Optional[bool] = pydantic.Field(None, description='Disable the cache and pass ``--no-cache`` to the ``docker build`` command. Default: - cache is used\n')
    cache_from: typing.Optional[typing.Sequence[typing.Union[models.cloud_assembly_schema.ContainerImageAssetCacheOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Cache from options to pass to the ``docker build`` command. Default: - no cache from options are passed to the build command\n')
    cache_to: typing.Union[models.cloud_assembly_schema.ContainerImageAssetCacheOptionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Cache to options to pass to the ``docker build`` command. Default: - no cache to options are passed to the build command\n')
    file: typing.Optional[str] = pydantic.Field(None, description='Path to the Dockerfile (relative to the directory). Default: - no file is passed\n')
    image_tag: typing.Optional[str] = pydantic.Field(None, description="The docker image tag to use for tagging pushed images. This field is required if ``imageParameterName`` is ommited (otherwise, the app won't be able to find the image). Default: - this parameter is REQUIRED after 1.21.0\n")
    network_mode: typing.Optional[str] = pydantic.Field(None, description='Networking mode for the RUN commands during build. Default: - no networking mode specified\n')
    outputs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Outputs to pass to the ``docker build`` command. Default: - no outputs are passed to the build command (default outputs are used)\n')
    platform: typing.Optional[str] = pydantic.Field(None, description='Platform to build for. *Requires Docker Buildx*. Default: - current machine platform\n')
    repository_name: typing.Optional[str] = pydantic.Field(None, description="ECR repository name, if omitted a default name based on the asset's ID is used instead. Specify this property if you need to statically address the image, e.g. from a Kubernetes Pod. Note, this is only the repository name, without the registry and the tag parts. Default: - this parameter is REQUIRED after 1.21.0\n")
    target: typing.Optional[str] = pydantic.Field(None, description='Docker target to build to. Default: no build target\n\nExample::\n\n    entry = {\n        "packaging": "container-image",\n        "repository_name": "repository-name",\n        "image_tag": "tag"\n    }\n')
    _init_params: typing.ClassVar[list[str]] = ['packaging', 'path', 'source_hash', 'build_args', 'build_secrets', 'build_ssh', 'cache_disabled', 'cache_from', 'cache_to', 'file', 'image_tag', 'network_mode', 'outputs', 'platform', 'repository_name', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.ContainerImageAssetMetadataEntry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DefaultCdkOptions
class DefaultCdkOptionsDef(BaseStruct):
    all: typing.Optional[bool] = pydantic.Field(None, description='Deploy all stacks. Requried if ``stacks`` is not set Default: - false\n')
    app: typing.Optional[str] = pydantic.Field(None, description='command-line for executing your app or a cloud assembly directory e.g. "node bin/my-app.js" or "cdk.out". Default: - read from cdk.json\n')
    asset_metadata: typing.Optional[bool] = pydantic.Field(None, description='Include "aws:asset:*" CloudFormation metadata for resources that use assets. Default: true\n')
    ca_bundle_path: typing.Optional[str] = pydantic.Field(None, description='Path to CA certificate to use when validating HTTPS requests. Default: - read from AWS_CA_BUNDLE environment variable\n')
    color: typing.Optional[bool] = pydantic.Field(None, description='Show colors and other style from console output. Default: true\n')
    context: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional context. Default: - no additional context\n')
    debug: typing.Optional[bool] = pydantic.Field(None, description='enable emission of additional debugging information, such as creation stack traces of tokens. Default: false\n')
    ec2_creds: typing.Optional[bool] = pydantic.Field(None, description='Force trying to fetch EC2 instance credentials. Default: - guess EC2 instance status\n')
    ignore_errors: typing.Optional[bool] = pydantic.Field(None, description='Ignores synthesis errors, which will likely produce an invalid output. Default: false\n')
    json_: typing.Optional[bool] = pydantic.Field(None, description='Use JSON output instead of YAML when templates are printed to STDOUT. Default: false\n', alias='json')
    lookups: typing.Optional[bool] = pydantic.Field(None, description='Perform context lookups. Synthesis fails if this is disabled and context lookups need to be performed Default: true\n')
    notices: typing.Optional[bool] = pydantic.Field(None, description='Show relevant notices. Default: true\n')
    output: typing.Optional[str] = pydantic.Field(None, description='Emits the synthesized cloud assembly into a directory. Default: cdk.out\n')
    path_metadata: typing.Optional[bool] = pydantic.Field(None, description='Include "aws:cdk:path" CloudFormation metadata for each resource. Default: true\n')
    profile: typing.Optional[str] = pydantic.Field(None, description='Use the indicated AWS profile as the default environment. Default: - no profile is used\n')
    proxy: typing.Optional[str] = pydantic.Field(None, description='Use the indicated proxy. Will read from HTTPS_PROXY environment if specified Default: - no proxy\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='Role to pass to CloudFormation for deployment. Default: - use the bootstrap cfn-exec role\n')
    stacks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of stacks to deploy. Requried if ``all`` is not set Default: - []\n')
    staging: typing.Optional[bool] = pydantic.Field(None, description='Copy assets to the output directory. Needed for local debugging the source files with SAM CLI Default: false\n')
    strict: typing.Optional[bool] = pydantic.Field(None, description='Do not construct stacks with warnings. Default: false\n')
    trace: typing.Optional[bool] = pydantic.Field(None, description='Print trace for stack warnings. Default: false\n')
    verbose: typing.Optional[bool] = pydantic.Field(None, description='show debug logs. Default: false\n')
    version_reporting: typing.Optional[bool] = pydantic.Field(None, description='Include "AWS::CDK::Metadata" resource in synthesized templates. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    default_cdk_options = cloud_assembly_schema.DefaultCdkOptions(\n        all=False,\n        app="app",\n        asset_metadata=False,\n        ca_bundle_path="caBundlePath",\n        color=False,\n        context={\n            "context_key": "context"\n        },\n        debug=False,\n        ec2_creds=False,\n        ignore_errors=False,\n        json=False,\n        lookups=False,\n        notices=False,\n        output="output",\n        path_metadata=False,\n        profile="profile",\n        proxy="proxy",\n        role_arn="roleArn",\n        stacks=["stacks"],\n        staging=False,\n        strict=False,\n        trace=False,\n        verbose=False,\n        version_reporting=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['all', 'app', 'asset_metadata', 'ca_bundle_path', 'color', 'context', 'debug', 'ec2_creds', 'ignore_errors', 'json', 'lookups', 'notices', 'output', 'path_metadata', 'profile', 'proxy', 'role_arn', 'stacks', 'staging', 'strict', 'trace', 'verbose', 'version_reporting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DefaultCdkOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DeployCommand
class DeployCommandDef(BaseStruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to run this command as part of the workflow This can be used if you only want to test some of the workflow for example enable ``synth`` and disable ``deploy`` & ``destroy`` in order to limit the test to synthesis. Default: true\n')
    expected_message: typing.Optional[str] = pydantic.Field(None, description='This can be used in combination with ``expectedError`` to validate that a specific message is returned. Default: - do not validate message\n')
    expect_error: typing.Optional[bool] = pydantic.Field(None, description='If the runner should expect this command to fail. Default: false\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'expected_message', 'expect_error']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DeployCommand'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DeployOptions
class DeployOptionsDef(BaseStruct):
    all: typing.Optional[bool] = pydantic.Field(None, description='Deploy all stacks. Requried if ``stacks`` is not set Default: - false\n')
    app: typing.Optional[str] = pydantic.Field(None, description='command-line for executing your app or a cloud assembly directory e.g. "node bin/my-app.js" or "cdk.out". Default: - read from cdk.json\n')
    asset_metadata: typing.Optional[bool] = pydantic.Field(None, description='Include "aws:asset:*" CloudFormation metadata for resources that use assets. Default: true\n')
    ca_bundle_path: typing.Optional[str] = pydantic.Field(None, description='Path to CA certificate to use when validating HTTPS requests. Default: - read from AWS_CA_BUNDLE environment variable\n')
    color: typing.Optional[bool] = pydantic.Field(None, description='Show colors and other style from console output. Default: true\n')
    context: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional context. Default: - no additional context\n')
    debug: typing.Optional[bool] = pydantic.Field(None, description='enable emission of additional debugging information, such as creation stack traces of tokens. Default: false\n')
    ec2_creds: typing.Optional[bool] = pydantic.Field(None, description='Force trying to fetch EC2 instance credentials. Default: - guess EC2 instance status\n')
    ignore_errors: typing.Optional[bool] = pydantic.Field(None, description='Ignores synthesis errors, which will likely produce an invalid output. Default: false\n')
    json_: typing.Optional[bool] = pydantic.Field(None, description='Use JSON output instead of YAML when templates are printed to STDOUT. Default: false\n', alias='json')
    lookups: typing.Optional[bool] = pydantic.Field(None, description='Perform context lookups. Synthesis fails if this is disabled and context lookups need to be performed Default: true\n')
    notices: typing.Optional[bool] = pydantic.Field(None, description='Show relevant notices. Default: true\n')
    output: typing.Optional[str] = pydantic.Field(None, description='Emits the synthesized cloud assembly into a directory. Default: cdk.out\n')
    path_metadata: typing.Optional[bool] = pydantic.Field(None, description='Include "aws:cdk:path" CloudFormation metadata for each resource. Default: true\n')
    profile: typing.Optional[str] = pydantic.Field(None, description='Use the indicated AWS profile as the default environment. Default: - no profile is used\n')
    proxy: typing.Optional[str] = pydantic.Field(None, description='Use the indicated proxy. Will read from HTTPS_PROXY environment if specified Default: - no proxy\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='Role to pass to CloudFormation for deployment. Default: - use the bootstrap cfn-exec role\n')
    stacks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of stacks to deploy. Requried if ``all`` is not set Default: - []\n')
    staging: typing.Optional[bool] = pydantic.Field(None, description='Copy assets to the output directory. Needed for local debugging the source files with SAM CLI Default: false\n')
    strict: typing.Optional[bool] = pydantic.Field(None, description='Do not construct stacks with warnings. Default: false\n')
    trace: typing.Optional[bool] = pydantic.Field(None, description='Print trace for stack warnings. Default: false\n')
    verbose: typing.Optional[bool] = pydantic.Field(None, description='show debug logs. Default: false\n')
    version_reporting: typing.Optional[bool] = pydantic.Field(None, description='Include "AWS::CDK::Metadata" resource in synthesized templates. Default: true\n')
    change_set_name: typing.Optional[str] = pydantic.Field(None, description='Optional name to use for the CloudFormation change set. If not provided, a name will be generated automatically. Default: - auto generate a name\n')
    ci: typing.Optional[bool] = pydantic.Field(None, description='Whether we are on a CI system. Default: false\n')
    concurrency: typing.Union[int, float, None] = pydantic.Field(None, description='Deploy multiple stacks in parallel. Default: 1\n')
    exclusively: typing.Optional[bool] = pydantic.Field(None, description='Only perform action on the given stack. Default: false\n')
    execute: typing.Optional[bool] = pydantic.Field(None, description='Whether to execute the ChangeSet Not providing ``execute`` parameter will result in execution of ChangeSet. Default: true\n')
    force: typing.Optional[bool] = pydantic.Field(None, description='Always deploy, even if templates are identical. Default: false\n')
    notification_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='ARNs of SNS topics that CloudFormation will notify with stack related events. Default: - no notifications\n')
    outputs_file: typing.Optional[str] = pydantic.Field(None, description='Path to file where stack outputs will be written after a successful deploy as JSON. Default: - Outputs are not written to any file\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional parameters for CloudFormation at deploy time. Default: {}\n')
    require_approval: typing.Optional[aws_cdk.cloud_assembly_schema.RequireApproval] = pydantic.Field(None, description='What kind of security changes require approval. Default: RequireApproval.Never\n')
    reuse_assets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Reuse the assets with the given asset IDs. Default: - do not reuse assets\n')
    rollback: typing.Optional[bool] = pydantic.Field(None, description='Rollback failed deployments. Default: true\n')
    toolkit_stack_name: typing.Optional[str] = pydantic.Field(None, description='Name of the toolkit stack to use/deploy. Default: CDKToolkit\n')
    use_previous_parameters: typing.Optional[bool] = pydantic.Field(None, description='Use previous values for unspecified parameters. If not set, all parameters must be specified for every deployment. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    app = App()\n\n    stack_under_test = Stack(app, "StackUnderTest")\n\n    stack = Stack(app, "stack")\n\n    test_case = IntegTest(app, "CustomizedDeploymentWorkflow",\n        test_cases=[stack_under_test],\n        diff_assets=True,\n        stack_update_workflow=True,\n        cdk_command_options=CdkCommands(\n            deploy=DeployCommand(\n                args=DeployOptions(\n                    require_approval=RequireApproval.NEVER,\n                    json=True\n                )\n            ),\n            destroy=DestroyCommand(\n                args=DestroyOptions(\n                    force=True\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['all', 'app', 'asset_metadata', 'ca_bundle_path', 'color', 'context', 'debug', 'ec2_creds', 'ignore_errors', 'json', 'lookups', 'notices', 'output', 'path_metadata', 'profile', 'proxy', 'role_arn', 'stacks', 'staging', 'strict', 'trace', 'verbose', 'version_reporting', 'change_set_name', 'ci', 'concurrency', 'exclusively', 'execute', 'force', 'notification_arns', 'outputs_file', 'parameters', 'require_approval', 'reuse_assets', 'rollback', 'toolkit_stack_name', 'use_previous_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DeployOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DestroyCommand
class DestroyCommandDef(BaseStruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to run this command as part of the workflow This can be used if you only want to test some of the workflow for example enable ``synth`` and disable ``deploy`` & ``destroy`` in order to limit the test to synthesis. Default: true\n')
    expected_message: typing.Optional[str] = pydantic.Field(None, description='This can be used in combination with ``expectedError`` to validate that a specific message is returned. Default: - do not validate message\n')
    expect_error: typing.Optional[bool] = pydantic.Field(None, description='If the runner should expect this command to fail. Default: false\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'expected_message', 'expect_error']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DestroyCommand'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DestroyOptions
class DestroyOptionsDef(BaseStruct):
    all: typing.Optional[bool] = pydantic.Field(None, description='Deploy all stacks. Requried if ``stacks`` is not set Default: - false\n')
    app: typing.Optional[str] = pydantic.Field(None, description='command-line for executing your app or a cloud assembly directory e.g. "node bin/my-app.js" or "cdk.out". Default: - read from cdk.json\n')
    asset_metadata: typing.Optional[bool] = pydantic.Field(None, description='Include "aws:asset:*" CloudFormation metadata for resources that use assets. Default: true\n')
    ca_bundle_path: typing.Optional[str] = pydantic.Field(None, description='Path to CA certificate to use when validating HTTPS requests. Default: - read from AWS_CA_BUNDLE environment variable\n')
    color: typing.Optional[bool] = pydantic.Field(None, description='Show colors and other style from console output. Default: true\n')
    context: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional context. Default: - no additional context\n')
    debug: typing.Optional[bool] = pydantic.Field(None, description='enable emission of additional debugging information, such as creation stack traces of tokens. Default: false\n')
    ec2_creds: typing.Optional[bool] = pydantic.Field(None, description='Force trying to fetch EC2 instance credentials. Default: - guess EC2 instance status\n')
    ignore_errors: typing.Optional[bool] = pydantic.Field(None, description='Ignores synthesis errors, which will likely produce an invalid output. Default: false\n')
    json_: typing.Optional[bool] = pydantic.Field(None, description='Use JSON output instead of YAML when templates are printed to STDOUT. Default: false\n', alias='json')
    lookups: typing.Optional[bool] = pydantic.Field(None, description='Perform context lookups. Synthesis fails if this is disabled and context lookups need to be performed Default: true\n')
    notices: typing.Optional[bool] = pydantic.Field(None, description='Show relevant notices. Default: true\n')
    output: typing.Optional[str] = pydantic.Field(None, description='Emits the synthesized cloud assembly into a directory. Default: cdk.out\n')
    path_metadata: typing.Optional[bool] = pydantic.Field(None, description='Include "aws:cdk:path" CloudFormation metadata for each resource. Default: true\n')
    profile: typing.Optional[str] = pydantic.Field(None, description='Use the indicated AWS profile as the default environment. Default: - no profile is used\n')
    proxy: typing.Optional[str] = pydantic.Field(None, description='Use the indicated proxy. Will read from HTTPS_PROXY environment if specified Default: - no proxy\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='Role to pass to CloudFormation for deployment. Default: - use the bootstrap cfn-exec role\n')
    stacks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of stacks to deploy. Requried if ``all`` is not set Default: - []\n')
    staging: typing.Optional[bool] = pydantic.Field(None, description='Copy assets to the output directory. Needed for local debugging the source files with SAM CLI Default: false\n')
    strict: typing.Optional[bool] = pydantic.Field(None, description='Do not construct stacks with warnings. Default: false\n')
    trace: typing.Optional[bool] = pydantic.Field(None, description='Print trace for stack warnings. Default: false\n')
    verbose: typing.Optional[bool] = pydantic.Field(None, description='show debug logs. Default: false\n')
    version_reporting: typing.Optional[bool] = pydantic.Field(None, description='Include "AWS::CDK::Metadata" resource in synthesized templates. Default: true\n')
    exclusively: typing.Optional[bool] = pydantic.Field(None, description='Only destroy the given stack. Default: false\n')
    force: typing.Optional[bool] = pydantic.Field(None, description='Do not ask for permission before destroying stacks. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    app = App()\n\n    stack_under_test = Stack(app, "StackUnderTest")\n\n    stack = Stack(app, "stack")\n\n    test_case = IntegTest(app, "CustomizedDeploymentWorkflow",\n        test_cases=[stack_under_test],\n        diff_assets=True,\n        stack_update_workflow=True,\n        cdk_command_options=CdkCommands(\n            deploy=DeployCommand(\n                args=DeployOptions(\n                    require_approval=RequireApproval.NEVER,\n                    json=True\n                )\n            ),\n            destroy=DestroyCommand(\n                args=DestroyOptions(\n                    force=True\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['all', 'app', 'asset_metadata', 'ca_bundle_path', 'color', 'context', 'debug', 'ec2_creds', 'ignore_errors', 'json', 'lookups', 'notices', 'output', 'path_metadata', 'profile', 'proxy', 'role_arn', 'stacks', 'staging', 'strict', 'trace', 'verbose', 'version_reporting', 'exclusively', 'force']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DestroyOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DockerCacheOption
class DockerCacheOptionDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of cache to use. Refer to https://docs.docker.com/build/cache/backends/ for full list of backends. Default: - unspecified\n')
    params: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Any parameters to pass into the docker cache backend configuration. Refer to https://docs.docker.com/build/cache/backends/ for cache backend configuration. Default: {} No options provided\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    docker_cache_option = cloud_assembly_schema.DockerCacheOption(\n        type="type",\n\n        # the properties below are optional\n        params={\n            "params_key": "params"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'params']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DockerCacheOption'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DockerImageAsset
class DockerImageAssetDef(BaseStruct):
    destinations: typing.Union[typing.Mapping[str, typing.Union[models.cloud_assembly_schema.DockerImageDestinationDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Destinations for this file asset.\n')
    source: typing.Union[_REQUIRED_INIT_PARAM, models.cloud_assembly_schema.DockerImageSourceDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Source description for file assets.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    docker_image_asset = cloud_assembly_schema.DockerImageAsset(\n        destinations={\n            "destinations_key": cloud_assembly_schema.DockerImageDestination(\n                image_tag="imageTag",\n                repository_name="repositoryName",\n\n                # the properties below are optional\n                assume_role_arn="assumeRoleArn",\n                assume_role_external_id="assumeRoleExternalId",\n                region="region"\n            )\n        },\n        source=cloud_assembly_schema.DockerImageSource(\n            cache_disabled=False,\n            cache_from=[cloud_assembly_schema.DockerCacheOption(\n                type="type",\n\n                # the properties below are optional\n                params={\n                    "params_key": "params"\n                }\n            )],\n            cache_to=cloud_assembly_schema.DockerCacheOption(\n                type="type",\n\n                # the properties below are optional\n                params={\n                    "params_key": "params"\n                }\n            ),\n            directory="directory",\n            docker_build_args={\n                "docker_build_args_key": "dockerBuildArgs"\n            },\n            docker_build_secrets={\n                "docker_build_secrets_key": "dockerBuildSecrets"\n            },\n            docker_build_ssh="dockerBuildSsh",\n            docker_build_target="dockerBuildTarget",\n            docker_file="dockerFile",\n            docker_outputs=["dockerOutputs"],\n            executable=["executable"],\n            network_mode="networkMode",\n            platform="platform"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destinations', 'source']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DockerImageAsset'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DockerImageDestination
class DockerImageDestinationDef(BaseStruct):
    assume_role_arn: typing.Optional[str] = pydantic.Field(None, description='The role that needs to be assumed while publishing this asset. Default: - No role will be assumed\n')
    assume_role_external_id: typing.Optional[str] = pydantic.Field(None, description='The ExternalId that needs to be supplied while assuming this role. Default: - No ExternalId will be supplied\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region where this asset will need to be published. Default: - Current region\n')
    image_tag: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Tag of the image to publish.\n')
    repository_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the ECR repository to publish to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    docker_image_destination = cloud_assembly_schema.DockerImageDestination(\n        image_tag="imageTag",\n        repository_name="repositoryName",\n\n        # the properties below are optional\n        assume_role_arn="assumeRoleArn",\n        assume_role_external_id="assumeRoleExternalId",\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assume_role_arn', 'assume_role_external_id', 'region', 'image_tag', 'repository_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DockerImageDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.DockerImageSource
class DockerImageSourceDef(BaseStruct):
    cache_disabled: typing.Optional[bool] = pydantic.Field(None, description='Disable the cache and pass ``--no-cache`` to the ``docker build`` command. Default: - cache is used\n')
    cache_from: typing.Optional[typing.Sequence[typing.Union[models.cloud_assembly_schema.DockerCacheOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Cache from options to pass to the ``docker build`` command. Default: - no cache from options are passed to the build command\n')
    cache_to: typing.Union[models.cloud_assembly_schema.DockerCacheOptionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Cache to options to pass to the ``docker build`` command. Default: - no cache to options are passed to the build command\n')
    directory: typing.Optional[str] = pydantic.Field(None, description='The directory containing the Docker image build instructions. This path is relative to the asset manifest location. Default: - Exactly one of ``directory`` and ``executable`` is required\n')
    docker_build_args: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional build arguments. Only allowed when ``directory`` is set. Default: - No additional build arguments\n')
    docker_build_secrets: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional build secrets. Only allowed when ``directory`` is set. Default: - No additional build secrets\n')
    docker_build_ssh: typing.Optional[str] = pydantic.Field(None, description='SSH agent socket or keys. Requires building with docker buildkit. Default: - No ssh flag is set\n')
    docker_build_target: typing.Optional[str] = pydantic.Field(None, description='Target build stage in a Dockerfile with multiple build stages. Only allowed when ``directory`` is set. Default: - The last stage in the Dockerfile\n')
    docker_file: typing.Optional[str] = pydantic.Field(None, description='The name of the file with build instructions. Only allowed when ``directory`` is set. Default: "Dockerfile"\n')
    docker_outputs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Outputs. Default: - no outputs are passed to the build command (default outputs are used)\n')
    executable: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A command-line executable that returns the name of a local Docker image on stdout after being run. Default: - Exactly one of ``directory`` and ``executable`` is required\n')
    network_mode: typing.Optional[str] = pydantic.Field(None, description='Networking mode for the RUN commands during build. *Requires Docker Engine API v1.25+*. Specify this property to build images on a specific networking mode. Default: - no networking mode specified\n')
    platform: typing.Optional[str] = pydantic.Field(None, description='Platform to build for. *Requires Docker Buildx*. Specify this property to build images on a specific platform/architecture. Default: - current machine platform\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    docker_image_source = cloud_assembly_schema.DockerImageSource(\n        cache_disabled=False,\n        cache_from=[cloud_assembly_schema.DockerCacheOption(\n            type="type",\n\n            # the properties below are optional\n            params={\n                "params_key": "params"\n            }\n        )],\n        cache_to=cloud_assembly_schema.DockerCacheOption(\n            type="type",\n\n            # the properties below are optional\n            params={\n                "params_key": "params"\n            }\n        ),\n        directory="directory",\n        docker_build_args={\n            "docker_build_args_key": "dockerBuildArgs"\n        },\n        docker_build_secrets={\n            "docker_build_secrets_key": "dockerBuildSecrets"\n        },\n        docker_build_ssh="dockerBuildSsh",\n        docker_build_target="dockerBuildTarget",\n        docker_file="dockerFile",\n        docker_outputs=["dockerOutputs"],\n        executable=["executable"],\n        network_mode="networkMode",\n        platform="platform"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cache_disabled', 'cache_from', 'cache_to', 'directory', 'docker_build_args', 'docker_build_secrets', 'docker_build_ssh', 'docker_build_target', 'docker_file', 'docker_outputs', 'executable', 'network_mode', 'platform']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.DockerImageSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.EndpointServiceAvailabilityZonesContextQuery
class EndpointServiceAvailabilityZonesContextQueryDef(BaseStruct):
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    service_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query service name.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    endpoint_service_availability_zones_context_query = cloud_assembly_schema.EndpointServiceAvailabilityZonesContextQuery(\n        account="account",\n        region="region",\n        service_name="serviceName",\n\n        # the properties below are optional\n        lookup_role_arn="lookupRoleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'region', 'service_name', 'lookup_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.EndpointServiceAvailabilityZonesContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.FileAsset
class FileAssetDef(BaseStruct):
    destinations: typing.Union[typing.Mapping[str, typing.Union[models.cloud_assembly_schema.FileDestinationDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Destinations for this file asset.\n')
    source: typing.Union[_REQUIRED_INIT_PARAM, models.cloud_assembly_schema.FileSourceDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Source description for file assets.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    file_asset = cloud_assembly_schema.FileAsset(\n        destinations={\n            "destinations_key": cloud_assembly_schema.FileDestination(\n                bucket_name="bucketName",\n                object_key="objectKey",\n\n                # the properties below are optional\n                assume_role_arn="assumeRoleArn",\n                assume_role_external_id="assumeRoleExternalId",\n                region="region"\n            )\n        },\n        source=cloud_assembly_schema.FileSource(\n            executable=["executable"],\n            packaging=cloud_assembly_schema.FileAssetPackaging.FILE,\n            path="path"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destinations', 'source']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.FileAsset'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.FileAssetMetadataEntry
class FileAssetMetadataEntryDef(BaseStruct):
    artifact_hash_parameter: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the parameter where the hash of the bundled asset should be passed in.\n')
    packaging: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Requested packaging style.\n')
    path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Path on disk to the asset.\n')
    s3_bucket_parameter: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of parameter where S3 bucket should be passed in.\n')
    s3_key_parameter: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of parameter where S3 key should be passed in.\n')
    source_hash: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The hash of the asset source.\n\nExample::\n\n    entry = {\n        "packaging": "file",\n        "s3_bucket_parameter": "bucket-parameter",\n        "s3_key_paramenter": "key-parameter",\n        "artifact_hash_parameter": "hash-parameter"\n    }\n')
    _init_params: typing.ClassVar[list[str]] = ['artifact_hash_parameter', 'packaging', 'path', 's3_bucket_parameter', 's3_key_parameter', 'source_hash']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.FileAssetMetadataEntry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.FileDestination
class FileDestinationDef(BaseStruct):
    assume_role_arn: typing.Optional[str] = pydantic.Field(None, description='The role that needs to be assumed while publishing this asset. Default: - No role will be assumed\n')
    assume_role_external_id: typing.Optional[str] = pydantic.Field(None, description='The ExternalId that needs to be supplied while assuming this role. Default: - No ExternalId will be supplied\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region where this asset will need to be published. Default: - Current region\n')
    bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the bucket.\n')
    object_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The destination object key.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    file_destination = cloud_assembly_schema.FileDestination(\n        bucket_name="bucketName",\n        object_key="objectKey",\n\n        # the properties below are optional\n        assume_role_arn="assumeRoleArn",\n        assume_role_external_id="assumeRoleExternalId",\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assume_role_arn', 'assume_role_external_id', 'region', 'bucket_name', 'object_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.FileDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.FileSource
class FileSourceDef(BaseStruct):
    executable: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='External command which will produce the file asset to upload. Default: - Exactly one of ``executable`` and ``path`` is required.\n')
    packaging: typing.Optional[aws_cdk.cloud_assembly_schema.FileAssetPackaging] = pydantic.Field(None, description='Packaging method. Only allowed when ``path`` is specified. Default: FILE\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The filesystem object to upload. This path is relative to the asset manifest location. Default: - Exactly one of ``executable`` and ``path`` is required.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    file_source = cloud_assembly_schema.FileSource(\n        executable=["executable"],\n        packaging=cloud_assembly_schema.FileAssetPackaging.FILE,\n        path="path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['executable', 'packaging', 'path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.FileSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.Hooks
class HooksDef(BaseStruct):
    post_deploy: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Commands to run prior after deploying the cdk stacks in the integration test. Default: - no commands\n')
    post_destroy: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Commands to run after destroying the cdk stacks in the integration test. Default: - no commands\n')
    pre_deploy: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Commands to run prior to deploying the cdk stacks in the integration test. Default: - no commands\n')
    pre_destroy: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Commands to run prior to destroying the cdk stacks in the integration test. Default: - no commands\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    hooks = cloud_assembly_schema.Hooks(\n        post_deploy=["postDeploy"],\n        post_destroy=["postDestroy"],\n        pre_deploy=["preDeploy"],\n        pre_destroy=["preDestroy"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['post_deploy', 'post_destroy', 'pre_deploy', 'pre_destroy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.Hooks'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.HostedZoneContextQuery
class HostedZoneContextQueryDef(BaseStruct):
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain name e.g. example.com to lookup.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n')
    private_zone: typing.Optional[bool] = pydantic.Field(None, description='True if the zone you want to find is a private hosted zone. Default: false\n')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='The VPC ID to that the private zone must be associated with. If you provide VPC ID and privateZone is false, this will return no results and raise an error. Default: - Required if privateZone=true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    hosted_zone_context_query = cloud_assembly_schema.HostedZoneContextQuery(\n        account="account",\n        domain_name="domainName",\n        region="region",\n\n        # the properties below are optional\n        lookup_role_arn="lookupRoleArn",\n        private_zone=False,\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'domain_name', 'region', 'lookup_role_arn', 'private_zone', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.HostedZoneContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.IntegManifest
class IntegManifestDef(BaseStruct):
    test_cases: typing.Union[typing.Mapping[str, typing.Union[models.cloud_assembly_schema.TestCaseDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='test cases.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Version of the manifest.\n')
    enable_lookups: typing.Optional[bool] = pydantic.Field(None, description='Enable lookups for this test. If lookups are enabled then ``stackUpdateWorkflow`` must be set to false. Lookups should only be enabled when you are explicitely testing lookups. Default: false\n')
    synth_context: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional context to use when performing a synth. Any context provided here will override any default context Default: - no additional context\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    integ_manifest = cloud_assembly_schema.IntegManifest(\n        test_cases={\n            "test_cases_key": cloud_assembly_schema.TestCase(\n                stacks=["stacks"],\n\n                # the properties below are optional\n                allow_destroy=["allowDestroy"],\n                assertion_stack="assertionStack",\n                assertion_stack_name="assertionStackName",\n                cdk_command_options=cloud_assembly_schema.CdkCommands(\n                    deploy=cloud_assembly_schema.DeployCommand(\n                        args=cloud_assembly_schema.DeployOptions(\n                            all=False,\n                            app="app",\n                            asset_metadata=False,\n                            ca_bundle_path="caBundlePath",\n                            change_set_name="changeSetName",\n                            ci=False,\n                            color=False,\n                            concurrency=123,\n                            context={\n                                "context_key": "context"\n                            },\n                            debug=False,\n                            ec2_creds=False,\n                            exclusively=False,\n                            execute=False,\n                            force=False,\n                            ignore_errors=False,\n                            json=False,\n                            lookups=False,\n                            notices=False,\n                            notification_arns=["notificationArns"],\n                            output="output",\n                            outputs_file="outputsFile",\n                            parameters={\n                                "parameters_key": "parameters"\n                            },\n                            path_metadata=False,\n                            profile="profile",\n                            proxy="proxy",\n                            require_approval=cloud_assembly_schema.RequireApproval.NEVER,\n                            reuse_assets=["reuseAssets"],\n                            role_arn="roleArn",\n                            rollback=False,\n                            stacks=["stacks"],\n                            staging=False,\n                            strict=False,\n                            toolkit_stack_name="toolkitStackName",\n                            trace=False,\n                            use_previous_parameters=False,\n                            verbose=False,\n                            version_reporting=False\n                        ),\n                        enabled=False,\n                        expected_message="expectedMessage",\n                        expect_error=False\n                    ),\n                    destroy=cloud_assembly_schema.DestroyCommand(\n                        args=cloud_assembly_schema.DestroyOptions(\n                            all=False,\n                            app="app",\n                            asset_metadata=False,\n                            ca_bundle_path="caBundlePath",\n                            color=False,\n                            context={\n                                "context_key": "context"\n                            },\n                            debug=False,\n                            ec2_creds=False,\n                            exclusively=False,\n                            force=False,\n                            ignore_errors=False,\n                            json=False,\n                            lookups=False,\n                            notices=False,\n                            output="output",\n                            path_metadata=False,\n                            profile="profile",\n                            proxy="proxy",\n                            role_arn="roleArn",\n                            stacks=["stacks"],\n                            staging=False,\n                            strict=False,\n                            trace=False,\n                            verbose=False,\n                            version_reporting=False\n                        ),\n                        enabled=False,\n                        expected_message="expectedMessage",\n                        expect_error=False\n                    )\n                ),\n                diff_assets=False,\n                hooks=cloud_assembly_schema.Hooks(\n                    post_deploy=["postDeploy"],\n                    post_destroy=["postDestroy"],\n                    pre_deploy=["preDeploy"],\n                    pre_destroy=["preDestroy"]\n                ),\n                regions=["regions"],\n                stack_update_workflow=False\n            )\n        },\n        version="version",\n\n        # the properties below are optional\n        enable_lookups=False,\n        synth_context={\n            "synth_context_key": "synthContext"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['test_cases', 'version', 'enable_lookups', 'synth_context']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.IntegManifest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.KeyContextQuery
class KeyContextQueryDef(BaseStruct):
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    alias_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Alias name used to search the Key.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    key_context_query = cloud_assembly_schema.KeyContextQuery(\n        account="account",\n        alias_name="aliasName",\n        region="region",\n\n        # the properties below are optional\n        lookup_role_arn="lookupRoleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'alias_name', 'region', 'lookup_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.KeyContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.LoadBalancerContextQuery
class LoadBalancerContextQueryDef(BaseStruct):
    load_balancer_type: typing.Union[aws_cdk.cloud_assembly_schema.LoadBalancerType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Filter load balancers by their type.\n')
    load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description="Find by load balancer's ARN. Default: - does not search by load balancer arn\n")
    load_balancer_tags: typing.Optional[typing.Sequence[typing.Union[models.cloud_assembly_schema.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Match load balancer tags. Default: - does not match load balancers by tags\n')
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    load_balancer_context_query = cloud_assembly_schema.LoadBalancerContextQuery(\n        account="account",\n        load_balancer_type=cloud_assembly_schema.LoadBalancerType.NETWORK,\n        region="region",\n\n        # the properties below are optional\n        load_balancer_arn="loadBalancerArn",\n        load_balancer_tags=[cloud_assembly_schema.Tag(\n            key="key",\n            value="value"\n        )],\n        lookup_role_arn="lookupRoleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['load_balancer_type', 'load_balancer_arn', 'load_balancer_tags', 'account', 'region', 'lookup_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.LoadBalancerContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.LoadBalancerFilter
class LoadBalancerFilterDef(BaseStruct):
    load_balancer_type: typing.Union[aws_cdk.cloud_assembly_schema.LoadBalancerType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Filter load balancers by their type.\n')
    load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description="Find by load balancer's ARN. Default: - does not search by load balancer arn\n")
    load_balancer_tags: typing.Optional[typing.Sequence[typing.Union[models.cloud_assembly_schema.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Match load balancer tags. Default: - does not match load balancers by tags\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    load_balancer_filter = cloud_assembly_schema.LoadBalancerFilter(\n        load_balancer_type=cloud_assembly_schema.LoadBalancerType.NETWORK,\n\n        # the properties below are optional\n        load_balancer_arn="loadBalancerArn",\n        load_balancer_tags=[cloud_assembly_schema.Tag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['load_balancer_type', 'load_balancer_arn', 'load_balancer_tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.LoadBalancerFilter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.LoadBalancerListenerContextQuery
class LoadBalancerListenerContextQueryDef(BaseStruct):
    load_balancer_type: typing.Union[aws_cdk.cloud_assembly_schema.LoadBalancerType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Filter load balancers by their type.\n')
    load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description="Find by load balancer's ARN. Default: - does not search by load balancer arn\n")
    load_balancer_tags: typing.Optional[typing.Sequence[typing.Union[models.cloud_assembly_schema.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Match load balancer tags. Default: - does not match load balancers by tags\n')
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    listener_arn: typing.Optional[str] = pydantic.Field(None, description="Find by listener's arn. Default: - does not find by listener arn\n")
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Filter listeners by listener port. Default: - does not filter by a listener port\n')
    listener_protocol: typing.Optional[aws_cdk.cloud_assembly_schema.LoadBalancerListenerProtocol] = pydantic.Field(None, description='Filter by listener protocol. Default: - does not filter by listener protocol\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    load_balancer_listener_context_query = cloud_assembly_schema.LoadBalancerListenerContextQuery(\n        account="account",\n        load_balancer_type=cloud_assembly_schema.LoadBalancerType.NETWORK,\n        region="region",\n\n        # the properties below are optional\n        listener_arn="listenerArn",\n        listener_port=123,\n        listener_protocol=cloud_assembly_schema.LoadBalancerListenerProtocol.HTTP,\n        load_balancer_arn="loadBalancerArn",\n        load_balancer_tags=[cloud_assembly_schema.Tag(\n            key="key",\n            value="value"\n        )],\n        lookup_role_arn="lookupRoleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['load_balancer_type', 'load_balancer_arn', 'load_balancer_tags', 'account', 'region', 'listener_arn', 'listener_port', 'listener_protocol', 'lookup_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.LoadBalancerListenerContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.LoadManifestOptions
class LoadManifestOptionsDef(BaseStruct):
    skip_enum_check: typing.Optional[bool] = pydantic.Field(None, description="Skip enum checks. This means you may read enum values you don't know about yet. Make sure to always check the values of enums you encounter in the manifest. Default: false\n")
    skip_version_check: typing.Optional[bool] = pydantic.Field(None, description='Skip the version check. This means you may read a newer cloud assembly than the CX API is designed to support, and your application may not be aware of all features that in use in the Cloud Assembly. Default: false\n')
    topo_sort: typing.Optional[bool] = pydantic.Field(None, description='Topologically sort all artifacts. This parameter is only respected by the constructor of ``CloudAssembly``. The property lives here for backwards compatibility reasons. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    load_manifest_options = cloud_assembly_schema.LoadManifestOptions(\n        skip_enum_check=False,\n        skip_version_check=False,\n        topo_sort=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['skip_enum_check', 'skip_version_check', 'topo_sort']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.LoadManifestOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.MetadataEntry
class MetadataEntryDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the metadata entry.\n')
    data: typing.Union[str, models.cloud_assembly_schema.FileAssetMetadataEntryDef, dict[str, typing.Any], models.cloud_assembly_schema.ContainerImageAssetMetadataEntryDef, typing.Sequence[typing.Union[models.cloud_assembly_schema.TagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The data. Default: - no data.\n')
    trace: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A stack trace for when the entry was created. Default: - no trace.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    metadata_entry = cloud_assembly_schema.MetadataEntry(\n        type="type",\n\n        # the properties below are optional\n        data="data",\n        trace=["trace"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'data', 'trace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.MetadataEntry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.MissingContext
class MissingContextDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The missing context key.\n')
    props: typing.Union[_REQUIRED_INIT_PARAM, models.cloud_assembly_schema.AmiContextQueryDef, dict[str, typing.Any], models.cloud_assembly_schema.AvailabilityZonesContextQueryDef, models.cloud_assembly_schema.HostedZoneContextQueryDef, models.cloud_assembly_schema.SSMParameterContextQueryDef, models.cloud_assembly_schema.VpcContextQueryDef, models.cloud_assembly_schema.EndpointServiceAvailabilityZonesContextQueryDef, models.cloud_assembly_schema.LoadBalancerContextQueryDef, models.cloud_assembly_schema.LoadBalancerListenerContextQueryDef, models.cloud_assembly_schema.SecurityGroupContextQueryDef, models.cloud_assembly_schema.KeyContextQueryDef, models.cloud_assembly_schema.PluginContextQueryDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='A set of provider-specific options.\n')
    provider: typing.Union[aws_cdk.cloud_assembly_schema.ContextProvider, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The provider from which we expect this context key to be obtained.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    missing_context = cloud_assembly_schema.MissingContext(\n        key="key",\n        props=cloud_assembly_schema.AmiContextQuery(\n            account="account",\n            filters={\n                "filters_key": ["filters"]\n            },\n            region="region",\n\n            # the properties below are optional\n            lookup_role_arn="lookupRoleArn",\n            owners=["owners"]\n        ),\n        provider=cloud_assembly_schema.ContextProvider.AMI_PROVIDER\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'props', 'provider']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.MissingContext'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.NestedCloudAssemblyProperties
class NestedCloudAssemblyPropertiesDef(BaseStruct):
    directory_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Relative path to the nested cloud assembly.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='Display name for the cloud assembly. Default: - The artifact ID\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    nested_cloud_assembly_properties = cloud_assembly_schema.NestedCloudAssemblyProperties(\n        directory_name="directoryName",\n\n        # the properties below are optional\n        display_name="displayName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['directory_name', 'display_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.NestedCloudAssemblyProperties'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.PluginContextQuery
class PluginContextQueryDef(BaseStruct):
    plugin_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the plugin.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    plugin_context_query = cloud_assembly_schema.PluginContextQuery(\n        plugin_name="pluginName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['plugin_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.PluginContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.RuntimeInfo
class RuntimeInfoDef(BaseStruct):
    libraries: typing.Union[typing.Mapping[str, str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The list of libraries loaded in the application, associated with their versions.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    runtime_info = cloud_assembly_schema.RuntimeInfo(\n        libraries={\n            "libraries_key": "libraries"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['libraries']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.RuntimeInfo'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.SecurityGroupContextQuery
class SecurityGroupContextQueryDef(BaseStruct):
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n')
    security_group_id: typing.Optional[str] = pydantic.Field(None, description='Security group id. Default: - None\n')
    security_group_name: typing.Optional[str] = pydantic.Field(None, description='Security group name. Default: - None\n')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='VPC ID. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    security_group_context_query = cloud_assembly_schema.SecurityGroupContextQuery(\n        account="account",\n        region="region",\n\n        # the properties below are optional\n        lookup_role_arn="lookupRoleArn",\n        security_group_id="securityGroupId",\n        security_group_name="securityGroupName",\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'region', 'lookup_role_arn', 'security_group_id', 'security_group_name', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.SecurityGroupContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.SSMParameterContextQuery
class SSMParameterContextQueryDef(BaseStruct):
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    parameter_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Parameter name to query.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    s_sMParameter_context_query = cloud_assembly_schema.SSMParameterContextQuery(\n        account="account",\n        parameter_name="parameterName",\n        region="region",\n\n        # the properties below are optional\n        lookup_role_arn="lookupRoleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'parameter_name', 'region', 'lookup_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.SSMParameterContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.Tag
class TagDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Tag key. (In the actual file on disk this will be cased as "Key", and the structure is patched to match this structure upon loading: https://github.com/aws/aws-cdk/blob/4aadaa779b48f35838cccd4e25107b2338f05547/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts#L137)\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Tag value. (In the actual file on disk this will be cased as "Value", and the structure is patched to match this structure upon loading: https://github.com/aws/aws-cdk/blob/4aadaa779b48f35838cccd4e25107b2338f05547/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts#L137)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    tag = cloud_assembly_schema.Tag(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.Tag'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.TestCase
class TestCaseDef(BaseStruct):
    allow_destroy: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="List of CloudFormation resource types in this stack that can be destroyed as part of an update without failing the test. This list should only include resources that for this specific integration test we are sure will not cause errors or an outage if destroyed. For example, maybe we know that a new resource will be created first before the old resource is destroyed which prevents any outage. e.g. ['AWS::IAM::Role'] Default: - do not allow destruction of any resources on update\n")
    cdk_command_options: typing.Union[models.cloud_assembly_schema.CdkCommandsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional options to use for each CDK command. Default: - runner default options\n')
    diff_assets: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to include asset hashes in the diff Asset hashes can introduces a lot of unneccessary noise into tests, but there are some cases where asset hashes *should* be included. For example any tests involving custom resources or bundling Default: false\n')
    hooks: typing.Union[models.cloud_assembly_schema.HooksDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Additional commands to run at predefined points in the test workflow. e.g. { postDeploy: ['yarn', 'test'] } Default: - no hooks\n")
    regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Limit deployment to these regions. Default: - can run in any region\n')
    stack_update_workflow: typing.Optional[bool] = pydantic.Field(None, description='Run update workflow on this test case This should only be set to false to test scenarios that are not possible to test as part of the update workflow. Default: true\n')
    stacks: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Stacks that should be tested as part of this test case The stackNames will be passed as args to the cdk commands so dependent stacks will be automatically deployed unless ``exclusively`` is passed.\n')
    assertion_stack: typing.Optional[str] = pydantic.Field(None, description='The node id of the stack that contains assertions. This is the value that can be used to deploy the stack with the CDK CLI Default: - no assertion stack\n')
    assertion_stack_name: typing.Optional[str] = pydantic.Field(None, description='The name of the stack that contains assertions. Default: - no assertion stack\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    test_case = cloud_assembly_schema.TestCase(\n        stacks=["stacks"],\n\n        # the properties below are optional\n        allow_destroy=["allowDestroy"],\n        assertion_stack="assertionStack",\n        assertion_stack_name="assertionStackName",\n        cdk_command_options=cloud_assembly_schema.CdkCommands(\n            deploy=cloud_assembly_schema.DeployCommand(\n                args=cloud_assembly_schema.DeployOptions(\n                    all=False,\n                    app="app",\n                    asset_metadata=False,\n                    ca_bundle_path="caBundlePath",\n                    change_set_name="changeSetName",\n                    ci=False,\n                    color=False,\n                    concurrency=123,\n                    context={\n                        "context_key": "context"\n                    },\n                    debug=False,\n                    ec2_creds=False,\n                    exclusively=False,\n                    execute=False,\n                    force=False,\n                    ignore_errors=False,\n                    json=False,\n                    lookups=False,\n                    notices=False,\n                    notification_arns=["notificationArns"],\n                    output="output",\n                    outputs_file="outputsFile",\n                    parameters={\n                        "parameters_key": "parameters"\n                    },\n                    path_metadata=False,\n                    profile="profile",\n                    proxy="proxy",\n                    require_approval=cloud_assembly_schema.RequireApproval.NEVER,\n                    reuse_assets=["reuseAssets"],\n                    role_arn="roleArn",\n                    rollback=False,\n                    stacks=["stacks"],\n                    staging=False,\n                    strict=False,\n                    toolkit_stack_name="toolkitStackName",\n                    trace=False,\n                    use_previous_parameters=False,\n                    verbose=False,\n                    version_reporting=False\n                ),\n                enabled=False,\n                expected_message="expectedMessage",\n                expect_error=False\n            ),\n            destroy=cloud_assembly_schema.DestroyCommand(\n                args=cloud_assembly_schema.DestroyOptions(\n                    all=False,\n                    app="app",\n                    asset_metadata=False,\n                    ca_bundle_path="caBundlePath",\n                    color=False,\n                    context={\n                        "context_key": "context"\n                    },\n                    debug=False,\n                    ec2_creds=False,\n                    exclusively=False,\n                    force=False,\n                    ignore_errors=False,\n                    json=False,\n                    lookups=False,\n                    notices=False,\n                    output="output",\n                    path_metadata=False,\n                    profile="profile",\n                    proxy="proxy",\n                    role_arn="roleArn",\n                    stacks=["stacks"],\n                    staging=False,\n                    strict=False,\n                    trace=False,\n                    verbose=False,\n                    version_reporting=False\n                ),\n                enabled=False,\n                expected_message="expectedMessage",\n                expect_error=False\n            )\n        ),\n        diff_assets=False,\n        hooks=cloud_assembly_schema.Hooks(\n            post_deploy=["postDeploy"],\n            post_destroy=["postDestroy"],\n            pre_deploy=["preDeploy"],\n            pre_destroy=["preDestroy"]\n        ),\n        regions=["regions"],\n        stack_update_workflow=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_destroy', 'cdk_command_options', 'diff_assets', 'hooks', 'regions', 'stack_update_workflow', 'stacks', 'assertion_stack', 'assertion_stack_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.TestCase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.TestOptions
class TestOptionsDef(BaseStruct):
    allow_destroy: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="List of CloudFormation resource types in this stack that can be destroyed as part of an update without failing the test. This list should only include resources that for this specific integration test we are sure will not cause errors or an outage if destroyed. For example, maybe we know that a new resource will be created first before the old resource is destroyed which prevents any outage. e.g. ['AWS::IAM::Role'] Default: - do not allow destruction of any resources on update\n")
    cdk_command_options: typing.Union[models.cloud_assembly_schema.CdkCommandsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional options to use for each CDK command. Default: - runner default options\n')
    diff_assets: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to include asset hashes in the diff Asset hashes can introduces a lot of unneccessary noise into tests, but there are some cases where asset hashes *should* be included. For example any tests involving custom resources or bundling Default: false\n')
    hooks: typing.Union[models.cloud_assembly_schema.HooksDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Additional commands to run at predefined points in the test workflow. e.g. { postDeploy: ['yarn', 'test'] } Default: - no hooks\n")
    regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Limit deployment to these regions. Default: - can run in any region\n')
    stack_update_workflow: typing.Optional[bool] = pydantic.Field(None, description='Run update workflow on this test case This should only be set to false to test scenarios that are not possible to test as part of the update workflow. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    test_options = cloud_assembly_schema.TestOptions(\n        allow_destroy=["allowDestroy"],\n        cdk_command_options=cloud_assembly_schema.CdkCommands(\n            deploy=cloud_assembly_schema.DeployCommand(\n                args=cloud_assembly_schema.DeployOptions(\n                    all=False,\n                    app="app",\n                    asset_metadata=False,\n                    ca_bundle_path="caBundlePath",\n                    change_set_name="changeSetName",\n                    ci=False,\n                    color=False,\n                    concurrency=123,\n                    context={\n                        "context_key": "context"\n                    },\n                    debug=False,\n                    ec2_creds=False,\n                    exclusively=False,\n                    execute=False,\n                    force=False,\n                    ignore_errors=False,\n                    json=False,\n                    lookups=False,\n                    notices=False,\n                    notification_arns=["notificationArns"],\n                    output="output",\n                    outputs_file="outputsFile",\n                    parameters={\n                        "parameters_key": "parameters"\n                    },\n                    path_metadata=False,\n                    profile="profile",\n                    proxy="proxy",\n                    require_approval=cloud_assembly_schema.RequireApproval.NEVER,\n                    reuse_assets=["reuseAssets"],\n                    role_arn="roleArn",\n                    rollback=False,\n                    stacks=["stacks"],\n                    staging=False,\n                    strict=False,\n                    toolkit_stack_name="toolkitStackName",\n                    trace=False,\n                    use_previous_parameters=False,\n                    verbose=False,\n                    version_reporting=False\n                ),\n                enabled=False,\n                expected_message="expectedMessage",\n                expect_error=False\n            ),\n            destroy=cloud_assembly_schema.DestroyCommand(\n                args=cloud_assembly_schema.DestroyOptions(\n                    all=False,\n                    app="app",\n                    asset_metadata=False,\n                    ca_bundle_path="caBundlePath",\n                    color=False,\n                    context={\n                        "context_key": "context"\n                    },\n                    debug=False,\n                    ec2_creds=False,\n                    exclusively=False,\n                    force=False,\n                    ignore_errors=False,\n                    json=False,\n                    lookups=False,\n                    notices=False,\n                    output="output",\n                    path_metadata=False,\n                    profile="profile",\n                    proxy="proxy",\n                    role_arn="roleArn",\n                    stacks=["stacks"],\n                    staging=False,\n                    strict=False,\n                    trace=False,\n                    verbose=False,\n                    version_reporting=False\n                ),\n                enabled=False,\n                expected_message="expectedMessage",\n                expect_error=False\n            )\n        ),\n        diff_assets=False,\n        hooks=cloud_assembly_schema.Hooks(\n            post_deploy=["postDeploy"],\n            post_destroy=["postDestroy"],\n            pre_deploy=["preDeploy"],\n            pre_destroy=["preDestroy"]\n        ),\n        regions=["regions"],\n        stack_update_workflow=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_destroy', 'cdk_command_options', 'diff_assets', 'hooks', 'regions', 'stack_update_workflow']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.TestOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.TreeArtifactProperties
class TreeArtifactPropertiesDef(BaseStruct):
    file: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Filename of the tree artifact.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    tree_artifact_properties = cloud_assembly_schema.TreeArtifactProperties(\n        file="file"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.TreeArtifactProperties'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.VpcContextQuery
class VpcContextQueryDef(BaseStruct):
    account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query account.\n')
    filter: typing.Union[typing.Mapping[str, str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Filters to apply to the VPC. Filter parameters are the same as passed to DescribeVpcs.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Query region.\n')
    lookup_role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that should be used to look up the missing values. Default: - None\n')
    return_asymmetric_subnets: typing.Optional[bool] = pydantic.Field(None, description='Whether to populate the subnetGroups field of the ``VpcContextResponse``, which contains potentially asymmetric subnet groups. Default: false\n')
    return_vpn_gateways: typing.Optional[bool] = pydantic.Field(None, description='Whether to populate the ``vpnGatewayId`` field of the ``VpcContextResponse``, which contains the VPN Gateway ID, if one exists. You can explicitly disable this in order to avoid the lookup if you know the VPC does not have a VPN Gatway attached. Default: true\n')
    subnet_group_name_tag: typing.Optional[str] = pydantic.Field(None, description='Optional tag for subnet group name. If not provided, we\'ll look at the aws-cdk:subnet-name tag. If the subnet does not have the specified tag, we\'ll use its type as the name. Default: \'aws-cdk:subnet-name\'\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cloud_assembly_schema\n\n    vpc_context_query = cloud_assembly_schema.VpcContextQuery(\n        account="account",\n        filter={\n            "filter_key": "filter"\n        },\n        region="region",\n\n        # the properties below are optional\n        lookup_role_arn="lookupRoleArn",\n        return_asymmetric_subnets=False,\n        return_vpn_gateways=False,\n        subnet_group_name_tag="subnetGroupNameTag"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'filter', 'region', 'lookup_role_arn', 'return_asymmetric_subnets', 'return_vpn_gateways', 'subnet_group_name_tag']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cloud_assembly_schema.VpcContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cloud_assembly_schema.ArtifactMetadataEntryType
# skipping emum

#  autogenerated from aws_cdk.cloud_assembly_schema.ArtifactType
# skipping emum

#  autogenerated from aws_cdk.cloud_assembly_schema.ContextProvider
# skipping emum

#  autogenerated from aws_cdk.cloud_assembly_schema.FileAssetPackaging
# skipping emum

#  autogenerated from aws_cdk.cloud_assembly_schema.LoadBalancerListenerProtocol
# skipping emum

#  autogenerated from aws_cdk.cloud_assembly_schema.LoadBalancerType
# skipping emum

#  autogenerated from aws_cdk.cloud_assembly_schema.RequireApproval
# skipping emum

class ModuleModel(pydantic.BaseModel):
    Manifest: typing.Optional[dict[str, models.cloud_assembly_schema.ManifestDef]] = pydantic.Field(None)
    AmiContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.AmiContextQueryDef]] = pydantic.Field(None)
    ArtifactManifest: typing.Optional[dict[str, models.cloud_assembly_schema.ArtifactManifestDef]] = pydantic.Field(None)
    AssemblyManifest: typing.Optional[dict[str, models.cloud_assembly_schema.AssemblyManifestDef]] = pydantic.Field(None)
    AssetManifest: typing.Optional[dict[str, models.cloud_assembly_schema.AssetManifestDef]] = pydantic.Field(None)
    AssetManifestOptions: typing.Optional[dict[str, models.cloud_assembly_schema.AssetManifestOptionsDef]] = pydantic.Field(None)
    AssetManifestProperties: typing.Optional[dict[str, models.cloud_assembly_schema.AssetManifestPropertiesDef]] = pydantic.Field(None)
    AvailabilityZonesContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.AvailabilityZonesContextQueryDef]] = pydantic.Field(None)
    AwsCloudFormationStackProperties: typing.Optional[dict[str, models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef]] = pydantic.Field(None)
    AwsDestination: typing.Optional[dict[str, models.cloud_assembly_schema.AwsDestinationDef]] = pydantic.Field(None)
    BootstrapRole: typing.Optional[dict[str, models.cloud_assembly_schema.BootstrapRoleDef]] = pydantic.Field(None)
    CdkCommand: typing.Optional[dict[str, models.cloud_assembly_schema.CdkCommandDef]] = pydantic.Field(None)
    CdkCommands: typing.Optional[dict[str, models.cloud_assembly_schema.CdkCommandsDef]] = pydantic.Field(None)
    ContainerImageAssetCacheOption: typing.Optional[dict[str, models.cloud_assembly_schema.ContainerImageAssetCacheOptionDef]] = pydantic.Field(None)
    ContainerImageAssetMetadataEntry: typing.Optional[dict[str, models.cloud_assembly_schema.ContainerImageAssetMetadataEntryDef]] = pydantic.Field(None)
    DefaultCdkOptions: typing.Optional[dict[str, models.cloud_assembly_schema.DefaultCdkOptionsDef]] = pydantic.Field(None)
    DeployCommand: typing.Optional[dict[str, models.cloud_assembly_schema.DeployCommandDef]] = pydantic.Field(None)
    DeployOptions: typing.Optional[dict[str, models.cloud_assembly_schema.DeployOptionsDef]] = pydantic.Field(None)
    DestroyCommand: typing.Optional[dict[str, models.cloud_assembly_schema.DestroyCommandDef]] = pydantic.Field(None)
    DestroyOptions: typing.Optional[dict[str, models.cloud_assembly_schema.DestroyOptionsDef]] = pydantic.Field(None)
    DockerCacheOption: typing.Optional[dict[str, models.cloud_assembly_schema.DockerCacheOptionDef]] = pydantic.Field(None)
    DockerImageAsset: typing.Optional[dict[str, models.cloud_assembly_schema.DockerImageAssetDef]] = pydantic.Field(None)
    DockerImageDestination: typing.Optional[dict[str, models.cloud_assembly_schema.DockerImageDestinationDef]] = pydantic.Field(None)
    DockerImageSource: typing.Optional[dict[str, models.cloud_assembly_schema.DockerImageSourceDef]] = pydantic.Field(None)
    EndpointServiceAvailabilityZonesContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.EndpointServiceAvailabilityZonesContextQueryDef]] = pydantic.Field(None)
    FileAsset: typing.Optional[dict[str, models.cloud_assembly_schema.FileAssetDef]] = pydantic.Field(None)
    FileAssetMetadataEntry: typing.Optional[dict[str, models.cloud_assembly_schema.FileAssetMetadataEntryDef]] = pydantic.Field(None)
    FileDestination: typing.Optional[dict[str, models.cloud_assembly_schema.FileDestinationDef]] = pydantic.Field(None)
    FileSource: typing.Optional[dict[str, models.cloud_assembly_schema.FileSourceDef]] = pydantic.Field(None)
    Hooks: typing.Optional[dict[str, models.cloud_assembly_schema.HooksDef]] = pydantic.Field(None)
    HostedZoneContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.HostedZoneContextQueryDef]] = pydantic.Field(None)
    IntegManifest: typing.Optional[dict[str, models.cloud_assembly_schema.IntegManifestDef]] = pydantic.Field(None)
    KeyContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.KeyContextQueryDef]] = pydantic.Field(None)
    LoadBalancerContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.LoadBalancerContextQueryDef]] = pydantic.Field(None)
    LoadBalancerFilter: typing.Optional[dict[str, models.cloud_assembly_schema.LoadBalancerFilterDef]] = pydantic.Field(None)
    LoadBalancerListenerContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.LoadBalancerListenerContextQueryDef]] = pydantic.Field(None)
    LoadManifestOptions: typing.Optional[dict[str, models.cloud_assembly_schema.LoadManifestOptionsDef]] = pydantic.Field(None)
    MetadataEntry: typing.Optional[dict[str, models.cloud_assembly_schema.MetadataEntryDef]] = pydantic.Field(None)
    MissingContext: typing.Optional[dict[str, models.cloud_assembly_schema.MissingContextDef]] = pydantic.Field(None)
    NestedCloudAssemblyProperties: typing.Optional[dict[str, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef]] = pydantic.Field(None)
    PluginContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.PluginContextQueryDef]] = pydantic.Field(None)
    RuntimeInfo: typing.Optional[dict[str, models.cloud_assembly_schema.RuntimeInfoDef]] = pydantic.Field(None)
    SecurityGroupContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.SecurityGroupContextQueryDef]] = pydantic.Field(None)
    SSMParameterContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.SSMParameterContextQueryDef]] = pydantic.Field(None)
    Tag: typing.Optional[dict[str, models.cloud_assembly_schema.TagDef]] = pydantic.Field(None)
    TestCase: typing.Optional[dict[str, models.cloud_assembly_schema.TestCaseDef]] = pydantic.Field(None)
    TestOptions: typing.Optional[dict[str, models.cloud_assembly_schema.TestOptionsDef]] = pydantic.Field(None)
    TreeArtifactProperties: typing.Optional[dict[str, models.cloud_assembly_schema.TreeArtifactPropertiesDef]] = pydantic.Field(None)
    VpcContextQuery: typing.Optional[dict[str, models.cloud_assembly_schema.VpcContextQueryDef]] = pydantic.Field(None)
    ...

import models
